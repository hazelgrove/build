(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod2) => function __require() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));

  // ../../../../../node_modules/big-integer/BigInteger.js
  var require_BigInteger = __commonJS({
    "../../../../../node_modules/big-integer/BigInteger.js"(exports2, module2) {
      var bigInt2 = function(undefined2) {
        "use strict";
        var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
        var supportsNativeBigInt = typeof BigInt === "function";
        function Integer(v3, radix, alphabet, caseSensitive) {
          if (typeof v3 === "undefined") return Integer[0];
          if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v3) : parseBase(v3, radix, alphabet, caseSensitive);
          return parseValue(v3);
        }
        function BigInteger(value, sign4) {
          this.value = value;
          this.sign = sign4;
          this.isSmall = false;
        }
        BigInteger.prototype = Object.create(Integer.prototype);
        function SmallInteger(value) {
          this.value = value;
          this.sign = value < 0;
          this.isSmall = true;
        }
        SmallInteger.prototype = Object.create(Integer.prototype);
        function NativeBigInt(value) {
          this.value = value;
        }
        NativeBigInt.prototype = Object.create(Integer.prototype);
        function isPrecise(n9) {
          return -MAX_INT < n9 && n9 < MAX_INT;
        }
        function smallToArray(n9) {
          if (n9 < 1e7)
            return [n9];
          if (n9 < 1e14)
            return [n9 % 1e7, Math.floor(n9 / 1e7)];
          return [n9 % 1e7, Math.floor(n9 / 1e7) % 1e7, Math.floor(n9 / 1e14)];
        }
        function arrayToSmall(arr) {
          trim(arr);
          var length4 = arr.length;
          if (length4 < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
            switch (length4) {
              case 0:
                return 0;
              case 1:
                return arr[0];
              case 2:
                return arr[0] + arr[1] * BASE;
              default:
                return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
            }
          }
          return arr;
        }
        function trim(v3) {
          var i6 = v3.length;
          while (v3[--i6] === 0) ;
          v3.length = i6 + 1;
        }
        function createArray(length4) {
          var x3 = new Array(length4);
          var i6 = -1;
          while (++i6 < length4) {
            x3[i6] = 0;
          }
          return x3;
        }
        function truncate(n9) {
          if (n9 > 0) return Math.floor(n9);
          return Math.ceil(n9);
        }
        function add3(a5, b2) {
          var l_a = a5.length, l_b = b2.length, r6 = new Array(l_a), carry = 0, base = BASE, sum3, i6;
          for (i6 = 0; i6 < l_b; i6++) {
            sum3 = a5[i6] + b2[i6] + carry;
            carry = sum3 >= base ? 1 : 0;
            r6[i6] = sum3 - carry * base;
          }
          while (i6 < l_a) {
            sum3 = a5[i6] + carry;
            carry = sum3 === base ? 1 : 0;
            r6[i6++] = sum3 - carry * base;
          }
          if (carry > 0) r6.push(carry);
          return r6;
        }
        function addAny(a5, b2) {
          if (a5.length >= b2.length) return add3(a5, b2);
          return add3(b2, a5);
        }
        function addSmall(a5, carry) {
          var l8 = a5.length, r6 = new Array(l8), base = BASE, sum3, i6;
          for (i6 = 0; i6 < l8; i6++) {
            sum3 = a5[i6] - base + carry;
            carry = Math.floor(sum3 / base);
            r6[i6] = sum3 - carry * base;
            carry += 1;
          }
          while (carry > 0) {
            r6[i6++] = carry % base;
            carry = Math.floor(carry / base);
          }
          return r6;
        }
        BigInteger.prototype.add = function(v3) {
          var n9 = parseValue(v3);
          if (this.sign !== n9.sign) {
            return this.subtract(n9.negate());
          }
          var a5 = this.value, b2 = n9.value;
          if (n9.isSmall) {
            return new BigInteger(addSmall(a5, Math.abs(b2)), this.sign);
          }
          return new BigInteger(addAny(a5, b2), this.sign);
        };
        BigInteger.prototype.plus = BigInteger.prototype.add;
        SmallInteger.prototype.add = function(v3) {
          var n9 = parseValue(v3);
          var a5 = this.value;
          if (a5 < 0 !== n9.sign) {
            return this.subtract(n9.negate());
          }
          var b2 = n9.value;
          if (n9.isSmall) {
            if (isPrecise(a5 + b2)) return new SmallInteger(a5 + b2);
            b2 = smallToArray(Math.abs(b2));
          }
          return new BigInteger(addSmall(b2, Math.abs(a5)), a5 < 0);
        };
        SmallInteger.prototype.plus = SmallInteger.prototype.add;
        NativeBigInt.prototype.add = function(v3) {
          return new NativeBigInt(this.value + parseValue(v3).value);
        };
        NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
        function subtract2(a5, b2) {
          var a_l = a5.length, b_l = b2.length, r6 = new Array(a_l), borrow = 0, base = BASE, i6, difference2;
          for (i6 = 0; i6 < b_l; i6++) {
            difference2 = a5[i6] - borrow - b2[i6];
            if (difference2 < 0) {
              difference2 += base;
              borrow = 1;
            } else borrow = 0;
            r6[i6] = difference2;
          }
          for (i6 = b_l; i6 < a_l; i6++) {
            difference2 = a5[i6] - borrow;
            if (difference2 < 0) difference2 += base;
            else {
              r6[i6++] = difference2;
              break;
            }
            r6[i6] = difference2;
          }
          for (; i6 < a_l; i6++) {
            r6[i6] = a5[i6];
          }
          trim(r6);
          return r6;
        }
        function subtractAny(a5, b2, sign4) {
          var value;
          if (compareAbs(a5, b2) >= 0) {
            value = subtract2(a5, b2);
          } else {
            value = subtract2(b2, a5);
            sign4 = !sign4;
          }
          value = arrayToSmall(value);
          if (typeof value === "number") {
            if (sign4) value = -value;
            return new SmallInteger(value);
          }
          return new BigInteger(value, sign4);
        }
        function subtractSmall(a5, b2, sign4) {
          var l8 = a5.length, r6 = new Array(l8), carry = -b2, base = BASE, i6, difference2;
          for (i6 = 0; i6 < l8; i6++) {
            difference2 = a5[i6] + carry;
            carry = Math.floor(difference2 / base);
            difference2 %= base;
            r6[i6] = difference2 < 0 ? difference2 + base : difference2;
          }
          r6 = arrayToSmall(r6);
          if (typeof r6 === "number") {
            if (sign4) r6 = -r6;
            return new SmallInteger(r6);
          }
          return new BigInteger(r6, sign4);
        }
        BigInteger.prototype.subtract = function(v3) {
          var n9 = parseValue(v3);
          if (this.sign !== n9.sign) {
            return this.add(n9.negate());
          }
          var a5 = this.value, b2 = n9.value;
          if (n9.isSmall)
            return subtractSmall(a5, Math.abs(b2), this.sign);
          return subtractAny(a5, b2, this.sign);
        };
        BigInteger.prototype.minus = BigInteger.prototype.subtract;
        SmallInteger.prototype.subtract = function(v3) {
          var n9 = parseValue(v3);
          var a5 = this.value;
          if (a5 < 0 !== n9.sign) {
            return this.add(n9.negate());
          }
          var b2 = n9.value;
          if (n9.isSmall) {
            return new SmallInteger(a5 - b2);
          }
          return subtractSmall(b2, Math.abs(a5), a5 >= 0);
        };
        SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
        NativeBigInt.prototype.subtract = function(v3) {
          return new NativeBigInt(this.value - parseValue(v3).value);
        };
        NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
        BigInteger.prototype.negate = function() {
          return new BigInteger(this.value, !this.sign);
        };
        SmallInteger.prototype.negate = function() {
          var sign4 = this.sign;
          var small = new SmallInteger(-this.value);
          small.sign = !sign4;
          return small;
        };
        NativeBigInt.prototype.negate = function() {
          return new NativeBigInt(-this.value);
        };
        BigInteger.prototype.abs = function() {
          return new BigInteger(this.value, false);
        };
        SmallInteger.prototype.abs = function() {
          return new SmallInteger(Math.abs(this.value));
        };
        NativeBigInt.prototype.abs = function() {
          return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
        };
        function multiplyLong(a5, b2) {
          var a_l = a5.length, b_l = b2.length, l8 = a_l + b_l, r6 = createArray(l8), base = BASE, product, carry, i6, a_i, b_j;
          for (i6 = 0; i6 < a_l; ++i6) {
            a_i = a5[i6];
            for (var j2 = 0; j2 < b_l; ++j2) {
              b_j = b2[j2];
              product = a_i * b_j + r6[i6 + j2];
              carry = Math.floor(product / base);
              r6[i6 + j2] = product - carry * base;
              r6[i6 + j2 + 1] += carry;
            }
          }
          trim(r6);
          return r6;
        }
        function multiplySmall(a5, b2) {
          var l8 = a5.length, r6 = new Array(l8), base = BASE, carry = 0, product, i6;
          for (i6 = 0; i6 < l8; i6++) {
            product = a5[i6] * b2 + carry;
            carry = Math.floor(product / base);
            r6[i6] = product - carry * base;
          }
          while (carry > 0) {
            r6[i6++] = carry % base;
            carry = Math.floor(carry / base);
          }
          return r6;
        }
        function shiftLeft(x3, n9) {
          var r6 = [];
          while (n9-- > 0) r6.push(0);
          return r6.concat(x3);
        }
        function multiplyKaratsuba(x3, y3) {
          var n9 = Math.max(x3.length, y3.length);
          if (n9 <= 30) return multiplyLong(x3, y3);
          n9 = Math.ceil(n9 / 2);
          var b2 = x3.slice(n9), a5 = x3.slice(0, n9), d3 = y3.slice(n9), c9 = y3.slice(0, n9);
          var ac2 = multiplyKaratsuba(a5, c9), bd2 = multiplyKaratsuba(b2, d3), abcd = multiplyKaratsuba(addAny(a5, b2), addAny(c9, d3));
          var product = addAny(addAny(ac2, shiftLeft(subtract2(subtract2(abcd, ac2), bd2), n9)), shiftLeft(bd2, 2 * n9));
          trim(product);
          return product;
        }
        function useKaratsuba(l1, l22) {
          return -0.012 * l1 - 0.012 * l22 + 15e-6 * l1 * l22 > 0;
        }
        BigInteger.prototype.multiply = function(v3) {
          var n9 = parseValue(v3), a5 = this.value, b2 = n9.value, sign4 = this.sign !== n9.sign, abs4;
          if (n9.isSmall) {
            if (b2 === 0) return Integer[0];
            if (b2 === 1) return this;
            if (b2 === -1) return this.negate();
            abs4 = Math.abs(b2);
            if (abs4 < BASE) {
              return new BigInteger(multiplySmall(a5, abs4), sign4);
            }
            b2 = smallToArray(abs4);
          }
          if (useKaratsuba(a5.length, b2.length))
            return new BigInteger(multiplyKaratsuba(a5, b2), sign4);
          return new BigInteger(multiplyLong(a5, b2), sign4);
        };
        BigInteger.prototype.times = BigInteger.prototype.multiply;
        function multiplySmallAndArray(a5, b2, sign4) {
          if (a5 < BASE) {
            return new BigInteger(multiplySmall(b2, a5), sign4);
          }
          return new BigInteger(multiplyLong(b2, smallToArray(a5)), sign4);
        }
        SmallInteger.prototype._multiplyBySmall = function(a5) {
          if (isPrecise(a5.value * this.value)) {
            return new SmallInteger(a5.value * this.value);
          }
          return multiplySmallAndArray(Math.abs(a5.value), smallToArray(Math.abs(this.value)), this.sign !== a5.sign);
        };
        BigInteger.prototype._multiplyBySmall = function(a5) {
          if (a5.value === 0) return Integer[0];
          if (a5.value === 1) return this;
          if (a5.value === -1) return this.negate();
          return multiplySmallAndArray(Math.abs(a5.value), this.value, this.sign !== a5.sign);
        };
        SmallInteger.prototype.multiply = function(v3) {
          return parseValue(v3)._multiplyBySmall(this);
        };
        SmallInteger.prototype.times = SmallInteger.prototype.multiply;
        NativeBigInt.prototype.multiply = function(v3) {
          return new NativeBigInt(this.value * parseValue(v3).value);
        };
        NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
        function square2(a5) {
          var l8 = a5.length, r6 = createArray(l8 + l8), base = BASE, product, carry, i6, a_i, a_j;
          for (i6 = 0; i6 < l8; i6++) {
            a_i = a5[i6];
            carry = 0 - a_i * a_i;
            for (var j2 = i6; j2 < l8; j2++) {
              a_j = a5[j2];
              product = 2 * (a_i * a_j) + r6[i6 + j2] + carry;
              carry = Math.floor(product / base);
              r6[i6 + j2] = product - carry * base;
            }
            r6[i6 + l8] = carry;
          }
          trim(r6);
          return r6;
        }
        BigInteger.prototype.square = function() {
          return new BigInteger(square2(this.value), false);
        };
        SmallInteger.prototype.square = function() {
          var value = this.value * this.value;
          if (isPrecise(value)) return new SmallInteger(value);
          return new BigInteger(square2(smallToArray(Math.abs(this.value))), false);
        };
        NativeBigInt.prototype.square = function(v3) {
          return new NativeBigInt(this.value * this.value);
        };
        function divMod1(a5, b2) {
          var a_l = a5.length, b_l = b2.length, base = BASE, result = createArray(b2.length), divisorMostSignificantDigit = b2[b_l - 1], lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a5, lambda), divisor = multiplySmall(b2, lambda), quotientDigit, shift, carry, borrow, i6, l8, q;
          if (remainder.length <= a_l) remainder.push(0);
          divisor.push(0);
          divisorMostSignificantDigit = divisor[b_l - 1];
          for (shift = a_l - b_l; shift >= 0; shift--) {
            quotientDigit = base - 1;
            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
              quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
            }
            carry = 0;
            borrow = 0;
            l8 = divisor.length;
            for (i6 = 0; i6 < l8; i6++) {
              carry += quotientDigit * divisor[i6];
              q = Math.floor(carry / base);
              borrow += remainder[shift + i6] - (carry - q * base);
              carry = q;
              if (borrow < 0) {
                remainder[shift + i6] = borrow + base;
                borrow = -1;
              } else {
                remainder[shift + i6] = borrow;
                borrow = 0;
              }
            }
            while (borrow !== 0) {
              quotientDigit -= 1;
              carry = 0;
              for (i6 = 0; i6 < l8; i6++) {
                carry += remainder[shift + i6] - base + divisor[i6];
                if (carry < 0) {
                  remainder[shift + i6] = carry + base;
                  carry = 0;
                } else {
                  remainder[shift + i6] = carry;
                  carry = 1;
                }
              }
              borrow += carry;
            }
            result[shift] = quotientDigit;
          }
          remainder = divModSmall(remainder, lambda)[0];
          return [arrayToSmall(result), arrayToSmall(remainder)];
        }
        function divMod2(a5, b2) {
          var a_l = a5.length, b_l = b2.length, result = [], part = [], base = BASE, guess2, xlen, highx, highy, check;
          while (a_l) {
            part.unshift(a5[--a_l]);
            trim(part);
            if (compareAbs(part, b2) < 0) {
              result.push(0);
              continue;
            }
            xlen = part.length;
            highx = part[xlen - 1] * base + part[xlen - 2];
            highy = b2[b_l - 1] * base + b2[b_l - 2];
            if (xlen > b_l) {
              highx = (highx + 1) * base;
            }
            guess2 = Math.ceil(highx / highy);
            do {
              check = multiplySmall(b2, guess2);
              if (compareAbs(check, part) <= 0) break;
              guess2--;
            } while (guess2);
            result.push(guess2);
            part = subtract2(part, check);
          }
          result.reverse();
          return [arrayToSmall(result), arrayToSmall(part)];
        }
        function divModSmall(value, lambda) {
          var length4 = value.length, quotient = createArray(length4), base = BASE, i6, q, remainder, divisor;
          remainder = 0;
          for (i6 = length4 - 1; i6 >= 0; --i6) {
            divisor = remainder * base + value[i6];
            q = truncate(divisor / lambda);
            remainder = divisor - q * lambda;
            quotient[i6] = q | 0;
          }
          return [quotient, remainder | 0];
        }
        function divModAny(self, v3) {
          var value, n9 = parseValue(v3);
          if (supportsNativeBigInt) {
            return [new NativeBigInt(self.value / n9.value), new NativeBigInt(self.value % n9.value)];
          }
          var a5 = self.value, b2 = n9.value;
          var quotient;
          if (b2 === 0) throw new Error("Cannot divide by zero");
          if (self.isSmall) {
            if (n9.isSmall) {
              return [new SmallInteger(truncate(a5 / b2)), new SmallInteger(a5 % b2)];
            }
            return [Integer[0], self];
          }
          if (n9.isSmall) {
            if (b2 === 1) return [self, Integer[0]];
            if (b2 == -1) return [self.negate(), Integer[0]];
            var abs4 = Math.abs(b2);
            if (abs4 < BASE) {
              value = divModSmall(a5, abs4);
              quotient = arrayToSmall(value[0]);
              var remainder = value[1];
              if (self.sign) remainder = -remainder;
              if (typeof quotient === "number") {
                if (self.sign !== n9.sign) quotient = -quotient;
                return [new SmallInteger(quotient), new SmallInteger(remainder)];
              }
              return [new BigInteger(quotient, self.sign !== n9.sign), new SmallInteger(remainder)];
            }
            b2 = smallToArray(abs4);
          }
          var comparison = compareAbs(a5, b2);
          if (comparison === -1) return [Integer[0], self];
          if (comparison === 0) return [Integer[self.sign === n9.sign ? 1 : -1], Integer[0]];
          if (a5.length + b2.length <= 200)
            value = divMod1(a5, b2);
          else value = divMod2(a5, b2);
          quotient = value[0];
          var qSign = self.sign !== n9.sign, mod2 = value[1], mSign = self.sign;
          if (typeof quotient === "number") {
            if (qSign) quotient = -quotient;
            quotient = new SmallInteger(quotient);
          } else quotient = new BigInteger(quotient, qSign);
          if (typeof mod2 === "number") {
            if (mSign) mod2 = -mod2;
            mod2 = new SmallInteger(mod2);
          } else mod2 = new BigInteger(mod2, mSign);
          return [quotient, mod2];
        }
        BigInteger.prototype.divmod = function(v3) {
          var result = divModAny(this, v3);
          return {
            quotient: result[0],
            remainder: result[1]
          };
        };
        NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
        BigInteger.prototype.divide = function(v3) {
          return divModAny(this, v3)[0];
        };
        NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v3) {
          return new NativeBigInt(this.value / parseValue(v3).value);
        };
        SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
        BigInteger.prototype.mod = function(v3) {
          return divModAny(this, v3)[1];
        };
        NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v3) {
          return new NativeBigInt(this.value % parseValue(v3).value);
        };
        SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
        BigInteger.prototype.pow = function(v3) {
          var n9 = parseValue(v3), a5 = this.value, b2 = n9.value, value, x3, y3;
          if (b2 === 0) return Integer[1];
          if (a5 === 0) return Integer[0];
          if (a5 === 1) return Integer[1];
          if (a5 === -1) return n9.isEven() ? Integer[1] : Integer[-1];
          if (n9.sign) {
            return Integer[0];
          }
          if (!n9.isSmall) throw new Error("The exponent " + n9.toString() + " is too large.");
          if (this.isSmall) {
            if (isPrecise(value = Math.pow(a5, b2)))
              return new SmallInteger(truncate(value));
          }
          x3 = this;
          y3 = Integer[1];
          while (true) {
            if (b2 & true) {
              y3 = y3.times(x3);
              --b2;
            }
            if (b2 === 0) break;
            b2 /= 2;
            x3 = x3.square();
          }
          return y3;
        };
        SmallInteger.prototype.pow = BigInteger.prototype.pow;
        NativeBigInt.prototype.pow = function(v3) {
          var n9 = parseValue(v3);
          var a5 = this.value, b2 = n9.value;
          var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
          if (b2 === _0) return Integer[1];
          if (a5 === _0) return Integer[0];
          if (a5 === _1) return Integer[1];
          if (a5 === BigInt(-1)) return n9.isEven() ? Integer[1] : Integer[-1];
          if (n9.isNegative()) return new NativeBigInt(_0);
          var x3 = this;
          var y3 = Integer[1];
          while (true) {
            if ((b2 & _1) === _1) {
              y3 = y3.times(x3);
              --b2;
            }
            if (b2 === _0) break;
            b2 /= _2;
            x3 = x3.square();
          }
          return y3;
        };
        BigInteger.prototype.modPow = function(exp2, mod2) {
          exp2 = parseValue(exp2);
          mod2 = parseValue(mod2);
          if (mod2.isZero()) throw new Error("Cannot take modPow with modulus 0");
          var r6 = Integer[1], base = this.mod(mod2);
          if (exp2.isNegative()) {
            exp2 = exp2.multiply(Integer[-1]);
            base = base.modInv(mod2);
          }
          while (exp2.isPositive()) {
            if (base.isZero()) return Integer[0];
            if (exp2.isOdd()) r6 = r6.multiply(base).mod(mod2);
            exp2 = exp2.divide(2);
            base = base.square().mod(mod2);
          }
          return r6;
        };
        NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
        function compareAbs(a5, b2) {
          if (a5.length !== b2.length) {
            return a5.length > b2.length ? 1 : -1;
          }
          for (var i6 = a5.length - 1; i6 >= 0; i6--) {
            if (a5[i6] !== b2[i6]) return a5[i6] > b2[i6] ? 1 : -1;
          }
          return 0;
        }
        BigInteger.prototype.compareAbs = function(v3) {
          var n9 = parseValue(v3), a5 = this.value, b2 = n9.value;
          if (n9.isSmall) return 1;
          return compareAbs(a5, b2);
        };
        SmallInteger.prototype.compareAbs = function(v3) {
          var n9 = parseValue(v3), a5 = Math.abs(this.value), b2 = n9.value;
          if (n9.isSmall) {
            b2 = Math.abs(b2);
            return a5 === b2 ? 0 : a5 > b2 ? 1 : -1;
          }
          return -1;
        };
        NativeBigInt.prototype.compareAbs = function(v3) {
          var a5 = this.value;
          var b2 = parseValue(v3).value;
          a5 = a5 >= 0 ? a5 : -a5;
          b2 = b2 >= 0 ? b2 : -b2;
          return a5 === b2 ? 0 : a5 > b2 ? 1 : -1;
        };
        BigInteger.prototype.compare = function(v3) {
          if (v3 === Infinity) {
            return -1;
          }
          if (v3 === -Infinity) {
            return 1;
          }
          var n9 = parseValue(v3), a5 = this.value, b2 = n9.value;
          if (this.sign !== n9.sign) {
            return n9.sign ? 1 : -1;
          }
          if (n9.isSmall) {
            return this.sign ? -1 : 1;
          }
          return compareAbs(a5, b2) * (this.sign ? -1 : 1);
        };
        BigInteger.prototype.compareTo = BigInteger.prototype.compare;
        SmallInteger.prototype.compare = function(v3) {
          if (v3 === Infinity) {
            return -1;
          }
          if (v3 === -Infinity) {
            return 1;
          }
          var n9 = parseValue(v3), a5 = this.value, b2 = n9.value;
          if (n9.isSmall) {
            return a5 == b2 ? 0 : a5 > b2 ? 1 : -1;
          }
          if (a5 < 0 !== n9.sign) {
            return a5 < 0 ? -1 : 1;
          }
          return a5 < 0 ? 1 : -1;
        };
        SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
        NativeBigInt.prototype.compare = function(v3) {
          if (v3 === Infinity) {
            return -1;
          }
          if (v3 === -Infinity) {
            return 1;
          }
          var a5 = this.value;
          var b2 = parseValue(v3).value;
          return a5 === b2 ? 0 : a5 > b2 ? 1 : -1;
        };
        NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
        BigInteger.prototype.equals = function(v3) {
          return this.compare(v3) === 0;
        };
        NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
        BigInteger.prototype.notEquals = function(v3) {
          return this.compare(v3) !== 0;
        };
        NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
        BigInteger.prototype.greater = function(v3) {
          return this.compare(v3) > 0;
        };
        NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
        BigInteger.prototype.lesser = function(v3) {
          return this.compare(v3) < 0;
        };
        NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
        BigInteger.prototype.greaterOrEquals = function(v3) {
          return this.compare(v3) >= 0;
        };
        NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
        BigInteger.prototype.lesserOrEquals = function(v3) {
          return this.compare(v3) <= 0;
        };
        NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
        BigInteger.prototype.isEven = function() {
          return (this.value[0] & 1) === 0;
        };
        SmallInteger.prototype.isEven = function() {
          return (this.value & 1) === 0;
        };
        NativeBigInt.prototype.isEven = function() {
          return (this.value & BigInt(1)) === BigInt(0);
        };
        BigInteger.prototype.isOdd = function() {
          return (this.value[0] & 1) === 1;
        };
        SmallInteger.prototype.isOdd = function() {
          return (this.value & 1) === 1;
        };
        NativeBigInt.prototype.isOdd = function() {
          return (this.value & BigInt(1)) === BigInt(1);
        };
        BigInteger.prototype.isPositive = function() {
          return !this.sign;
        };
        SmallInteger.prototype.isPositive = function() {
          return this.value > 0;
        };
        NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
        BigInteger.prototype.isNegative = function() {
          return this.sign;
        };
        SmallInteger.prototype.isNegative = function() {
          return this.value < 0;
        };
        NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
        BigInteger.prototype.isUnit = function() {
          return false;
        };
        SmallInteger.prototype.isUnit = function() {
          return Math.abs(this.value) === 1;
        };
        NativeBigInt.prototype.isUnit = function() {
          return this.abs().value === BigInt(1);
        };
        BigInteger.prototype.isZero = function() {
          return false;
        };
        SmallInteger.prototype.isZero = function() {
          return this.value === 0;
        };
        NativeBigInt.prototype.isZero = function() {
          return this.value === BigInt(0);
        };
        BigInteger.prototype.isDivisibleBy = function(v3) {
          var n9 = parseValue(v3);
          if (n9.isZero()) return false;
          if (n9.isUnit()) return true;
          if (n9.compareAbs(2) === 0) return this.isEven();
          return this.mod(n9).isZero();
        };
        NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
        function isBasicPrime(v3) {
          var n9 = v3.abs();
          if (n9.isUnit()) return false;
          if (n9.equals(2) || n9.equals(3) || n9.equals(5)) return true;
          if (n9.isEven() || n9.isDivisibleBy(3) || n9.isDivisibleBy(5)) return false;
          if (n9.lesser(49)) return true;
        }
        function millerRabinTest(n9, a5) {
          var nPrev = n9.prev(), b2 = nPrev, r6 = 0, d3, t5, i6, x3;
          while (b2.isEven()) b2 = b2.divide(2), r6++;
          next: for (i6 = 0; i6 < a5.length; i6++) {
            if (n9.lesser(a5[i6])) continue;
            x3 = bigInt2(a5[i6]).modPow(b2, n9);
            if (x3.isUnit() || x3.equals(nPrev)) continue;
            for (d3 = r6 - 1; d3 != 0; d3--) {
              x3 = x3.square().mod(n9);
              if (x3.isUnit()) return false;
              if (x3.equals(nPrev)) continue next;
            }
            return false;
          }
          return true;
        }
        BigInteger.prototype.isPrime = function(strict) {
          var isPrime = isBasicPrime(this);
          if (isPrime !== undefined2) return isPrime;
          var n9 = this.abs();
          var bits = n9.bitLength();
          if (bits <= 64)
            return millerRabinTest(n9, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
          var logN = Math.log(2) * bits.toJSNumber();
          var t5 = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
          for (var a5 = [], i6 = 0; i6 < t5; i6++) {
            a5.push(bigInt2(i6 + 2));
          }
          return millerRabinTest(n9, a5);
        };
        NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
        BigInteger.prototype.isProbablePrime = function(iterations2, rng) {
          var isPrime = isBasicPrime(this);
          if (isPrime !== undefined2) return isPrime;
          var n9 = this.abs();
          var t5 = iterations2 === undefined2 ? 5 : iterations2;
          for (var a5 = [], i6 = 0; i6 < t5; i6++) {
            a5.push(bigInt2.randBetween(2, n9.minus(2), rng));
          }
          return millerRabinTest(n9, a5);
        };
        NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
        BigInteger.prototype.modInv = function(n9) {
          var t5 = bigInt2.zero, newT = bigInt2.one, r6 = parseValue(n9), newR = this.abs(), q, lastT, lastR;
          while (!newR.isZero()) {
            q = r6.divide(newR);
            lastT = t5;
            lastR = r6;
            t5 = newT;
            r6 = newR;
            newT = lastT.subtract(q.multiply(newT));
            newR = lastR.subtract(q.multiply(newR));
          }
          if (!r6.isUnit()) throw new Error(this.toString() + " and " + n9.toString() + " are not co-prime");
          if (t5.compare(0) === -1) {
            t5 = t5.add(n9);
          }
          if (this.isNegative()) {
            return t5.negate();
          }
          return t5;
        };
        NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
        BigInteger.prototype.next = function() {
          var value = this.value;
          if (this.sign) {
            return subtractSmall(value, 1, this.sign);
          }
          return new BigInteger(addSmall(value, 1), this.sign);
        };
        SmallInteger.prototype.next = function() {
          var value = this.value;
          if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
          return new BigInteger(MAX_INT_ARR, false);
        };
        NativeBigInt.prototype.next = function() {
          return new NativeBigInt(this.value + BigInt(1));
        };
        BigInteger.prototype.prev = function() {
          var value = this.value;
          if (this.sign) {
            return new BigInteger(addSmall(value, 1), true);
          }
          return subtractSmall(value, 1, this.sign);
        };
        SmallInteger.prototype.prev = function() {
          var value = this.value;
          if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
          return new BigInteger(MAX_INT_ARR, true);
        };
        NativeBigInt.prototype.prev = function() {
          return new NativeBigInt(this.value - BigInt(1));
        };
        var powersOfTwo = [1];
        while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
        var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
        function shift_isSmall(n9) {
          return Math.abs(n9) <= BASE;
        }
        BigInteger.prototype.shiftLeft = function(v3) {
          var n9 = parseValue(v3).toJSNumber();
          if (!shift_isSmall(n9)) {
            throw new Error(String(n9) + " is too large for shifting.");
          }
          if (n9 < 0) return this.shiftRight(-n9);
          var result = this;
          if (result.isZero()) return result;
          while (n9 >= powers2Length) {
            result = result.multiply(highestPower2);
            n9 -= powers2Length - 1;
          }
          return result.multiply(powersOfTwo[n9]);
        };
        NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
        BigInteger.prototype.shiftRight = function(v3) {
          var remQuo;
          var n9 = parseValue(v3).toJSNumber();
          if (!shift_isSmall(n9)) {
            throw new Error(String(n9) + " is too large for shifting.");
          }
          if (n9 < 0) return this.shiftLeft(-n9);
          var result = this;
          while (n9 >= powers2Length) {
            if (result.isZero() || result.isNegative() && result.isUnit()) return result;
            remQuo = divModAny(result, highestPower2);
            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            n9 -= powers2Length - 1;
          }
          remQuo = divModAny(result, powersOfTwo[n9]);
          return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
        };
        NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
        function bitwise(x3, y3, fn) {
          y3 = parseValue(y3);
          var xSign = x3.isNegative(), ySign = y3.isNegative();
          var xRem = xSign ? x3.not() : x3, yRem = ySign ? y3.not() : y3;
          var xDigit = 0, yDigit = 0;
          var xDivMod = null, yDivMod = null;
          var result = [];
          while (!xRem.isZero() || !yRem.isZero()) {
            xDivMod = divModAny(xRem, highestPower2);
            xDigit = xDivMod[1].toJSNumber();
            if (xSign) {
              xDigit = highestPower2 - 1 - xDigit;
            }
            yDivMod = divModAny(yRem, highestPower2);
            yDigit = yDivMod[1].toJSNumber();
            if (ySign) {
              yDigit = highestPower2 - 1 - yDigit;
            }
            xRem = xDivMod[0];
            yRem = yDivMod[0];
            result.push(fn(xDigit, yDigit));
          }
          var sum3 = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt2(-1) : bigInt2(0);
          for (var i6 = result.length - 1; i6 >= 0; i6 -= 1) {
            sum3 = sum3.multiply(highestPower2).add(bigInt2(result[i6]));
          }
          return sum3;
        }
        BigInteger.prototype.not = function() {
          return this.negate().prev();
        };
        NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;
        BigInteger.prototype.and = function(n9) {
          return bitwise(this, n9, function(a5, b2) {
            return a5 & b2;
          });
        };
        NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;
        BigInteger.prototype.or = function(n9) {
          return bitwise(this, n9, function(a5, b2) {
            return a5 | b2;
          });
        };
        NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;
        BigInteger.prototype.xor = function(n9) {
          return bitwise(this, n9, function(a5, b2) {
            return a5 ^ b2;
          });
        };
        NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;
        var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
        function roughLOB(n9) {
          var v3 = n9.value, x3 = typeof v3 === "number" ? v3 | LOBMASK_I : typeof v3 === "bigint" ? v3 | BigInt(LOBMASK_I) : v3[0] + v3[1] * BASE | LOBMASK_BI;
          return x3 & -x3;
        }
        function integerLogarithm(value, base) {
          if (base.compareTo(value) <= 0) {
            var tmp = integerLogarithm(value, base.square(base));
            var p11 = tmp.p;
            var e11 = tmp.e;
            var t5 = p11.multiply(base);
            return t5.compareTo(value) <= 0 ? { p: t5, e: e11 * 2 + 1 } : { p: p11, e: e11 * 2 };
          }
          return { p: bigInt2(1), e: 0 };
        }
        BigInteger.prototype.bitLength = function() {
          var n9 = this;
          if (n9.compareTo(bigInt2(0)) < 0) {
            n9 = n9.negate().subtract(bigInt2(1));
          }
          if (n9.compareTo(bigInt2(0)) === 0) {
            return bigInt2(0);
          }
          return bigInt2(integerLogarithm(n9, bigInt2(2)).e).add(bigInt2(1));
        };
        NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
        function max3(a5, b2) {
          a5 = parseValue(a5);
          b2 = parseValue(b2);
          return a5.greater(b2) ? a5 : b2;
        }
        function min4(a5, b2) {
          a5 = parseValue(a5);
          b2 = parseValue(b2);
          return a5.lesser(b2) ? a5 : b2;
        }
        function gcd2(a5, b2) {
          a5 = parseValue(a5).abs();
          b2 = parseValue(b2).abs();
          if (a5.equals(b2)) return a5;
          if (a5.isZero()) return b2;
          if (b2.isZero()) return a5;
          var c9 = Integer[1], d3, t5;
          while (a5.isEven() && b2.isEven()) {
            d3 = min4(roughLOB(a5), roughLOB(b2));
            a5 = a5.divide(d3);
            b2 = b2.divide(d3);
            c9 = c9.multiply(d3);
          }
          while (a5.isEven()) {
            a5 = a5.divide(roughLOB(a5));
          }
          do {
            while (b2.isEven()) {
              b2 = b2.divide(roughLOB(b2));
            }
            if (a5.greater(b2)) {
              t5 = b2;
              b2 = a5;
              a5 = t5;
            }
            b2 = b2.subtract(a5);
          } while (!b2.isZero());
          return c9.isUnit() ? a5 : a5.multiply(c9);
        }
        function lcm2(a5, b2) {
          a5 = parseValue(a5).abs();
          b2 = parseValue(b2).abs();
          return a5.divide(gcd2(a5, b2)).multiply(b2);
        }
        function randBetween(a5, b2, rng) {
          a5 = parseValue(a5);
          b2 = parseValue(b2);
          var usedRNG = rng || Math.random;
          var low = min4(a5, b2), high = max3(a5, b2);
          var range3 = high.subtract(low).add(1);
          if (range3.isSmall) return low.add(Math.floor(usedRNG() * range3));
          var digits = toBase(range3, BASE).value;
          var result = [], restricted = true;
          for (var i6 = 0; i6 < digits.length; i6++) {
            var top3 = restricted ? digits[i6] + (i6 + 1 < digits.length ? digits[i6 + 1] / BASE : 0) : BASE;
            var digit = truncate(usedRNG() * top3);
            result.push(digit);
            if (digit < digits[i6]) restricted = false;
          }
          return low.add(Integer.fromArray(result, BASE, false));
        }
        var parseBase = function(text2, base, alphabet, caseSensitive) {
          alphabet = alphabet || DEFAULT_ALPHABET;
          text2 = String(text2);
          if (!caseSensitive) {
            text2 = text2.toLowerCase();
            alphabet = alphabet.toLowerCase();
          }
          var length4 = text2.length;
          var i6;
          var absBase = Math.abs(base);
          var alphabetValues = {};
          for (i6 = 0; i6 < alphabet.length; i6++) {
            alphabetValues[alphabet[i6]] = i6;
          }
          for (i6 = 0; i6 < length4; i6++) {
            var c9 = text2[i6];
            if (c9 === "-") continue;
            if (c9 in alphabetValues) {
              if (alphabetValues[c9] >= absBase) {
                if (c9 === "1" && absBase === 1) continue;
                throw new Error(c9 + " is not a valid digit in base " + base + ".");
              }
            }
          }
          base = parseValue(base);
          var digits = [];
          var isNegative = text2[0] === "-";
          for (i6 = isNegative ? 1 : 0; i6 < text2.length; i6++) {
            var c9 = text2[i6];
            if (c9 in alphabetValues) digits.push(parseValue(alphabetValues[c9]));
            else if (c9 === "<") {
              var start2 = i6;
              do {
                i6++;
              } while (text2[i6] !== ">" && i6 < text2.length);
              digits.push(parseValue(text2.slice(start2 + 1, i6)));
            } else throw new Error(c9 + " is not a valid character");
          }
          return parseBaseFromArray(digits, base, isNegative);
        };
        function parseBaseFromArray(digits, base, isNegative) {
          var val = Integer[0], pow4 = Integer[1], i6;
          for (i6 = digits.length - 1; i6 >= 0; i6--) {
            val = val.add(digits[i6].times(pow4));
            pow4 = pow4.times(base);
          }
          return isNegative ? val.negate() : val;
        }
        function stringify(digit, alphabet) {
          alphabet = alphabet || DEFAULT_ALPHABET;
          if (digit < alphabet.length) {
            return alphabet[digit];
          }
          return "<" + digit + ">";
        }
        function toBase(n9, base) {
          base = bigInt2(base);
          if (base.isZero()) {
            if (n9.isZero()) return { value: [0], isNegative: false };
            throw new Error("Cannot convert nonzero numbers to base 0.");
          }
          if (base.equals(-1)) {
            if (n9.isZero()) return { value: [0], isNegative: false };
            if (n9.isNegative())
              return {
                value: [].concat.apply(
                  [],
                  Array.apply(null, Array(-n9.toJSNumber())).map(Array.prototype.valueOf, [1, 0])
                ),
                isNegative: false
              };
            var arr = Array.apply(null, Array(n9.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
            arr.unshift([1]);
            return {
              value: [].concat.apply([], arr),
              isNegative: false
            };
          }
          var neg = false;
          if (n9.isNegative() && base.isPositive()) {
            neg = true;
            n9 = n9.abs();
          }
          if (base.isUnit()) {
            if (n9.isZero()) return { value: [0], isNegative: false };
            return {
              value: Array.apply(null, Array(n9.toJSNumber())).map(Number.prototype.valueOf, 1),
              isNegative: neg
            };
          }
          var out = [];
          var left2 = n9, divmod;
          while (left2.isNegative() || left2.compareAbs(base) >= 0) {
            divmod = left2.divmod(base);
            left2 = divmod.quotient;
            var digit = divmod.remainder;
            if (digit.isNegative()) {
              digit = base.minus(digit).abs();
              left2 = left2.next();
            }
            out.push(digit.toJSNumber());
          }
          out.push(left2.toJSNumber());
          return { value: out.reverse(), isNegative: neg };
        }
        function toBaseString(n9, base, alphabet) {
          var arr = toBase(n9, base);
          return (arr.isNegative ? "-" : "") + arr.value.map(function(x3) {
            return stringify(x3, alphabet);
          }).join("");
        }
        BigInteger.prototype.toArray = function(radix) {
          return toBase(this, radix);
        };
        SmallInteger.prototype.toArray = function(radix) {
          return toBase(this, radix);
        };
        NativeBigInt.prototype.toArray = function(radix) {
          return toBase(this, radix);
        };
        BigInteger.prototype.toString = function(radix, alphabet) {
          if (radix === undefined2) radix = 10;
          if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);
          var v3 = this.value, l8 = v3.length, str = String(v3[--l8]), zeros = "0000000", digit;
          while (--l8 >= 0) {
            digit = String(v3[l8]);
            str += zeros.slice(digit.length) + digit;
          }
          var sign4 = this.sign ? "-" : "";
          return sign4 + str;
        };
        SmallInteger.prototype.toString = function(radix, alphabet) {
          if (radix === undefined2) radix = 10;
          if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);
          return String(this.value);
        };
        NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
        NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
          return this.toString();
        };
        BigInteger.prototype.valueOf = function() {
          return parseInt(this.toString(), 10);
        };
        BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
        SmallInteger.prototype.valueOf = function() {
          return this.value;
        };
        SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
        NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {
          return parseInt(this.toString(), 10);
        };
        function parseStringValue(v3) {
          if (isPrecise(+v3)) {
            var x3 = +v3;
            if (x3 === truncate(x3))
              return supportsNativeBigInt ? new NativeBigInt(BigInt(x3)) : new SmallInteger(x3);
            throw new Error("Invalid integer: " + v3);
          }
          var sign4 = v3[0] === "-";
          if (sign4) v3 = v3.slice(1);
          var split = v3.split(/e/i);
          if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
          if (split.length === 2) {
            var exp2 = split[1];
            if (exp2[0] === "+") exp2 = exp2.slice(1);
            exp2 = +exp2;
            if (exp2 !== truncate(exp2) || !isPrecise(exp2)) throw new Error("Invalid integer: " + exp2 + " is not a valid exponent.");
            var text2 = split[0];
            var decimalPlace = text2.indexOf(".");
            if (decimalPlace >= 0) {
              exp2 -= text2.length - decimalPlace - 1;
              text2 = text2.slice(0, decimalPlace) + text2.slice(decimalPlace + 1);
            }
            if (exp2 < 0) throw new Error("Cannot include negative exponent part for integers");
            text2 += new Array(exp2 + 1).join("0");
            v3 = text2;
          }
          var isValid = /^([0-9][0-9]*)$/.test(v3);
          if (!isValid) throw new Error("Invalid integer: " + v3);
          if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(sign4 ? "-" + v3 : v3));
          }
          var r6 = [], max4 = v3.length, l8 = LOG_BASE, min5 = max4 - l8;
          while (max4 > 0) {
            r6.push(+v3.slice(min5, max4));
            min5 -= l8;
            if (min5 < 0) min5 = 0;
            max4 -= l8;
          }
          trim(r6);
          return new BigInteger(r6, sign4);
        }
        function parseNumberValue(v3) {
          if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(v3));
          }
          if (isPrecise(v3)) {
            if (v3 !== truncate(v3)) throw new Error(v3 + " is not an integer.");
            return new SmallInteger(v3);
          }
          return parseStringValue(v3.toString());
        }
        function parseValue(v3) {
          if (typeof v3 === "number") {
            return parseNumberValue(v3);
          }
          if (typeof v3 === "string") {
            return parseStringValue(v3);
          }
          if (typeof v3 === "bigint") {
            return new NativeBigInt(v3);
          }
          return v3;
        }
        for (var i5 = 0; i5 < 1e3; i5++) {
          Integer[i5] = parseValue(i5);
          if (i5 > 0) Integer[-i5] = parseValue(-i5);
        }
        Integer.one = Integer[1];
        Integer.zero = Integer[0];
        Integer.minusOne = Integer[-1];
        Integer.max = max3;
        Integer.min = min4;
        Integer.gcd = gcd2;
        Integer.lcm = lcm2;
        Integer.isInstance = function(x3) {
          return x3 instanceof BigInteger || x3 instanceof SmallInteger || x3 instanceof NativeBigInt;
        };
        Integer.randBetween = randBetween;
        Integer.fromArray = function(digits, base, isNegative) {
          return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
        };
        return Integer;
      }();
      if (typeof module2 !== "undefined" && module2.hasOwnProperty("exports")) {
        module2.exports = bigInt2;
      }
      if (typeof define === "function" && define.amd) {
        define(function() {
          return bigInt2;
        });
      }
    }
  });

  // ../../../../../node_modules/algebrite/dist/algebrite.js
  var require_algebrite = __commonJS({
    "../../../../../node_modules/algebrite/dist/algebrite.js"(exports, module) {
      (function() {
        var $, ABS, ADD, ADJ, AND, APPROXRATIO, ARCCOS, ARCCOSH, ARCSIN, ARCSINH, ARCTAN, ARCTANH, ARG, ASSUME_REAL_VARIABLES, ATOMIZE, AUTOEXPAND, BAKE, BESSELJ, BESSELY, BINDING, BINOMIAL, BINOM_check_args, BUF, C1, C2, C3, C4, C5, C6, CEILING, CHECK, CHOOSE, CIRCEXP, CLEAR, CLEARALL, CLEARPATTERNS, CLOCK, COEFF, COFACTOR, CONDENSE, CONJ, CONS, CONTRACT, COS, COSH, Condense, DEBUG, DEBUG_ABS, DEBUG_ARG, DEBUG_CLOCKFORM, DEBUG_IMAG, DEBUG_IS, DEBUG_MULTIPLY, DEBUG_POWER, DEBUG_RATIONALIZE, DEBUG_RECT, DEBUG_SIMPLIFY, DECOMP, DEFINT, DEGREE, DENOMINATOR, DERIVATIVE, DET, DET_check_arg, DIM, DIRAC, DIVISORS, DO, DOT, DOUBLE, DRAW, DRAWX, DSOLVE, E, EIGEN, EIGENVAL, EIGENVEC, EIG_N, EIG_check_arg, EIG_yydd, EIG_yyqq, ERF, ERFC, EVAL, EXP, EXPAND, EXPCOS, EXPSIN, Eval, Eval_Eval, Eval_abs, Eval_add, Eval_adj, Eval_and, Eval_approxratio, Eval_arccos, Eval_arccosh, Eval_arcsin, Eval_arcsinh, Eval_arctan, Eval_arctanh, Eval_arg, Eval_besselj, Eval_bessely, Eval_binding, Eval_binomial, Eval_ceiling, Eval_check, Eval_choose, Eval_circexp, Eval_clear, Eval_clearall, Eval_clearpatterns, Eval_clock, Eval_coeff, Eval_cofactor, Eval_condense, Eval_conj, Eval_cons, Eval_contract, Eval_cos, Eval_cosh, Eval_decomp, Eval_defint, Eval_degree, Eval_denominator, Eval_derivative, Eval_det, Eval_dim, Eval_dirac, Eval_divisors, Eval_do, Eval_dsolve, Eval_eigen, Eval_eigenval, Eval_eigenvec, Eval_erf, Eval_erfc, Eval_exp, Eval_expand, Eval_expcos, Eval_expsin, Eval_factor, Eval_factorial, Eval_factorpoly, Eval_filter, Eval_float, Eval_floor, Eval_for, Eval_function_reference, Eval_gamma, Eval_gcd, Eval_hermite, Eval_hilbert, Eval_imag, Eval_index, Eval_inner, Eval_integral, Eval_inv, Eval_invg, Eval_isinteger, Eval_isprime, Eval_laguerre, Eval_lcm, Eval_leading, Eval_legendre, Eval_log, Eval_lookup, Eval_mod, Eval_multiply, Eval_noexpand, Eval_not, Eval_nroots, Eval_number, Eval_numerator, Eval_operator, Eval_or, Eval_outer, Eval_pattern, Eval_patternsinfo, Eval_polar, Eval_power, Eval_predicate, Eval_prime, Eval_print, Eval_print2dascii, Eval_printcomputer, Eval_printhuman, Eval_printlatex, Eval_printlist, Eval_product, Eval_quote, Eval_quotient, Eval_rank, Eval_rationalize, Eval_real, Eval_rect, Eval_roots, Eval_round, Eval_setq, Eval_sgn, Eval_shape, Eval_silentpattern, Eval_simfac, Eval_simplify, Eval_sin, Eval_sinh, Eval_sqrt, Eval_stop, Eval_subst, Eval_sum, Eval_sym, Eval_symbolsinfo, Eval_tan, Eval_tanh, Eval_taylor, Eval_tensor, Eval_test, Eval_testeq, Eval_testge, Eval_testgt, Eval_testle, Eval_testlt, Eval_transpose, Eval_unit, Eval_user_function, Eval_zero, Evalpoly, FACTOR, FACTORIAL, FACTORPOLY, FILTER, FLOATF, FLOOR, FOR, FORCE_FIXED_PRINTOUT, FUNCTION, Find, GAMMA, GCD, HERMITE, HILBERT, IMAG, INDEX, INNER, INTEGRAL, INV, INVG, INV_check_arg, INV_decomp, ISINTEGER, ISPRIME, LAGUERRE, LAST, LAST_2DASCII_PRINT, LAST_FULL_PRINT, LAST_LATEX_PRINT, LAST_LIST_PRINT, LAST_PLAIN_PRINT, LAST_PRINT, LCM, LEADING, LEGENDRE, LOG, LOOKUP, M, MAXDIM, MAXPRIMETAB, MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES, MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE, MAX_FIXED_PRINTOUT_DIGITS, MAX_PROGRAM_SIZE, MEQUAL, METAA, METAB, METAX, MLENGTH, MOD, MSIGN, MULTIPLY, MZERO, N, NIL, NOT, NROOTS, NROOTS_ABS, NROOTS_DELTA, NROOTS_EPSILON, NROOTS_RANDOM, NROOTS_YMAX, NROOTS_divpoly, NSYM, NUM, NUMBER, NUMERATOR, OPERATOR, OR, OUTER, PATTERN, PATTERNSINFO, PI, POLAR, POWER, PRIME, PRINT, PRINT2DASCII, PRINTFULL, PRINTLATEX, PRINTLIST, PRINTMODE_2DASCII, PRINTMODE_COMPUTER, PRINTMODE_HUMAN, PRINTMODE_LATEX, PRINTMODE_LIST, PRINTOUTRESULT, PRINTPLAIN, PRINT_LEAVE_E_ALONE, PRINT_LEAVE_X_ALONE, PRODUCT, QUOTE, QUOTIENT, RANK, RATIONALIZE, REAL, ROOTS, ROUND, SECRETX, SELFTEST, SETQ, SGN, SHAPE, SILENTPATTERN, SIMPLIFY, SIN, SINH, SPACE_BETWEEN_COLUMNS, SPACE_BETWEEN_ROWS, SQRT, STOP, STR, SUBST, SUM, SYM, SYMBOLSINFO, SYMBOL_A, SYMBOL_A_UNDERSCORE, SYMBOL_B, SYMBOL_B_UNDERSCORE, SYMBOL_C, SYMBOL_D, SYMBOL_I, SYMBOL_IDENTITY_MATRIX, SYMBOL_J, SYMBOL_N, SYMBOL_R, SYMBOL_S, SYMBOL_T, SYMBOL_X, SYMBOL_X_UNDERSCORE, SYMBOL_Y, SYMBOL_Z, TAN, TANH, TAYLOR, TENSOR, TEST, TESTEQ, TESTGE, TESTGT, TESTLE, TESTLT, TIMING_DEBUGS, TOS, TRACE, TRANSPOSE, T_DOUBLE, T_EQ, T_FUNCTION, T_GTEQ, T_INTEGER, T_LTEQ, T_NEQ, T_NEWLINE, T_QUOTASSIGN, T_STRING, T_SYMBOL, U, UNIT, USR_SYMBOLS, VERSION, YMAX, YYE, YYRECT, ZERO, __emit_char, __emit_str, __factor_add, __factorial, __is_negative, __is_radical_number, __lcm, __legendre, __legendre2, __legendre3, __normalize_radical_factors, __rationalize_tensor, _print, abs, absValFloat, absval, absval_tensor, add, addSymbolLeftOfAssignment, addSymbolRightOfAssignment, add_all, add_factor_to_accumulator, add_numbers, add_terms, addf, adj, alloc_tensor, allocatedId, any_denominators, approxAll, approxLogs, approxLogsOfRationals, approxOneRatioOnly, approxRadicals, approxRadicalsOfRationals, approxRationalsOfLogs, approxRationalsOfPowersOfE, approxRationalsOfPowersOfPI, approxRationalsOfRadicals, approxSineOfRationalMultiplesOfPI, approxSineOfRationals, approxTrigonometric, approx_just_an_integer, approx_logarithmsOfRationals, approx_nothingUseful, approx_radicalOfRatio, approx_ratioOfRadical, approx_rationalOfE, approx_rationalOfPi, approx_rationalsOfLogarithms, approx_sine_of_pi_times_rational, approx_sine_of_rational, approxratioRecursive, arccos, arccosh, arcsin, arcsinh, arctan, arctanh, areunivarpolysfactoredorexpandedform, arg, arglist, assignmentFound, avoidCalculatingPowersIntoArctans, bake, bake_poly, bake_poly_term, besselj, bessely, bigInt, bignum_factorial, bignum_float, bignum_power_number, bignum_scan_float, bignum_scan_integer, bignum_truncate, binding, binomial, buffer, build_tensor, caaddr, caadr, caar, cadaddr, cadadr, cadar, caddaddr, caddadr, caddar, caddddr, cadddr, caddr, cadr, called_from_Algebra_block, car, cdaddr, cdadr, cdar, cddaddr, cddar, cdddaddr, cddddr, cdddr, cddr, cdr, ceiling, chainOfUserSymbolsNotFunctionsBeingEvaluated, charTabIndex, chartab, checkFloatHasWorkedOutCompletely, check_esc_flag, check_stack, check_tensor_dimensions, choose, choose_check_args, circexp, clearAlgebraEnvironment, clearRenamedVariablesToAvoidBindingToExternalScope, clear_symbols, clear_term, clearall, clockform, cmpGlyphs, cmp_args, cmp_expr, cmp_terms, cmp_terms_count, codeGen, coeff, cofactor, collectLatexStringFromReturnValue, collectUserSymbols, combine_factors, combine_gammas, combine_terms, compareState, compare_numbers, compare_rationals, compare_tensors, compatible, computeDependenciesFromAlgebra, computeResultsAndJavaScriptFromAlgebra, compute_fa, conjugate, cons, consCount, contract, convert_bignum_to_double, convert_rational_to_double, copy_tensor, cosine, cosine_of_angle, cosine_of_angle_sum, count, countOccurrencesOfSymbol, count_denominators, counter, countsize, d_scalar_scalar, d_scalar_scalar_1, d_scalar_tensor, d_tensor_scalar, d_tensor_tensor, dabs, darccos, darccosh, darcsin, darcsinh, darctan, darctanh, dbesselj0, dbesseljn, dbessely0, dbesselyn, dcos, dcosh, dd, decomp, decomp_product, decomp_sum, defineSomeHandyConstants, define_user_function, defn, defn_str, degree, denominator, derf, derfc, derivative, derivative_of_integral, det, determinant, detg, dfunction, dhermite, dirac, display, display_flag, displaychar, divide, divide_numbers, divisors, divisors_onstack, divpoly, dlog, do_clearPatterns, do_clearall, do_simplify_nested_radicals, dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication, dotprod_unicode, doubleToReasonableString, dpow, dpower, dproduct, draw_flag, draw_stop_return, dsgn, dsin, dsinh, dsum, dtan, dtanh, dupl, eigen, elelmIndex, elem, emit_denominator, emit_denominators, emit_expr, emit_factor, emit_factorial_function, emit_flat_tensor, emit_fraction, emit_function, emit_index_function, emit_multiply, emit_number, emit_numerators, emit_numerical_fraction, emit_power, emit_string, emit_subexpr, emit_symbol, emit_tensor, emit_tensor_inner, emit_term, emit_top_expr, emit_unsigned_expr, emit_x, equal, equaln, equalq, erfc, errorMessage, esc_flag, evaluatingAsFloats, evaluatingPolar, exec, expand, expand_get_A, expand_get_AF, expand_get_B, expand_get_C, expand_get_CF, expand_tensor, expanding, expcos, exponential, expr_level, expsin, f1, f10, f2, f3, f4, f5, f9, f_equals_a, factor, factor_a, factor_again, factor_b, factor_number, factor_small_number, factor_term, factorial, factorpoly, factors, fill_buf, filter, filter_main, filter_sum, filter_tensor, findDependenciesInScript, findPossibleClockForm, findPossibleExponentialForm, findroot, fixup_fraction, fixup_power, flag, floatToRatioRoutine, fmt_index, fmt_level, fmt_x, frame, freeze, functionInvokationsScanningStack, gamma, gamma_of_sum, gammaf, gcd, gcd_main, gcd_numbers, gcd_polys, gcd_powers_with_same_base, gcd_product_product, gcd_product_sum, gcd_sum, gcd_sum_product, gcd_sum_sum, gen, getSimpleRoots, getStateHash, get_binding, get_factor_from_complex_root, get_factor_from_real_root, get_innerprod_factors, get_next_token, get_printname, get_size, get_token, getdisplaystr, glyph, gp, guess, hasImaginaryCoeff, hasNegativeRationalExponent, hash_addition, hash_function, hash_multiplication, hash_power, hashcode_values, hashed_itab, hermite, hilbert, i1, imag, imaginaryunit, index_function, init, initNRoots, inited, inner, inner_f, input_str, integral, integral_of_form, integral_of_product, integral_of_sum, inv, inverse, invert_number, invg, isNumberOneOverSomething, isNumericAtom, isNumericAtomOrTensor, isSimpleRoot, isSmall, isSymbolLeftOfAssignment, isSymbolReclaimable, isZeroAtom, isZeroAtomOrTensor, isZeroLikeOrNonZeroLikeOrUndetermined, isZeroTensor, is_denominator, is_factor, is_small_integer, is_square_matrix, is_usr_symbol, isadd, isalnumorunderscore, isalpha, isalphaOrUnderscore, iscomplexnumber, iscomplexnumberdouble, iscons, isdenominator, isdigit, isdouble, iseveninteger, isfactor, isfactorial, isfloating, isfraction, isidentitymatrix, isimaginarynumber, isimaginarynumberdouble, isimaginaryunit, isinnerordot, isinteger, isintegerfactor, isintegerorintegerfloat, isinv, iskeyword, isminusone, isminusoneoversqrttwo, isminusoneovertwo, isminussqrtthreeovertwo, ismultiply, isnegative, isnegativenumber, isnegativeterm, isnonnegativeinteger, isnpi, isone, isoneover, isoneoversqrttwo, isoneovertwo, isplusone, isplustwo, ispolyexpandedform, ispolyexpandedform_expr, ispolyexpandedform_factor, ispolyexpandedform_term, ispolyfactoredorexpandedform, ispolyfactoredorexpandedform_factor, ispolyfactoredorexpandedform_power, isposint, ispositivenumber, ispower, isquarterturn, isrational, isspace, issqrtthree, issqrtthreeovertwo, isstr, issymbol, issymbolic, istensor, istranspose, isunderscore, isunivarpolyfactoredorexpandedform, itab, italu_hashcode, j1, laguerre, laguerre2, lastFoundSymbol, latexErrorSign, lcm, leading, legendre, length, lessp, level, list, listLength, logarithm, logbuf, lookupsTotal, lu_decomp, madd, makePositive, makeSignSameAs, make_hashed_itab, mask, mcmp, mcmpint, mdiv, mdivrem, meta_mode, mgcd, mini_solve, mint, mmod, mmul, mod, monic, move, moveTos, mp_clr_bit, mp_denominator, mp_numerator, mp_set_bit, mpow, mprime, mroot, mshiftright, msub, mtotal, multinomial_sum, multiply, multiply_all, multiply_all_noexpand, multiply_consecutive_constants, multiply_denominators, multiply_denominators_factor, multiply_denominators_term, multiply_noexpand, multiply_numbers, n_factor_number, negate, negate_expand, negate_noexpand, negate_number, new_integer, new_string, newline_flag, nil_symbols, normaliseDots, normalisedCoeff, normalize_angle, nroots_a, nroots_b, nroots_c, nroots_df, nroots_dx, nroots_fa, nroots_fb, nroots_x, nroots_y, nterms, nthCadr, numerator, numericRootOfPolynomial, o, one, oneElement, one_as_double, out_buf, out_count, out_of_memory, outer, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, parse, parse_internal, parse_p1, parse_p2, parse_time_simplifications, partition, patternHasBeenFound, patternsinfo, performing_roots, polar, polarRectAMinusOneBase, polyform, pop, pop_double, pop_frame, pop_integer, power, power_str, power_sum, power_tensor, predefinedSymbolsInGlobalScope_doNotTrackInDependencies, prime, primetab, print2dascii, printMode, print_ABS_latex, print_ARCCOS_codegen, print_ARCSIN_codegen, print_ARCTAN_codegen, print_BINOMIAL_latex, print_COS_codegen, print_DEFINT_latex, print_DOT_codegen, print_DOT_latex, print_DO_codegen, print_FOR_codegen, print_INV_codegen, print_INV_latex, print_PRODUCT_codegen, print_PRODUCT_latex, print_SETQ_codegen, print_SIN_codegen, print_SQRT_latex, print_SUM_codegen, print_SUM_latex, print_TAN_codegen, print_TESTEQ_latex, print_TESTGE_latex, print_TESTGT_latex, print_TESTLE_latex, print_TESTLT_latex, print_TEST_codegen, print_TEST_latex, print_TRANSPOSE_codegen, print_TRANSPOSE_latex, print_UNIT_codegen, print_a_over_b, print_base, print_base_of_denom, print_char, print_denom, print_double, print_expo_of_denom, print_exponent, print_expr, print_factor, print_factorial_function, print_glyphs, print_index_function, print_list, print_multiply_sign, print_number, print_power, print_str, print_subexpr, print_tensor, print_tensor_inner, print_tensor_inner_latex, print_tensor_latex, print_term, printchar, printchar_nowrap, printline, program_buf, promote_tensor, push, pushTryNotToDuplicate, push_cars, push_double, push_factor, push_frame, push_identity_matrix, push_integer, push_rational, push_symbol, push_term_factors, push_terms, push_zero_matrix, qadd, qdiv, qmul, qpow, qpowf, quickfactor, quickpower, rational, rationalize, rationalize_coefficients, real, reciprocate, rect, recursionLevelNestedRadicalsRemoval, recursiveDependencies, ref, ref1, rememberPrint, remove_negative_exponents, reset_after_error, restore, restoreMetaBindings, rewrite_args, rewrite_args_tensor, roots, roots2, roots3, run, runUserDefinedSimplifications, save, saveMetaBindings, scalar_times_tensor, scan, scan_error, scan_expression, scan_factor, scan_function_call_with_function_name, scan_function_call_without_function_name, scan_index, scan_meta, scan_power, scan_relation, scan_stmt, scan_str, scan_string, scan_subexpr, scan_symbol, scan_tensor, scan_term, scanned, scanningParameters, setM, setSignTo, set_binding, set_component, setq_indexed, sfac_product, sfac_product_f, sgn, shape, show_power_debug, sign, sign_of_term, simfac, simfac_term, simpleComplexityMeasure, simplify, simplifyForCodeGeneration, simplify_1_in_products, simplify_main, simplify_nested_radicals, simplify_polar, simplify_polarRect, simplify_rational_expressions, simplify_rectToClock, simplify_tensor, simplify_trig, simplifyfactorials, sine, sine_of_angle, sine_of_angle_sum, skipRootVariableToBeSolved, sort_stack, square, ssqrt, stack, stackAddsCount, std_symbol, step, step2, stop, strcmp, stringsEmittedByUserPrintouts, subf, subst, subtract, subtract_numbers, swap, symbol, symbolsDependencies, symbolsHavingReassignments, symbolsInExpressionsWithoutAssignments, symbolsLeftOfAssignment, symbolsRightOfAssignment, symbolsinfo, symnum, symtab, take_care_of_nested_radicals, tangent, taylor, tensor, tensor_plus_tensor, tensor_times_scalar, testApprox, test_flag, text_metric, theRandom, token, token_buf, token_str, top, top_level_eval, tos, transform, transpose, transpose_unicode, trigmode, trivial_divide, try_kth_prime, turnErrorMessageToLatex, ucmp, unfreeze, unique, unique_f, update_token_buf, userSimplificationsInListForm, userSimplificationsInStringForm, usr_symbol, verbosing, version, will_be_displayed_as_fraction, ybinomial, ycosh, ydirac, yerf, yerfc, yfloor, yindex, yround, ysinh, yyarg, yybesselj, yybessely, yyceiling, yycondense, yycontract, yycosh, yydegree, yydetg, yydivpoly, yyerf, yyerfc, yyexpand, yyfactorpoly, yyfloat, yyfloor, yyhermite, yyhermite2, yyinvg, yylcm, yylog, yymultiply, yyouter, yypower, yyrationalize, yyround, yysgn, yysimfac, yysinh, yytangent, zero, zzfloat, hasProp = {}.hasOwnProperty;
        bigInt = require_BigInteger();
        version = "1.4.0";
        SELFTEST = 1;
        NSYM = 1e3;
        DEBUG = false;
        PRINTOUTRESULT = false;
        PRINTMODE_LATEX = "PRINTMODE_LATEX";
        PRINTMODE_2DASCII = "PRINTMODE_2DASCII";
        PRINTMODE_COMPUTER = "PRINTMODE_COMPUTER";
        PRINTMODE_HUMAN = "PRINTMODE_HUMAN";
        PRINTMODE_LIST = "PRINTMODE_LIST";
        printMode = PRINTMODE_COMPUTER;
        dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication = true;
        recursionLevelNestedRadicalsRemoval = 0;
        do_simplify_nested_radicals = true;
        avoidCalculatingPowersIntoArctans = true;
        rational = function() {
          class rational2 {
          }
          ;
          rational2.prototype.a = null;
          rational2.prototype.b = null;
          return rational2;
        }.call(this);
        U = function() {
          class U2 {
            toString() {
              return print_expr(this);
            }
            toLatexString() {
              return collectLatexStringFromReturnValue(this);
            }
            constructor() {
              this.cons = {};
              this.cons.car = null;
              this.cons.cdr = null;
              this.q = new rational();
            }
          }
          ;
          U2.prototype.cons = null;
          U2.prototype.printname = "";
          U2.prototype.str = "";
          U2.prototype.tensor = null;
          U2.prototype.q = null;
          U2.prototype.d = 0;
          U2.prototype.k = 0;
          U2.prototype.tag = 0;
          return U2;
        }.call(this);
        errorMessage = "";
        CONS = 0;
        NUM = 1;
        DOUBLE = 2;
        STR = 3;
        TENSOR = 4;
        SYM = 5;
        counter = 0;
        ABS = counter++;
        ADD = counter++;
        ADJ = counter++;
        AND = counter++;
        APPROXRATIO = counter++;
        ARCCOS = counter++;
        ARCCOSH = counter++;
        ARCSIN = counter++;
        ARCSINH = counter++;
        ARCTAN = counter++;
        ARCTANH = counter++;
        ARG = counter++;
        ATOMIZE = counter++;
        BESSELJ = counter++;
        BESSELY = counter++;
        BINDING = counter++;
        BINOMIAL = counter++;
        CEILING = counter++;
        CHECK = counter++;
        CHOOSE = counter++;
        CIRCEXP = counter++;
        CLEAR = counter++;
        CLEARALL = counter++;
        CLEARPATTERNS = counter++;
        CLOCK = counter++;
        COEFF = counter++;
        COFACTOR = counter++;
        CONDENSE = counter++;
        CONJ = counter++;
        CONTRACT = counter++;
        COS = counter++;
        COSH = counter++;
        DECOMP = counter++;
        DEFINT = counter++;
        DEGREE = counter++;
        DENOMINATOR = counter++;
        DERIVATIVE = counter++;
        DET = counter++;
        DIM = counter++;
        DIRAC = counter++;
        DIVISORS = counter++;
        DO = counter++;
        DOT = counter++;
        DRAW = counter++;
        DSOLVE = counter++;
        EIGEN = counter++;
        EIGENVAL = counter++;
        EIGENVEC = counter++;
        ERF = counter++;
        ERFC = counter++;
        EVAL = counter++;
        EXP = counter++;
        EXPAND = counter++;
        EXPCOS = counter++;
        EXPSIN = counter++;
        FACTOR = counter++;
        FACTORIAL = counter++;
        FACTORPOLY = counter++;
        FILTER = counter++;
        FLOATF = counter++;
        FLOOR = counter++;
        FOR = counter++;
        FUNCTION = counter++;
        GAMMA = counter++;
        GCD = counter++;
        HERMITE = counter++;
        HILBERT = counter++;
        IMAG = counter++;
        INDEX = counter++;
        INNER = counter++;
        INTEGRAL = counter++;
        INV = counter++;
        INVG = counter++;
        ISINTEGER = counter++;
        ISPRIME = counter++;
        LAGUERRE = counter++;
        LCM = counter++;
        LEADING = counter++;
        LEGENDRE = counter++;
        LOG = counter++;
        LOOKUP = counter++;
        MOD = counter++;
        MULTIPLY = counter++;
        NOT = counter++;
        NROOTS = counter++;
        NUMBER = counter++;
        NUMERATOR = counter++;
        OPERATOR = counter++;
        OR = counter++;
        OUTER = counter++;
        PATTERN = counter++;
        PATTERNSINFO = counter++;
        POLAR = counter++;
        POWER = counter++;
        PRIME = counter++;
        PRINT_LEAVE_E_ALONE = counter++;
        PRINT_LEAVE_X_ALONE = counter++;
        PRINT = counter++;
        PRINT2DASCII = counter++;
        PRINTFULL = counter++;
        PRINTLATEX = counter++;
        PRINTLIST = counter++;
        PRINTPLAIN = counter++;
        PRODUCT = counter++;
        QUOTE = counter++;
        QUOTIENT = counter++;
        RANK = counter++;
        RATIONALIZE = counter++;
        REAL = counter++;
        ROUND = counter++;
        YYRECT = counter++;
        ROOTS = counter++;
        SETQ = counter++;
        SGN = counter++;
        SILENTPATTERN = counter++;
        SIMPLIFY = counter++;
        SIN = counter++;
        SINH = counter++;
        SHAPE = counter++;
        SQRT = counter++;
        STOP = counter++;
        SUBST = counter++;
        SUM = counter++;
        SYMBOLSINFO = counter++;
        TAN = counter++;
        TANH = counter++;
        TAYLOR = counter++;
        TEST = counter++;
        TESTEQ = counter++;
        TESTGE = counter++;
        TESTGT = counter++;
        TESTLE = counter++;
        TESTLT = counter++;
        TRANSPOSE = counter++;
        UNIT = counter++;
        ZERO = counter++;
        NIL = counter++;
        LAST = counter++;
        LAST_PRINT = counter++;
        LAST_2DASCII_PRINT = counter++;
        LAST_FULL_PRINT = counter++;
        LAST_LATEX_PRINT = counter++;
        LAST_LIST_PRINT = counter++;
        LAST_PLAIN_PRINT = counter++;
        AUTOEXPAND = counter++;
        BAKE = counter++;
        ASSUME_REAL_VARIABLES = counter++;
        TRACE = counter++;
        FORCE_FIXED_PRINTOUT = counter++;
        MAX_FIXED_PRINTOUT_DIGITS = counter++;
        YYE = counter++;
        DRAWX = counter++;
        METAA = counter++;
        METAB = counter++;
        METAX = counter++;
        SECRETX = counter++;
        VERSION = counter++;
        PI = counter++;
        SYMBOL_A = counter++;
        SYMBOL_B = counter++;
        SYMBOL_C = counter++;
        SYMBOL_D = counter++;
        SYMBOL_I = counter++;
        SYMBOL_J = counter++;
        SYMBOL_N = counter++;
        SYMBOL_R = counter++;
        SYMBOL_S = counter++;
        SYMBOL_T = counter++;
        SYMBOL_X = counter++;
        SYMBOL_Y = counter++;
        SYMBOL_Z = counter++;
        SYMBOL_IDENTITY_MATRIX = counter++;
        SYMBOL_A_UNDERSCORE = counter++;
        SYMBOL_B_UNDERSCORE = counter++;
        SYMBOL_X_UNDERSCORE = counter++;
        C1 = counter++;
        C2 = counter++;
        C3 = counter++;
        C4 = counter++;
        C5 = counter++;
        C6 = counter++;
        USR_SYMBOLS = counter++;
        E = YYE;
        TOS = 1e5;
        BUF = 1e4;
        MAX_PROGRAM_SIZE = 100001;
        MAXPRIMETAB = 1e4;
        MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES = 5;
        MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE = 10;
        MAXDIM = 24;
        symbolsDependencies = {};
        symbolsHavingReassignments = [];
        symbolsInExpressionsWithoutAssignments = [];
        patternHasBeenFound = false;
        predefinedSymbolsInGlobalScope_doNotTrackInDependencies = ["rationalize", "abs", "e", "i", "pi", "sin", "ceiling", "cos", "roots", "integral", "derivative", "defint", "sqrt", "eig", "cov", "deig", "dcov", "float", "floor", "product", "root", "round", "sum", "test", "unit"];
        parse_time_simplifications = true;
        chainOfUserSymbolsNotFunctionsBeingEvaluated = [];
        stringsEmittedByUserPrintouts = "";
        called_from_Algebra_block = false;
        tensor = function() {
          class tensor2 {
            constructor() {
              this.dim = function() {
                var o12, ref2, results;
                results = [];
                for (o12 = 0, ref2 = MAXDIM; 0 <= ref2 ? o12 <= ref2 : o12 >= ref2; 0 <= ref2 ? o12++ : o12--) {
                  results.push(0);
                }
                return results;
              }();
              this.elem = [];
            }
          }
          ;
          tensor2.prototype.ndim = 0;
          tensor2.prototype.dim = null;
          tensor2.prototype.nelem = 0;
          tensor2.prototype.elem = null;
          return tensor2;
        }.call(this);
        display = function() {
          class display2 {
          }
          ;
          display2.prototype.h = 0;
          display2.prototype.w = 0;
          display2.prototype.n = 0;
          display2.prototype.a = [];
          return display2;
        }.call(this);
        text_metric = function() {
          class text_metric2 {
          }
          ;
          text_metric2.prototype.ascent = 0;
          text_metric2.prototype.descent = 0;
          text_metric2.prototype.width = 0;
          return text_metric2;
        }.call(this);
        tos = 0;
        expanding = 0;
        evaluatingAsFloats = 0;
        evaluatingPolar = 0;
        fmt_x = 0;
        fmt_index = 0;
        fmt_level = 0;
        verbosing = 0;
        primetab = function() {
          var ceil2, i5, j2, primes;
          primes = [2];
          i5 = 3;
          while (primes.length < MAXPRIMETAB) {
            j2 = 0;
            ceil2 = Math.sqrt(i5);
            while (j2 < primes.length && primes[j2] <= ceil2) {
              if (i5 % primes[j2] === 0) {
                j2 = -1;
                break;
              }
              j2++;
            }
            if (j2 !== -1) {
              primes.push(i5);
            }
            i5 += 2;
          }
          primes[MAXPRIMETAB] = 0;
          return primes;
        }();
        esc_flag = 0;
        draw_flag = 0;
        mtotal = 0;
        trigmode = 0;
        logbuf = "";
        program_buf = "";
        symtab = [];
        binding = [];
        isSymbolReclaimable = [];
        arglist = [];
        stack = [];
        frame = 0;
        p0 = null;
        p1 = null;
        p2 = null;
        p3 = null;
        p4 = null;
        p5 = null;
        p6 = null;
        p7 = null;
        p8 = null;
        p9 = null;
        zero = null;
        one = null;
        one_as_double = null;
        imaginaryunit = null;
        out_buf = "";
        out_count = 0;
        test_flag = 0;
        codeGen = false;
        draw_stop_return = null;
        userSimplificationsInListForm = [];
        userSimplificationsInStringForm = [];
        transpose_unicode = 7488;
        dotprod_unicode = 183;
        symbol = function(x3) {
          return symtab[x3];
        };
        iscons = function(p11) {
          return p11.k === CONS;
        };
        isrational = function(p11) {
          return p11.k === NUM;
        };
        isdouble = function(p11) {
          return p11.k === DOUBLE;
        };
        isNumericAtom = function(p11) {
          return isrational(p11) || isdouble(p11);
        };
        isstr = function(p11) {
          return p11.k === STR;
        };
        istensor = function(p11) {
          if (p11 == null) {
            debugger;
          } else {
            return p11.k === TENSOR;
          }
        };
        isNumericAtomOrTensor = function(p11) {
          var a5, i5, n9, o12, ref2;
          if (isNumericAtom(p11) || p11 === symbol(SYMBOL_IDENTITY_MATRIX)) {
            return 1;
          }
          if (!istensor(p11) && !isNumericAtom(p11)) {
            return 0;
          }
          n9 = p11.tensor.nelem;
          a5 = p11.tensor.elem;
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            if (!isNumericAtomOrTensor(a5[i5])) {
              return 0;
            }
          }
          return 1;
        };
        issymbol = function(p11) {
          return p11.k === SYM;
        };
        iskeyword = function(p11) {
          return issymbol(p11) && symnum(p11) < NIL;
        };
        car = function(p11) {
          if (iscons(p11)) {
            return p11.cons.car;
          } else {
            return symbol(NIL);
          }
        };
        cdr = function(p11) {
          if (iscons(p11)) {
            return p11.cons.cdr;
          } else {
            return symbol(NIL);
          }
        };
        caar = function(p11) {
          return car(car(p11));
        };
        cadr = function(p11) {
          return car(cdr(p11));
        };
        cdar = function(p11) {
          return cdr(car(p11));
        };
        cddr = function(p11) {
          return cdr(cdr(p11));
        };
        caadr = function(p11) {
          return car(car(cdr(p11)));
        };
        caddr = function(p11) {
          return car(cdr(cdr(p11)));
        };
        cadar = function(p11) {
          return car(cdr(car(p11)));
        };
        cdadr = function(p11) {
          return cdr(car(cdr(p11)));
        };
        cddar = function(p11) {
          return cdr(cdr(car(p11)));
        };
        cdddr = function(p11) {
          return cdr(cdr(cdr(p11)));
        };
        caaddr = function(p11) {
          return car(car(cdr(cdr(p11))));
        };
        cadadr = function(p11) {
          return car(cdr(car(cdr(p11))));
        };
        caddar = function(p11) {
          return car(cdr(cdr(car(p11))));
        };
        cdaddr = function(p11) {
          return cdr(car(cdr(cdr(p11))));
        };
        cadddr = function(p11) {
          return car(cdr(cdr(cdr(p11))));
        };
        cddddr = function(p11) {
          return cdr(cdr(cdr(cdr(p11))));
        };
        caddddr = function(p11) {
          return car(cdr(cdr(cdr(cdr(p11)))));
        };
        cadaddr = function(p11) {
          return car(cdr(car(cdr(cdr(p11)))));
        };
        cddaddr = function(p11) {
          return cdr(cdr(car(cdr(cdr(p11)))));
        };
        caddadr = function(p11) {
          return car(cdr(cdr(car(cdr(p11)))));
        };
        cdddaddr = function(p11) {
          return cdr(cdr(cdr(car(cdr(cdr(p11))))));
        };
        caddaddr = function(p11) {
          return car(cdr(cdr(car(cdr(cdr(p11))))));
        };
        listLength = function(p11) {
          var startCount;
          startCount = -1;
          while (iscons(p11)) {
            p11 = cdr(p11);
            startCount++;
          }
          return startCount;
        };
        nthCadr = function(p11, n9) {
          var startCount;
          startCount = 0;
          while (startCount <= n9) {
            p11 = cdr(p11);
            startCount++;
          }
          return car(p11);
        };
        isadd = function(p11) {
          return car(p11) === symbol(ADD);
        };
        ismultiply = function(p11) {
          return car(p11) === symbol(MULTIPLY);
        };
        ispower = function(p11) {
          return car(p11) === symbol(POWER);
        };
        isfactorial = function(p11) {
          return car(p11) === symbol(FACTORIAL);
        };
        isinnerordot = function(p11) {
          return car(p11) === symbol(INNER) || car(p11) === symbol(DOT);
        };
        istranspose = function(p11) {
          return car(p11) === symbol(TRANSPOSE);
        };
        isinv = function(p11) {
          return car(p11) === symbol(INV);
        };
        isidentitymatrix = function(p11) {
          return p11 === symbol(SYMBOL_IDENTITY_MATRIX);
        };
        MSIGN = function(p11) {
          if (p11.isPositive()) {
            return 1;
          } else if (p11.isZero()) {
            return 0;
          } else {
            return -1;
          }
        };
        MLENGTH = function(p11) {
          return p11.toString().length;
        };
        MZERO = function(p11) {
          return p11.isZero();
        };
        MEQUAL = function(p11, n9) {
          if (p11 == null) {
            debugger;
          }
          return p11.equals(n9);
        };
        reset_after_error = function() {
          moveTos(0);
          esc_flag = 0;
          draw_flag = 0;
          frame = TOS;
          evaluatingAsFloats = 0;
          return evaluatingPolar = 0;
        };
        $ = typeof exports !== "undefined" && exports !== null ? exports : this;
        $.version = version;
        $.isadd = isadd;
        $.ismultiply = ismultiply;
        $.ispower = ispower;
        $.isfactorial = isfactorial;
        $.car = car;
        $.cdr = cdr;
        $.caar = caar;
        $.cadr = cadr;
        $.cdar = cdar;
        $.cddr = cddr;
        $.caadr = caadr;
        $.caddr = caddr;
        $.cadar = cadar;
        $.cdadr = cdadr;
        $.cddar = cddar;
        $.cdddr = cdddr;
        $.caaddr = caaddr;
        $.cadadr = cadadr;
        $.caddar = caddar;
        $.cdaddr = cdaddr;
        $.cadddr = cadddr;
        $.cddddr = cddddr;
        $.caddddr = caddddr;
        $.cadaddr = cadaddr;
        $.cddaddr = cddaddr;
        $.caddadr = caddadr;
        $.cdddaddr = cdddaddr;
        $.caddaddr = caddaddr;
        $.symbol = symbol;
        $.iscons = iscons;
        $.isrational = isrational;
        $.isdouble = isdouble;
        $.isNumericAtom = isNumericAtom;
        $.isstr = isstr;
        $.istensor = istensor;
        $.issymbol = issymbol;
        $.iskeyword = iskeyword;
        $.CONS = CONS;
        $.NUM = NUM;
        $.DOUBLE = DOUBLE;
        $.STR = STR;
        $.TENSOR = TENSOR;
        $.SYM = SYM;
        DEBUG_ABS = false;
        Eval_abs = function() {
          push(cadr(p1));
          Eval();
          return abs();
        };
        absValFloat = function() {
          Eval();
          absval();
          Eval();
          return zzfloat();
        };
        abs = function() {
          var theArgument2;
          theArgument2 = top();
          if (DEBUG_ABS) {
            console.trace(">>>>  ABS of " + theArgument2);
          }
          numerator();
          if (DEBUG_ABS) {
            console.log("ABS numerator " + stack[tos - 1]);
          }
          absval();
          if (DEBUG_ABS) {
            console.log("ABSVAL numerator: " + stack[tos - 1]);
          }
          push(theArgument2);
          denominator();
          if (DEBUG_ABS) {
            console.log("ABS denominator: " + stack[tos - 1]);
          }
          absval();
          if (DEBUG_ABS) {
            console.log("ABSVAL denominator: " + stack[tos - 1]);
          }
          divide();
          if (DEBUG_ABS) {
            console.log("ABSVAL divided: " + stack[tos - 1]);
          }
          if (DEBUG_ABS) {
            return console.log("<<<<<<<  ABS");
          }
        };
        absval = function() {
          var anyFactorsYet, input;
          save();
          p1 = pop();
          input = p1;
          if (DEBUG_ABS) {
            console.log("ABS of " + p1);
          }
          if (isZeroAtomOrTensor(p1)) {
            if (DEBUG_ABS) {
              console.log(" abs: " + p1 + " just zero");
            }
            push(zero);
            if (DEBUG_ABS) {
              console.log(" --> ABS of " + input + " : " + stack[tos - 1]);
            }
            restore();
            return;
          }
          if (isnegativenumber(p1)) {
            if (DEBUG_ABS) {
              console.log(" abs: " + p1 + " just a negative");
            }
            push(p1);
            negate();
            restore();
            return;
          }
          if (ispositivenumber(p1)) {
            if (DEBUG_ABS) {
              console.log(" abs: " + p1 + " just a positive");
            }
            push(p1);
            if (DEBUG_ABS) {
              console.log(" --> ABS of " + input + " : " + stack[tos - 1]);
            }
            restore();
            return;
          }
          if (p1 === symbol(PI)) {
            if (DEBUG_ABS) {
              console.log(" abs: " + p1 + " of PI");
            }
            push(p1);
            if (DEBUG_ABS) {
              console.log(" --> ABS of " + input + " : " + stack[tos - 1]);
            }
            restore();
            return;
          }
          if (car(p1) === symbol(ADD) && (findPossibleClockForm(p1) || findPossibleExponentialForm(p1) || Find(p1, imaginaryunit))) {
            if (DEBUG_ABS) {
              console.log(" abs: " + p1 + " is a sum");
            }
            if (DEBUG_ABS) {
              console.log("abs of a sum");
            }
            push(p1);
            rect();
            p1 = pop();
            push(p1);
            real();
            push_integer(2);
            power();
            push(p1);
            imag();
            push_integer(2);
            power();
            add();
            push_rational(1, 2);
            power();
            simplify_trig();
            if (DEBUG_ABS) {
              console.log(" --> ABS of " + input + " : " + stack[tos - 1]);
            }
            restore();
            return;
          }
          if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {
            if (DEBUG_ABS) {
              console.log(" abs: " + p1 + " is -1 to any power");
            }
            if (evaluatingAsFloats) {
              if (DEBUG_ABS) {
                console.log(" abs: numeric, so result is 1.0");
              }
              push_double(1);
            } else {
              if (DEBUG_ABS) {
                console.log(" abs: symbolic, so result is 1");
              }
              push_integer(1);
            }
            if (DEBUG_ABS) {
              console.log(" --> ABS of " + input + " : " + stack[tos - 1]);
            }
            restore();
            return;
          }
          if (car(p1) === symbol(POWER) && ispositivenumber(caddr(p1))) {
            if (DEBUG_ABS) {
              console.log(" abs: " + p1 + " is something to the power of a positive number");
            }
            push(cadr(p1));
            abs();
            push(caddr(p1));
            power();
            if (DEBUG_ABS) {
              console.log(" --> ABS of " + input + " : " + stack[tos - 1]);
            }
            restore();
            return;
          }
          if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {
            if (DEBUG_ABS) {
              console.log(" abs: " + p1 + " is an exponential");
            }
            push(caddr(p1));
            real();
            exponential();
            if (DEBUG_ABS) {
              console.log(" --> ABS of " + input + " : " + stack[tos - 1]);
            }
            restore();
            return;
          }
          if (car(p1) === symbol(MULTIPLY)) {
            if (DEBUG_ABS) {
              console.log(" abs: " + p1 + " is a product");
            }
            anyFactorsYet = false;
            p1 = cdr(p1);
            while (iscons(p1)) {
              push(car(p1));
              absval();
              if (anyFactorsYet) {
                multiply();
              }
              anyFactorsYet = true;
              p1 = cdr(p1);
            }
            if (DEBUG_ABS) {
              console.log(" --> ABS of " + input + " : " + stack[tos - 1]);
            }
            restore();
            return;
          }
          if (car(p1) === symbol(ABS)) {
            if (DEBUG_ABS) {
              console.log(" abs: " + p1 + " is abs of a abs");
            }
            push_symbol(ABS);
            push(cadr(p1));
            list(2);
            if (DEBUG_ABS) {
              console.log(" --> ABS of " + input + " : " + stack[tos - 1]);
            }
            restore();
            return;
          }
          if (istensor(p1)) {
            absval_tensor();
            restore();
            return;
          }
          if (isnegativeterm(p1) || car(p1) === symbol(ADD) && isnegativeterm(cadr(p1))) {
            push(p1);
            negate();
            p1 = pop();
          }
          if (DEBUG_ABS) {
            console.log(" abs: " + p1 + " is nothing decomposable");
          }
          push_symbol(ABS);
          push(p1);
          list(2);
          if (DEBUG_ABS) {
            console.log(" --> ABS of " + input + " : " + stack[tos - 1]);
          }
          return restore();
        };
        absval_tensor = function() {
          if (p1.tensor.ndim !== 1) {
            stop("abs(tensor) with tensor rank > 1");
          }
          push(p1);
          push(p1);
          conjugate();
          inner();
          push_rational(1, 2);
          power();
          simplify();
          return Eval();
        };
        flag = 0;
        Eval_add = function() {
          var h5;
          h5 = tos;
          p1 = cdr(p1);
          while (iscons(p1)) {
            push(car(p1));
            Eval();
            p2 = pop();
            push_terms(p2);
            p1 = cdr(p1);
          }
          return add_terms(tos - h5);
        };
        stackAddsCount = 0;
        add_terms = function(n9) {
          var h5, i5, i12, j12, o12, ref2, ref12, results, s8, subsetOfStack;
          stackAddsCount++;
          i5 = 0;
          h5 = tos - n9;
          s8 = h5;
          if (DEBUG) {
            console.log("stack before adding terms #" + stackAddsCount);
          }
          if (DEBUG) {
            for (i5 = o12 = 0, ref2 = tos; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
              console.log(print_list(stack[i5]));
            }
          }
          for (i5 = i12 = 0; i12 < 10; i5 = ++i12) {
            if (n9 < 2) {
              break;
            }
            flag = 0;
            subsetOfStack = stack.slice(h5, h5 + n9);
            subsetOfStack.sort(cmp_terms);
            stack = stack.slice(0, h5).concat(subsetOfStack).concat(stack.slice(h5 + n9));
            if (flag === 0) {
              break;
            }
            n9 = combine_terms(h5, n9);
          }
          moveTos(h5 + n9);
          switch (n9) {
            case 0:
              if (evaluatingAsFloats) {
                push_double(0);
              } else {
                push(zero);
              }
              break;
            case 1:
              break;
            default:
              list(n9);
              p1 = pop();
              push_symbol(ADD);
              push(p1);
              cons();
          }
          if (DEBUG) {
            console.log("stack after adding terms #" + stackAddsCount);
          }
          if (DEBUG) {
            results = [];
            for (i5 = j12 = 0, ref12 = tos; 0 <= ref12 ? j12 < ref12 : j12 > ref12; i5 = 0 <= ref12 ? ++j12 : --j12) {
              results.push(console.log(print_list(stack[i5])));
            }
            return results;
          }
        };
        cmp_terms_count = 0;
        cmp_terms = function(p12, p22) {
          var i5, o12, ref2, t5;
          cmp_terms_count++;
          i5 = 0;
          if (isNumericAtom(p12) && isNumericAtom(p22)) {
            flag = 1;
            return 0;
          }
          if (istensor(p12) && istensor(p22)) {
            if (p12.tensor.ndim < p22.tensor.ndim) {
              return -1;
            }
            if (p12.tensor.ndim > p22.tensor.ndim) {
              return 1;
            }
            for (i5 = o12 = 0, ref2 = p12.tensor.ndim; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
              if (p12.tensor.dim[i5] < p22.tensor.dim[i5]) {
                return -1;
              }
              if (p12.tensor.dim[i5] > p22.tensor.dim[i5]) {
                return 1;
              }
            }
            flag = 1;
            return 0;
          }
          if (car(p12) === symbol(MULTIPLY)) {
            p12 = cdr(p12);
            if (isNumericAtom(car(p12))) {
              p12 = cdr(p12);
              if (cdr(p12) === symbol(NIL)) {
                p12 = car(p12);
              }
            }
          }
          if (car(p22) === symbol(MULTIPLY)) {
            p22 = cdr(p22);
            if (isNumericAtom(car(p22))) {
              p22 = cdr(p22);
              if (cdr(p22) === symbol(NIL)) {
                p22 = car(p22);
              }
            }
          }
          t5 = cmp_expr(p12, p22);
          if (t5 === 0) {
            flag = 1;
          }
          return t5;
        };
        combine_terms = function(s8, n9) {
          var i5, i12, j2, j12, l1, m1, o12, ref2, ref12, ref22, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t5;
          i5 = 0;
          while (i5 < n9 - 1) {
            check_esc_flag();
            p3 = stack[s8 + i5];
            p4 = stack[s8 + i5 + 1];
            if (istensor(p3) && istensor(p4)) {
              push(p3);
              push(p4);
              tensor_plus_tensor();
              p1 = pop();
              if (p1 !== symbol(NIL)) {
                stack[s8 + i5] = p1;
                for (j2 = o12 = ref2 = i5 + 1, ref12 = n9 - 1; ref2 <= ref12 ? o12 < ref12 : o12 > ref12; j2 = ref2 <= ref12 ? ++o12 : --o12) {
                  stack[s8 + j2] = stack[s8 + j2 + 1];
                }
                n9--;
                i5--;
              }
              i5++;
              continue;
            }
            if (istensor(p3) || istensor(p4)) {
              i5++;
              continue;
            }
            if (isNumericAtom(p3) && isNumericAtom(p4)) {
              push(p3);
              push(p4);
              add_numbers();
              p1 = pop();
              if (isZeroAtomOrTensor(p1)) {
                for (j2 = i12 = ref22 = i5, ref3 = n9 - 2; ref22 <= ref3 ? i12 < ref3 : i12 > ref3; j2 = ref22 <= ref3 ? ++i12 : --i12) {
                  stack[s8 + j2] = stack[s8 + j2 + 2];
                }
                n9 -= 2;
              } else {
                stack[s8 + i5] = p1;
                for (j2 = j12 = ref4 = i5 + 1, ref5 = n9 - 1; ref4 <= ref5 ? j12 < ref5 : j12 > ref5; j2 = ref4 <= ref5 ? ++j12 : --j12) {
                  stack[s8 + j2] = stack[s8 + j2 + 1];
                }
                n9--;
              }
              i5--;
              i5++;
              continue;
            }
            if (isNumericAtom(p3) || isNumericAtom(p4)) {
              i5++;
              continue;
            }
            if (evaluatingAsFloats) {
              p1 = one_as_double;
              p2 = one_as_double;
            } else {
              p1 = one;
              p2 = one;
            }
            t5 = 0;
            if (car(p3) === symbol(MULTIPLY)) {
              p3 = cdr(p3);
              t5 = 1;
              if (isNumericAtom(car(p3))) {
                p1 = car(p3);
                p3 = cdr(p3);
                if (cdr(p3) === symbol(NIL)) {
                  p3 = car(p3);
                  t5 = 0;
                }
              }
            }
            if (car(p4) === symbol(MULTIPLY)) {
              p4 = cdr(p4);
              if (isNumericAtom(car(p4))) {
                p2 = car(p4);
                p4 = cdr(p4);
                if (cdr(p4) === symbol(NIL)) {
                  p4 = car(p4);
                }
              }
            }
            if (!equal(p3, p4)) {
              i5++;
              continue;
            }
            push(p1);
            push(p2);
            add_numbers();
            p1 = pop();
            if (isZeroAtomOrTensor(p1)) {
              for (j2 = l1 = ref6 = i5, ref7 = n9 - 2; ref6 <= ref7 ? l1 < ref7 : l1 > ref7; j2 = ref6 <= ref7 ? ++l1 : --l1) {
                stack[s8 + j2] = stack[s8 + j2 + 2];
              }
              n9 -= 2;
              i5--;
              i5++;
              continue;
            }
            push(p1);
            if (t5) {
              push(symbol(MULTIPLY));
              push(p3);
              cons();
            } else {
              push(p3);
            }
            multiply();
            stack[s8 + i5] = pop();
            for (j2 = m1 = ref8 = i5 + 1, ref9 = n9 - 1; ref8 <= ref9 ? m1 < ref9 : m1 > ref9; j2 = ref8 <= ref9 ? ++m1 : --m1) {
              stack[s8 + j2] = stack[s8 + j2 + 1];
            }
            n9--;
            i5--;
            i5++;
          }
          return n9;
        };
        push_terms = function(p11) {
          var results;
          if (car(p11) === symbol(ADD)) {
            p11 = cdr(p11);
            results = [];
            while (iscons(p11)) {
              push(car(p11));
              results.push(p11 = cdr(p11));
            }
            return results;
          } else if (!isZeroAtom(p11)) {
            return push(p11);
          }
        };
        add = function() {
          var h5;
          save();
          p2 = pop();
          p1 = pop();
          h5 = tos;
          push_terms(p1);
          push_terms(p2);
          add_terms(tos - h5);
          return restore();
        };
        add_all = function(k3) {
          var h5, i5, o12, ref2, s8;
          i5 = 0;
          save();
          s8 = tos - k3;
          h5 = tos;
          for (i5 = o12 = 0, ref2 = k3; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            push_terms(stack[s8 + i5]);
          }
          add_terms(tos - h5);
          p1 = pop();
          moveTos(tos - k3);
          push(p1);
          return restore();
        };
        subtract = function() {
          negate();
          return add();
        };
        Eval_adj = function() {
          push(cadr(p1));
          Eval();
          return adj();
        };
        adj = function() {
          var doNothing, i5, i12, j2, n9, o12, ref2, ref12;
          i5 = 0;
          j2 = 0;
          n9 = 0;
          save();
          p1 = pop();
          if (istensor(p1) && p1.tensor.ndim === 2 && p1.tensor.dim[0] === p1.tensor.dim[1]) {
            doNothing = 1;
          } else {
            stop("adj: square matrix expected");
          }
          n9 = p1.tensor.dim[0];
          p2 = alloc_tensor(n9 * n9);
          p2.tensor.ndim = 2;
          p2.tensor.dim[0] = n9;
          p2.tensor.dim[1] = n9;
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            for (j2 = i12 = 0, ref12 = n9; 0 <= ref12 ? i12 < ref12 : i12 > ref12; j2 = 0 <= ref12 ? ++i12 : --i12) {
              cofactor(p1, n9, i5, j2);
              p2.tensor.elem[n9 * j2 + i5] = pop();
            }
          }
          push(p2);
          return restore();
        };
        Eval_approxratio = function() {
          var theArgument2;
          theArgument2 = cadr(p1);
          push(theArgument2);
          return approxratioRecursive();
        };
        approxratioRecursive = function() {
          var i5, i12, o12, ref2, ref12;
          i5 = 0;
          save();
          p1 = pop();
          if (istensor(p1)) {
            p4 = alloc_tensor(p1.tensor.nelem);
            p4.tensor.ndim = p1.tensor.ndim;
            for (i5 = o12 = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
              p4.tensor.dim[i5] = p1.tensor.dim[i5];
            }
            for (i5 = i12 = 0, ref12 = p1.tensor.nelem; 0 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
              push(p1.tensor.elem[i5]);
              approxratioRecursive();
              p4.tensor.elem[i5] = pop();
              check_tensor_dimensions(p4);
            }
            push(p4);
          } else if (p1.k === DOUBLE) {
            push(p1);
            approxOneRatioOnly();
          } else if (iscons(p1)) {
            push(car(p1));
            approxratioRecursive();
            push(cdr(p1));
            approxratioRecursive();
            cons();
          } else {
            push(p1);
          }
          return restore();
        };
        approxOneRatioOnly = function() {
          var numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot, supposedlyTheFloat, theFloat, theRatio;
          zzfloat();
          supposedlyTheFloat = pop();
          if (supposedlyTheFloat.k === DOUBLE) {
            theFloat = supposedlyTheFloat.d;
            splitBeforeAndAfterDot = theFloat.toString().split(".");
            if (splitBeforeAndAfterDot.length === 2) {
              numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;
              precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);
              theRatio = floatToRatioRoutine(theFloat, precision);
              push_rational(theRatio[0], theRatio[1]);
            } else {
              push_integer(theFloat);
            }
            return;
          }
          push_symbol(APPROXRATIO);
          push(theArgument);
          return list(2);
        };
        floatToRatioRoutine = function(decimal, AccuracyFactor) {
          var DecimalSign, FractionDenominator, FractionNumerator, PreviousDenominator, ScratchValue, Z3, ret;
          FractionNumerator = void 0;
          FractionDenominator = void 0;
          DecimalSign = void 0;
          Z3 = void 0;
          PreviousDenominator = void 0;
          ScratchValue = void 0;
          ret = [0, 0];
          if (isNaN(decimal)) {
            return ret;
          }
          if (decimal === Infinity) {
            ret[0] = 1;
            ret[1] = 0;
            return ret;
          }
          if (decimal === -Infinity) {
            ret[0] = -1;
            ret[1] = 0;
            return ret;
          }
          if (decimal < 0) {
            DecimalSign = -1;
          } else {
            DecimalSign = 1;
          }
          decimal = Math.abs(decimal);
          if (Math.abs(decimal - Math.floor(decimal)) < AccuracyFactor) {
            FractionNumerator = decimal * DecimalSign;
            FractionDenominator = 1;
            ret[0] = FractionNumerator;
            ret[1] = FractionDenominator;
            return ret;
          }
          if (decimal < 1e-19) {
            FractionNumerator = DecimalSign;
            FractionDenominator = 1e19;
            ret[0] = FractionNumerator;
            ret[1] = FractionDenominator;
            return ret;
          }
          if (decimal > 1e19) {
            FractionNumerator = 1e19 * DecimalSign;
            FractionDenominator = 1;
            ret[0] = FractionNumerator;
            ret[1] = FractionDenominator;
            return ret;
          }
          Z3 = decimal;
          PreviousDenominator = 0;
          FractionDenominator = 1;
          while (true) {
            Z3 = 1 / (Z3 - Math.floor(Z3));
            ScratchValue = FractionDenominator;
            FractionDenominator = FractionDenominator * Math.floor(Z3) + PreviousDenominator;
            PreviousDenominator = ScratchValue;
            FractionNumerator = Math.floor(decimal * FractionDenominator + 0.5);
            if (!(Math.abs(decimal - FractionNumerator / FractionDenominator) > AccuracyFactor && Z3 !== Math.floor(Z3))) {
              break;
            }
          }
          FractionNumerator = DecimalSign * FractionNumerator;
          ret[0] = FractionNumerator;
          ret[1] = FractionDenominator;
          return ret;
        };
        approx_just_an_integer = 0;
        approx_sine_of_rational = 1;
        approx_sine_of_pi_times_rational = 2;
        approx_rationalOfPi = 3;
        approx_radicalOfRatio = 4;
        approx_nothingUseful = 5;
        approx_ratioOfRadical = 6;
        approx_rationalOfE = 7;
        approx_logarithmsOfRationals = 8;
        approx_rationalsOfLogarithms = 9;
        approxRationalsOfRadicals = function(theFloat) {
          var bestResultSoFar, complexity, error, hypothesis, i5, i12, j2, len, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o12, precision, ratio, ref2, result, splitBeforeAndAfterDot;
          splitBeforeAndAfterDot = theFloat.toString().split(".");
          if (splitBeforeAndAfterDot.length === 2) {
            numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;
            precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);
          } else {
            return ["" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];
          }
          console.log("precision: " + precision);
          bestResultSoFar = null;
          minimumComplexity = Number.MAX_VALUE;
          ref2 = [2, 3, 5, 6, 7, 8, 10];
          for (o12 = 0, len = ref2.length; o12 < len; o12++) {
            i5 = ref2[o12];
            for (j2 = i12 = 1; i12 <= 10; j2 = ++i12) {
              hypothesis = Math.sqrt(i5) / j2;
              if (Math.abs(hypothesis) > 1e-10) {
                ratio = theFloat / hypothesis;
                likelyMultiplier = Math.round(ratio);
                error = Math.abs(1 - ratio / likelyMultiplier);
              } else {
                ratio = 1;
                likelyMultiplier = 1;
                error = Math.abs(theFloat - hypothesis);
              }
              if (error < 2 * precision) {
                complexity = simpleComplexityMeasure(likelyMultiplier, i5, j2);
                if (complexity < minimumComplexity) {
                  minimumComplexity = complexity;
                  result = likelyMultiplier + " * sqrt( " + i5 + " ) / " + j2;
                  bestResultSoFar = [result, approx_ratioOfRadical, likelyMultiplier, i5, j2];
                }
              }
            }
          }
          return bestResultSoFar;
        };
        approxRadicalsOfRationals = function(theFloat) {
          var bestResultSoFar, complexity, error, hypothesis, i5, i12, j2, len, len1, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o12, precision, ratio, ref2, ref12, result, splitBeforeAndAfterDot;
          splitBeforeAndAfterDot = theFloat.toString().split(".");
          if (splitBeforeAndAfterDot.length === 2) {
            numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;
            precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);
          } else {
            return ["" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];
          }
          console.log("precision: " + precision);
          bestResultSoFar = null;
          minimumComplexity = Number.MAX_VALUE;
          ref2 = [1, 2, 3, 5, 6, 7, 8, 10];
          for (o12 = 0, len = ref2.length; o12 < len; o12++) {
            i5 = ref2[o12];
            ref12 = [1, 2, 3, 5, 6, 7, 8, 10];
            for (i12 = 0, len1 = ref12.length; i12 < len1; i12++) {
              j2 = ref12[i12];
              hypothesis = Math.sqrt(i5 / j2);
              if (Math.abs(hypothesis) > 1e-10) {
                ratio = theFloat / hypothesis;
                likelyMultiplier = Math.round(ratio);
                error = Math.abs(1 - ratio / likelyMultiplier);
              } else {
                ratio = 1;
                likelyMultiplier = 1;
                error = Math.abs(theFloat - hypothesis);
              }
              if (error < 2 * precision) {
                complexity = simpleComplexityMeasure(likelyMultiplier, i5, j2);
                if (complexity < minimumComplexity) {
                  minimumComplexity = complexity;
                  result = likelyMultiplier + " * (sqrt( " + i5 + " / " + j2 + " )";
                  bestResultSoFar = [result, approx_radicalOfRatio, likelyMultiplier, i5, j2];
                }
              }
            }
          }
          return bestResultSoFar;
        };
        approxRadicals = function(theFloat) {
          var approxRadicalsOfRationalsResult, approxRationalsOfRadicalsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;
          splitBeforeAndAfterDot = theFloat.toString().split(".");
          if (splitBeforeAndAfterDot.length === 2) {
            numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;
            precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);
          } else {
            return ["" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];
          }
          console.log("precision: " + precision);
          approxRationalsOfRadicalsResult = approxRationalsOfRadicals(theFloat);
          if (approxRationalsOfRadicalsResult != null) {
            return approxRationalsOfRadicalsResult;
          }
          approxRadicalsOfRationalsResult = approxRadicalsOfRationals(theFloat);
          if (approxRadicalsOfRationalsResult != null) {
            return approxRadicalsOfRationalsResult;
          }
          return null;
        };
        approxLogs = function(theFloat) {
          var approxLogsOfRationalsResult, approxRationalsOfLogsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;
          splitBeforeAndAfterDot = theFloat.toString().split(".");
          if (splitBeforeAndAfterDot.length === 2) {
            numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;
            precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);
          } else {
            return ["" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];
          }
          console.log("precision: " + precision);
          approxRationalsOfLogsResult = approxRationalsOfLogs(theFloat);
          if (approxRationalsOfLogsResult != null) {
            return approxRationalsOfLogsResult;
          }
          approxLogsOfRationalsResult = approxLogsOfRationals(theFloat);
          if (approxLogsOfRationalsResult != null) {
            return approxLogsOfRationalsResult;
          }
          return null;
        };
        approxRationalsOfLogs = function(theFloat) {
          var bestResultSoFar, complexity, error, hypothesis, i5, i12, j2, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o12, precision, ratio, result, splitBeforeAndAfterDot;
          splitBeforeAndAfterDot = theFloat.toString().split(".");
          if (splitBeforeAndAfterDot.length === 2) {
            numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;
            precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);
          } else {
            return ["" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];
          }
          console.log("precision: " + precision);
          bestResultSoFar = null;
          minimumComplexity = Number.MAX_VALUE;
          for (i5 = o12 = 2; o12 <= 5; i5 = ++o12) {
            for (j2 = i12 = 1; i12 <= 5; j2 = ++i12) {
              hypothesis = Math.log(i5) / j2;
              if (Math.abs(hypothesis) > 1e-10) {
                ratio = theFloat / hypothesis;
                likelyMultiplier = Math.round(ratio);
                error = Math.abs(1 - ratio / likelyMultiplier);
              } else {
                ratio = 1;
                likelyMultiplier = 1;
                error = Math.abs(theFloat - hypothesis);
              }
              if (likelyMultiplier !== 1 && Math.abs(Math.floor(likelyMultiplier / j2)) === Math.abs(likelyMultiplier / j2)) {
                continue;
              }
              if (error < 2.2 * precision) {
                complexity = simpleComplexityMeasure(likelyMultiplier, i5, j2);
                if (complexity < minimumComplexity) {
                  minimumComplexity = complexity;
                  result = likelyMultiplier + " * log( " + i5 + " ) / " + j2;
                  bestResultSoFar = [result, approx_rationalsOfLogarithms, likelyMultiplier, i5, j2];
                }
              }
            }
          }
          return bestResultSoFar;
        };
        approxLogsOfRationals = function(theFloat) {
          var bestResultSoFar, complexity, error, hypothesis, i5, i12, j2, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o12, precision, ratio, result, splitBeforeAndAfterDot;
          splitBeforeAndAfterDot = theFloat.toString().split(".");
          if (splitBeforeAndAfterDot.length === 2) {
            numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;
            precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);
          } else {
            return ["" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];
          }
          console.log("precision: " + precision);
          bestResultSoFar = null;
          minimumComplexity = Number.MAX_VALUE;
          for (i5 = o12 = 1; o12 <= 5; i5 = ++o12) {
            for (j2 = i12 = 1; i12 <= 5; j2 = ++i12) {
              hypothesis = Math.log(i5 / j2);
              if (Math.abs(hypothesis) > 1e-10) {
                ratio = theFloat / hypothesis;
                likelyMultiplier = Math.round(ratio);
                error = Math.abs(1 - ratio / likelyMultiplier);
              } else {
                ratio = 1;
                likelyMultiplier = 1;
                error = Math.abs(theFloat - hypothesis);
              }
              if (error < 1.96 * precision) {
                complexity = simpleComplexityMeasure(likelyMultiplier, i5, j2);
                if (complexity < minimumComplexity) {
                  minimumComplexity = complexity;
                  result = likelyMultiplier + " * log( " + i5 + " / " + j2 + " )";
                  bestResultSoFar = [result, approx_logarithmsOfRationals, likelyMultiplier, i5, j2];
                }
              }
            }
          }
          return bestResultSoFar;
        };
        approxRationalsOfPowersOfE = function(theFloat) {
          var bestResultSoFar, complexity, error, hypothesis, i5, i12, j2, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o12, precision, ratio, result, splitBeforeAndAfterDot;
          splitBeforeAndAfterDot = theFloat.toString().split(".");
          if (splitBeforeAndAfterDot.length === 2) {
            numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;
            precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);
          } else {
            return ["" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];
          }
          console.log("precision: " + precision);
          bestResultSoFar = null;
          minimumComplexity = Number.MAX_VALUE;
          for (i5 = o12 = 1; o12 <= 2; i5 = ++o12) {
            for (j2 = i12 = 1; i12 <= 12; j2 = ++i12) {
              hypothesis = Math.pow(Math.E, i5) / j2;
              if (Math.abs(hypothesis) > 1e-10) {
                ratio = theFloat / hypothesis;
                likelyMultiplier = Math.round(ratio);
                error = Math.abs(1 - ratio / likelyMultiplier);
              } else {
                ratio = 1;
                likelyMultiplier = 1;
                error = Math.abs(theFloat - hypothesis);
              }
              if (error < 2 * precision) {
                complexity = simpleComplexityMeasure(likelyMultiplier, i5, j2);
                if (complexity < minimumComplexity) {
                  minimumComplexity = complexity;
                  result = likelyMultiplier + " * (e ^ " + i5 + " ) / " + j2;
                  bestResultSoFar = [result, approx_rationalOfE, likelyMultiplier, i5, j2];
                }
              }
            }
          }
          return bestResultSoFar;
        };
        approxRationalsOfPowersOfPI = function(theFloat) {
          var bestResultSoFar, complexity, error, hypothesis, i5, i12, j2, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o12, precision, ratio, result, splitBeforeAndAfterDot;
          splitBeforeAndAfterDot = theFloat.toString().split(".");
          if (splitBeforeAndAfterDot.length === 2) {
            numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;
            precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);
          } else {
            return ["" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];
          }
          console.log("precision: " + precision);
          bestResultSoFar = null;
          minimumComplexity = Number.MAX_VALUE;
          for (i5 = o12 = 1; o12 <= 5; i5 = ++o12) {
            for (j2 = i12 = 1; i12 <= 12; j2 = ++i12) {
              hypothesis = Math.pow(Math.PI, i5) / j2;
              if (Math.abs(hypothesis) > 1e-10) {
                ratio = theFloat / hypothesis;
                likelyMultiplier = Math.round(ratio);
                error = Math.abs(1 - ratio / likelyMultiplier);
              } else {
                ratio = 1;
                likelyMultiplier = 1;
                error = Math.abs(theFloat - hypothesis);
              }
              if (error < 2 * precision) {
                complexity = simpleComplexityMeasure(likelyMultiplier, i5, j2);
                if (complexity < minimumComplexity) {
                  minimumComplexity = complexity;
                  result = likelyMultiplier + " * (pi ^ " + i5 + " ) / " + j2 + " )";
                  bestResultSoFar = [result, approx_rationalOfPi, likelyMultiplier, i5, j2];
                }
              }
            }
          }
          return bestResultSoFar;
        };
        approxTrigonometric = function(theFloat) {
          var approxSineOfRationalMultiplesOfPIResult, approxSineOfRationalsResult, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;
          splitBeforeAndAfterDot = theFloat.toString().split(".");
          if (splitBeforeAndAfterDot.length === 2) {
            numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;
            precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);
          } else {
            return ["" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];
          }
          console.log("precision: " + precision);
          approxSineOfRationalsResult = approxSineOfRationals(theFloat);
          if (approxSineOfRationalsResult != null) {
            return approxSineOfRationalsResult;
          }
          approxSineOfRationalMultiplesOfPIResult = approxSineOfRationalMultiplesOfPI(theFloat);
          if (approxSineOfRationalMultiplesOfPIResult != null) {
            return approxSineOfRationalMultiplesOfPIResult;
          }
          return null;
        };
        approxSineOfRationals = function(theFloat) {
          var bestResultSoFar, complexity, error, fraction, hypothesis, i5, i12, j2, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o12, precision, ratio, result, splitBeforeAndAfterDot;
          splitBeforeAndAfterDot = theFloat.toString().split(".");
          if (splitBeforeAndAfterDot.length === 2) {
            numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;
            precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);
          } else {
            return ["" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];
          }
          console.log("precision: " + precision);
          bestResultSoFar = null;
          minimumComplexity = Number.MAX_VALUE;
          for (i5 = o12 = 1; o12 <= 4; i5 = ++o12) {
            for (j2 = i12 = 1; i12 <= 4; j2 = ++i12) {
              fraction = i5 / j2;
              hypothesis = Math.sin(fraction);
              if (Math.abs(hypothesis) > 1e-10) {
                ratio = theFloat / hypothesis;
                likelyMultiplier = Math.round(ratio);
                error = Math.abs(1 - ratio / likelyMultiplier);
              } else {
                ratio = 1;
                likelyMultiplier = 1;
                error = Math.abs(theFloat - hypothesis);
              }
              if (error < 2 * precision) {
                complexity = simpleComplexityMeasure(likelyMultiplier, i5, j2);
                if (complexity < minimumComplexity) {
                  minimumComplexity = complexity;
                  result = likelyMultiplier + " * sin( " + i5 + "/" + j2 + " )";
                  bestResultSoFar = [result, approx_sine_of_rational, likelyMultiplier, i5, j2];
                }
              }
            }
          }
          return bestResultSoFar;
        };
        approxSineOfRationalMultiplesOfPI = function(theFloat) {
          var bestResultSoFar, complexity, error, fraction, hypothesis, i5, i12, j2, likelyMultiplier, minimumComplexity, numberOfDigitsAfterTheDot, o12, precision, ratio, result, splitBeforeAndAfterDot;
          splitBeforeAndAfterDot = theFloat.toString().split(".");
          if (splitBeforeAndAfterDot.length === 2) {
            numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;
            precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);
          } else {
            return ["" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];
          }
          console.log("precision: " + precision);
          bestResultSoFar = null;
          minimumComplexity = Number.MAX_VALUE;
          for (i5 = o12 = 1; o12 <= 13; i5 = ++o12) {
            for (j2 = i12 = 1; i12 <= 13; j2 = ++i12) {
              fraction = i5 / j2;
              hypothesis = Math.sin(Math.PI * fraction);
              if (Math.abs(hypothesis) > 1e-10) {
                ratio = theFloat / hypothesis;
                likelyMultiplier = Math.round(ratio);
                error = Math.abs(1 - ratio / likelyMultiplier);
              } else {
                ratio = 1;
                likelyMultiplier = 1;
                error = Math.abs(theFloat - hypothesis);
              }
              if (error < 23 * precision) {
                complexity = simpleComplexityMeasure(likelyMultiplier, i5, j2);
                if (complexity < minimumComplexity) {
                  minimumComplexity = complexity;
                  result = likelyMultiplier + " * sin( " + i5 + "/" + j2 + " * pi )";
                  bestResultSoFar = [result, approx_sine_of_pi_times_rational, likelyMultiplier, i5, j2];
                }
              }
            }
          }
          return bestResultSoFar;
        };
        approxAll = function(theFloat) {
          var LOG_EXPLANATIONS, approxLogsResult, approxRadicalsResult, approxRationalsOfPowersOfEResult, approxRationalsOfPowersOfPIResult, approxTrigonometricResult, bestApproxSoFar, constantsSum, constantsSumMin, numberOfDigitsAfterTheDot, precision, splitBeforeAndAfterDot;
          splitBeforeAndAfterDot = theFloat.toString().split(".");
          if (splitBeforeAndAfterDot.length === 2) {
            numberOfDigitsAfterTheDot = splitBeforeAndAfterDot[1].length;
            precision = 1 / Math.pow(10, numberOfDigitsAfterTheDot);
          } else {
            return ["" + Math.floor(theFloat), approx_just_an_integer, Math.floor(theFloat), 1, 2];
          }
          console.log("precision: " + precision);
          constantsSumMin = Number.MAX_VALUE;
          constantsSum = 0;
          bestApproxSoFar = null;
          LOG_EXPLANATIONS = true;
          approxRadicalsResult = approxRadicals(theFloat);
          if (approxRadicalsResult != null) {
            constantsSum = simpleComplexityMeasure(approxRadicalsResult);
            if (constantsSum < constantsSumMin) {
              if (LOG_EXPLANATIONS) {
                console.log("better explanation by approxRadicals: " + approxRadicalsResult + " complexity: " + constantsSum);
              }
              constantsSumMin = constantsSum;
              bestApproxSoFar = approxRadicalsResult;
            } else {
              if (LOG_EXPLANATIONS) {
                console.log("subpar explanation by approxRadicals: " + approxRadicalsResult + " complexity: " + constantsSum);
              }
            }
          }
          approxLogsResult = approxLogs(theFloat);
          if (approxLogsResult != null) {
            constantsSum = simpleComplexityMeasure(approxLogsResult);
            if (constantsSum < constantsSumMin) {
              if (LOG_EXPLANATIONS) {
                console.log("better explanation by approxLogs: " + approxLogsResult + " complexity: " + constantsSum);
              }
              constantsSumMin = constantsSum;
              bestApproxSoFar = approxLogsResult;
            } else {
              if (LOG_EXPLANATIONS) {
                console.log("subpar explanation by approxLogs: " + approxLogsResult + " complexity: " + constantsSum);
              }
            }
          }
          approxRationalsOfPowersOfEResult = approxRationalsOfPowersOfE(theFloat);
          if (approxRationalsOfPowersOfEResult != null) {
            constantsSum = simpleComplexityMeasure(approxRationalsOfPowersOfEResult);
            if (constantsSum < constantsSumMin) {
              if (LOG_EXPLANATIONS) {
                console.log("better explanation by approxRationalsOfPowersOfE: " + approxRationalsOfPowersOfEResult + " complexity: " + constantsSum);
              }
              constantsSumMin = constantsSum;
              bestApproxSoFar = approxRationalsOfPowersOfEResult;
            } else {
              if (LOG_EXPLANATIONS) {
                console.log("subpar explanation by approxRationalsOfPowersOfE: " + approxRationalsOfPowersOfEResult + " complexity: " + constantsSum);
              }
            }
          }
          approxRationalsOfPowersOfPIResult = approxRationalsOfPowersOfPI(theFloat);
          if (approxRationalsOfPowersOfPIResult != null) {
            constantsSum = simpleComplexityMeasure(approxRationalsOfPowersOfPIResult);
            if (constantsSum < constantsSumMin) {
              if (LOG_EXPLANATIONS) {
                console.log("better explanation by approxRationalsOfPowersOfPI: " + approxRationalsOfPowersOfPIResult + " complexity: " + constantsSum);
              }
              constantsSumMin = constantsSum;
              bestApproxSoFar = approxRationalsOfPowersOfPIResult;
            } else {
              if (LOG_EXPLANATIONS) {
                console.log("subpar explanation by approxRationalsOfPowersOfPI: " + approxRationalsOfPowersOfPIResult + " complexity: " + constantsSum);
              }
            }
          }
          approxTrigonometricResult = approxTrigonometric(theFloat);
          if (approxTrigonometricResult != null) {
            constantsSum = simpleComplexityMeasure(approxTrigonometricResult);
            if (constantsSum < constantsSumMin) {
              if (LOG_EXPLANATIONS) {
                console.log("better explanation by approxTrigonometric: " + approxTrigonometricResult + " complexity: " + constantsSum);
              }
              constantsSumMin = constantsSum;
              bestApproxSoFar = approxTrigonometricResult;
            } else {
              if (LOG_EXPLANATIONS) {
                console.log("subpar explanation by approxTrigonometric: " + approxTrigonometricResult + " complexity: " + constantsSum);
              }
            }
          }
          return bestApproxSoFar;
        };
        simpleComplexityMeasure = function(aResult, b2, c9) {
          var theSum;
          theSum = null;
          if (aResult instanceof Array) {
            switch (aResult[1]) {
              case approx_sine_of_pi_times_rational:
                theSum = 4;
                break;
              // exponents of PI and E need to be penalised as well
              // otherwise they come to explain any big number
              // so we count them just as much as the multiplier
              case approx_rationalOfPi:
                theSum = Math.pow(4, Math.abs(aResult[3])) * Math.abs(aResult[2]);
                break;
              case approx_rationalOfE:
                theSum = Math.pow(3, Math.abs(aResult[3])) * Math.abs(aResult[2]);
                break;
              default:
                theSum = 0;
            }
            theSum += Math.abs(aResult[2]) * (Math.abs(aResult[3]) + Math.abs(aResult[4]));
          } else {
            theSum += Math.abs(aResult) * (Math.abs(b2) + Math.abs(c9));
          }
          if (aResult[2] === 1) {
            theSum -= 1;
          } else {
            theSum += 1;
          }
          if (aResult[3] === 1) {
            theSum -= 1;
          } else {
            theSum += 1;
          }
          if (aResult[4] === 1) {
            theSum -= 1;
          } else {
            theSum += 1;
          }
          if (theSum < 0) {
            theSum = 0;
          }
          return theSum;
        };
        testApprox = function() {
          var error, fraction, i5, i12, i22, i32, j2, j12, j22, j3, k3, l1, l22, l32, len, len1, len2, len3, len4, len5, len6, len7, m1, m22, m3, n1, n22, o12, o1, o22, originalValue, q1, q2, r1, r22, ref2, ref12, ref22, ref3, ref4, ref5, ref6, ref7, returned, returnedFraction, returnedValue, s1, s22, t13, t23, u1, u22, v1, v22, value, x12, x22, z1, z2;
          ref2 = [2, 3, 5, 6, 7, 8, 10];
          for (o12 = 0, len = ref2.length; o12 < len; o12++) {
            i5 = ref2[o12];
            ref12 = [2, 3, 5, 6, 7, 8, 10];
            for (i12 = 0, len1 = ref12.length; i12 < len1; i12++) {
              j2 = ref12[i12];
              if (i5 === j2) {
                continue;
              }
              console.log("testapproxRadicals testing: 1 * sqrt( " + i5 + " ) / " + j2);
              fraction = i5 / j2;
              value = Math.sqrt(i5) / j2;
              returned = approxRadicals(value);
              returnedValue = returned[2] * Math.sqrt(returned[3]) / returned[4];
              if (Math.abs(value - returnedValue) > 1e-15) {
                console.log("fail testapproxRadicals: 1 * sqrt( " + i5 + " ) / " + j2 + " . obtained: " + returned);
              }
            }
          }
          ref22 = [2, 3, 5, 6, 7, 8, 10];
          for (j12 = 0, len2 = ref22.length; j12 < len2; j12++) {
            i5 = ref22[j12];
            ref3 = [2, 3, 5, 6, 7, 8, 10];
            for (l1 = 0, len3 = ref3.length; l1 < len3; l1++) {
              j2 = ref3[l1];
              if (i5 === j2) {
                continue;
              }
              console.log("testapproxRadicals testing with 4 digits: 1 * sqrt( " + i5 + " ) / " + j2);
              fraction = i5 / j2;
              originalValue = Math.sqrt(i5) / j2;
              value = originalValue.toFixed(4);
              returned = approxRadicals(value);
              returnedValue = returned[2] * Math.sqrt(returned[3]) / returned[4];
              if (Math.abs(originalValue - returnedValue) > 1e-15) {
                console.log("fail testapproxRadicals with 4 digits: 1 * sqrt( " + i5 + " ) / " + j2 + " . obtained: " + returned);
              }
            }
          }
          ref4 = [2, 3, 5, 6, 7, 8, 10];
          for (m1 = 0, len4 = ref4.length; m1 < len4; m1++) {
            i5 = ref4[m1];
            ref5 = [2, 3, 5, 6, 7, 8, 10];
            for (n1 = 0, len5 = ref5.length; n1 < len5; n1++) {
              j2 = ref5[n1];
              if (i5 === j2) {
                continue;
              }
              console.log("testapproxRadicals testing: 1 * sqrt( " + i5 + " / " + j2 + " )");
              fraction = i5 / j2;
              value = Math.sqrt(i5 / j2);
              returned = approxRadicals(value);
              if (returned != null) {
                returnedValue = returned[2] * Math.sqrt(returned[3] / returned[4]);
                if (returned[1] === approx_radicalOfRatio && Math.abs(value - returnedValue) > 1e-15) {
                  console.log("fail testapproxRadicals: 1 * sqrt( " + i5 + " / " + j2 + " ) . obtained: " + returned);
                }
              }
            }
          }
          ref6 = [1, 2, 3, 5, 6, 7, 8, 10];
          for (o1 = 0, len6 = ref6.length; o1 < len6; o1++) {
            i5 = ref6[o1];
            ref7 = [1, 2, 3, 5, 6, 7, 8, 10];
            for (q1 = 0, len7 = ref7.length; q1 < len7; q1++) {
              j2 = ref7[q1];
              if (i5 === 1 && j2 === 1) {
                continue;
              }
              console.log("testapproxRadicals testing with 4 digits:: 1 * sqrt( " + i5 + " / " + j2 + " )");
              fraction = i5 / j2;
              originalValue = Math.sqrt(i5 / j2);
              value = originalValue.toFixed(4);
              returned = approxRadicals(value);
              returnedValue = returned[2] * Math.sqrt(returned[3] / returned[4]);
              if (returned[1] === approx_radicalOfRatio && Math.abs(originalValue - returnedValue) > 1e-15) {
                console.log("fail testapproxRadicals with 4 digits:: 1 * sqrt( " + i5 + " / " + j2 + " ) . obtained: " + returned);
              }
            }
          }
          for (i5 = r1 = 1; r1 <= 5; i5 = ++r1) {
            for (j2 = s1 = 1; s1 <= 5; j2 = ++s1) {
              console.log("testApproxAll testing: 1 * log(" + i5 + " ) / " + j2);
              fraction = i5 / j2;
              value = Math.log(i5) / j2;
              returned = approxAll(value);
              returnedValue = returned[2] * Math.log(returned[3]) / returned[4];
              if (Math.abs(value - returnedValue) > 1e-15) {
                console.log("fail testApproxAll: 1 * log(" + i5 + " ) / " + j2 + " . obtained: " + returned);
              }
            }
          }
          for (i5 = t13 = 1; t13 <= 5; i5 = ++t13) {
            for (j2 = u1 = 1; u1 <= 5; j2 = ++u1) {
              console.log("testApproxAll testing with 4 digits: 1 * log(" + i5 + " ) / " + j2);
              fraction = i5 / j2;
              originalValue = Math.log(i5) / j2;
              value = originalValue.toFixed(4);
              returned = approxAll(value);
              returnedValue = returned[2] * Math.log(returned[3]) / returned[4];
              if (Math.abs(originalValue - returnedValue) > 1e-15) {
                console.log("fail testApproxAll with 4 digits: 1 * log(" + i5 + " ) / " + j2 + " . obtained: " + returned);
              }
            }
          }
          for (i5 = v1 = 1; v1 <= 5; i5 = ++v1) {
            for (j2 = x12 = 1; x12 <= 5; j2 = ++x12) {
              console.log("testApproxAll testing: 1 * log(" + i5 + " / " + j2 + " )");
              fraction = i5 / j2;
              value = Math.log(i5 / j2);
              returned = approxAll(value);
              returnedValue = returned[2] * Math.log(returned[3] / returned[4]);
              if (Math.abs(value - returnedValue) > 1e-15) {
                console.log("fail testApproxAll: 1 * log(" + i5 + " / " + j2 + " ) . obtained: " + returned);
              }
            }
          }
          for (i5 = z1 = 1; z1 <= 5; i5 = ++z1) {
            for (j2 = i22 = 1; i22 <= 5; j2 = ++i22) {
              console.log("testApproxAll testing with 4 digits: 1 * log(" + i5 + " / " + j2 + " )");
              fraction = i5 / j2;
              originalValue = Math.log(i5 / j2);
              value = originalValue.toFixed(4);
              returned = approxAll(value);
              returnedValue = returned[2] * Math.log(returned[3] / returned[4]);
              if (Math.abs(originalValue - returnedValue) > 1e-15) {
                console.log("fail testApproxAll with 4 digits: 1 * log(" + i5 + " / " + j2 + " ) . obtained: " + returned);
              }
            }
          }
          for (i5 = j22 = 1; j22 <= 2; i5 = ++j22) {
            for (j2 = l22 = 1; l22 <= 12; j2 = ++l22) {
              console.log("testApproxAll testing: 1 * (e ^ " + i5 + " ) / " + j2);
              fraction = i5 / j2;
              value = Math.pow(Math.E, i5) / j2;
              returned = approxAll(value);
              returnedValue = returned[2] * Math.pow(Math.E, returned[3]) / returned[4];
              if (Math.abs(value - returnedValue) > 1e-15) {
                console.log("fail testApproxAll: 1 * (e ^ " + i5 + " ) / " + j2 + " . obtained: " + returned);
              }
            }
          }
          for (i5 = m22 = 1; m22 <= 2; i5 = ++m22) {
            for (j2 = n22 = 1; n22 <= 12; j2 = ++n22) {
              console.log("approxRationalsOfPowersOfE testing with 4 digits: 1 * (e ^ " + i5 + " ) / " + j2);
              fraction = i5 / j2;
              originalValue = Math.pow(Math.E, i5) / j2;
              value = originalValue.toFixed(4);
              returned = approxRationalsOfPowersOfE(value);
              returnedValue = returned[2] * Math.pow(Math.E, returned[3]) / returned[4];
              if (Math.abs(originalValue - returnedValue) > 1e-15) {
                console.log("fail approxRationalsOfPowersOfE with 4 digits: 1 * (e ^ " + i5 + " ) / " + j2 + " . obtained: " + returned);
              }
            }
          }
          for (i5 = o22 = 1; o22 <= 2; i5 = ++o22) {
            for (j2 = q2 = 1; q2 <= 12; j2 = ++q2) {
              console.log("testApproxAll testing: 1 * pi ^ " + i5 + " / " + j2);
              fraction = i5 / j2;
              value = Math.pow(Math.PI, i5) / j2;
              returned = approxAll(value);
              returnedValue = returned[2] * Math.pow(Math.PI, returned[3]) / returned[4];
              if (Math.abs(value - returnedValue) > 1e-15) {
                console.log("fail testApproxAll: 1 * pi ^ " + i5 + " / " + j2 + " ) . obtained: " + returned);
              }
            }
          }
          for (i5 = r22 = 1; r22 <= 2; i5 = ++r22) {
            for (j2 = s22 = 1; s22 <= 12; j2 = ++s22) {
              console.log("approxRationalsOfPowersOfPI testing with 4 digits: 1 * pi ^ " + i5 + " / " + j2);
              fraction = i5 / j2;
              originalValue = Math.pow(Math.PI, i5) / j2;
              value = originalValue.toFixed(4);
              returned = approxRationalsOfPowersOfPI(value);
              returnedValue = returned[2] * Math.pow(Math.PI, returned[3]) / returned[4];
              if (Math.abs(originalValue - returnedValue) > 1e-15) {
                console.log("fail approxRationalsOfPowersOfPI with 4 digits: 1 * pi ^ " + i5 + " / " + j2 + " ) . obtained: " + returned);
              }
            }
          }
          for (i5 = t23 = 1; t23 <= 4; i5 = ++t23) {
            for (j2 = u22 = 1; u22 <= 4; j2 = ++u22) {
              console.log("testApproxAll testing: 1 * sin( " + i5 + "/" + j2 + " )");
              fraction = i5 / j2;
              value = Math.sin(fraction);
              returned = approxAll(value);
              returnedFraction = returned[3] / returned[4];
              returnedValue = returned[2] * Math.sin(returnedFraction);
              if (Math.abs(value - returnedValue) > 1e-15) {
                console.log("fail testApproxAll: 1 * sin( " + i5 + "/" + j2 + " ) . obtained: " + returned);
              }
            }
          }
          for (i5 = v22 = 1; v22 <= 4; i5 = ++v22) {
            for (j2 = x22 = 1; x22 <= 4; j2 = ++x22) {
              console.log("testApproxAll testing with 5 digits: 1 * sin( " + i5 + "/" + j2 + " )");
              fraction = i5 / j2;
              originalValue = Math.sin(fraction);
              value = originalValue.toFixed(5);
              returned = approxAll(value);
              if (returned == null) {
                console.log("fail testApproxAll with 5 digits: 1 * sin( " + i5 + "/" + j2 + " ) . obtained:  undefined ");
              }
              returnedFraction = returned[3] / returned[4];
              returnedValue = returned[2] * Math.sin(returnedFraction);
              error = Math.abs(originalValue - returnedValue);
              if (error > 1e-14) {
                console.log("fail testApproxAll with 5 digits: 1 * sin( " + i5 + "/" + j2 + " ) . obtained: " + returned + " error: " + error);
              }
            }
          }
          for (i5 = z2 = 1; z2 <= 4; i5 = ++z2) {
            for (j2 = i32 = 1; i32 <= 4; j2 = ++i32) {
              console.log("testApproxAll testing with 4 digits: 1 * sin( " + i5 + "/" + j2 + " )");
              fraction = i5 / j2;
              originalValue = Math.sin(fraction);
              value = originalValue.toFixed(4);
              returned = approxAll(value);
              if (returned == null) {
                console.log("fail testApproxAll with 4 digits: 1 * sin( " + i5 + "/" + j2 + " ) . obtained:  undefined ");
              }
              returnedFraction = returned[3] / returned[4];
              returnedValue = returned[2] * Math.sin(returnedFraction);
              error = Math.abs(originalValue - returnedValue);
              if (error > 1e-14) {
                console.log("fail testApproxAll with 4 digits: 1 * sin( " + i5 + "/" + j2 + " ) . obtained: " + returned + " error: " + error);
              }
            }
          }
          value = 0;
          if (approxAll(value)[0] !== "0") {
            console.log("fail testApproxAll: 0");
          }
          value = 0;
          if (approxAll(value)[0] !== "0") {
            console.log("fail testApproxAll: 0.0");
          }
          value = 0;
          if (approxAll(value)[0] !== "0") {
            console.log("fail testApproxAll: 0.00");
          }
          value = 0;
          if (approxAll(value)[0] !== "0") {
            console.log("fail testApproxAll: 0.000");
          }
          value = 0;
          if (approxAll(value)[0] !== "0") {
            console.log("fail testApproxAll: 0.0000");
          }
          value = 1;
          if (approxAll(value)[0] !== "1") {
            console.log("fail testApproxAll: 1");
          }
          value = 1;
          if (approxAll(value)[0] !== "1") {
            console.log("fail testApproxAll: 1.0");
          }
          value = 1;
          if (approxAll(value)[0] !== "1") {
            console.log("fail testApproxAll: 1.00");
          }
          value = 1;
          if (approxAll(value)[0] !== "1") {
            console.log("fail testApproxAll: 1.000");
          }
          value = 1;
          if (approxAll(value)[0] !== "1") {
            console.log("fail testApproxAll: 1.0000");
          }
          value = 1;
          if (approxAll(value)[0] !== "1") {
            console.log("fail testApproxAll: 1.00000");
          }
          value = Math.sqrt(2);
          if (approxAll(value)[0] !== "1 * sqrt( 2 ) / 1") {
            console.log("fail testApproxAll: Math.sqrt(2)");
          }
          value = 1.41;
          if (approxAll(value)[0] !== "1 * sqrt( 2 ) / 1") {
            console.log("fail testApproxAll: 1.41");
          }
          value = 1.4;
          if (approxRadicals(value)[0] !== "1 * sqrt( 2 ) / 1") {
            console.log("fail approxRadicals: 1.4");
          }
          value = 0.6;
          if (approxLogs(value)[0] !== "1 * log( 2 ) / 1") {
            console.log("fail approxLogs: 0.6");
          }
          value = 0.69;
          if (approxLogs(value)[0] !== "1 * log( 2 ) / 1") {
            console.log("fail approxLogs: 0.69");
          }
          value = 0.7;
          if (approxLogs(value)[0] !== "1 * log( 2 ) / 1") {
            console.log("fail approxLogs: 0.7");
          }
          value = 1.09;
          if (approxLogs(value)[0] !== "1 * log( 3 ) / 1") {
            console.log("fail approxLogs: 1.09");
          }
          value = 1.09;
          if (approxAll(value)[0] !== "1 * log( 3 ) / 1") {
            console.log("fail approxAll: 1.09");
          }
          value = 1.098;
          if (approxAll(value)[0] !== "1 * log( 3 ) / 1") {
            console.log("fail approxAll: 1.098");
          }
          value = 1.1;
          if (approxAll(value)[0] !== "1 * log( 3 ) / 1") {
            console.log("fail approxAll: 1.1");
          }
          value = 1.11;
          if (approxAll(value)[0] !== "1 * log( 3 ) / 1") {
            console.log("fail approxAll: 1.11");
          }
          value = Math.sqrt(3);
          if (approxAll(value)[0] !== "1 * sqrt( 3 ) / 1") {
            console.log("fail testApproxAll: Math.sqrt(3)");
          }
          value = 1;
          if (approxAll(value)[0] !== "1") {
            console.log("fail testApproxAll: 1.0000");
          }
          value = 3.141592;
          if (approxAll(value)[0] !== "1 * (pi ^ 1 ) / 1 )") {
            console.log("fail testApproxAll: 3.141592");
          }
          value = 31.41592;
          if (approxAll(value)[0] !== "10 * (pi ^ 1 ) / 1 )") {
            console.log("fail testApproxAll: 31.41592");
          }
          value = 314.1592;
          if (approxAll(value)[0] !== "100 * (pi ^ 1 ) / 1 )") {
            console.log("fail testApproxAll: 314.1592");
          }
          value = 3141592653589793e-8;
          if (approxAll(value)[0] !== "10000000 * (pi ^ 1 ) / 1 )") {
            console.log("fail testApproxAll: 31415926.53589793");
          }
          value = Math.sqrt(2);
          if (approxTrigonometric(value)[0] !== "2 * sin( 1/4 * pi )") {
            console.log("fail approxTrigonometric: Math.sqrt(2)");
          }
          value = Math.sqrt(3);
          if (approxTrigonometric(value)[0] !== "2 * sin( 1/3 * pi )") {
            console.log("fail approxTrigonometric: Math.sqrt(3)");
          }
          value = (Math.sqrt(6) - Math.sqrt(2)) / 4;
          if (approxAll(value)[0] !== "1 * sin( 1/12 * pi )") {
            console.log("fail testApproxAll: (Math.sqrt(6) - Math.sqrt(2))/4");
          }
          value = Math.sqrt(2 - Math.sqrt(2)) / 2;
          if (approxAll(value)[0] !== "1 * sin( 1/8 * pi )") {
            console.log("fail testApproxAll: Math.sqrt(2 - Math.sqrt(2))/2");
          }
          value = (Math.sqrt(6) + Math.sqrt(2)) / 4;
          if (approxAll(value)[0] !== "1 * sin( 5/12 * pi )") {
            console.log("fail testApproxAll: (Math.sqrt(6) + Math.sqrt(2))/4");
          }
          value = Math.sqrt(2 + Math.sqrt(3)) / 2;
          if (approxAll(value)[0] !== "1 * sin( 5/12 * pi )") {
            console.log("fail testApproxAll: Math.sqrt(2 + Math.sqrt(3))/2");
          }
          value = (Math.sqrt(5) - 1) / 4;
          if (approxAll(value)[0] !== "1 * sin( 1/10 * pi )") {
            console.log("fail testApproxAll: (Math.sqrt(5) - 1)/4");
          }
          value = Math.sqrt(10 - 2 * Math.sqrt(5)) / 4;
          if (approxAll(value)[0] !== "1 * sin( 1/5 * pi )") {
            console.log("fail testApproxAll: Math.sqrt(10 - 2*Math.sqrt(5))/4");
          }
          value = Math.sin(Math.PI / 7);
          if (approxAll(value)[0] !== "1 * sin( 1/7 * pi )") {
            console.log("fail testApproxAll: Math.sin(Math.PI/7)");
          }
          value = Math.sin(Math.PI / 9);
          if (approxAll(value)[0] !== "1 * sin( 1/9 * pi )") {
            console.log("fail testApproxAll: Math.sin(Math.PI/9)");
          }
          value = 1836.15267;
          if (approxRationalsOfPowersOfPI(value)[0] !== "6 * (pi ^ 5 ) / 1 )") {
            console.log("fail approxRationalsOfPowersOfPI: 1836.15267");
          }
          for (i5 = j3 = 1; j3 <= 13; i5 = ++j3) {
            for (j2 = k3 = 1; k3 <= 13; j2 = ++k3) {
              console.log("approxTrigonometric testing: 1 * sin( " + i5 + "/" + j2 + " * pi )");
              fraction = i5 / j2;
              value = Math.sin(Math.PI * fraction);
              returned = approxTrigonometric(value);
              returnedFraction = returned[3] / returned[4];
              returnedValue = returned[2] * Math.sin(Math.PI * returnedFraction);
              if (Math.abs(value - returnedValue) > 1e-15) {
                console.log("fail approxTrigonometric: 1 * sin( " + i5 + "/" + j2 + " * pi ) . obtained: " + returned);
              }
            }
          }
          for (i5 = l32 = 1; l32 <= 13; i5 = ++l32) {
            for (j2 = m3 = 1; m3 <= 13; j2 = ++m3) {
              if (i5 === 5 && j2 === 11 || i5 === 6 && j2 === 11) {
                continue;
              }
              console.log("approxTrigonometric testing with 4 digits: 1 * sin( " + i5 + "/" + j2 + " * pi )");
              fraction = i5 / j2;
              originalValue = Math.sin(Math.PI * fraction);
              value = originalValue.toFixed(4);
              returned = approxTrigonometric(value);
              returnedFraction = returned[3] / returned[4];
              returnedValue = returned[2] * Math.sin(Math.PI * returnedFraction);
              error = Math.abs(originalValue - returnedValue);
              if (error > 1e-14) {
                console.log("fail approxTrigonometric with 4 digits: 1 * sin( " + i5 + "/" + j2 + " * pi ) . obtained: " + returned + " error: " + error);
              }
            }
          }
          return console.log("testApprox done");
        };
        $.approxRadicals = approxRadicals;
        $.approxRationalsOfLogs = approxRationalsOfLogs;
        $.approxAll = approxAll;
        $.testApprox = testApprox;
        Eval_arccos = function() {
          push(cadr(p1));
          Eval();
          return arccos();
        };
        arccos = function() {
          var d3, errno, n9;
          n9 = 0;
          d3 = 0;
          save();
          p1 = pop();
          if (car(p1) === symbol(COS)) {
            push(cadr(p1));
            restore();
            return;
          }
          if (isdouble(p1)) {
            errno = 0;
            d3 = Math.acos(p1.d);
            if (errno) {
              stop("arccos function argument is not in the interval [-1,1]");
            }
            push_double(d3);
            restore();
            return;
          }
          if (isoneoversqrttwo(p1) || car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2)) {
            if (evaluatingAsFloats) {
              push_double(Math.PI / 4);
            } else {
              push_rational(1, 4);
              push_symbol(PI);
              multiply();
            }
            restore();
            return;
          }
          if (isminusoneoversqrttwo(p1) || car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), -1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2)) {
            if (evaluatingAsFloats) {
              push_double(Math.PI * 3 / 4);
            } else {
              push_rational(3, 4);
              push_symbol(PI);
              multiply();
            }
            restore();
            return;
          }
          if (issqrtthreeovertwo(p1)) {
            if (evaluatingAsFloats) {
              push_double(Math.PI / 6);
            } else {
              push_rational(1, 6);
              push_symbol(PI);
              multiply();
            }
            restore();
            return;
          }
          if (isminussqrtthreeovertwo(p1)) {
            if (evaluatingAsFloats) {
              push_double(5 * Math.PI / 6);
            } else {
              push_rational(5, 6);
              push_symbol(PI);
              multiply();
            }
            restore();
            return;
          }
          if (!isrational(p1)) {
            push_symbol(ARCCOS);
            push(p1);
            list(2);
            restore();
            return;
          }
          push(p1);
          push_integer(2);
          multiply();
          n9 = pop_integer();
          switch (n9) {
            case -2:
              if (evaluatingAsFloats) {
                push_double(Math.PI);
              } else {
                push_symbol(PI);
              }
              break;
            case -1:
              if (evaluatingAsFloats) {
                push_double(Math.PI * 2 / 3);
              } else {
                push_rational(2, 3);
                push_symbol(PI);
                multiply();
              }
              break;
            case 0:
              if (evaluatingAsFloats) {
                push_double(Math.PI / 2);
              } else {
                push_rational(1, 2);
                push_symbol(PI);
                multiply();
              }
              break;
            case 1:
              if (evaluatingAsFloats) {
                push_double(Math.PI / 3);
              } else {
                push_rational(1, 3);
                push_symbol(PI);
                multiply();
              }
              break;
            case 2:
              if (evaluatingAsFloats) {
                push_double(0);
              } else {
                push(zero);
              }
              break;
            default:
              push_symbol(ARCCOS);
              push(p1);
              list(2);
          }
          return restore();
        };
        Eval_arccosh = function() {
          push(cadr(p1));
          Eval();
          return arccosh();
        };
        arccosh = function() {
          var d3;
          d3 = 0;
          save();
          p1 = pop();
          if (car(p1) === symbol(COSH)) {
            push(cadr(p1));
            restore();
            return;
          }
          if (isdouble(p1)) {
            d3 = p1.d;
            if (d3 < 1) {
              stop("arccosh function argument is less than 1.0");
            }
            d3 = Math.log(d3 + Math.sqrt(d3 * d3 - 1));
            push_double(d3);
            restore();
            return;
          }
          if (isplusone(p1)) {
            push(zero);
            restore();
            return;
          }
          push_symbol(ARCCOSH);
          push(p1);
          list(2);
          return restore();
        };
        Eval_arcsin = function() {
          push(cadr(p1));
          Eval();
          return arcsin();
        };
        arcsin = function() {
          var d3, errno, n9;
          n9 = 0;
          d3 = 0;
          save();
          p1 = pop();
          if (car(p1) === symbol(SIN)) {
            push(cadr(p1));
            restore();
            return;
          }
          if (isdouble(p1)) {
            errno = 0;
            d3 = Math.asin(p1.d);
            if (errno) {
              stop("arcsin function argument is not in the interval [-1,1]");
            }
            push_double(d3);
            restore();
            return;
          }
          if (isoneoversqrttwo(p1) || car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2)) {
            push_rational(1, 4);
            push_symbol(PI);
            multiply();
            restore();
            return;
          }
          if (isminusoneoversqrttwo(p1) || car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), -1, 2) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 2) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2)) {
            if (evaluatingAsFloats) {
              push_double(-Math.PI / 4);
            } else {
              push_rational(-1, 4);
              push_symbol(PI);
              multiply();
            }
            restore();
            return;
          }
          if (issqrtthreeovertwo(p1)) {
            if (evaluatingAsFloats) {
              push_double(Math.PI / 3);
            } else {
              push_rational(1, 3);
              push_symbol(PI);
              multiply();
            }
            restore();
            return;
          }
          if (isminussqrtthreeovertwo(p1)) {
            if (evaluatingAsFloats) {
              push_double(-Math.PI / 3);
            } else {
              push_rational(-1, 3);
              push_symbol(PI);
              multiply();
            }
            restore();
            return;
          }
          if (!isrational(p1)) {
            push_symbol(ARCSIN);
            push(p1);
            list(2);
            restore();
            return;
          }
          push(p1);
          push_integer(2);
          multiply();
          n9 = pop_integer();
          switch (n9) {
            case -2:
              if (evaluatingAsFloats) {
                push_double(-Math.PI / 2);
              } else {
                push_rational(-1, 2);
                push_symbol(PI);
                multiply();
              }
              break;
            case -1:
              if (evaluatingAsFloats) {
                push_double(-Math.PI / 6);
              } else {
                push_rational(-1, 6);
                push_symbol(PI);
                multiply();
              }
              break;
            case 0:
              if (evaluatingAsFloats) {
                push_double(0);
              } else {
                push(zero);
              }
              break;
            case 1:
              if (evaluatingAsFloats) {
                push_double(Math.PI / 6);
              } else {
                push_rational(1, 6);
                push_symbol(PI);
                multiply();
              }
              break;
            case 2:
              if (evaluatingAsFloats) {
                push_double(Math.PI / 2);
              } else {
                push_rational(1, 2);
                push_symbol(PI);
                multiply();
              }
              break;
            default:
              push_symbol(ARCSIN);
              push(p1);
              list(2);
          }
          return restore();
        };
        Eval_arcsinh = function() {
          push(cadr(p1));
          Eval();
          return arcsinh();
        };
        arcsinh = function() {
          var d3;
          d3 = 0;
          save();
          p1 = pop();
          if (car(p1) === symbol(SINH)) {
            push(cadr(p1));
            restore();
            return;
          }
          if (isdouble(p1)) {
            d3 = p1.d;
            d3 = Math.log(d3 + Math.sqrt(d3 * d3 + 1));
            push_double(d3);
            restore();
            return;
          }
          if (isZeroAtomOrTensor(p1)) {
            push(zero);
            restore();
            return;
          }
          push_symbol(ARCSINH);
          push(p1);
          list(2);
          return restore();
        };
        Eval_arctan = function() {
          push(cadr(p1));
          Eval();
          return arctan();
        };
        arctan = function() {
          var d3, errno;
          d3 = 0;
          save();
          p1 = pop();
          if (car(p1) === symbol(TAN)) {
            push(cadr(p1));
            restore();
            return;
          }
          if (isdouble(p1)) {
            errno = 0;
            d3 = Math.atan(p1.d);
            if (errno) {
              stop("arctan function error");
            }
            push_double(d3);
            restore();
            return;
          }
          if (isZeroAtomOrTensor(p1)) {
            push(zero);
            restore();
            return;
          }
          if (isnegative(p1)) {
            push(p1);
            negate();
            arctan();
            negate();
            restore();
            return;
          }
          if (Find(p1, symbol(SIN)) && Find(p1, symbol(COS))) {
            push(p1);
            numerator();
            p2 = pop();
            push(p1);
            denominator();
            p3 = pop();
            if (car(p2) === symbol(SIN) && car(p3) === symbol(COS) && equal(cadr(p2), cadr(p3))) {
              push(cadr(p2));
              restore();
              return;
            }
          }
          if (car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), -1, 2) || car(p1) === symbol(MULTIPLY) && equalq(car(cdr(p1)), 1, 3) && car(car(cdr(cdr(p1)))) === symbol(POWER) && equaln(car(cdr(car(cdr(cdr(p1))))), 3) && equalq(car(cdr(cdr(car(cdr(cdr(p1)))))), 1, 2)) {
            push_rational(1, 6);
            if (evaluatingAsFloats) {
              push_double(Math.PI);
            } else {
              push(symbol(PI));
            }
            multiply();
            restore();
            return;
          }
          if (equaln(p1, 1)) {
            push_rational(1, 4);
            if (evaluatingAsFloats) {
              push_double(Math.PI);
            } else {
              push(symbol(PI));
            }
            multiply();
            restore();
            return;
          }
          if (car(p1) === symbol(POWER) && equaln(cadr(p1), 3) && equalq(caddr(p1), 1, 2)) {
            push_rational(1, 3);
            if (evaluatingAsFloats) {
              push_double(Math.PI);
            } else {
              push(symbol(PI));
            }
            multiply();
            restore();
            return;
          }
          push_symbol(ARCTAN);
          push(p1);
          list(2);
          return restore();
        };
        Eval_arctanh = function() {
          push(cadr(p1));
          Eval();
          return arctanh();
        };
        arctanh = function() {
          var d3;
          d3 = 0;
          save();
          p1 = pop();
          if (car(p1) === symbol(TANH)) {
            push(cadr(p1));
            restore();
            return;
          }
          if (isdouble(p1)) {
            d3 = p1.d;
            if (d3 < -1 || d3 > 1) {
              stop("arctanh function argument is not in the interval [-1,1]");
            }
            d3 = Math.log((1 + d3) / (1 - d3)) / 2;
            push_double(d3);
            restore();
            return;
          }
          if (isZeroAtomOrTensor(p1)) {
            push(zero);
            restore();
            return;
          }
          push_symbol(ARCTANH);
          push(p1);
          list(2);
          return restore();
        };
        DEBUG_ARG = false;
        Eval_arg = function() {
          push(cadr(p1));
          Eval();
          return arg();
        };
        arg = function() {
          save();
          p1 = pop();
          push(p1);
          numerator();
          yyarg();
          push(p1);
          denominator();
          yyarg();
          subtract();
          return restore();
        };
        yyarg = function() {
          save();
          p1 = pop();
          if (ispositivenumber(p1) || p1 === symbol(PI)) {
            if (isdouble(p1) || evaluatingAsFloats) {
              push_double(0);
            } else {
              push_integer(0);
            }
          } else if (isnegativenumber(p1)) {
            if (isdouble(p1) || evaluatingAsFloats) {
              push_double(Math.PI);
            } else {
              push(symbol(PI));
            }
            negate();
          } else if (issymbol(p1)) {
            push_symbol(ARG);
            push(p1);
            list(2);
          } else if (car(p1) === symbol(POWER) && equaln(cadr(p1), -1)) {
            if (evaluatingAsFloats) {
              push_double(Math.PI);
            } else {
              push(symbol(PI));
            }
            push(caddr(p1));
            multiply();
          } else if (car(p1) === symbol(POWER) && cadr(p1) === symbol(E)) {
            push(caddr(p1));
            imag();
          } else if (car(p1) === symbol(POWER) && isoneovertwo(caddr(p1))) {
            if (DEBUG_ARG) {
              console.log("arg of a sqrt: " + p1);
            }
            if (DEBUG_ARG) {
              debugger;
            }
            push(cadr(p1));
            arg();
            if (DEBUG_ARG) {
              console.log(" = 1/2 * " + stack[tos - 1]);
            }
            push(caddr(p1));
            multiply();
          } else if (car(p1) === symbol(MULTIPLY)) {
            push_integer(0);
            p1 = cdr(p1);
            while (iscons(p1)) {
              push(car(p1));
              arg();
              add();
              p1 = cdr(p1);
            }
          } else if (car(p1) === symbol(ADD)) {
            push(p1);
            rect();
            p1 = pop();
            push(p1);
            real();
            p2 = pop();
            push(p1);
            imag();
            p3 = pop();
            if (isZeroAtomOrTensor(p2)) {
              if (evaluatingAsFloats) {
                push_double(Math.PI);
              } else {
                push(symbol(PI));
              }
              if (isnegative(p3)) {
                negate();
              }
            } else {
              push(p3);
              push(p2);
              divide();
              arctan();
              if (isnegative(p2)) {
                if (evaluatingAsFloats) {
                  push_double(Math.PI);
                } else {
                  push_symbol(PI);
                }
                if (isnegative(p3)) {
                  subtract();
                } else {
                  add();
                }
              }
            }
          } else {
            if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {
              push_integer(0);
            } else {
              push_symbol(ARG);
              push(p1);
              list(2);
            }
          }
          return restore();
        };
        bake = function() {
          var h5, s8, t5, x3, y3, z2;
          h5 = 0;
          s8 = 0;
          t5 = 0;
          x3 = 0;
          y3 = 0;
          z2 = 0;
          expanding++;
          save();
          p1 = pop();
          s8 = ispolyexpandedform(p1, symbol(SYMBOL_S));
          t5 = ispolyexpandedform(p1, symbol(SYMBOL_T));
          x3 = ispolyexpandedform(p1, symbol(SYMBOL_X));
          y3 = ispolyexpandedform(p1, symbol(SYMBOL_Y));
          z2 = ispolyexpandedform(p1, symbol(SYMBOL_Z));
          if (s8 === 1 && t5 === 0 && x3 === 0 && y3 === 0 && z2 === 0) {
            p2 = symbol(SYMBOL_S);
            bake_poly();
          } else if (s8 === 0 && t5 === 1 && x3 === 0 && y3 === 0 && z2 === 0) {
            p2 = symbol(SYMBOL_T);
            bake_poly();
          } else if (s8 === 0 && t5 === 0 && x3 === 1 && y3 === 0 && z2 === 0) {
            p2 = symbol(SYMBOL_X);
            bake_poly();
          } else if (s8 === 0 && t5 === 0 && x3 === 0 && y3 === 1 && z2 === 0) {
            p2 = symbol(SYMBOL_Y);
            bake_poly();
          } else if (s8 === 0 && t5 === 0 && x3 === 0 && y3 === 0 && z2 === 1) {
            p2 = symbol(SYMBOL_Z);
            bake_poly();
          } else if (iscons(p1) && car(p1) !== symbol(FOR)) {
            h5 = tos;
            push(car(p1));
            p1 = cdr(p1);
            while (iscons(p1)) {
              push(car(p1));
              bake();
              p1 = cdr(p1);
            }
            list(tos - h5);
          } else {
            push(p1);
          }
          restore();
          return expanding--;
        };
        polyform = function() {
          var h5;
          h5 = 0;
          save();
          p2 = pop();
          p1 = pop();
          if (ispolyexpandedform(p1, p2)) {
            bake_poly();
          } else if (iscons(p1)) {
            h5 = tos;
            push(car(p1));
            p1 = cdr(p1);
            while (iscons(p1)) {
              push(car(p1));
              push(p2);
              polyform();
              p1 = cdr(p1);
            }
            list(tos - h5);
          } else {
            push(p1);
          }
          return restore();
        };
        bake_poly = function() {
          var a5, h5, i5, k3, n9, o12, ref2;
          h5 = 0;
          i5 = 0;
          k3 = 0;
          n9 = 0;
          a5 = tos;
          k3 = coeff(p2, p1);
          h5 = tos;
          for (i5 = o12 = ref2 = k3 - 1; o12 >= 0; i5 = o12 += -1) {
            p1 = stack[a5 + i5];
            bake_poly_term(i5);
          }
          n9 = tos - h5;
          if (n9 > 1) {
            list(n9);
            push(symbol(ADD));
            swap();
            cons();
          }
          p1 = pop();
          moveTos(tos - k3);
          return push(p1);
        };
        bake_poly_term = function(k3) {
          var h5, n9;
          h5 = 0;
          n9 = 0;
          if (isZeroAtomOrTensor(p1)) {
            return;
          }
          if (k3 === 0) {
            if (car(p1) === symbol(ADD)) {
              p1 = cdr(p1);
              while (iscons(p1)) {
                push(car(p1));
                p1 = cdr(p1);
              }
            } else {
              push(p1);
            }
            return;
          }
          h5 = tos;
          if (car(p1) === symbol(MULTIPLY)) {
            p1 = cdr(p1);
            while (iscons(p1)) {
              push(car(p1));
              p1 = cdr(p1);
            }
          } else if (!equaln(p1, 1)) {
            push(p1);
          }
          if (k3 === 1) {
            push(p2);
          } else {
            push(symbol(POWER));
            push(p2);
            push_integer(k3);
            list(3);
          }
          n9 = tos - h5;
          if (n9 > 1) {
            list(n9);
            push(symbol(MULTIPLY));
            swap();
            return cons();
          }
        };
        Eval_besselj = function() {
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          return besselj();
        };
        besselj = function() {
          save();
          yybesselj();
          return restore();
        };
        yybesselj = function() {
          var d3, n9;
          d3 = 0;
          n9 = 0;
          p2 = pop();
          p1 = pop();
          push(p2);
          n9 = pop_integer();
          if (isdouble(p1) && !isNaN(n9)) {
            d3 = jn(n9, p1.d);
            push_double(d3);
            return;
          }
          if (isZeroAtomOrTensor(p1) && isZeroAtomOrTensor(p2)) {
            push_integer(1);
            return;
          }
          if (isZeroAtomOrTensor(p1) && !isNaN(n9)) {
            push_integer(0);
            return;
          }
          if (p2.k === NUM && MEQUAL(p2.q.b, 2)) {
            if (MEQUAL(p2.q.a, 1)) {
              if (evaluatingAsFloats) {
                push_double(2 / Math.PI);
              } else {
                push_integer(2);
                push_symbol(PI);
                divide();
              }
              push(p1);
              divide();
              push_rational(1, 2);
              power();
              push(p1);
              sine();
              multiply();
              return;
            }
            if (MEQUAL(p2.q.a, -1)) {
              if (evaluatingAsFloats) {
                push_double(2 / Math.PI);
              } else {
                push_integer(2);
                push_symbol(PI);
                divide();
              }
              push(p1);
              divide();
              push_rational(1, 2);
              power();
              push(p1);
              cosine();
              multiply();
              return;
            }
            push_integer(MSIGN(p2.q.a));
            p3 = pop();
            push_integer(2);
            push(p1);
            divide();
            push(p2);
            push(p3);
            subtract();
            multiply();
            push(p1);
            push(p2);
            push(p3);
            subtract();
            besselj();
            multiply();
            push(p1);
            push(p2);
            push_integer(2);
            push(p3);
            multiply();
            subtract();
            besselj();
            subtract();
            return;
          }
          if (isnegativeterm(p1)) {
            push(p1);
            negate();
            push(p2);
            power();
            push(p1);
            push(p2);
            negate();
            power();
            multiply();
            push_symbol(BESSELJ);
            push(p1);
            negate();
            push(p2);
            list(3);
            multiply();
            return;
          }
          if (isnegativeterm(p2)) {
            push_integer(-1);
            push(p2);
            power();
            push_symbol(BESSELJ);
            push(p1);
            push(p2);
            negate();
            list(3);
            multiply();
            return;
          }
          push(symbol(BESSELJ));
          push(p1);
          push(p2);
          return list(3);
        };
        Eval_bessely = function() {
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          return bessely();
        };
        bessely = function() {
          save();
          yybessely();
          return restore();
        };
        yybessely = function() {
          var d3, n9;
          d3 = 0;
          n9 = 0;
          p2 = pop();
          p1 = pop();
          push(p2);
          n9 = pop_integer();
          if (isdouble(p1) && !isNaN(n9)) {
            d3 = yn(n9, p1.d);
            push_double(d3);
            return;
          }
          if (isnegativeterm(p2)) {
            push_integer(-1);
            push(p2);
            power();
            push_symbol(BESSELY);
            push(p1);
            push(p2);
            negate();
            list(3);
            multiply();
            return;
          }
          push_symbol(BESSELY);
          push(p1);
          push(p2);
          list(3);
        };
        mint = function(a5) {
          return bigInt(a5);
        };
        isSmall = function(a5) {
          return a5.geq(Number.MIN_SAFE_INTEGER) && a5.leq(Number.MAX_SAFE_INTEGER);
        };
        setSignTo = function(a5, b2) {
          if (a5.isPositive()) {
            if (b2 < 0) {
              return a5.multiply(bigInt(-1));
            }
          } else {
            if (b2 > 0) {
              return a5.multiply(bigInt(-1));
            }
          }
          return a5;
        };
        makeSignSameAs = function(a5, b2) {
          if (a5.isPositive()) {
            if (b2.isNegative()) {
              return a5.multiply(bigInt(-1));
            }
          } else {
            if (b2.isPositive()) {
              return a5.multiply(bigInt(-1));
            }
          }
          return a5;
        };
        makePositive = function(a5) {
          if (a5.isNegative()) {
            return a5.multiply(bigInt(-1));
          }
          return a5;
        };
        add_numbers = function() {
          var a5, b2, theResult;
          a5 = 1;
          b2 = 1;
          if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
            qadd();
            return;
          }
          save();
          p2 = pop();
          p1 = pop();
          if (isdouble(p1)) {
            a5 = p1.d;
          } else {
            a5 = convert_rational_to_double(p1);
          }
          if (isdouble(p2)) {
            b2 = p2.d;
          } else {
            b2 = convert_rational_to_double(p2);
          }
          theResult = a5 + b2;
          push_double(theResult);
          return restore();
        };
        subtract_numbers = function() {
          var a5, b2;
          a5 = 0;
          b2 = 0;
          if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
            qsub();
            return;
          }
          save();
          p2 = pop();
          p1 = pop();
          if (isdouble(p1)) {
            a5 = p1.d;
          } else {
            a5 = convert_rational_to_double(p1);
          }
          if (isdouble(p2)) {
            b2 = p2.d;
          } else {
            b2 = convert_rational_to_double(p2);
          }
          push_double(a5 - b2);
          return restore();
        };
        multiply_numbers = function() {
          var a5, b2;
          a5 = 0;
          b2 = 0;
          if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
            qmul();
            return;
          }
          save();
          p2 = pop();
          p1 = pop();
          if (isdouble(p1)) {
            a5 = p1.d;
          } else {
            a5 = convert_rational_to_double(p1);
          }
          if (isdouble(p2)) {
            b2 = p2.d;
          } else {
            b2 = convert_rational_to_double(p2);
          }
          push_double(a5 * b2);
          return restore();
        };
        divide_numbers = function() {
          var a5, b2;
          a5 = 0;
          b2 = 0;
          if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
            qdiv();
            return;
          }
          save();
          p2 = pop();
          p1 = pop();
          if (isZeroAtomOrTensor(p2)) {
            stop("divide by zero");
          }
          if (isdouble(p1)) {
            a5 = p1.d;
          } else {
            a5 = convert_rational_to_double(p1);
          }
          if (isdouble(p2)) {
            b2 = p2.d;
          } else {
            b2 = convert_rational_to_double(p2);
          }
          push_double(a5 / b2);
          return restore();
        };
        invert_number = function() {
          var a5, b2;
          save();
          p1 = pop();
          if (isZeroAtomOrTensor(p1)) {
            stop("divide by zero");
          }
          if (isdouble(p1)) {
            push_double(1 / p1.d);
            restore();
            return;
          }
          a5 = bigInt(p1.q.a);
          b2 = bigInt(p1.q.b);
          b2 = makeSignSameAs(b2, a5);
          a5 = setSignTo(a5, 1);
          p1 = new U();
          p1.k = NUM;
          p1.q.a = b2;
          p1.q.b = a5;
          push(p1);
          return restore();
        };
        compare_rationals = function(a5, b2) {
          var ab4, ba, t5;
          t5 = 0;
          ab4 = mmul(a5.q.a, b2.q.b);
          ba = mmul(a5.q.b, b2.q.a);
          t5 = mcmp(ab4, ba);
          return t5;
        };
        compare_numbers = function(a5, b2) {
          var x3, y3;
          x3 = 0;
          y3 = 0;
          if (isrational(a5) && isrational(b2)) {
            return compare_rationals(a5, b2);
          }
          if (isdouble(a5)) {
            x3 = a5.d;
          } else {
            x3 = convert_rational_to_double(a5);
          }
          if (isdouble(b2)) {
            y3 = b2.d;
          } else {
            y3 = convert_rational_to_double(b2);
          }
          if (x3 < y3) {
            return -1;
          }
          if (x3 > y3) {
            return 1;
          }
          return 0;
        };
        negate_number = function() {
          save();
          p1 = pop();
          if (isZeroAtomOrTensor(p1)) {
            push(p1);
            restore();
            return;
          }
          switch (p1.k) {
            case NUM:
              p2 = new U();
              p2.k = NUM;
              p2.q.a = bigInt(p1.q.a.multiply(bigInt.minusOne));
              p2.q.b = bigInt(p1.q.b);
              push(p2);
              break;
            case DOUBLE:
              push_double(-p1.d);
              break;
            default:
              stop("bug caught in mp_negate_number");
          }
          return restore();
        };
        bignum_truncate = function() {
          var a5;
          save();
          p1 = pop();
          a5 = mdiv(p1.q.a, p1.q.b);
          p1 = new U();
          p1.k = NUM;
          p1.q.a = a5;
          p1.q.b = bigInt(1);
          push(p1);
          return restore();
        };
        mp_numerator = function() {
          save();
          p1 = pop();
          if (p1.k !== NUM) {
            push(one);
            restore();
            return;
          }
          p2 = new U();
          p2.k = NUM;
          p2.q.a = bigInt(p1.q.a);
          p2.q.b = bigInt(1);
          push(p2);
          return restore();
        };
        mp_denominator = function() {
          save();
          p1 = pop();
          if (p1.k !== NUM) {
            push(one);
            restore();
            return;
          }
          p2 = new U();
          p2.k = NUM;
          p2.q.a = bigInt(p1.q.b);
          p2.q.b = bigInt(1);
          push(p2);
          return restore();
        };
        bignum_power_number = function(expo) {
          var a5, b2, t5;
          save();
          p1 = pop();
          a5 = mpow(p1.q.a, Math.abs(expo));
          b2 = mpow(p1.q.b, Math.abs(expo));
          if (expo < 0) {
            t5 = a5;
            a5 = b2;
            b2 = t5;
            a5 = makeSignSameAs(a5, b2);
            b2 = setSignTo(b2, 1);
          }
          p1 = new U();
          p1.k = NUM;
          p1.q.a = a5;
          p1.q.b = b2;
          push(p1);
          return restore();
        };
        convert_bignum_to_double = function(p11) {
          return p11.toJSNumber();
        };
        convert_rational_to_double = function(p11) {
          var quotientAndRemainder, result;
          if (p11.q == null) {
            debugger;
          }
          quotientAndRemainder = p11.q.a.divmod(p11.q.b);
          result = quotientAndRemainder.quotient + quotientAndRemainder.remainder / p11.q.b.toJSNumber();
          return result;
        };
        new_integer = function(n9) {
          var theNewInteger;
          theNewInteger = new U();
          theNewInteger.k = NUM;
          theNewInteger.q.a = bigInt(n9);
          theNewInteger.q.b = bigInt(1);
          return theNewInteger;
        };
        push_integer = function(n9) {
          if (DEBUG) {
            console.log("pushing integer " + n9);
          }
          return push(new_integer(n9));
        };
        push_double = function(d3) {
          save();
          p1 = new U();
          p1.k = DOUBLE;
          p1.d = d3;
          push(p1);
          return restore();
        };
        push_rational = function(a5, b2) {
          var p11;
          p11 = new U();
          p11.k = NUM;
          p11.q.a = bigInt(a5);
          p11.q.b = bigInt(b2);
          return push(p11);
        };
        pop_integer = function() {
          var n9;
          n9 = 0 / 0;
          save();
          p1 = pop();
          switch (p1.k) {
            case NUM:
              if (isinteger(p1) && isSmall(p1.q.a)) {
                n9 = p1.q.a.toJSNumber();
              }
              break;
            case DOUBLE:
              if (DEBUG) {
                console.log("popping integer but double is found");
              }
              if (Math.floor(p1.d) === p1.d) {
                if (DEBUG) {
                  console.log("...altough it's an integer");
                }
                n9 = p1.d;
              }
          }
          restore();
          return n9;
        };
        print_double = function(p11, flag2) {
          var accumulator, buf;
          accumulator = "";
          buf = doubleToReasonableString(p11.d);
          if (flag2 === 1 && buf === "-") {
            accumulator += print_str(buf + 1);
          } else {
            accumulator += print_str(buf);
          }
          return accumulator;
        };
        bignum_scan_integer = function(s8) {
          var a5, scounter, sign_;
          save();
          scounter = 0;
          sign_ = s8[scounter];
          if (sign_ === "+" || sign_ === "-") {
            scounter++;
          }
          a5 = bigInt(s8.substring(scounter));
          p1 = new U();
          p1.k = NUM;
          p1.q.a = a5;
          p1.q.b = bigInt(1);
          push(p1);
          if (sign_ === "-") {
            negate();
          }
          return restore();
        };
        bignum_scan_float = function(s8) {
          return push_double(parseFloat(s8));
        };
        print_number = function(p11, signed) {
          var aAsString, accumulator, buf, denominatorString;
          accumulator = "";
          denominatorString = "";
          buf = "";
          switch (p11.k) {
            case NUM:
              aAsString = p11.q.a.toString();
              if (!signed) {
                if (aAsString[0] === "-") {
                  aAsString = aAsString.substring(1);
                }
              }
              if (printMode === PRINTMODE_LATEX && isfraction(p11)) {
                aAsString = "\\frac{" + aAsString + "}{";
              }
              accumulator += aAsString;
              if (isfraction(p11)) {
                if (printMode !== PRINTMODE_LATEX) {
                  accumulator += "/";
                }
                denominatorString = p11.q.b.toString();
                if (printMode === PRINTMODE_LATEX) {
                  denominatorString += "}";
                }
                accumulator += denominatorString;
              }
              break;
            case DOUBLE:
              aAsString = doubleToReasonableString(p11.d);
              if (!signed) {
                if (aAsString[0] === "-") {
                  aAsString = aAsString.substring(1);
                }
              }
              accumulator += aAsString;
          }
          return accumulator;
        };
        gcd_numbers = function() {
          save();
          p2 = pop();
          p1 = pop();
          p3 = new U();
          p3.k = NUM;
          p3.q.a = mgcd(p1.q.a, p2.q.a);
          p3.q.b = mgcd(p1.q.b, p2.q.b);
          p3.q.a = setSignTo(p3.q.a, 1);
          push(p3);
          return restore();
        };
        pop_double = function() {
          var d3;
          d3 = 0;
          save();
          p1 = pop();
          switch (p1.k) {
            case NUM:
              d3 = convert_rational_to_double(p1);
              break;
            case DOUBLE:
              d3 = p1.d;
              break;
            default:
              d3 = 0;
          }
          restore();
          return d3;
        };
        bignum_float = function() {
          var d3;
          d3 = 0;
          d3 = convert_rational_to_double(pop());
          return push_double(d3);
        };
        bignum_factorial = function(n9) {
          save();
          p1 = new U();
          p1.k = NUM;
          p1.q.a = __factorial(n9);
          p1.q.b = bigInt(1);
          push(p1);
          return restore();
        };
        __factorial = function(n9) {
          var a5, b2, i5, o12, ref2, t5;
          i5 = 0;
          if (n9 === 0 || n9 === 1) {
            a5 = bigInt(1);
            return a5;
          }
          a5 = bigInt(2);
          b2 = bigInt(0);
          if (3 <= n9) {
            for (i5 = o12 = 3, ref2 = n9; 3 <= ref2 ? o12 <= ref2 : o12 >= ref2; i5 = 3 <= ref2 ? ++o12 : --o12) {
              b2 = bigInt(i5);
              t5 = mmul(a5, b2);
              a5 = t5;
            }
          }
          return a5;
        };
        mask = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648];
        mp_set_bit = function(x3, k3) {
          console.log("not implemented yet");
          debugger;
          return x3[k3 / 32] |= mask[k3 % 32];
        };
        mp_clr_bit = function(x3, k3) {
          console.log("not implemented yet");
          debugger;
          return x3[k3 / 32] &= ~mask[k3 % 32];
        };
        mshiftright = function(a5) {
          return a5 = a5.shiftRight();
        };
        Eval_binomial = function() {
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          return binomial();
        };
        binomial = function() {
          save();
          ybinomial();
          return restore();
        };
        ybinomial = function() {
          p2 = pop();
          p1 = pop();
          if (BINOM_check_args() === 0) {
            push(zero);
            return;
          }
          push(p1);
          factorial();
          push(p2);
          factorial();
          divide();
          push(p1);
          push(p2);
          subtract();
          factorial();
          return divide();
        };
        BINOM_check_args = function() {
          if (isNumericAtom(p1) && lessp(p1, zero)) {
            return 0;
          } else if (isNumericAtom(p2) && lessp(p2, zero)) {
            return 0;
          } else if (isNumericAtom(p1) && isNumericAtom(p2) && lessp(p1, p2)) {
            return 0;
          } else {
            return 1;
          }
        };
        Eval_ceiling = function() {
          push(cadr(p1));
          Eval();
          return ceiling();
        };
        ceiling = function() {
          save();
          yyceiling();
          return restore();
        };
        yyceiling = function() {
          var d3, doNothing;
          d3 = 0;
          p1 = pop();
          if (!isNumericAtom(p1)) {
            push_symbol(CEILING);
            push(p1);
            list(2);
            return;
          }
          if (isdouble(p1)) {
            d3 = Math.ceil(p1.d);
            push_double(d3);
            return;
          }
          if (isinteger(p1)) {
            push(p1);
            return;
          }
          p3 = new U();
          p3.k = NUM;
          p3.q.a = mdiv(p1.q.a, p1.q.b);
          p3.q.b = mint(1);
          push(p3);
          if (isnegativenumber(p1)) {
            return doNothing = 1;
          } else {
            push_integer(1);
            return add();
          }
        };
        Eval_choose = function() {
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          return choose();
        };
        choose = function() {
          save();
          p2 = pop();
          p1 = pop();
          if (choose_check_args() === 0) {
            push_integer(0);
            restore();
            return;
          }
          push(p1);
          factorial();
          push(p2);
          factorial();
          divide();
          push(p1);
          push(p2);
          subtract();
          factorial();
          divide();
          return restore();
        };
        choose_check_args = function() {
          if (isNumericAtom(p1) && lessp(p1, zero)) {
            return 0;
          } else if (isNumericAtom(p2) && lessp(p2, zero)) {
            return 0;
          } else if (isNumericAtom(p1) && isNumericAtom(p2) && lessp(p1, p2)) {
            return 0;
          } else {
            return 1;
          }
        };
        Eval_circexp = function() {
          push(cadr(p1));
          Eval();
          circexp();
          return Eval();
        };
        circexp = function() {
          var h5, i5, o12, ref2;
          i5 = 0;
          h5 = 0;
          save();
          p1 = pop();
          if (car(p1) === symbol(COS)) {
            push(cadr(p1));
            expcos();
            restore();
            return;
          }
          if (car(p1) === symbol(SIN)) {
            push(cadr(p1));
            expsin();
            restore();
            return;
          }
          if (car(p1) === symbol(TAN)) {
            p1 = cadr(p1);
            push(imaginaryunit);
            push(p1);
            multiply();
            exponential();
            p2 = pop();
            push(imaginaryunit);
            push(p1);
            multiply();
            negate();
            exponential();
            p3 = pop();
            push(p3);
            push(p2);
            subtract();
            push(imaginaryunit);
            multiply();
            push(p2);
            push(p3);
            add();
            divide();
            restore();
            return;
          }
          if (car(p1) === symbol(COSH)) {
            p1 = cadr(p1);
            push(p1);
            exponential();
            push(p1);
            negate();
            exponential();
            add();
            push_rational(1, 2);
            multiply();
            restore();
            return;
          }
          if (car(p1) === symbol(SINH)) {
            p1 = cadr(p1);
            push(p1);
            exponential();
            push(p1);
            negate();
            exponential();
            subtract();
            push_rational(1, 2);
            multiply();
            restore();
            return;
          }
          if (car(p1) === symbol(TANH)) {
            p1 = cadr(p1);
            push(p1);
            push_integer(2);
            multiply();
            exponential();
            p1 = pop();
            push(p1);
            push_integer(1);
            subtract();
            push(p1);
            push_integer(1);
            add();
            divide();
            restore();
            return;
          }
          if (iscons(p1)) {
            h5 = tos;
            while (iscons(p1)) {
              push(car(p1));
              circexp();
              p1 = cdr(p1);
            }
            list(tos - h5);
            restore();
            return;
          }
          if (p1.k === TENSOR) {
            push(p1);
            copy_tensor();
            p1 = pop();
            for (i5 = o12 = 0, ref2 = p1.tensor.nelem; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
              push(p1.tensor.elem[i5]);
              circexp();
              p1.tensor.elem[i5] = pop();
            }
            push(p1);
            restore();
            return;
          }
          push(p1);
          return restore();
        };
        Eval_clearall = function() {
          do_clearall();
          return push(symbol(NIL));
        };
        do_clearall = function() {
          if (test_flag === 0) {
            clear_term();
          }
          do_clearPatterns();
          clear_symbols();
          defn();
          return codeGen = false;
        };
        clearall = function() {
          return run("clearall");
        };
        clearRenamedVariablesToAvoidBindingToExternalScope = function() {
          var i5, o12, ref2, results;
          results = [];
          for (i5 = o12 = 0, ref2 = symtab.length; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            if (symtab[i5].printname.indexOf("AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE") !== -1) {
              symtab[i5].k = SYM;
              symtab[i5].printname = "";
              binding[i5] = symtab[i5];
              results.push(isSymbolReclaimable[i5] = true);
            } else {
              results.push(void 0);
            }
          }
          return results;
        };
        Eval_clear = function() {
          var indexFound, variableToBeCleared;
          p2 = cdr(p1);
          while (iscons(p2)) {
            variableToBeCleared = car(p2);
            if (variableToBeCleared.k !== SYM) {
              stop("symbol error");
            }
            indexFound = symtab.indexOf(variableToBeCleared);
            symtab[indexFound].k = SYM;
            symtab[indexFound].printname = "";
            binding[indexFound] = symtab[indexFound];
            isSymbolReclaimable[indexFound] = true;
            p2 = cdr(p2);
          }
          return push(symbol(NIL));
        };
        DEBUG_CLOCKFORM = false;
        Eval_clock = function() {
          push(cadr(p1));
          Eval();
          return clockform();
        };
        clockform = function() {
          save();
          p1 = pop();
          push(p1);
          abs();
          if (DEBUG_CLOCKFORM) {
            console.log("clockform: abs of " + p1 + " : " + stack[tos - 1]);
          }
          push_symbol(POWER);
          push_integer(-1);
          push(p1);
          arg();
          if (DEBUG_CLOCKFORM) {
            console.log("clockform: arg of " + p1 + " : " + stack[tos - 1]);
          }
          if (evaluatingAsFloats) {
            push_double(Math.PI);
          } else {
            push(symbol(PI));
          }
          divide();
          if (DEBUG_CLOCKFORM) {
            console.log("clockform: divide : " + stack[tos - 1]);
          }
          list(3);
          if (DEBUG_CLOCKFORM) {
            console.log("clockform: power : " + stack[tos - 1]);
          }
          multiply();
          if (DEBUG_CLOCKFORM) {
            console.log("clockform: multiply : " + stack[tos - 1]);
          }
          return restore();
        };
        Eval_coeff = function() {
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          push(cadddr(p1));
          Eval();
          p3 = pop();
          p2 = pop();
          p1 = pop();
          if (p3 === symbol(NIL)) {
            p3 = p2;
            p2 = symbol(SYMBOL_X);
          }
          push(p1);
          push(p2);
          push(p3);
          power();
          divide();
          push(p2);
          return filter();
        };
        coeff = function(variable, polynomial) {
          var coeffsCount, constant2, polynomialWithoutConstant, prev_expanding;
          if (DEBUG) {
            console.log("coeff: " + variable + " " + polynomial);
          }
          coeffsCount = 0;
          while (true) {
            push(polynomial);
            push(variable);
            push(zero);
            subst();
            Eval();
            constant2 = pop();
            push(constant2);
            coeffsCount++;
            push(polynomial);
            push(constant2);
            subtract();
            polynomialWithoutConstant = pop();
            if (equal(polynomialWithoutConstant, zero)) {
              if (DEBUG) {
                console.log("coeff: result: " + coeffsCount);
              }
              return coeffsCount;
            }
            push(polynomialWithoutConstant);
            push(variable);
            prev_expanding = expanding;
            expanding = 1;
            divide();
            expanding = prev_expanding;
            polynomial = pop();
          }
        };
        Eval_cofactor = function() {
          var doNothing, i5, j2, n9;
          i5 = 0;
          j2 = 0;
          n9 = 0;
          push(cadr(p1));
          Eval();
          p2 = pop();
          if (istensor(p2) && p2.tensor.ndim === 2 && p2.tensor.dim[0] === p2.tensor.dim[1]) {
            doNothing = 1;
          } else {
            stop("cofactor: 1st arg: square matrix expected");
          }
          n9 = p2.tensor.dim[0];
          push(caddr(p1));
          Eval();
          i5 = pop_integer();
          if (i5 < 1 || i5 > n9) {
            stop("cofactor: 2nd arg: row index expected");
          }
          push(cadddr(p1));
          Eval();
          j2 = pop_integer();
          if (j2 < 1 || j2 > n9) {
            stop("cofactor: 3rd arg: column index expected");
          }
          return cofactor(p2, n9, i5 - 1, j2 - 1);
        };
        cofactor = function(p11, n9, row, col) {
          var i5, i12, j2, o12, ref2, ref12;
          i5 = 0;
          j2 = 0;
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            for (j2 = i12 = 0, ref12 = n9; 0 <= ref12 ? i12 < ref12 : i12 > ref12; j2 = 0 <= ref12 ? ++i12 : --i12) {
              if (i5 !== row && j2 !== col) {
                push(p11.tensor.elem[n9 * i5 + j2]);
              }
            }
          }
          determinant(n9 - 1);
          if ((row + col) % 2) {
            return negate();
          }
        };
        Eval_condense = function() {
          push(cadr(p1));
          Eval();
          return Condense();
        };
        Condense = function() {
          var prev_expanding;
          prev_expanding = expanding;
          expanding = 0;
          save();
          yycondense();
          restore();
          return expanding = prev_expanding;
        };
        yycondense = function() {
          p1 = pop();
          if (car(p1) !== symbol(ADD)) {
            push(p1);
            return;
          }
          p3 = cdr(p1);
          push(car(p3));
          p3 = cdr(p3);
          while (iscons(p3)) {
            push(car(p3));
            if (DEBUG) {
              console.log("calculating gcd between: " + stack[tos - 1] + " and " + stack[tos - 2]);
            }
            gcd();
            if (DEBUG) {
              console.log("partial gcd: " + stack[tos - 1]);
            }
            p3 = cdr(p3);
          }
          if (DEBUG) {
            console.log("condense: this is the gcd of all the terms: " + stack[tos - 1]);
          }
          inverse();
          p2 = pop();
          push(zero);
          p3 = cdr(p1);
          while (iscons(p3)) {
            push(p2);
            push(car(p3));
            multiply_noexpand();
            add();
            p3 = cdr(p3);
          }
          yyexpand();
          push(p2);
          return divide();
        };
        Eval_conj = function() {
          push(cadr(p1));
          Eval();
          p1 = pop();
          push(p1);
          if (!Find(p1, imaginaryunit)) {
            polar();
            conjugate();
            return clockform();
          } else {
            return conjugate();
          }
        };
        conjugate = function() {
          push(imaginaryunit);
          push(imaginaryunit);
          negate();
          subst();
          return Eval();
        };
        consCount = 0;
        cons = function() {
          var p11;
          consCount++;
          if (DEBUG) {
            console.log("cons tos: " + tos + " # " + consCount);
          }
          p11 = new U();
          p11.k = CONS;
          p11.cons.cdr = pop();
          if (p11 === p11.cons.cdr) {
            debugger;
            console.log("something wrong p == its cdr");
          }
          p11.cons.car = pop();
          return push(p11);
        };
        Eval_contract = function() {
          push(cadr(p1));
          Eval();
          if (cddr(p1) === symbol(NIL)) {
            push_integer(1);
            push_integer(2);
          } else {
            push(caddr(p1));
            Eval();
            push(cadddr(p1));
            Eval();
          }
          return contract();
        };
        contract = function() {
          save();
          yycontract();
          return restore();
        };
        yycontract = function() {
          var a5, ai, an, b2, h5, i5, i12, j2, j12, k3, l8, l1, m3, m1, n9, n1, ndim, nelem, o12, o1, ref2, ref12, ref22, ref3, ref4, ref5, ref6;
          h5 = 0;
          i5 = 0;
          j2 = 0;
          k3 = 0;
          l8 = 0;
          m3 = 0;
          n9 = 0;
          ndim = 0;
          nelem = 0;
          ai = [];
          an = [];
          p3 = pop();
          p2 = pop();
          p1 = pop();
          if (!istensor(p1)) {
            if (!isZeroAtomOrTensor(p1)) {
              stop("contract: tensor expected, 1st arg is not a tensor");
            }
            push(zero);
            return;
          }
          push(p2);
          l8 = pop_integer();
          push(p3);
          m3 = pop_integer();
          ndim = p1.tensor.ndim;
          if (l8 < 1 || l8 > ndim || m3 < 1 || m3 > ndim || l8 === m3 || p1.tensor.dim[l8 - 1] !== p1.tensor.dim[m3 - 1]) {
            stop("contract: index out of range");
          }
          l8--;
          m3--;
          n9 = p1.tensor.dim[l8];
          nelem = 1;
          for (i5 = o12 = 0, ref2 = ndim; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            if (i5 !== l8 && i5 !== m3) {
              nelem *= p1.tensor.dim[i5];
            }
          }
          p2 = alloc_tensor(nelem);
          p2.tensor.ndim = ndim - 2;
          j2 = 0;
          for (i5 = i12 = 0, ref12 = ndim; 0 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
            if (i5 !== l8 && i5 !== m3) {
              p2.tensor.dim[j2++] = p1.tensor.dim[i5];
            }
          }
          a5 = p1.tensor.elem;
          b2 = p2.tensor.elem;
          for (i5 = j12 = 0, ref22 = ndim; 0 <= ref22 ? j12 < ref22 : j12 > ref22; i5 = 0 <= ref22 ? ++j12 : --j12) {
            ai[i5] = 0;
            an[i5] = p1.tensor.dim[i5];
          }
          for (i5 = l1 = 0, ref3 = nelem; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i5 = 0 <= ref3 ? ++l1 : --l1) {
            push(zero);
            for (j2 = m1 = 0, ref4 = n9; 0 <= ref4 ? m1 < ref4 : m1 > ref4; j2 = 0 <= ref4 ? ++m1 : --m1) {
              ai[l8] = j2;
              ai[m3] = j2;
              h5 = 0;
              for (k3 = n1 = 0, ref5 = ndim; 0 <= ref5 ? n1 < ref5 : n1 > ref5; k3 = 0 <= ref5 ? ++n1 : --n1) {
                h5 = h5 * an[k3] + ai[k3];
              }
              push(a5[h5]);
              add();
            }
            b2[i5] = pop();
            for (j2 = o1 = ref6 = ndim - 1; ref6 <= 0 ? o1 <= 0 : o1 >= 0; j2 = ref6 <= 0 ? ++o1 : --o1) {
              if (j2 === l8 || j2 === m3) {
                continue;
              }
              if (++ai[j2] < an[j2]) {
                break;
              }
              ai[j2] = 0;
            }
          }
          if (nelem === 1) {
            return push(b2[0]);
          } else {
            return push(p2);
          }
        };
        Eval_cos = function() {
          push(cadr(p1));
          Eval();
          return cosine();
        };
        cosine = function() {
          save();
          p1 = pop();
          if (car(p1) === symbol(ADD)) {
            cosine_of_angle_sum();
          } else {
            cosine_of_angle();
          }
          return restore();
        };
        cosine_of_angle_sum = function() {
          p2 = cdr(p1);
          while (iscons(p2)) {
            p4 = car(p2);
            if (isnpi(p4)) {
              push(p1);
              push(p4);
              subtract();
              p3 = pop();
              push(p3);
              cosine();
              push(p4);
              cosine();
              multiply();
              push(p3);
              sine();
              push(p4);
              sine();
              multiply();
              subtract();
              return;
            }
            p2 = cdr(p2);
          }
          return cosine_of_angle();
        };
        cosine_of_angle = function() {
          var d3, n9;
          if (car(p1) === symbol(ARCCOS)) {
            push(cadr(p1));
            return;
          }
          if (isdouble(p1)) {
            d3 = Math.cos(p1.d);
            if (Math.abs(d3) < 1e-10) {
              d3 = 0;
            }
            push_double(d3);
            return;
          }
          if (isnegative(p1)) {
            push(p1);
            negate();
            p1 = pop();
          }
          if (car(p1) === symbol(ARCTAN)) {
            push_integer(1);
            push(cadr(p1));
            push_integer(2);
            power();
            add();
            push_rational(-1, 2);
            power();
            return;
          }
          push(p1);
          push_integer(180);
          multiply();
          if (evaluatingAsFloats) {
            push_double(Math.PI);
          } else {
            push_symbol(PI);
          }
          divide();
          n9 = pop_integer();
          if (n9 < 0 || isNaN(n9)) {
            push(symbol(COS));
            push(p1);
            list(2);
            return;
          }
          switch (n9 % 360) {
            case 90:
            case 270:
              return push_integer(0);
            case 60:
            case 300:
              return push_rational(1, 2);
            case 120:
            case 240:
              return push_rational(-1, 2);
            case 45:
            case 315:
              push_rational(1, 2);
              push_integer(2);
              push_rational(1, 2);
              power();
              return multiply();
            case 135:
            case 225:
              push_rational(-1, 2);
              push_integer(2);
              push_rational(1, 2);
              power();
              return multiply();
            case 30:
            case 330:
              push_rational(1, 2);
              push_integer(3);
              push_rational(1, 2);
              power();
              return multiply();
            case 150:
            case 210:
              push_rational(-1, 2);
              push_integer(3);
              push_rational(1, 2);
              power();
              return multiply();
            case 0:
              return push_integer(1);
            case 180:
              return push_integer(-1);
            default:
              push(symbol(COS));
              push(p1);
              return list(2);
          }
        };
        Eval_cosh = function() {
          push(cadr(p1));
          Eval();
          return ycosh();
        };
        ycosh = function() {
          save();
          yycosh();
          return restore();
        };
        yycosh = function() {
          var d3;
          d3 = 0;
          p1 = pop();
          if (car(p1) === symbol(ARCCOSH)) {
            push(cadr(p1));
            return;
          }
          if (isdouble(p1)) {
            d3 = Math.cosh(p1.d);
            if (Math.abs(d3) < 1e-10) {
              d3 = 0;
            }
            push_double(d3);
            return;
          }
          if (isZeroAtomOrTensor(p1)) {
            push(one);
            return;
          }
          push_symbol(COSH);
          push(p1);
          return list(2);
        };
        Eval_decomp = function() {
          var h5;
          save();
          console.log("Eval_decomp is being called!!!!!!!!!!!!!!!!!!!!");
          h5 = tos;
          push(symbol(NIL));
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          p1 = pop();
          if (p1 === symbol(NIL)) {
            guess();
          } else {
            push(p1);
          }
          decomp(false);
          list(tos - h5);
          return restore();
        };
        pushTryNotToDuplicate = function(toBePushed) {
          if (tos > 0) {
            if (DEBUG) {
              console.log("comparing " + toBePushed + " to: " + stack[tos - 1]);
            }
            if (equal(toBePushed, stack[tos - 1])) {
              if (DEBUG) {
                console.log("skipping " + toBePushed + " because it's already on stack ");
              }
              return;
            }
          }
          return push(toBePushed);
        };
        decomp = function(generalTransform) {
          save();
          p2 = pop();
          p1 = pop();
          if (DEBUG) {
            console.log("DECOMPOSING " + p1);
          }
          if (generalTransform) {
            if (!iscons(p1)) {
              if (DEBUG) {
                console.log(" ground thing: " + p1);
              }
              pushTryNotToDuplicate(p1);
              restore();
              return;
            }
          } else {
            if (Find(p1, p2) === 0) {
              if (DEBUG) {
                console.log(" entire expression is constant");
              }
              pushTryNotToDuplicate(p1);
              restore();
              return;
            }
          }
          if (isadd(p1)) {
            decomp_sum(generalTransform);
            restore();
            return;
          }
          if (ismultiply(p1)) {
            decomp_product(generalTransform);
            restore();
            return;
          }
          if (DEBUG) {
            console.log(" naive decomp");
          }
          p3 = cdr(p1);
          if (DEBUG) {
            console.log("startig p3: " + p3);
          }
          while (iscons(p3)) {
            if (generalTransform) {
              push(car(p3));
            }
            if (DEBUG) {
              console.log("recursive decomposition");
            }
            push(car(p3));
            if (DEBUG) {
              console.log("car(p3): " + car(p3));
            }
            push(p2);
            if (DEBUG) {
              console.log("p2: " + p2);
            }
            decomp(generalTransform);
            p3 = cdr(p3);
          }
          return restore();
        };
        decomp_sum = function(generalTransform) {
          var h5;
          if (DEBUG) {
            console.log(" decomposing the sum ");
          }
          h5 = 0;
          p3 = cdr(p1);
          while (iscons(p3)) {
            if (Find(car(p3), p2) || generalTransform) {
              push(car(p3));
              push(p2);
              decomp(generalTransform);
            }
            p3 = cdr(p3);
          }
          h5 = tos;
          p3 = cdr(p1);
          while (iscons(p3)) {
            if (Find(car(p3), p2) === 0) {
              pushTryNotToDuplicate(car(p3));
            }
            p3 = cdr(p3);
          }
          if (tos - h5) {
            add_all(tos - h5);
            p3 = pop();
            pushTryNotToDuplicate(p3);
            push(p3);
            return negate();
          }
        };
        decomp_product = function(generalTransform) {
          var h5;
          if (DEBUG) {
            console.log(" decomposing the product ");
          }
          h5 = 0;
          p3 = cdr(p1);
          while (iscons(p3)) {
            if (Find(car(p3), p2) || generalTransform) {
              push(car(p3));
              push(p2);
              decomp(generalTransform);
            }
            p3 = cdr(p3);
          }
          h5 = tos;
          p3 = cdr(p1);
          while (iscons(p3)) {
            if (Find(car(p3), p2) === 0) {
              pushTryNotToDuplicate(car(p3));
            }
            p3 = cdr(p3);
          }
          if (tos - h5) {
            return multiply_all(tos - h5);
          }
        };
        define_user_function = function() {
          p3 = caadr(p1);
          p4 = cdadr(p1);
          p5 = caddr(p1);
          if (!issymbol(p3)) {
            stop("function name?");
          }
          if (car(p5) === symbol(EVAL)) {
            push(cadr(p5));
            Eval();
            p5 = pop();
          }
          push_symbol(FUNCTION);
          push(p5);
          push(p4);
          list(3);
          p5 = pop();
          set_binding(p3, p5);
          return push_symbol(NIL);
        };
        Eval_function_reference = function() {
          return push(p1);
        };
        Eval_defint = function() {
          push(cadr(p1));
          Eval();
          p2 = pop();
          p1 = cddr(p1);
          while (iscons(p1)) {
            push(car(p1));
            p1 = cdr(p1);
            Eval();
            p3 = pop();
            push(car(p1));
            p1 = cdr(p1);
            Eval();
            p4 = pop();
            push(car(p1));
            p1 = cdr(p1);
            Eval();
            p5 = pop();
            push(p2);
            push(p3);
            integral();
            p2 = pop();
            push(p2);
            push(p3);
            push(p5);
            subst();
            Eval();
            push(p2);
            push(p3);
            push(p4);
            subst();
            Eval();
            subtract();
            p2 = pop();
          }
          return push(p2);
        };
        Eval_degree = function() {
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          p1 = pop();
          if (p1 === symbol(NIL)) {
            guess();
          } else {
            push(p1);
          }
          return degree();
        };
        degree = function() {
          save();
          p2 = pop();
          p1 = pop();
          p3 = zero;
          yydegree(p1);
          push(p3);
          return restore();
        };
        yydegree = function(p11) {
          var results;
          if (equal(p11, p2)) {
            if (isZeroAtomOrTensor(p3)) {
              return p3 = one;
            }
          } else if (car(p11) === symbol(POWER)) {
            if (equal(cadr(p11), p2) && isNumericAtom(caddr(p11)) && lessp(p3, caddr(p11))) {
              return p3 = caddr(p11);
            }
          } else if (iscons(p11)) {
            p11 = cdr(p11);
            results = [];
            while (iscons(p11)) {
              yydegree(car(p11));
              results.push(p11 = cdr(p11));
            }
            return results;
          }
        };
        Eval_denominator = function() {
          push(cadr(p1));
          Eval();
          return denominator();
        };
        denominator = function() {
          var h5, theArgument2;
          h5 = 0;
          theArgument2 = pop();
          if (car(theArgument2) === symbol(ADD)) {
            push(theArgument2);
            rationalize();
            theArgument2 = pop();
          }
          if (car(theArgument2) === symbol(MULTIPLY) && !isplusone(car(cdr(theArgument2)))) {
            h5 = tos;
            theArgument2 = cdr(theArgument2);
            while (iscons(theArgument2)) {
              push(car(theArgument2));
              denominator();
              theArgument2 = cdr(theArgument2);
            }
            return multiply_all(tos - h5);
          } else if (isrational(theArgument2)) {
            push(theArgument2);
            return mp_denominator();
          } else if (car(theArgument2) === symbol(POWER) && isnegativeterm(caddr(theArgument2))) {
            push(theArgument2);
            return reciprocate();
          } else {
            return push(one);
          }
        };
        Eval_derivative = function() {
          var doNothing, i5, i12, n9, o12, ref2, ref12;
          i5 = 0;
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p2 = pop();
          if (p2 === symbol(NIL)) {
            guess();
            push(symbol(NIL));
          } else if (isNumericAtom(p2)) {
            guess();
            push(p2);
          } else {
            push(p2);
            p1 = cdr(p1);
            push(car(p1));
            Eval();
          }
          p5 = pop();
          p4 = pop();
          p3 = pop();
          while (1) {
            if (isNumericAtom(p5)) {
              push(p5);
              n9 = pop_integer();
              if (isNaN(n9)) {
                stop("nth derivative: check n");
              }
            } else {
              n9 = 1;
            }
            push(p3);
            if (n9 >= 0) {
              for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
                push(p4);
                derivative();
              }
            } else {
              n9 = -n9;
              for (i5 = i12 = 0, ref12 = n9; 0 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
                push(p4);
                integral();
              }
            }
            p3 = pop();
            if (p5 === symbol(NIL)) {
              break;
            }
            if (isNumericAtom(p5)) {
              p1 = cdr(p1);
              push(car(p1));
              Eval();
              p5 = pop();
              if (p5 === symbol(NIL)) {
                break;
              }
              if (isNumericAtom(p5)) {
                doNothing = 1;
              } else {
                p4 = p5;
                p1 = cdr(p1);
                push(car(p1));
                Eval();
                p5 = pop();
              }
            } else {
              p4 = p5;
              p1 = cdr(p1);
              push(car(p1));
              Eval();
              p5 = pop();
            }
          }
          return push(p3);
        };
        derivative = function() {
          save();
          p2 = pop();
          p1 = pop();
          if (isNumericAtom(p2)) {
            stop("undefined function");
          }
          if (istensor(p1)) {
            if (istensor(p2)) {
              d_tensor_tensor();
            } else {
              d_tensor_scalar();
            }
          } else {
            if (istensor(p2)) {
              d_scalar_tensor();
            } else {
              d_scalar_scalar();
            }
          }
          return restore();
        };
        d_scalar_scalar = function() {
          if (issymbol(p2)) {
            return d_scalar_scalar_1();
          } else {
            push(p1);
            push(p2);
            push(symbol(SECRETX));
            subst();
            push(symbol(SECRETX));
            derivative();
            push(symbol(SECRETX));
            push(p2);
            return subst();
          }
        };
        d_scalar_scalar_1 = function() {
          if (equal(p1, p2)) {
            push(one);
            return;
          }
          if (!iscons(p1)) {
            push(zero);
            return;
          }
          if (isadd(p1)) {
            dsum();
            return;
          }
          if (car(p1) === symbol(MULTIPLY)) {
            dproduct();
            return;
          }
          if (car(p1) === symbol(POWER)) {
            dpower();
            return;
          }
          if (car(p1) === symbol(DERIVATIVE)) {
            dd();
            return;
          }
          if (car(p1) === symbol(LOG)) {
            dlog();
            return;
          }
          if (car(p1) === symbol(SIN)) {
            dsin();
            return;
          }
          if (car(p1) === symbol(COS)) {
            dcos();
            return;
          }
          if (car(p1) === symbol(TAN)) {
            dtan();
            return;
          }
          if (car(p1) === symbol(ARCSIN)) {
            darcsin();
            return;
          }
          if (car(p1) === symbol(ARCCOS)) {
            darccos();
            return;
          }
          if (car(p1) === symbol(ARCTAN)) {
            darctan();
            return;
          }
          if (car(p1) === symbol(SINH)) {
            dsinh();
            return;
          }
          if (car(p1) === symbol(COSH)) {
            dcosh();
            return;
          }
          if (car(p1) === symbol(TANH)) {
            dtanh();
            return;
          }
          if (car(p1) === symbol(ARCSINH)) {
            darcsinh();
            return;
          }
          if (car(p1) === symbol(ARCCOSH)) {
            darccosh();
            return;
          }
          if (car(p1) === symbol(ARCTANH)) {
            darctanh();
            return;
          }
          if (car(p1) === symbol(ABS)) {
            dabs();
            return;
          }
          if (car(p1) === symbol(SGN)) {
            dsgn();
            return;
          }
          if (car(p1) === symbol(HERMITE)) {
            dhermite();
            return;
          }
          if (car(p1) === symbol(ERF)) {
            derf();
            return;
          }
          if (car(p1) === symbol(ERFC)) {
            derfc();
            return;
          }
          if (car(p1) === symbol(BESSELJ)) {
            if (isZeroAtomOrTensor(caddr(p1))) {
              dbesselj0();
            } else {
              dbesseljn();
            }
            return;
          }
          if (car(p1) === symbol(BESSELY)) {
            if (isZeroAtomOrTensor(caddr(p1))) {
              dbessely0();
            } else {
              dbesselyn();
            }
            return;
          }
          if (car(p1) === symbol(INTEGRAL) && caddr(p1) === p2) {
            derivative_of_integral();
            return;
          }
          return dfunction();
        };
        dsum = function() {
          var h5;
          h5 = tos;
          p1 = cdr(p1);
          while (iscons(p1)) {
            push(car(p1));
            push(p2);
            derivative();
            p1 = cdr(p1);
          }
          return add_all(tos - h5);
        };
        dproduct = function() {
          var i5, i12, j2, n9, o12, ref2, ref12;
          i5 = 0;
          j2 = 0;
          n9 = 0;
          n9 = length(p1) - 1;
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            p3 = cdr(p1);
            for (j2 = i12 = 0, ref12 = n9; 0 <= ref12 ? i12 < ref12 : i12 > ref12; j2 = 0 <= ref12 ? ++i12 : --i12) {
              push(car(p3));
              if (i5 === j2) {
                push(p2);
                derivative();
              }
              p3 = cdr(p3);
            }
            multiply_all(n9);
          }
          return add_all(n9);
        };
        dpower = function() {
          push(caddr(p1));
          push(cadr(p1));
          divide();
          push(cadr(p1));
          push(p2);
          derivative();
          multiply();
          push(cadr(p1));
          logarithm();
          push(caddr(p1));
          push(p2);
          derivative();
          multiply();
          add();
          push(p1);
          return multiply();
        };
        dlog = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push(cadr(p1));
          return divide();
        };
        dd = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          p3 = pop();
          if (car(p3) === symbol(DERIVATIVE)) {
            push_symbol(DERIVATIVE);
            push_symbol(DERIVATIVE);
            push(cadr(p3));
            if (lessp(caddr(p3), caddr(p1))) {
              push(caddr(p3));
              list(3);
              push(caddr(p1));
            } else {
              push(caddr(p1));
              list(3);
              push(caddr(p3));
            }
            return list(3);
          } else {
            push(p3);
            push(caddr(p1));
            return derivative();
          }
        };
        dfunction = function() {
          p3 = cdr(p1);
          if (p3 === symbol(NIL) || Find(p3, p2)) {
            push_symbol(DERIVATIVE);
            push(p1);
            push(p2);
            return list(3);
          } else {
            return push(zero);
          }
        };
        dsin = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push(cadr(p1));
          cosine();
          return multiply();
        };
        dcos = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push(cadr(p1));
          sine();
          multiply();
          return negate();
        };
        dtan = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push(cadr(p1));
          cosine();
          push_integer(-2);
          power();
          return multiply();
        };
        darcsin = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push_integer(1);
          push(cadr(p1));
          push_integer(2);
          power();
          subtract();
          push_rational(-1, 2);
          power();
          return multiply();
        };
        darccos = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push_integer(1);
          push(cadr(p1));
          push_integer(2);
          power();
          subtract();
          push_rational(-1, 2);
          power();
          multiply();
          return negate();
        };
        darctan = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push_integer(1);
          push(cadr(p1));
          push_integer(2);
          power();
          add();
          inverse();
          multiply();
          return simplify();
        };
        dsinh = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push(cadr(p1));
          ycosh();
          return multiply();
        };
        dcosh = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push(cadr(p1));
          ysinh();
          return multiply();
        };
        dtanh = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push(cadr(p1));
          ycosh();
          push_integer(-2);
          power();
          return multiply();
        };
        darcsinh = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push(cadr(p1));
          push_integer(2);
          power();
          push_integer(1);
          add();
          push_rational(-1, 2);
          power();
          return multiply();
        };
        darccosh = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push(cadr(p1));
          push_integer(2);
          power();
          push_integer(-1);
          add();
          push_rational(-1, 2);
          power();
          return multiply();
        };
        darctanh = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push_integer(1);
          push(cadr(p1));
          push_integer(2);
          power();
          subtract();
          inverse();
          return multiply();
        };
        dabs = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push(cadr(p1));
          sgn();
          return multiply();
        };
        dsgn = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push(cadr(p1));
          dirac();
          multiply();
          push_integer(2);
          return multiply();
        };
        dhermite = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push_integer(2);
          push(caddr(p1));
          multiply();
          multiply();
          push(cadr(p1));
          push(caddr(p1));
          push_integer(-1);
          add();
          hermite();
          return multiply();
        };
        derf = function() {
          push(cadr(p1));
          push_integer(2);
          power();
          push_integer(-1);
          multiply();
          exponential();
          if (evaluatingAsFloats) {
            push_double(Math.PI);
          } else {
            push_symbol(PI);
          }
          push_rational(-1, 2);
          power();
          multiply();
          push_integer(2);
          multiply();
          push(cadr(p1));
          push(p2);
          derivative();
          return multiply();
        };
        derfc = function() {
          push(cadr(p1));
          push_integer(2);
          power();
          push_integer(-1);
          multiply();
          exponential();
          if (evaluatingAsFloats) {
            push_double(Math.PI);
          } else {
            push_symbol(PI);
          }
          push_rational(-1, 2);
          power();
          multiply();
          push_integer(-2);
          multiply();
          push(cadr(p1));
          push(p2);
          derivative();
          return multiply();
        };
        dbesselj0 = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push(cadr(p1));
          push_integer(1);
          besselj();
          multiply();
          push_integer(-1);
          return multiply();
        };
        dbesseljn = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push(cadr(p1));
          push(caddr(p1));
          push_integer(-1);
          add();
          besselj();
          push(caddr(p1));
          push_integer(-1);
          multiply();
          push(cadr(p1));
          divide();
          push(cadr(p1));
          push(caddr(p1));
          besselj();
          multiply();
          add();
          return multiply();
        };
        dbessely0 = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push(cadr(p1));
          push_integer(1);
          besselj();
          multiply();
          push_integer(-1);
          return multiply();
        };
        dbesselyn = function() {
          push(cadr(p1));
          push(p2);
          derivative();
          push(cadr(p1));
          push(caddr(p1));
          push_integer(-1);
          add();
          bessely();
          push(caddr(p1));
          push_integer(-1);
          multiply();
          push(cadr(p1));
          divide();
          push(cadr(p1));
          push(caddr(p1));
          bessely();
          multiply();
          add();
          return multiply();
        };
        derivative_of_integral = function() {
          return push(cadr(p1));
        };
        DET_check_arg = function() {
          if (!istensor(p1)) {
            return 0;
          } else if (p1.tensor.ndim !== 2) {
            return 0;
          } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {
            return 0;
          } else {
            return 1;
          }
        };
        det = function() {
          var a5, i5, i12, n9, o12, ref2, ref12;
          i5 = 0;
          n9 = 0;
          save();
          p1 = pop();
          if (DET_check_arg() === 0) {
            push_symbol(DET);
            push(p1);
            list(2);
            restore();
            return;
          }
          n9 = p1.tensor.nelem;
          a5 = p1.tensor.elem;
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            if (!isNumericAtom(a5[i5])) {
              break;
            }
          }
          if (i5 === n9) {
            yydetg();
          } else {
            for (i5 = i12 = 0, ref12 = p1.tensor.nelem; 0 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
              push(p1.tensor.elem[i5]);
            }
            determinant(p1.tensor.dim[0]);
          }
          return restore();
        };
        determinant = function(n9) {
          var a5, breakFromOutherWhile, h5, i5, i12, j2, k3, o12, q, ref2, ref12, s8, sign_, t5;
          h5 = 0;
          i5 = 0;
          j2 = 0;
          k3 = 0;
          q = 0;
          s8 = 0;
          sign_ = 0;
          t5 = 0;
          a5 = [];
          h5 = tos - n9 * n9;
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            a5[i5] = i5;
            a5[i5 + n9] = 0;
            a5[i5 + n9 + n9] = 1;
          }
          sign_ = 1;
          push(zero);
          while (1) {
            if (sign_ === 1) {
              push_integer(1);
            } else {
              push_integer(-1);
            }
            for (i5 = i12 = 0, ref12 = n9; 0 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
              k3 = n9 * a5[i5] + i5;
              push(stack[h5 + k3]);
              multiply();
            }
            add();
            j2 = n9 - 1;
            s8 = 0;
            breakFromOutherWhile = false;
            while (1) {
              q = a5[n9 + j2] + a5[n9 + n9 + j2];
              if (q < 0) {
                a5[n9 + n9 + j2] = -a5[n9 + n9 + j2];
                j2--;
                continue;
              }
              if (q === j2 + 1) {
                if (j2 === 0) {
                  breakFromOutherWhile = true;
                  break;
                }
                s8++;
                a5[n9 + n9 + j2] = -a5[n9 + n9 + j2];
                j2--;
                continue;
              }
              break;
            }
            if (breakFromOutherWhile) {
              break;
            }
            t5 = a5[j2 - a5[n9 + j2] + s8];
            a5[j2 - a5[n9 + j2] + s8] = a5[j2 - q + s8];
            a5[j2 - q + s8] = t5;
            a5[n9 + j2] = q;
            sign_ = -sign_;
          }
          stack[h5] = stack[tos - 1];
          return moveTos(h5 + 1);
        };
        detg = function() {
          save();
          p1 = pop();
          if (DET_check_arg() === 0) {
            push_symbol(DET);
            push(p1);
            list(2);
            restore();
            return;
          }
          yydetg();
          return restore();
        };
        yydetg = function() {
          var i5, n9, o12, ref2;
          i5 = 0;
          n9 = 0;
          n9 = p1.tensor.dim[0];
          for (i5 = o12 = 0, ref2 = n9 * n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            push(p1.tensor.elem[i5]);
          }
          lu_decomp(n9);
          moveTos(tos - n9 * n9);
          return push(p1);
        };
        M = function(h5, n9, i5, j2) {
          return stack[h5 + n9 * i5 + j2];
        };
        setM = function(h5, n9, i5, j2, value) {
          return stack[h5 + n9 * i5 + j2] = value;
        };
        lu_decomp = function(n9) {
          var d3, h5, i5, i12, j2, j12, l1, m1, o12, ref2, ref12, ref22, ref3, ref4, ref5, ref6, ref7, ref8;
          d3 = 0;
          h5 = 0;
          i5 = 0;
          j2 = 0;
          h5 = tos - n9 * n9;
          p1 = one;
          for (d3 = o12 = 0, ref2 = n9 - 1; 0 <= ref2 ? o12 < ref2 : o12 > ref2; d3 = 0 <= ref2 ? ++o12 : --o12) {
            if (equal(M(h5, n9, d3, d3), zero)) {
              for (i5 = i12 = ref12 = d3 + 1, ref22 = n9; ref12 <= ref22 ? i12 < ref22 : i12 > ref22; i5 = ref12 <= ref22 ? ++i12 : --i12) {
                if (!equal(M(h5, n9, i5, d3), zero)) {
                  break;
                }
              }
              if (i5 === n9) {
                p1 = zero;
                break;
              }
              for (j2 = j12 = ref3 = d3, ref4 = n9; ref3 <= ref4 ? j12 < ref4 : j12 > ref4; j2 = ref3 <= ref4 ? ++j12 : --j12) {
                p2 = M(h5, n9, d3, j2);
                setM(h5, n9, d3, j2, M(h5, n9, i5, j2));
                setM(h5, n9, i5, j2, p2);
              }
              push(p1);
              negate();
              p1 = pop();
            }
            push(p1);
            push(M(h5, n9, d3, d3));
            multiply();
            p1 = pop();
            for (i5 = l1 = ref5 = d3 + 1, ref6 = n9; ref5 <= ref6 ? l1 < ref6 : l1 > ref6; i5 = ref5 <= ref6 ? ++l1 : --l1) {
              push(M(h5, n9, i5, d3));
              push(M(h5, n9, d3, d3));
              divide();
              negate();
              p2 = pop();
              setM(h5, n9, i5, d3, zero);
              for (j2 = m1 = ref7 = d3 + 1, ref8 = n9; ref7 <= ref8 ? m1 < ref8 : m1 > ref8; j2 = ref7 <= ref8 ? ++m1 : --m1) {
                push(M(h5, n9, d3, j2));
                push(p2);
                multiply();
                push(M(h5, n9, i5, j2));
                add();
                setM(h5, n9, i5, j2, pop());
              }
            }
          }
          push(p1);
          push(M(h5, n9, n9 - 1, n9 - 1));
          multiply();
          return p1 = pop();
        };
        Eval_dirac = function() {
          push(cadr(p1));
          Eval();
          return dirac();
        };
        dirac = function() {
          save();
          ydirac();
          return restore();
        };
        ydirac = function() {
          p1 = pop();
          if (isdouble(p1)) {
            if (p1.d === 0) {
              push_integer(1);
              return;
            } else {
              push_integer(0);
              return;
            }
          }
          if (isrational(p1)) {
            if (MZERO(mmul(p1.q.a, p1.q.b))) {
              push_integer(1);
              return;
            } else {
              push_integer(0);
              return;
            }
          }
          if (car(p1) === symbol(POWER)) {
            push_symbol(DIRAC);
            push(cadr(p1));
            list(2);
            return;
          }
          if (isnegativeterm(p1)) {
            push_symbol(DIRAC);
            push(p1);
            negate();
            list(2);
            return;
          }
          if (isnegativeterm(p1) || car(p1) === symbol(ADD) && isnegativeterm(cadr(p1))) {
            push(p1);
            negate();
            p1 = pop();
          }
          push_symbol(DIRAC);
          push(p1);
          return list(2);
        };
        divisors = function() {
          var h5, i5, n9, o12, ref2, subsetOfStack;
          i5 = 0;
          h5 = 0;
          n9 = 0;
          save();
          h5 = tos - 1;
          divisors_onstack();
          n9 = tos - h5;
          subsetOfStack = stack.slice(h5, h5 + n9);
          subsetOfStack.sort(cmp_expr);
          stack = stack.slice(0, h5).concat(subsetOfStack).concat(stack.slice(h5 + n9));
          p1 = alloc_tensor(n9);
          p1.tensor.ndim = 1;
          p1.tensor.dim[0] = n9;
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            p1.tensor.elem[i5] = stack[h5 + i5];
          }
          moveTos(h5);
          push(p1);
          return restore();
        };
        divisors_onstack = function() {
          var h5, i5, k3, n9, o12, ref2;
          h5 = 0;
          i5 = 0;
          k3 = 0;
          n9 = 0;
          save();
          p1 = pop();
          h5 = tos;
          if (isNumericAtom(p1)) {
            push(p1);
            factor_small_number();
          } else if (car(p1) === symbol(ADD)) {
            push(p1);
            __factor_add();
          } else if (car(p1) === symbol(MULTIPLY)) {
            p1 = cdr(p1);
            if (isNumericAtom(car(p1))) {
              push(car(p1));
              factor_small_number();
              p1 = cdr(p1);
            }
            while (iscons(p1)) {
              p2 = car(p1);
              if (car(p2) === symbol(POWER)) {
                push(cadr(p2));
                push(caddr(p2));
              } else {
                push(p2);
                push(one);
              }
              p1 = cdr(p1);
            }
          } else if (car(p1) === symbol(POWER)) {
            push(cadr(p1));
            push(caddr(p1));
          } else {
            push(p1);
            push(one);
          }
          k3 = tos;
          push(one);
          gen(h5, k3);
          n9 = tos - k3;
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            stack[h5 + i5] = stack[k3 + i5];
          }
          moveTos(h5 + n9);
          return restore();
        };
        gen = function(h5, k3) {
          var expo, i5, o12, ref2;
          expo = 0;
          i5 = 0;
          save();
          p1 = pop();
          if (h5 === k3) {
            push(p1);
            restore();
            return;
          }
          p2 = stack[h5 + 0];
          p3 = stack[h5 + 1];
          push(p3);
          expo = pop_integer();
          if (!isNaN(expo)) {
            for (i5 = o12 = 0, ref2 = Math.abs(expo); 0 <= ref2 ? o12 <= ref2 : o12 >= ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
              push(p1);
              push(p2);
              push_integer(sign(expo) * i5);
              power();
              multiply();
              gen(h5 + 2, k3);
            }
          }
          return restore();
        };
        __factor_add = function() {
          save();
          p1 = pop();
          p3 = cdr(p1);
          push(car(p3));
          p3 = cdr(p3);
          while (iscons(p3)) {
            push(car(p3));
            gcd();
            p3 = cdr(p3);
          }
          p2 = pop();
          if (isplusone(p2)) {
            push(p1);
            push(one);
            restore();
            return;
          }
          if (isNumericAtom(p2)) {
            push(p2);
            factor_small_number();
          } else if (car(p2) === symbol(MULTIPLY)) {
            p3 = cdr(p2);
            if (isNumericAtom(car(p3))) {
              push(car(p3));
              factor_small_number();
            } else {
              push(car(p3));
              push(one);
            }
            p3 = cdr(p3);
            while (iscons(p3)) {
              push(car(p3));
              push(one);
              p3 = cdr(p3);
            }
          } else {
            push(p2);
            push(one);
          }
          push(p2);
          inverse();
          p2 = pop();
          push(zero);
          p3 = cdr(p1);
          while (iscons(p3)) {
            push(p2);
            push(car(p3));
            multiply();
            add();
            p3 = cdr(p3);
          }
          push(one);
          return restore();
        };
        dpow = function() {
          var a5, b2, base, expo, result, theta;
          a5 = 0;
          b2 = 0;
          base = 0;
          expo = 0;
          result = 0;
          theta = 0;
          expo = pop_double();
          base = pop_double();
          if (base === 0 && expo < 0) {
            stop("divide by zero");
          }
          if (base >= 0 || expo % 1 === 0) {
            result = Math.pow(base, expo);
            push_double(result);
            return;
          }
          result = Math.pow(Math.abs(base), expo);
          theta = Math.PI * expo;
          if (expo % 0.5 === 0) {
            a5 = 0;
            b2 = Math.sin(theta);
          } else {
            a5 = Math.cos(theta);
            b2 = Math.sin(theta);
          }
          push_double(a5 * result);
          push_double(b2 * result);
          push(imaginaryunit);
          multiply();
          return add();
        };
        EIG_N = 0;
        EIG_yydd = [];
        EIG_yyqq = [];
        Eval_eigen = function() {
          if (EIG_check_arg() === 0) {
            stop("eigen: argument is not a square matrix");
          }
          eigen(EIGEN);
          p1 = usr_symbol("D");
          set_binding(p1, p2);
          p1 = usr_symbol("Q");
          set_binding(p1, p3);
          return push(symbol(NIL));
        };
        Eval_eigenval = function() {
          if (EIG_check_arg() === 0) {
            push_symbol(EIGENVAL);
            push(p1);
            list(2);
            return;
          }
          eigen(EIGENVAL);
          return push(p2);
        };
        Eval_eigenvec = function() {
          if (EIG_check_arg() === 0) {
            push_symbol(EIGENVEC);
            push(p1);
            list(2);
            return;
          }
          eigen(EIGENVEC);
          return push(p3);
        };
        EIG_check_arg = function() {
          var i5, i12, j2, j12, l1, o12, ref2, ref12, ref22, ref3, ref4;
          i5 = 0;
          j2 = 0;
          push(cadr(p1));
          Eval();
          yyfloat();
          Eval();
          p1 = pop();
          if (!istensor(p1)) {
            return 0;
          }
          if (p1.tensor.ndim !== 2 || p1.tensor.dim[0] !== p1.tensor.dim[1]) {
            stop("eigen: argument is not a square matrix");
          }
          EIG_N = p1.tensor.dim[0];
          for (i5 = o12 = 0, ref2 = EIG_N; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            for (j2 = i12 = 0, ref12 = EIG_N; 0 <= ref12 ? i12 < ref12 : i12 > ref12; j2 = 0 <= ref12 ? ++i12 : --i12) {
              if (!isdouble(p1.tensor.elem[EIG_N * i5 + j2])) {
                stop("eigen: matrix is not numerical");
              }
            }
          }
          for (i5 = j12 = 0, ref22 = EIG_N - 1; 0 <= ref22 ? j12 < ref22 : j12 > ref22; i5 = 0 <= ref22 ? ++j12 : --j12) {
            for (j2 = l1 = ref3 = i5 + 1, ref4 = EIG_N; ref3 <= ref4 ? l1 < ref4 : l1 > ref4; j2 = ref3 <= ref4 ? ++l1 : --l1) {
              if (Math.abs(p1.tensor.elem[EIG_N * i5 + j2].d - p1.tensor.elem[EIG_N * j2 + i5].d) > 1e-10) {
                stop("eigen: matrix is not symmetrical");
              }
            }
          }
          return 1;
        };
        eigen = function(op) {
          var i5, i12, j2, j12, l1, m1, n1, o12, o1, q1, r1, ref2, ref12, ref10, ref22, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, s1;
          i5 = 0;
          j2 = 0;
          for (i5 = o12 = 0, ref2 = EIG_N * EIG_N; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            EIG_yydd[i5] = 0;
          }
          for (i5 = i12 = 0, ref12 = EIG_N * EIG_N; 0 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
            EIG_yyqq[i5] = 0;
          }
          for (i5 = j12 = 0, ref22 = EIG_N; 0 <= ref22 ? j12 < ref22 : j12 > ref22; i5 = 0 <= ref22 ? ++j12 : --j12) {
            EIG_yydd[EIG_N * i5 + i5] = p1.tensor.elem[EIG_N * i5 + i5].d;
            for (j2 = l1 = ref3 = i5 + 1, ref4 = EIG_N; ref3 <= ref4 ? l1 < ref4 : l1 > ref4; j2 = ref3 <= ref4 ? ++l1 : --l1) {
              EIG_yydd[EIG_N * i5 + j2] = p1.tensor.elem[EIG_N * i5 + j2].d;
              EIG_yydd[EIG_N * j2 + i5] = p1.tensor.elem[EIG_N * i5 + j2].d;
            }
          }
          for (i5 = m1 = 0, ref5 = EIG_N; 0 <= ref5 ? m1 < ref5 : m1 > ref5; i5 = 0 <= ref5 ? ++m1 : --m1) {
            EIG_yyqq[EIG_N * i5 + i5] = 1;
            for (j2 = n1 = ref6 = i5 + 1, ref7 = EIG_N; ref6 <= ref7 ? n1 < ref7 : n1 > ref7; j2 = ref6 <= ref7 ? ++n1 : --n1) {
              EIG_yyqq[EIG_N * i5 + j2] = 0;
              EIG_yyqq[EIG_N * j2 + i5] = 0;
            }
          }
          for (i5 = o1 = 0; o1 < 100; i5 = ++o1) {
            if (step() === 0) {
              break;
            }
          }
          if (i5 === 100) {
            printstr("\nnote: eigen did not converge\n");
          }
          if (op === EIGEN || op === EIGENVAL) {
            push(p1);
            copy_tensor();
            p2 = pop();
            for (i5 = q1 = 0, ref8 = EIG_N; 0 <= ref8 ? q1 < ref8 : q1 > ref8; i5 = 0 <= ref8 ? ++q1 : --q1) {
              for (j2 = r1 = 0, ref9 = EIG_N; 0 <= ref9 ? r1 < ref9 : r1 > ref9; j2 = 0 <= ref9 ? ++r1 : --r1) {
                push_double(EIG_yydd[EIG_N * i5 + j2]);
                p2.tensor.elem[EIG_N * i5 + j2] = pop();
              }
            }
          }
          if (op === EIGEN || op === EIGENVEC) {
            push(p1);
            copy_tensor();
            p3 = pop();
            results = [];
            for (i5 = s1 = 0, ref10 = EIG_N; 0 <= ref10 ? s1 < ref10 : s1 > ref10; i5 = 0 <= ref10 ? ++s1 : --s1) {
              results.push(function() {
                var ref11, results1, t13;
                results1 = [];
                for (j2 = t13 = 0, ref11 = EIG_N; 0 <= ref11 ? t13 < ref11 : t13 > ref11; j2 = 0 <= ref11 ? ++t13 : --t13) {
                  push_double(EIG_yyqq[EIG_N * i5 + j2]);
                  results1.push(p3.tensor.elem[EIG_N * i5 + j2] = pop());
                }
                return results1;
              }());
            }
            return results;
          }
        };
        step = function() {
          var count4, i5, i12, j2, o12, ref2, ref12, ref22;
          i5 = 0;
          j2 = 0;
          count4 = 0;
          for (i5 = o12 = 0, ref2 = EIG_N - 1; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            for (j2 = i12 = ref12 = i5 + 1, ref22 = EIG_N; ref12 <= ref22 ? i12 < ref22 : i12 > ref22; j2 = ref12 <= ref22 ? ++i12 : --i12) {
              if (EIG_yydd[EIG_N * i5 + j2] !== 0) {
                step2(i5, j2);
                count4++;
              }
            }
          }
          return count4;
        };
        step2 = function(p11, q) {
          var c9, cc2, i12, j12, k3, o12, ref2, ref12, ref22, s8, ss, t5, theta;
          k3 = 0;
          t5 = 0;
          theta = 0;
          c9 = 0;
          cc2 = 0;
          s8 = 0;
          ss = 0;
          theta = 0.5 * (EIG_yydd[EIG_N * p11 + p11] - EIG_yydd[EIG_N * q + q]) / EIG_yydd[EIG_N * p11 + q];
          t5 = 1 / (Math.abs(theta) + Math.sqrt(theta * theta + 1));
          if (theta < 0) {
            t5 = -t5;
          }
          c9 = 1 / Math.sqrt(t5 * t5 + 1);
          s8 = t5 * c9;
          for (k3 = o12 = 0, ref2 = EIG_N; 0 <= ref2 ? o12 < ref2 : o12 > ref2; k3 = 0 <= ref2 ? ++o12 : --o12) {
            cc2 = EIG_yydd[EIG_N * p11 + k3];
            ss = EIG_yydd[EIG_N * q + k3];
            EIG_yydd[EIG_N * p11 + k3] = c9 * cc2 + s8 * ss;
            EIG_yydd[EIG_N * q + k3] = c9 * ss - s8 * cc2;
          }
          for (k3 = i12 = 0, ref12 = EIG_N; 0 <= ref12 ? i12 < ref12 : i12 > ref12; k3 = 0 <= ref12 ? ++i12 : --i12) {
            cc2 = EIG_yydd[EIG_N * k3 + p11];
            ss = EIG_yydd[EIG_N * k3 + q];
            EIG_yydd[EIG_N * k3 + p11] = c9 * cc2 + s8 * ss;
            EIG_yydd[EIG_N * k3 + q] = c9 * ss - s8 * cc2;
          }
          for (k3 = j12 = 0, ref22 = EIG_N; 0 <= ref22 ? j12 < ref22 : j12 > ref22; k3 = 0 <= ref22 ? ++j12 : --j12) {
            cc2 = EIG_yyqq[EIG_N * p11 + k3];
            ss = EIG_yyqq[EIG_N * q + k3];
            EIG_yyqq[EIG_N * p11 + k3] = c9 * cc2 + s8 * ss;
            EIG_yyqq[EIG_N * q + k3] = c9 * ss - s8 * cc2;
          }
          EIG_yydd[EIG_N * p11 + q] = 0;
          return EIG_yydd[EIG_N * q + p11] = 0;
        };
        Eval_erf = function() {
          push(cadr(p1));
          Eval();
          return yerf();
        };
        yerf = function() {
          save();
          yyerf();
          return restore();
        };
        yyerf = function() {
          var d3;
          d3 = 0;
          p1 = pop();
          if (isdouble(p1)) {
            d3 = 1 - erfc(p1.d);
            push_double(d3);
            return;
          }
          if (isZeroAtomOrTensor(p1)) {
            push(zero);
            return;
          }
          if (isnegativeterm(p1)) {
            push_symbol(ERF);
            push(p1);
            negate();
            list(2);
            negate();
            return;
          }
          push_symbol(ERF);
          push(p1);
          list(2);
        };
        Eval_erfc = function() {
          push(cadr(p1));
          Eval();
          return yerfc();
        };
        yerfc = function() {
          save();
          yyerfc();
          return restore();
        };
        yyerfc = function() {
          var d3;
          d3 = 0;
          p1 = pop();
          if (isdouble(p1)) {
            d3 = erfc(p1.d);
            push_double(d3);
            return;
          }
          if (isZeroAtomOrTensor(p1)) {
            push(one);
            return;
          }
          push_symbol(ERFC);
          push(p1);
          list(2);
        };
        erfc = function(x3) {
          var ans, t5, z2;
          if (x3 === 0) {
            return 1;
          }
          t5 = 0;
          z2 = 0;
          ans = 0;
          z2 = Math.abs(x3);
          t5 = 1 / (1 + 0.5 * z2);
          ans = t5 * Math.exp(-z2 * z2 - 1.26551223 + t5 * (1.00002368 + t5 * (0.37409196 + t5 * (0.09678418 + t5 * (-0.18628806 + t5 * (0.27886807 + t5 * (-1.13520398 + t5 * (1.48851587 + t5 * (-0.82215223 + t5 * 0.17087277)))))))));
          if (x3 >= 0) {
            return ans;
          } else {
            return 2 - ans;
          }
        };
        Eval = function() {
          var willEvaluateAsFloats;
          check_esc_flag();
          save();
          p1 = pop();
          if (p1 == null) {
            debugger;
          }
          if (!evaluatingAsFloats && isfloating(p1)) {
            willEvaluateAsFloats = true;
            evaluatingAsFloats++;
          }
          switch (p1.k) {
            case CONS:
              Eval_cons();
              break;
            case NUM:
              if (evaluatingAsFloats) {
                push_double(convert_rational_to_double(p1));
              } else {
                push(p1);
              }
              break;
            case DOUBLE:
            case STR:
              push(p1);
              break;
            case TENSOR:
              Eval_tensor();
              break;
            case SYM:
              Eval_sym();
              break;
            default:
              stop("atom?");
          }
          if (willEvaluateAsFloats) {
            evaluatingAsFloats--;
          }
          return restore();
        };
        Eval_sym = function() {
          var cycleString, i5, o12, positionIfSymbolAlreadyBeingEvaluated, ref2, ref12;
          if (iskeyword(p1)) {
            push(p1);
            push(symbol(LAST));
            list(2);
            Eval();
            return;
          } else if (p1 === symbol(PI) && evaluatingAsFloats) {
            push_double(Math.PI);
            return;
          }
          p2 = get_binding(p1);
          if (DEBUG) {
            console.log("looked up: " + p1 + " which contains: " + p2);
          }
          push(p2);
          if (p1 !== p2) {
            positionIfSymbolAlreadyBeingEvaluated = chainOfUserSymbolsNotFunctionsBeingEvaluated.indexOf(p1);
            if (positionIfSymbolAlreadyBeingEvaluated !== -1) {
              cycleString = "";
              for (i5 = o12 = ref2 = positionIfSymbolAlreadyBeingEvaluated, ref12 = chainOfUserSymbolsNotFunctionsBeingEvaluated.length; ref2 <= ref12 ? o12 < ref12 : o12 > ref12; i5 = ref2 <= ref12 ? ++o12 : --o12) {
                cycleString += chainOfUserSymbolsNotFunctionsBeingEvaluated[i5].printname + " -> ";
              }
              cycleString += p1.printname;
              stop("recursive evaluation of symbols: " + cycleString);
              return;
            }
            chainOfUserSymbolsNotFunctionsBeingEvaluated.push(p1);
            Eval();
            return chainOfUserSymbolsNotFunctionsBeingEvaluated.pop();
          }
        };
        Eval_cons = function() {
          var cons_head;
          cons_head = car(p1);
          if (car(cons_head) === symbol(EVAL)) {
            Eval_user_function();
            return;
          }
          if (!issymbol(cons_head)) {
            stop("cons?");
          }
          switch (symnum(cons_head)) {
            case ABS:
              return Eval_abs();
            case ADD:
              return Eval_add();
            case ADJ:
              return Eval_adj();
            case AND:
              return Eval_and();
            case ARCCOS:
              return Eval_arccos();
            case ARCCOSH:
              return Eval_arccosh();
            case ARCSIN:
              return Eval_arcsin();
            case ARCSINH:
              return Eval_arcsinh();
            case ARCTAN:
              return Eval_arctan();
            case ARCTANH:
              return Eval_arctanh();
            case ARG:
              return Eval_arg();
            case ATOMIZE:
              return Eval_atomize();
            case BESSELJ:
              return Eval_besselj();
            case BESSELY:
              return Eval_bessely();
            case BINDING:
              return Eval_binding();
            case BINOMIAL:
              return Eval_binomial();
            case CEILING:
              return Eval_ceiling();
            case CHECK:
              return Eval_check();
            case CHOOSE:
              return Eval_choose();
            case CIRCEXP:
              return Eval_circexp();
            case CLEAR:
              return Eval_clear();
            case CLEARALL:
              return Eval_clearall();
            case CLEARPATTERNS:
              return Eval_clearpatterns();
            case CLOCK:
              return Eval_clock();
            case COEFF:
              return Eval_coeff();
            case COFACTOR:
              return Eval_cofactor();
            case CONDENSE:
              return Eval_condense();
            case CONJ:
              return Eval_conj();
            case CONTRACT:
              return Eval_contract();
            case COS:
              return Eval_cos();
            case COSH:
              return Eval_cosh();
            case DECOMP:
              return Eval_decomp();
            case DEGREE:
              return Eval_degree();
            case DEFINT:
              return Eval_defint();
            case DENOMINATOR:
              return Eval_denominator();
            case DERIVATIVE:
              return Eval_derivative();
            case DET:
              return Eval_det();
            case DIM:
              return Eval_dim();
            case DIRAC:
              return Eval_dirac();
            case DIVISORS:
              return Eval_divisors();
            case DO:
              return Eval_do();
            case DOT:
              return Eval_inner();
            case DRAW:
              return Eval_draw();
            case DSOLVE:
              return Eval_dsolve();
            case EIGEN:
              return Eval_eigen();
            case EIGENVAL:
              return Eval_eigenval();
            case EIGENVEC:
              return Eval_eigenvec();
            case ERF:
              return Eval_erf();
            case ERFC:
              return Eval_erfc();
            case EVAL:
              return Eval_Eval();
            case EXP:
              return Eval_exp();
            case EXPAND:
              return Eval_expand();
            case EXPCOS:
              return Eval_expcos();
            case EXPSIN:
              return Eval_expsin();
            case FACTOR:
              return Eval_factor();
            case FACTORIAL:
              return Eval_factorial();
            case FACTORPOLY:
              return Eval_factorpoly();
            case FILTER:
              return Eval_filter();
            case FLOATF:
              return Eval_float();
            case APPROXRATIO:
              return Eval_approxratio();
            case FLOOR:
              return Eval_floor();
            case FOR:
              return Eval_for();
            // this is invoked only when we
            // evaluate a function that is NOT being called
            // e.g. when f is a function as we do
            //  g = f
            case FUNCTION:
              return Eval_function_reference();
            case GAMMA:
              return Eval_gamma();
            case GCD:
              return Eval_gcd();
            case HERMITE:
              return Eval_hermite();
            case HILBERT:
              return Eval_hilbert();
            case IMAG:
              return Eval_imag();
            case INDEX:
              return Eval_index();
            case INNER:
              return Eval_inner();
            case INTEGRAL:
              return Eval_integral();
            case INV:
              return Eval_inv();
            case INVG:
              return Eval_invg();
            case ISINTEGER:
              return Eval_isinteger();
            case ISPRIME:
              return Eval_isprime();
            case LAGUERRE:
              return Eval_laguerre();
            //  when LAPLACE then Eval_laplace()
            case LCM:
              return Eval_lcm();
            case LEADING:
              return Eval_leading();
            case LEGENDRE:
              return Eval_legendre();
            case LOG:
              return Eval_log();
            case LOOKUP:
              return Eval_lookup();
            case MOD:
              return Eval_mod();
            case MULTIPLY:
              return Eval_multiply();
            case NOT:
              return Eval_not();
            case NROOTS:
              return Eval_nroots();
            case NUMBER:
              return Eval_number();
            case NUMERATOR:
              return Eval_numerator();
            case OPERATOR:
              return Eval_operator();
            case OR:
              return Eval_or();
            case OUTER:
              return Eval_outer();
            case PATTERN:
              return Eval_pattern();
            case PATTERNSINFO:
              return Eval_patternsinfo();
            case POLAR:
              return Eval_polar();
            case POWER:
              return Eval_power();
            case PRIME:
              return Eval_prime();
            case PRINT:
              return Eval_print();
            case PRINT2DASCII:
              return Eval_print2dascii();
            case PRINTFULL:
              return Eval_printcomputer();
            case PRINTLATEX:
              return Eval_printlatex();
            case PRINTLIST:
              return Eval_printlist();
            case PRINTPLAIN:
              return Eval_printhuman();
            case PRODUCT:
              return Eval_product();
            case QUOTE:
              return Eval_quote();
            case QUOTIENT:
              return Eval_quotient();
            case RANK:
              return Eval_rank();
            case RATIONALIZE:
              return Eval_rationalize();
            case REAL:
              return Eval_real();
            case ROUND:
              return Eval_round();
            case YYRECT:
              return Eval_rect();
            case ROOTS:
              return Eval_roots();
            case SETQ:
              return Eval_setq();
            case SGN:
              return Eval_sgn();
            case SILENTPATTERN:
              return Eval_silentpattern();
            case SIMPLIFY:
              return Eval_simplify();
            case SIN:
              return Eval_sin();
            case SINH:
              return Eval_sinh();
            case SHAPE:
              return Eval_shape();
            case SQRT:
              return Eval_sqrt();
            case STOP:
              return Eval_stop();
            case SUBST:
              return Eval_subst();
            case SUM:
              return Eval_sum();
            case SYMBOLSINFO:
              return Eval_symbolsinfo();
            case TAN:
              return Eval_tan();
            case TANH:
              return Eval_tanh();
            case TAYLOR:
              return Eval_taylor();
            case TEST:
              return Eval_test();
            case TESTEQ:
              return Eval_testeq();
            case TESTGE:
              return Eval_testge();
            case TESTGT:
              return Eval_testgt();
            case TESTLE:
              return Eval_testle();
            case TESTLT:
              return Eval_testlt();
            case TRANSPOSE:
              return Eval_transpose();
            case UNIT:
              return Eval_unit();
            case ZERO:
              return Eval_zero();
            default:
              return Eval_user_function();
          }
        };
        Eval_binding = function() {
          return push(get_binding(cadr(p1)));
        };
        Eval_check = function() {
          var checkResult;
          checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(cadr(p1));
          if (checkResult == null) {
            return push(p1);
          } else {
            return push_integer(checkResult);
          }
        };
        Eval_det = function() {
          push(cadr(p1));
          Eval();
          return det();
        };
        Eval_dim = function() {
          var n9;
          push(cadr(p1));
          Eval();
          p2 = pop();
          if (iscons(cddr(p1))) {
            push(caddr(p1));
            Eval();
            n9 = pop_integer();
          } else {
            n9 = 1;
          }
          if (!istensor(p2)) {
            return push_integer(1);
          } else if (n9 < 1 || n9 > p2.tensor.ndim) {
            return push(p1);
          } else {
            return push_integer(p2.tensor.dim[n9 - 1]);
          }
        };
        Eval_divisors = function() {
          push(cadr(p1));
          Eval();
          return divisors();
        };
        Eval_do = function() {
          var results;
          push(car(p1));
          p1 = cdr(p1);
          results = [];
          while (iscons(p1)) {
            pop();
            push(car(p1));
            Eval();
            results.push(p1 = cdr(p1));
          }
          return results;
        };
        Eval_dsolve = function() {
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          push(cadddr(p1));
          Eval();
          return dsolve();
        };
        Eval_Eval = function() {
          push(cadr(p1));
          Eval();
          p1 = cddr(p1);
          while (iscons(p1)) {
            push(car(p1));
            Eval();
            push(cadr(p1));
            Eval();
            subst();
            p1 = cddr(p1);
          }
          return Eval();
        };
        Eval_exp = function() {
          push(cadr(p1));
          Eval();
          return exponential();
        };
        Eval_factorial = function() {
          push(cadr(p1));
          Eval();
          return factorial();
        };
        Eval_factorpoly = function() {
          var results;
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          factorpoly();
          p1 = cdr(p1);
          results = [];
          while (iscons(p1)) {
            push(car(p1));
            Eval();
            factorpoly();
            results.push(p1 = cdr(p1));
          }
          return results;
        };
        Eval_hermite = function() {
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          return hermite();
        };
        Eval_hilbert = function() {
          push(cadr(p1));
          Eval();
          return hilbert();
        };
        Eval_index = function() {
          var h5, orig, theTensor;
          h5 = tos;
          orig = p1;
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          theTensor = stack[tos - 1];
          if (isNumericAtom(theTensor)) {
            stop("trying to access a scalar as a tensor");
          }
          if (!istensor(theTensor)) {
            moveTos(h5);
            push(orig);
            return;
          }
          p1 = cdr(p1);
          while (iscons(p1)) {
            push(car(p1));
            Eval();
            if (!isintegerorintegerfloat(stack[tos - 1])) {
              moveTos(h5);
              push(orig);
              return;
            }
            p1 = cdr(p1);
          }
          return index_function(tos - h5);
        };
        Eval_inv = function() {
          push(cadr(p1));
          Eval();
          return inv();
        };
        Eval_invg = function() {
          push(cadr(p1));
          Eval();
          return invg();
        };
        Eval_isinteger = function() {
          var n9;
          push(cadr(p1));
          Eval();
          p1 = pop();
          if (isrational(p1)) {
            if (isinteger(p1)) {
              push(one);
            } else {
              push(zero);
            }
            return;
          }
          if (isdouble(p1)) {
            n9 = Math.floor(p1.d);
            if (n9 === p1.d) {
              push(one);
            } else {
              push(zero);
            }
            return;
          }
          push_symbol(ISINTEGER);
          push(p1);
          return list(2);
        };
        Eval_number = function() {
          push(cadr(p1));
          Eval();
          p1 = pop();
          if (p1.k === NUM || p1.k === DOUBLE) {
            return push_integer(1);
          } else {
            return push_integer(0);
          }
        };
        Eval_operator = function() {
          var h5;
          h5 = tos;
          push_symbol(OPERATOR);
          p1 = cdr(p1);
          while (iscons(p1)) {
            push(car(p1));
            Eval();
            p1 = cdr(p1);
          }
          return list(tos - h5);
        };
        Eval_quote = function() {
          return push(cadr(p1));
        };
        Eval_rank = function() {
          push(cadr(p1));
          Eval();
          p1 = pop();
          if (istensor(p1)) {
            return push_integer(p1.tensor.ndim);
          } else {
            return push(zero);
          }
        };
        Eval_setq = function() {
          if (caadr(p1) === symbol(INDEX)) {
            setq_indexed();
            return;
          }
          if (iscons(cadr(p1))) {
            define_user_function();
            return;
          }
          if (!issymbol(cadr(p1))) {
            stop("symbol assignment: error in symbol");
          }
          push(caddr(p1));
          Eval();
          p2 = pop();
          set_binding(cadr(p1), p2);
          return push(symbol(NIL));
        };
        setq_indexed = function() {
          var h5;
          p4 = cadadr(p1);
          if (!issymbol(p4)) {
            stop("indexed assignment: expected a symbol name");
          }
          h5 = tos;
          push(caddr(p1));
          Eval();
          p2 = cdadr(p1);
          while (iscons(p2)) {
            push(car(p2));
            Eval();
            p2 = cdr(p2);
          }
          set_component(tos - h5);
          p3 = pop();
          set_binding(p4, p3);
          return push(symbol(NIL));
        };
        Eval_sqrt = function() {
          push(cadr(p1));
          Eval();
          push_rational(1, 2);
          return power();
        };
        Eval_stop = function() {
          return stop("user stop");
        };
        Eval_subst = function() {
          push(cadddr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          push(cadr(p1));
          Eval();
          subst();
          return Eval();
        };
        Eval_unit = function() {
          var i5, n9, o12, ref2;
          i5 = 0;
          n9 = 0;
          push(cadr(p1));
          Eval();
          n9 = pop_integer();
          if (isNaN(n9)) {
            push(p1);
            return;
          }
          if (n9 < 1) {
            push(p1);
            return;
          }
          p1 = alloc_tensor(n9 * n9);
          p1.tensor.ndim = 2;
          p1.tensor.dim[0] = n9;
          p1.tensor.dim[1] = n9;
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            p1.tensor.elem[n9 * i5 + i5] = one;
          }
          check_tensor_dimensions(p1);
          return push(p1);
        };
        Eval_noexpand = function() {
          var prev_expanding;
          prev_expanding = expanding;
          expanding = 0;
          Eval();
          return expanding = prev_expanding;
        };
        Eval_predicate = function() {
          save();
          p1 = top();
          if (car(p1) === symbol(SETQ)) {
            pop();
            push_symbol(TESTEQ);
            push(cadr(p1));
            push(caddr(p1));
            list(3);
          }
          Eval();
          return restore();
        };
        Eval_expand = function() {
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          p2 = pop();
          if (p2 === symbol(NIL)) {
            guess();
          } else {
            push(p2);
          }
          return expand();
        };
        expand = function() {
          var prev_expanding;
          save();
          p9 = pop();
          p5 = pop();
          if (istensor(p5)) {
            expand_tensor();
            restore();
            return;
          }
          if (car(p5) === symbol(ADD)) {
            push_integer(0);
            p1 = cdr(p5);
            while (iscons(p1)) {
              push(car(p1));
              push(p9);
              expand();
              add();
              p1 = cdr(p1);
            }
            restore();
            return;
          }
          push(p5);
          numerator();
          p3 = pop();
          push(p5);
          denominator();
          p2 = pop();
          remove_negative_exponents();
          push(p3);
          push(p2);
          push(p9);
          if (isone(p3) || isone(p2)) {
            if (!ispolyexpandedform(p2, p9) || isone(p2)) {
              pop();
              pop();
              pop();
              push(p5);
              restore();
              return;
            }
          }
          divpoly();
          p7 = pop();
          push(p3);
          push(p2);
          push(p7);
          multiply();
          subtract();
          p3 = pop();
          if (isZeroAtomOrTensor(p3)) {
            push(p7);
            restore();
            return;
          }
          push(p2);
          push(p9);
          factorpoly();
          p2 = pop();
          expand_get_C();
          expand_get_B();
          expand_get_A();
          if (istensor(p4)) {
            push(p4);
            prev_expanding = expanding;
            expanding = 1;
            inv();
            expanding = prev_expanding;
            push(p3);
            inner();
            push(p2);
            inner();
          } else {
            push(p3);
            push(p4);
            prev_expanding = expanding;
            expanding = 1;
            divide();
            expanding = prev_expanding;
            push(p2);
            multiply();
          }
          push(p7);
          add();
          return restore();
        };
        expand_tensor = function() {
          var i5, o12, ref2;
          i5 = 0;
          push(p5);
          copy_tensor();
          p5 = pop();
          for (i5 = o12 = 0, ref2 = p5.tensor.nelem; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            push(p5.tensor.elem[i5]);
            push(p9);
            expand();
            p5.tensor.elem[i5] = pop();
          }
          return push(p5);
        };
        remove_negative_exponents = function() {
          var h5, i5, j2, k3, n9, o12, ref2;
          h5 = 0;
          i5 = 0;
          j2 = 0;
          k3 = 0;
          n9 = 0;
          h5 = tos;
          factors(p2);
          factors(p3);
          n9 = tos - h5;
          j2 = 0;
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            p1 = stack[h5 + i5];
            if (car(p1) !== symbol(POWER)) {
              continue;
            }
            if (cadr(p1) !== p9) {
              continue;
            }
            push(caddr(p1));
            k3 = pop_integer();
            if (isNaN(k3)) {
              continue;
            }
            if (k3 < j2) {
              j2 = k3;
            }
          }
          moveTos(h5);
          if (j2 === 0) {
            return;
          }
          push(p2);
          push(p9);
          push_integer(-j2);
          power();
          multiply();
          p2 = pop();
          push(p3);
          push(p9);
          push_integer(-j2);
          power();
          multiply();
          return p3 = pop();
        };
        expand_get_C = function() {
          var a5, h5, i5, i12, j2, n9, o12, prev_expanding, ref2, ref12;
          h5 = 0;
          i5 = 0;
          j2 = 0;
          n9 = 0;
          h5 = tos;
          if (car(p2) === symbol(MULTIPLY)) {
            p1 = cdr(p2);
            while (iscons(p1)) {
              p5 = car(p1);
              expand_get_CF();
              p1 = cdr(p1);
            }
          } else {
            p5 = p2;
            expand_get_CF();
          }
          n9 = tos - h5;
          if (n9 === 1) {
            p4 = pop();
            return;
          }
          p4 = alloc_tensor(n9 * n9);
          p4.tensor.ndim = 2;
          p4.tensor.dim[0] = n9;
          p4.tensor.dim[1] = n9;
          a5 = h5;
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            for (j2 = i12 = 0, ref12 = n9; 0 <= ref12 ? i12 < ref12 : i12 > ref12; j2 = 0 <= ref12 ? ++i12 : --i12) {
              push(stack[a5 + j2]);
              push(p9);
              push_integer(i5);
              power();
              prev_expanding = expanding;
              expanding = 1;
              divide();
              expanding = prev_expanding;
              push(p9);
              filter();
              p4.tensor.elem[n9 * i5 + j2] = pop();
            }
          }
          return moveTos(tos - n9);
        };
        expand_get_CF = function() {
          var d3, i5, j2, n9, o12, prev_expanding, ref2, results;
          d3 = 0;
          i5 = 0;
          j2 = 0;
          n9 = 0;
          if (!Find(p5, p9)) {
            return;
          }
          prev_expanding = expanding;
          expanding = 1;
          trivial_divide();
          expanding = prev_expanding;
          if (car(p5) === symbol(POWER)) {
            push(caddr(p5));
            n9 = pop_integer();
            p6 = cadr(p5);
          } else {
            n9 = 1;
            p6 = p5;
          }
          push(p6);
          push(p9);
          degree();
          d3 = pop_integer();
          results = [];
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            results.push(function() {
              var i12, ref12, results1;
              results1 = [];
              for (j2 = i12 = 0, ref12 = d3; 0 <= ref12 ? i12 < ref12 : i12 > ref12; j2 = 0 <= ref12 ? ++i12 : --i12) {
                push(p8);
                push(p6);
                push_integer(i5);
                power();
                prev_expanding = expanding;
                expanding = 1;
                multiply();
                expanding = prev_expanding;
                push(p9);
                push_integer(j2);
                power();
                prev_expanding = expanding;
                expanding = 1;
                multiply();
                results1.push(expanding = prev_expanding);
              }
              return results1;
            }());
          }
          return results;
        };
        trivial_divide = function() {
          var h5;
          h5 = 0;
          if (car(p2) === symbol(MULTIPLY)) {
            h5 = tos;
            p0 = cdr(p2);
            while (iscons(p0)) {
              if (!equal(car(p0), p5)) {
                push(car(p0));
                Eval();
              }
              p0 = cdr(p0);
            }
            multiply_all(tos - h5);
          } else {
            push_integer(1);
          }
          return p8 = pop();
        };
        expand_get_B = function() {
          var i5, n9, o12, prev_expanding, ref2;
          i5 = 0;
          n9 = 0;
          if (!istensor(p4)) {
            return;
          }
          n9 = p4.tensor.dim[0];
          p8 = alloc_tensor(n9);
          p8.tensor.ndim = 1;
          p8.tensor.dim[0] = n9;
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            push(p3);
            push(p9);
            push_integer(i5);
            power();
            prev_expanding = expanding;
            expanding = 1;
            divide();
            expanding = prev_expanding;
            push(p9);
            filter();
            p8.tensor.elem[i5] = pop();
          }
          return p3 = p8;
        };
        expand_get_A = function() {
          var h5, i5, n9, o12, ref2;
          h5 = 0;
          i5 = 0;
          n9 = 0;
          if (!istensor(p4)) {
            push(p2);
            reciprocate();
            p2 = pop();
            return;
          }
          h5 = tos;
          if (car(p2) === symbol(MULTIPLY)) {
            p8 = cdr(p2);
            while (iscons(p8)) {
              p5 = car(p8);
              expand_get_AF();
              p8 = cdr(p8);
            }
          } else {
            p5 = p2;
            expand_get_AF();
          }
          n9 = tos - h5;
          p8 = alloc_tensor(n9);
          p8.tensor.ndim = 1;
          p8.tensor.dim[0] = n9;
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            p8.tensor.elem[i5] = stack[h5 + i5];
          }
          moveTos(h5);
          return p2 = p8;
        };
        expand_get_AF = function() {
          var d3, i5, j2, n9, o12, ref2, results;
          d3 = 0;
          i5 = 0;
          j2 = 0;
          n9 = 1;
          if (!Find(p5, p9)) {
            return;
          }
          if (car(p5) === symbol(POWER)) {
            push(caddr(p5));
            n9 = pop_integer();
            p5 = cadr(p5);
          }
          push(p5);
          push(p9);
          degree();
          d3 = pop_integer();
          results = [];
          for (i5 = o12 = ref2 = n9; ref2 <= 0 ? o12 < 0 : o12 > 0; i5 = ref2 <= 0 ? ++o12 : --o12) {
            results.push(function() {
              var i12, ref12, results1;
              results1 = [];
              for (j2 = i12 = 0, ref12 = d3; 0 <= ref12 ? i12 < ref12 : i12 > ref12; j2 = 0 <= ref12 ? ++i12 : --i12) {
                push(p5);
                push_integer(i5);
                power();
                reciprocate();
                push(p9);
                push_integer(j2);
                power();
                results1.push(multiply());
              }
              return results1;
            }());
          }
          return results;
        };
        Eval_expcos = function() {
          push(cadr(p1));
          Eval();
          return expcos();
        };
        expcos = function() {
          save();
          p1 = pop();
          push(imaginaryunit);
          push(p1);
          multiply();
          exponential();
          push_rational(1, 2);
          multiply();
          push(imaginaryunit);
          negate();
          push(p1);
          multiply();
          exponential();
          push_rational(1, 2);
          multiply();
          add();
          return restore();
        };
        Eval_expsin = function() {
          push(cadr(p1));
          Eval();
          return expsin();
        };
        expsin = function() {
          save();
          p1 = pop();
          push(imaginaryunit);
          push(p1);
          multiply();
          exponential();
          push(imaginaryunit);
          divide();
          push_rational(1, 2);
          multiply();
          push(imaginaryunit);
          negate();
          push(p1);
          multiply();
          exponential();
          push(imaginaryunit);
          divide();
          push_rational(1, 2);
          multiply();
          subtract();
          return restore();
        };
        Eval_factor = function() {
          var results;
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          p2 = pop();
          if (p2 === symbol(NIL)) {
            guess();
          } else {
            push(p2);
          }
          factor();
          p1 = cdddr(p1);
          results = [];
          while (iscons(p1)) {
            push(car(p1));
            Eval();
            factor_again();
            results.push(p1 = cdr(p1));
          }
          return results;
        };
        factor_again = function() {
          var h5, n9;
          save();
          p2 = pop();
          p1 = pop();
          h5 = tos;
          if (car(p1) === symbol(MULTIPLY)) {
            p1 = cdr(p1);
            while (iscons(p1)) {
              push(car(p1));
              push(p2);
              factor_term();
              p1 = cdr(p1);
            }
          } else {
            push(p1);
            push(p2);
            factor_term();
          }
          n9 = tos - h5;
          if (n9 > 1) {
            multiply_all_noexpand(n9);
          }
          return restore();
        };
        factor_term = function() {
          save();
          factorpoly();
          p1 = pop();
          if (car(p1) === symbol(MULTIPLY)) {
            p1 = cdr(p1);
            while (iscons(p1)) {
              push(car(p1));
              p1 = cdr(p1);
            }
          } else {
            push(p1);
          }
          return restore();
        };
        factor = function() {
          save();
          p2 = pop();
          p1 = pop();
          if (isinteger(p1)) {
            push(p1);
            factor_number();
          } else {
            push(p1);
            push(p2);
            factorpoly();
          }
          return restore();
        };
        factor_small_number = function() {
          var d3, expo, i5, n9, o12, ref2;
          i5 = 0;
          save();
          n9 = pop_integer();
          if (isNaN(n9)) {
            stop("number too big to factor");
          }
          if (n9 < 0) {
            n9 = -n9;
          }
          for (i5 = o12 = 0, ref2 = MAXPRIMETAB; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            d3 = primetab[i5];
            if (d3 > n9 / d3) {
              break;
            }
            expo = 0;
            while (n9 % d3 === 0) {
              n9 /= d3;
              expo++;
            }
            if (expo) {
              push_integer(d3);
              push_integer(expo);
            }
          }
          if (n9 > 1) {
            push_integer(n9);
            push_integer(1);
          }
          return restore();
        };
        factorial = function() {
          var n9;
          n9 = 0;
          save();
          p1 = pop();
          push(p1);
          n9 = pop_integer();
          if (n9 < 0 || isNaN(n9)) {
            push_symbol(FACTORIAL);
            push(p1);
            list(2);
            restore();
            return;
          }
          bignum_factorial(n9);
          return restore();
        };
        simplifyfactorials = function() {
          var x3;
          x3 = 0;
          save();
          x3 = expanding;
          expanding = 0;
          p1 = pop();
          if (car(p1) === symbol(ADD)) {
            push(zero);
            p1 = cdr(p1);
            while (iscons(p1)) {
              push(car(p1));
              simplifyfactorials();
              add();
              p1 = cdr(p1);
            }
            expanding = x3;
            restore();
            return;
          }
          if (car(p1) === symbol(MULTIPLY)) {
            sfac_product();
            expanding = x3;
            restore();
            return;
          }
          push(p1);
          expanding = x3;
          return restore();
        };
        sfac_product = function() {
          var i5, i12, j2, j12, n9, o12, ref2, ref12, ref22, ref3, s8;
          i5 = 0;
          j2 = 0;
          n9 = 0;
          s8 = tos;
          p1 = cdr(p1);
          n9 = 0;
          while (iscons(p1)) {
            push(car(p1));
            p1 = cdr(p1);
            n9++;
          }
          for (i5 = o12 = 0, ref2 = n9 - 1; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            if (stack[s8 + i5] === symbol(NIL)) {
              continue;
            }
            for (j2 = i12 = ref12 = i5 + 1, ref22 = n9; ref12 <= ref22 ? i12 < ref22 : i12 > ref22; j2 = ref12 <= ref22 ? ++i12 : --i12) {
              if (stack[s8 + j2] === symbol(NIL)) {
                continue;
              }
              sfac_product_f(s8, i5, j2);
            }
          }
          push(one);
          for (i5 = j12 = 0, ref3 = n9; 0 <= ref3 ? j12 < ref3 : j12 > ref3; i5 = 0 <= ref3 ? ++j12 : --j12) {
            if (stack[s8 + i5] === symbol(NIL)) {
              continue;
            }
            push(stack[s8 + i5]);
            multiply();
          }
          p1 = pop();
          moveTos(tos - n9);
          return push(p1);
        };
        sfac_product_f = function(s8, a5, b2) {
          var i5, n9, o12, ref2;
          i5 = 0;
          n9 = 0;
          p1 = stack[s8 + a5];
          p2 = stack[s8 + b2];
          if (ispower(p1)) {
            p3 = caddr(p1);
            p1 = cadr(p1);
          } else {
            p3 = one;
          }
          if (ispower(p2)) {
            p4 = caddr(p2);
            p2 = cadr(p2);
          } else {
            p4 = one;
          }
          if (isfactorial(p1) && isfactorial(p2)) {
            push(p3);
            push(p4);
            add();
            yyexpand();
            n9 = pop_integer();
            if (n9 !== 0) {
              return;
            }
            push(cadr(p1));
            push(cadr(p2));
            subtract();
            yyexpand();
            n9 = pop_integer();
            if (n9 === 0 || isNaN(n9)) {
              return;
            }
            if (n9 < 0) {
              n9 = -n9;
              p5 = p1;
              p1 = p2;
              p2 = p5;
              p5 = p3;
              p3 = p4;
              p4 = p5;
            }
            push(one);
            for (i5 = o12 = 1, ref2 = n9; 1 <= ref2 ? o12 <= ref2 : o12 >= ref2; i5 = 1 <= ref2 ? ++o12 : --o12) {
              push(cadr(p2));
              push_integer(i5);
              add();
              push(p3);
              power();
              multiply();
            }
            stack[s8 + a5] = pop();
            return stack[s8 + b2] = symbol(NIL);
          }
        };
        factorpoly = function() {
          var polynomial, variable;
          if (DEBUG) {
            console.log("factorpoly: " + stack[tos - 1].toString() + " " + stack[tos - 2].toString());
          }
          save();
          variable = pop();
          polynomial = pop();
          if (!Find(polynomial, variable) || !ispolyexpandedform(polynomial, variable) || !issymbol(variable)) {
            push(polynomial);
          } else {
            yyfactorpoly(variable, polynomial);
          }
          return restore();
        };
        yyfactorpoly = function(variable, polynomial) {
          var A5, AxPlusB, B4, checkingTheDivision, dividend, factpoly_expo, firstParam, foundComplexRoot, foundRealRoot, h5, i5, i12, j12, l1, o12, partOfPolynomialFactoredSoFar, polycoeff, prev_expanding, previousFactorisation, ref2, ref12, ref22, ref3, remainingPoly, secondDegreePloly, secondParam, whichRootsAreWeFinding;
          if (DEBUG) {
            firstParam = variable;
            secondParam = polynomial;
            console.log("yyfactorpoly: " + firstParam + " " + secondParam);
          }
          save();
          h5 = tos;
          if (isfloating(polynomial)) {
            stop("floating point numbers in polynomial");
          }
          polycoeff = tos;
          factpoly_expo = coeff(variable, polynomial) - 1;
          if (DEBUG) {
            console.log("yyfactorpoly: " + firstParam + " " + secondParam + " factpoly_expo before rationalize_coefficients: " + factpoly_expo);
          }
          partOfPolynomialFactoredSoFar = rationalize_coefficients(h5);
          if (DEBUG) {
            console.log("yyfactorpoly: " + firstParam + " " + secondParam + " factpoly_expo  after rationalize_coefficients: " + factpoly_expo);
          }
          whichRootsAreWeFinding = "real";
          remainingPoly = null;
          while (factpoly_expo > 0) {
            if (DEBUG) {
              console.log("yyfactorpoly: " + firstParam + " " + secondParam + " factpoly_expo inside while loop: " + factpoly_expo);
            }
            if (isZeroAtomOrTensor(stack[polycoeff + 0])) {
              if (DEBUG) {
                console.log("yyfactorpoly: " + firstParam + " " + secondParam + " isZeroAtomOrTensor");
              }
              A5 = one;
              B4 = zero;
            } else {
              if (whichRootsAreWeFinding === "real") {
                [foundRealRoot, A5, B4] = get_factor_from_real_root(variable, factpoly_expo, polycoeff);
              } else if (whichRootsAreWeFinding === "complex") {
                [foundComplexRoot, A5] = get_factor_from_complex_root(remainingPoly, factpoly_expo, polycoeff);
              }
            }
            if (whichRootsAreWeFinding === "real") {
              if (foundRealRoot === 0) {
                whichRootsAreWeFinding = "complex";
                continue;
              } else {
                push(A5);
                push(variable);
                multiply();
                push(B4);
                add();
                AxPlusB = pop();
                if (DEBUG) {
                  console.log("yyfactorpoly: " + firstParam + " " + secondParam + " success\nFACTOR=" + AxPlusB);
                }
                push(partOfPolynomialFactoredSoFar);
                push(AxPlusB);
                multiply_noexpand();
                partOfPolynomialFactoredSoFar = pop();
                yydivpoly(factpoly_expo, polycoeff, A5, B4);
                while (factpoly_expo && isZeroAtomOrTensor(stack[polycoeff + factpoly_expo])) {
                  factpoly_expo--;
                }
                push(zero);
                for (i5 = o12 = 0, ref2 = factpoly_expo; 0 <= ref2 ? o12 <= ref2 : o12 >= ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
                  push(stack[polycoeff + i5]);
                  push(variable);
                  push_integer(i5);
                  power();
                  multiply();
                  add();
                }
                remainingPoly = pop();
              }
            } else if (whichRootsAreWeFinding === "complex") {
              if (foundComplexRoot === 0) {
                break;
              } else {
                push(A5);
                push(variable);
                subtract();
                push(A5);
                conjugate();
                push(variable);
                subtract();
                multiply();
                secondDegreePloly = pop();
                if (DEBUG) {
                  console.log("yyfactorpoly: " + firstParam + " " + secondParam + " success\nFACTOR=" + secondDegreePloly);
                }
                push(partOfPolynomialFactoredSoFar);
                previousFactorisation = pop();
                push(partOfPolynomialFactoredSoFar);
                push(secondDegreePloly);
                multiply_noexpand();
                partOfPolynomialFactoredSoFar = pop();
                if (remainingPoly == null) {
                  push(zero);
                  for (i5 = i12 = 0, ref12 = factpoly_expo; 0 <= ref12 ? i12 <= ref12 : i12 >= ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
                    push(stack[polycoeff + i5]);
                    push(variable);
                    push_integer(i5);
                    power();
                    multiply();
                    add();
                  }
                  remainingPoly = pop();
                }
                dividend = remainingPoly;
                push(dividend);
                push(secondDegreePloly);
                push(variable);
                divpoly();
                remainingPoly = pop();
                push(remainingPoly);
                push(secondDegreePloly);
                multiply();
                checkingTheDivision = pop();
                if (!equal(checkingTheDivision, dividend)) {
                  if (DEBUG) {
                    console.log("we found a polynomial based on complex root and its conj but it doesn't divide the poly, quitting");
                  }
                  if (DEBUG) {
                    console.log("so just returning previousFactorisation times dividend: " + previousFactorisation + " * " + dividend);
                  }
                  push(previousFactorisation);
                  push(dividend);
                  prev_expanding = expanding;
                  expanding = 0;
                  yycondense();
                  expanding = prev_expanding;
                  multiply_noexpand();
                  partOfPolynomialFactoredSoFar = pop();
                  stack[h5] = partOfPolynomialFactoredSoFar;
                  moveTos(h5 + 1);
                  restore();
                  return;
                }
                for (i5 = j12 = 0, ref22 = factpoly_expo; 0 <= ref22 ? j12 <= ref22 : j12 >= ref22; i5 = 0 <= ref22 ? ++j12 : --j12) {
                  pop();
                }
                coeff(variable, remainingPoly);
                factpoly_expo -= 2;
              }
            }
          }
          if (DEBUG) {
            console.log("yyfactorpoly: " + firstParam + " " + secondParam + " building the remaining unfactored part of the polynomial");
          }
          push(zero);
          for (i5 = l1 = 0, ref3 = factpoly_expo; 0 <= ref3 ? l1 <= ref3 : l1 >= ref3; i5 = 0 <= ref3 ? ++l1 : --l1) {
            push(stack[polycoeff + i5]);
            push(variable);
            push_integer(i5);
            power();
            multiply();
            add();
          }
          polynomial = pop();
          if (DEBUG) {
            console.log("yyfactorpoly: " + firstParam + " " + secondParam + " remaining unfactored part of the polynomial: " + polynomial.toString());
          }
          push(polynomial);
          prev_expanding = expanding;
          expanding = 0;
          yycondense();
          expanding = prev_expanding;
          polynomial = pop();
          if (DEBUG) {
            console.log("yyfactorpoly: " + firstParam + " " + secondParam + " new poly with extracted common factor: " + polynomial.toString());
          }
          if (factpoly_expo > 0 && isnegativeterm(stack[polycoeff + factpoly_expo])) {
            push(polynomial);
            negate();
            polynomial = pop();
            push(partOfPolynomialFactoredSoFar);
            negate_noexpand();
            partOfPolynomialFactoredSoFar = pop();
          }
          push(partOfPolynomialFactoredSoFar);
          push(polynomial);
          multiply_noexpand();
          partOfPolynomialFactoredSoFar = pop();
          if (DEBUG) {
            console.log("yyfactorpoly: " + firstParam + " " + secondParam + " result: " + partOfPolynomialFactoredSoFar);
          }
          stack[h5] = partOfPolynomialFactoredSoFar;
          moveTos(h5 + 1);
          return restore();
        };
        rationalize_coefficients = function(h5) {
          var i5, i12, o12, ratio, ratioInverse, ref2, ref12, ref22, ref3;
          ratio = one;
          for (i5 = o12 = ref2 = h5, ref12 = tos; ref2 <= ref12 ? o12 < ref12 : o12 > ref12; i5 = ref2 <= ref12 ? ++o12 : --o12) {
            push(stack[i5]);
            denominator();
            push(ratio);
            lcm();
            ratio = pop();
          }
          for (i5 = i12 = ref22 = h5, ref3 = tos; ref22 <= ref3 ? i12 < ref3 : i12 > ref3; i5 = ref22 <= ref3 ? ++i12 : --i12) {
            push(ratio);
            push(stack[i5]);
            multiply();
            stack[i5] = pop();
          }
          push(ratio);
          reciprocate();
          ratioInverse = pop();
          if (DEBUG) {
            console.log("rationalize_coefficients result: " + ratioInverse.toString());
          }
          return ratioInverse;
        };
        get_factor_from_real_root = function(variable, factpoly_expo, polycoeff) {
          var a0, an, evalPolyResult, h5, i5, i12, j2, j12, l1, m1, na0, nan, o12, polynomial, ref2, ref12, ref22, ref3, ref4, rootsTries_i, rootsTries_j, testDenominator, testNumerator, testValue;
          if (DEBUG) {
            console.log("get_factor_from_real_root");
          }
          i5 = 0;
          j2 = 0;
          h5 = 0;
          a0 = 0;
          an = 0;
          na0 = 0;
          nan = 0;
          if (DEBUG) {
            push(zero);
            for (i5 = o12 = 0, ref2 = factpoly_expo; 0 <= ref2 ? o12 <= ref2 : o12 >= ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
              push(stack[polycoeff + i5]);
              push(variable);
              push_integer(i5);
              power();
              multiply();
              add();
            }
            polynomial = pop();
            console.log("POLY=" + polynomial);
          }
          h5 = tos;
          an = tos;
          push(stack[polycoeff + factpoly_expo]);
          divisors_onstack();
          nan = tos - an;
          a0 = tos;
          push(stack[polycoeff + 0]);
          divisors_onstack();
          na0 = tos - a0;
          if (DEBUG) {
            console.log("divisors of base term");
            for (i5 = i12 = 0, ref12 = na0; 0 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
              console.log(", " + stack[a0 + i5]);
            }
            console.log("divisors of leading term");
            for (i5 = j12 = 0, ref22 = nan; 0 <= ref22 ? j12 < ref22 : j12 > ref22; i5 = 0 <= ref22 ? ++j12 : --j12) {
              console.log(", " + stack[an + i5]);
            }
          }
          for (rootsTries_i = l1 = 0, ref3 = nan; 0 <= ref3 ? l1 < ref3 : l1 > ref3; rootsTries_i = 0 <= ref3 ? ++l1 : --l1) {
            for (rootsTries_j = m1 = 0, ref4 = na0; 0 <= ref4 ? m1 < ref4 : m1 > ref4; rootsTries_j = 0 <= ref4 ? ++m1 : --m1) {
              testNumerator = stack[an + rootsTries_i];
              testDenominator = stack[a0 + rootsTries_j];
              push(testDenominator);
              push(testNumerator);
              divide();
              negate();
              testValue = pop();
              evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);
              if (DEBUG) {
                console.log("try A=" + testNumerator);
                console.log(", B=" + testDenominator);
                console.log(", root " + variable);
                console.log("=-B/A=" + testValue);
                console.log(", POLY(" + testValue);
                console.log(")=" + evalPolyResult);
              }
              if (isZeroAtomOrTensor(evalPolyResult)) {
                moveTos(h5);
                if (DEBUG) {
                  console.log("get_factor_from_real_root returning 1");
                }
                return [1, testNumerator, testDenominator];
              }
              push(testDenominator);
              negate();
              testDenominator = pop();
              push(testValue);
              negate();
              testValue = pop();
              evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);
              if (DEBUG) {
                console.log("try A=" + testNumerator);
                console.log(", B=" + testDenominator);
                console.log(", root " + variable);
                console.log("=-B/A=" + testValue);
                console.log(", POLY(" + testValue);
                console.log(")=" + evalPolyResult);
              }
              if (isZeroAtomOrTensor(evalPolyResult)) {
                moveTos(h5);
                if (DEBUG) {
                  console.log("get_factor_from_real_root returning 1");
                }
                return [1, testNumerator, testDenominator];
              }
            }
          }
          moveTos(h5);
          if (DEBUG) {
            console.log("get_factor_from_real_root returning");
          }
          return [0, null, null];
        };
        get_factor_from_complex_root = function(remainingPoly, factpoly_expo, polycoeff) {
          var a0, an, evalPolyResult, h5, i5, i12, j2, na0, nan, o12, rootsTries_i, rootsTries_j, testValue;
          i5 = 0;
          j2 = 0;
          h5 = 0;
          a0 = 0;
          an = 0;
          na0 = 0;
          nan = 0;
          if (factpoly_expo <= 2) {
            if (DEBUG) {
              console.log("no more factoring via complex roots to be found in polynomial of degree <= 2");
            }
            return [0, null];
          }
          if (DEBUG) {
            console.log("complex root finding for POLY=" + remainingPoly);
          }
          h5 = tos;
          an = tos;
          push_integer(-1);
          push_rational(2, 3);
          power();
          rect();
          testValue = pop();
          if (DEBUG) {
            console.log("complex root finding: trying with " + testValue);
          }
          push(testValue);
          evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);
          if (DEBUG) {
            console.log("complex root finding result: " + evalPolyResult);
          }
          if (isZeroAtomOrTensor(evalPolyResult)) {
            moveTos(h5);
            if (DEBUG) {
              console.log("get_factor_from_complex_root returning 1");
            }
            return [1, testValue];
          }
          push_integer(1);
          push_rational(2, 3);
          power();
          rect();
          testValue = pop();
          if (DEBUG) {
            console.log("complex root finding: trying with " + testValue);
          }
          push(testValue);
          evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);
          if (DEBUG) {
            console.log("complex root finding result: " + evalPolyResult);
          }
          if (isZeroAtomOrTensor(evalPolyResult)) {
            moveTos(h5);
            if (DEBUG) {
              console.log("get_factor_from_complex_root returning 1");
            }
            return [1, testValue];
          }
          for (rootsTries_i = o12 = -10; o12 <= 10; rootsTries_i = ++o12) {
            for (rootsTries_j = i12 = 1; i12 <= 5; rootsTries_j = ++i12) {
              push_integer(rootsTries_i);
              push_integer(rootsTries_j);
              push(imaginaryunit);
              multiply();
              add();
              rect();
              testValue = pop();
              if (DEBUG) {
                console.log("complex root finding: trying simple complex combination " + testValue);
              }
              push(testValue);
              evalPolyResult = Evalpoly(factpoly_expo, polycoeff, testValue);
              if (isZeroAtomOrTensor(evalPolyResult)) {
                moveTos(h5);
                if (DEBUG) {
                  console.log("found complex root: " + evalPolyResult);
                }
                return [1, testValue];
              }
            }
          }
          moveTos(h5);
          if (DEBUG) {
            console.log("get_factor_from_complex_root returning 0");
          }
          return [0, null];
        };
        yydivpoly = function(factpoly_expo, polycoeff, A5, B4) {
          var Q, i5, o12, ref2;
          Q = zero;
          for (i5 = o12 = ref2 = factpoly_expo; ref2 <= 0 ? o12 < 0 : o12 > 0; i5 = ref2 <= 0 ? ++o12 : --o12) {
            push(stack[polycoeff + i5]);
            stack[polycoeff + i5] = Q;
            push(A5);
            divide();
            Q = pop();
            push(stack[polycoeff + i5 - 1]);
            push(Q);
            push(B4);
            multiply();
            subtract();
            stack[polycoeff + i5 - 1] = pop();
          }
          stack[polycoeff + 0] = Q;
          if (DEBUG) {
            return console.log("yydivpoly Q: " + Q.toString());
          }
        };
        Evalpoly = function(factpoly_expo, polycoeff, evaluateAt) {
          var i5, o12, ref2;
          push(zero);
          for (i5 = o12 = ref2 = factpoly_expo; ref2 <= 0 ? o12 <= 0 : o12 >= 0; i5 = ref2 <= 0 ? ++o12 : --o12) {
            push(evaluateAt);
            multiply();
            push(stack[polycoeff + i5]);
            add();
          }
          return pop();
        };
        factors = function(p11) {
          var h5;
          h5 = tos;
          if (car(p11) === symbol(ADD)) {
            p11 = cdr(p11);
            while (iscons(p11)) {
              push_term_factors(car(p11));
              p11 = cdr(p11);
            }
          } else {
            push_term_factors(p11);
          }
          return tos - h5;
        };
        push_term_factors = function(p11) {
          var results;
          if (car(p11) === symbol(MULTIPLY)) {
            p11 = cdr(p11);
            results = [];
            while (iscons(p11)) {
              push(car(p11));
              results.push(p11 = cdr(p11));
            }
            return results;
          } else {
            return push(p11);
          }
        };
        Eval_filter = function() {
          var results;
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p1 = cdr(p1);
          results = [];
          while (iscons(p1)) {
            push(car(p1));
            Eval();
            filter();
            results.push(p1 = cdr(p1));
          }
          return results;
        };
        filter = function() {
          save();
          p2 = pop();
          p1 = pop();
          filter_main();
          return restore();
        };
        filter_main = function() {
          if (car(p1) === symbol(ADD)) {
            return filter_sum();
          } else if (istensor(p1)) {
            return filter_tensor();
          } else if (Find(p1, p2)) {
            return push_integer(0);
          } else {
            return push(p1);
          }
        };
        filter_sum = function() {
          var results;
          push_integer(0);
          p1 = cdr(p1);
          results = [];
          while (iscons(p1)) {
            push(car(p1));
            push(p2);
            filter();
            add();
            results.push(p1 = cdr(p1));
          }
          return results;
        };
        filter_tensor = function() {
          var i5, i12, n9, o12, ref2, ref12;
          i5 = 0;
          n9 = 0;
          n9 = p1.tensor.nelem;
          p3 = alloc_tensor(n9);
          p3.tensor.ndim = p1.tensor.ndim;
          for (i5 = o12 = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            p3.tensor.dim[i5] = p1.tensor.dim[i5];
          }
          for (i5 = i12 = 0, ref12 = n9; 0 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
            push(p1.tensor.elem[i5]);
            push(p2);
            filter();
            p3.tensor.elem[i5] = pop();
          }
          return push(p3);
        };
        Eval_float = function() {
          evaluatingAsFloats++;
          push(cadr(p1));
          Eval();
          yyfloat();
          Eval();
          return evaluatingAsFloats--;
        };
        checkFloatHasWorkedOutCompletely = function(nodeToCheck) {
          var numberOfEs, numberOfMults, numberOfPIs, numberOfPowers, numberOfSums;
          numberOfPowers = countOccurrencesOfSymbol(symbol(POWER), nodeToCheck);
          numberOfPIs = countOccurrencesOfSymbol(symbol(PI), nodeToCheck);
          numberOfEs = countOccurrencesOfSymbol(symbol(E), nodeToCheck);
          numberOfMults = countOccurrencesOfSymbol(symbol(MULTIPLY), nodeToCheck);
          numberOfSums = countOccurrencesOfSymbol(symbol(ADD), nodeToCheck);
          if (DEBUG) {
            console.log("     ... numberOfPowers: " + numberOfPowers);
            console.log("     ... numberOfPIs: " + numberOfPIs);
            console.log("     ... numberOfEs: " + numberOfEs);
            console.log("     ... numberOfMults: " + numberOfMults);
            console.log("     ... numberOfSums: " + numberOfSums);
          }
          if (numberOfPowers > 1 || numberOfPIs > 0 || numberOfEs > 0 || numberOfMults > 1 || numberOfSums > 1) {
            return stop("float: some unevalued parts in " + nodeToCheck);
          }
        };
        zzfloat = function() {
          save();
          evaluatingAsFloats++;
          Eval();
          yyfloat();
          Eval();
          evaluatingAsFloats--;
          return restore();
        };
        yyfloat = function() {
          var h5, i5, o12, ref2;
          i5 = 0;
          h5 = 0;
          evaluatingAsFloats++;
          save();
          p1 = pop();
          if (iscons(p1)) {
            h5 = tos;
            while (iscons(p1)) {
              push(car(p1));
              yyfloat();
              p1 = cdr(p1);
            }
            list(tos - h5);
          } else if (p1.k === TENSOR) {
            push(p1);
            copy_tensor();
            p1 = pop();
            for (i5 = o12 = 0, ref2 = p1.tensor.nelem; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
              push(p1.tensor.elem[i5]);
              yyfloat();
              p1.tensor.elem[i5] = pop();
            }
            push(p1);
          } else if (p1.k === NUM) {
            push(p1);
            bignum_float();
          } else if (p1 === symbol(PI)) {
            push_double(Math.PI);
          } else if (p1 === symbol(E)) {
            push_double(Math.E);
          } else {
            push(p1);
          }
          restore();
          return evaluatingAsFloats--;
        };
        Eval_floor = function() {
          push(cadr(p1));
          Eval();
          return yfloor();
        };
        yfloor = function() {
          save();
          yyfloor();
          return restore();
        };
        yyfloor = function() {
          var d3;
          d3 = 0;
          p1 = pop();
          if (!isNumericAtom(p1)) {
            push_symbol(FLOOR);
            push(p1);
            list(2);
            return;
          }
          if (isdouble(p1)) {
            d3 = Math.floor(p1.d);
            push_double(d3);
            return;
          }
          if (isinteger(p1)) {
            push(p1);
            return;
          }
          p3 = new U();
          p3.k = NUM;
          p3.q.a = mdiv(p1.q.a, p1.q.b);
          p3.q.b = mint(1);
          push(p3);
          if (isnegativenumber(p1)) {
            push_integer(-1);
            return add();
          }
        };
        Eval_for = function() {
          var i5, j2, k3, loopingVariable, o12, ref2, ref12;
          i5 = 0;
          j2 = 0;
          k3 = 0;
          loopingVariable = caddr(p1);
          if (!issymbol(loopingVariable)) {
            stop("for: 2nd arg should be the variable to loop over");
          }
          push(cadddr(p1));
          Eval();
          j2 = pop_integer();
          if (isNaN(j2)) {
            push(p1);
            return;
          }
          push(caddddr(p1));
          Eval();
          k3 = pop_integer();
          if (isNaN(k3)) {
            push(p1);
            return;
          }
          p4 = get_binding(loopingVariable);
          for (i5 = o12 = ref2 = j2, ref12 = k3; ref2 <= ref12 ? o12 <= ref12 : o12 >= ref12; i5 = ref2 <= ref12 ? ++o12 : --o12) {
            push_integer(i5);
            p5 = pop();
            set_binding(loopingVariable, p5);
            push(cadr(p1));
            Eval();
            pop();
          }
          set_binding(loopingVariable, p4);
          return push_symbol(NIL);
        };
        Eval_gamma = function() {
          push(cadr(p1));
          Eval();
          return gamma();
        };
        gamma = function() {
          save();
          gammaf();
          return restore();
        };
        gammaf = function() {
          p1 = pop();
          if (isrational(p1) && MEQUAL(p1.q.a, 1) && MEQUAL(p1.q.b, 2)) {
            if (evaluatingAsFloats) {
              push_double(Math.PI);
            } else {
              push_symbol(PI);
            }
            push_rational(1, 2);
            power();
            return;
          }
          if (isrational(p1) && MEQUAL(p1.q.a, 3) && MEQUAL(p1.q.b, 2)) {
            if (evaluatingAsFloats) {
              push_double(Math.PI);
            } else {
              push_symbol(PI);
            }
            push_rational(1, 2);
            power();
            push_rational(1, 2);
            multiply();
            return;
          }
          if (isnegativeterm(p1)) {
            if (evaluatingAsFloats) {
              push_double(Math.PI);
            } else {
              push_symbol(PI);
            }
            push_integer(-1);
            multiply();
            if (evaluatingAsFloats) {
              push_double(Math.PI);
            } else {
              push_symbol(PI);
            }
            push(p1);
            multiply();
            sine();
            push(p1);
            multiply();
            push(p1);
            negate();
            gamma();
            multiply();
            divide();
            return;
          }
          if (car(p1) === symbol(ADD)) {
            gamma_of_sum();
            return;
          }
          push_symbol(GAMMA);
          push(p1);
          list(2);
        };
        gamma_of_sum = function() {
          p3 = cdr(p1);
          if (isrational(car(p3)) && MEQUAL(car(p3).q.a, 1) && MEQUAL(car(p3).q.b, 1)) {
            push(cadr(p3));
            push(cadr(p3));
            gamma();
            return multiply();
          } else {
            if (isrational(car(p3)) && MEQUAL(car(p3).q.a, -1) && MEQUAL(car(p3).q.b, 1)) {
              push(cadr(p3));
              gamma();
              push(cadr(p3));
              push_integer(-1);
              add();
              return divide();
            } else {
              push_symbol(GAMMA);
              push(p1);
              list(2);
            }
          }
        };
        Eval_gcd = function() {
          var results;
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p1 = cdr(p1);
          results = [];
          while (iscons(p1)) {
            push(car(p1));
            Eval();
            gcd();
            results.push(p1 = cdr(p1));
          }
          return results;
        };
        gcd = function() {
          var prev_expanding;
          prev_expanding = expanding;
          save();
          gcd_main();
          restore();
          return expanding = prev_expanding;
        };
        gcd_main = function() {
          var polyVar;
          expanding = 1;
          p2 = pop();
          p1 = pop();
          if (DEBUG) {
            console.log("gcd_main: p1: " + p1 + " p2: " + p2);
          }
          if (equal(p1, p2)) {
            push(p1);
            return;
          }
          if (isrational(p1) && isrational(p2)) {
            push(p1);
            push(p2);
            gcd_numbers();
            return;
          }
          if (polyVar = areunivarpolysfactoredorexpandedform(p1, p2)) {
            gcd_polys(polyVar);
            return;
          }
          if (car(p1) === symbol(ADD) && car(p2) === symbol(ADD)) {
            gcd_sum_sum();
            return;
          }
          if (car(p1) === symbol(ADD)) {
            gcd_sum(p1);
            p1 = pop();
          }
          if (car(p2) === symbol(ADD)) {
            gcd_sum(p2);
            p2 = pop();
          }
          if (car(p1) === symbol(MULTIPLY)) {
            gcd_sum_product();
            return;
          }
          if (car(p2) === symbol(MULTIPLY)) {
            gcd_product_sum();
            return;
          }
          if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {
            gcd_product_product();
            return;
          }
          return gcd_powers_with_same_base();
        };
        areunivarpolysfactoredorexpandedform = function(p12, p22) {
          var polyVar;
          if (DEBUG) {
            console.log("areunivarpolysfactoredorexpandedform: p1: " + p12 + " p2: " + p22);
          }
          if (polyVar = isunivarpolyfactoredorexpandedform(p12)) {
            if (isunivarpolyfactoredorexpandedform(p22, polyVar)) {
              return polyVar;
            }
          }
          return false;
        };
        gcd_polys = function(polyVar) {
          if (DEBUG) {
            console.log("gcd_polys: p1: " + p1 + " polyVar: " + polyVar);
          }
          push(p1);
          push(polyVar);
          factorpoly();
          p1 = pop();
          push(p2);
          push(polyVar);
          factorpoly();
          p2 = pop();
          if (DEBUG) {
            console.log("GCD: factored polys:");
          }
          if (DEBUG) {
            console.log("  p1:" + p1.toString());
          }
          if (DEBUG) {
            console.log("  p2:" + p2.toString());
          }
          if (car(p1) === symbol(MULTIPLY) || car(p2) === symbol(MULTIPLY)) {
            if (car(p1) !== symbol(MULTIPLY)) {
              push_symbol(MULTIPLY);
              push(p1);
              push(one);
              list(3);
              p1 = pop();
            }
            if (car(p2) !== symbol(MULTIPLY)) {
              push_symbol(MULTIPLY);
              push(p2);
              push(one);
              list(3);
              p2 = pop();
            }
          }
          if (car(p1) === symbol(MULTIPLY) && car(p2) === symbol(MULTIPLY)) {
            gcd_product_product();
            return;
          }
          gcd_powers_with_same_base();
          return true;
        };
        gcd_product_product = function() {
          var results;
          push(one);
          p3 = cdr(p1);
          results = [];
          while (iscons(p3)) {
            p4 = cdr(p2);
            while (iscons(p4)) {
              push(car(p3));
              push(car(p4));
              gcd();
              multiply();
              p4 = cdr(p4);
            }
            results.push(p3 = cdr(p3));
          }
          return results;
        };
        gcd_powers_with_same_base = function() {
          if (car(p1) === symbol(POWER)) {
            p3 = caddr(p1);
            p1 = cadr(p1);
          } else {
            p3 = one;
          }
          if (car(p2) === symbol(POWER)) {
            p4 = caddr(p2);
            p2 = cadr(p2);
          } else {
            p4 = one;
          }
          if (!equal(p1, p2)) {
            push(one);
            return;
          }
          if (isNumericAtom(p3) && isNumericAtom(p4)) {
            push(p1);
            if (lessp(p3, p4)) {
              push(p3);
            } else {
              push(p4);
            }
            power();
            return;
          }
          push(p3);
          push(p4);
          divide();
          p5 = pop();
          if (isNumericAtom(p5)) {
            push(p1);
            if (car(p3) === symbol(MULTIPLY) && isNumericAtom(cadr(p3))) {
              p5 = cadr(p3);
            } else {
              p5 = one;
            }
            if (car(p4) === symbol(MULTIPLY) && isNumericAtom(cadr(p4))) {
              p6 = cadr(p4);
            } else {
              p6 = one;
            }
            if (lessp(p5, p6)) {
              push(p3);
            } else {
              push(p4);
            }
            power();
            return;
          }
          push(p3);
          push(p4);
          subtract();
          p5 = pop();
          if (!isNumericAtom(p5)) {
            push(one);
            return;
          }
          push(p1);
          if (isnegativenumber(p5)) {
            push(p3);
          } else {
            push(p4);
          }
          return power();
        };
        gcd_sum_sum = function() {
          if (length(p1) !== length(p2)) {
            push(one);
            return;
          }
          p3 = cdr(p1);
          push(car(p3));
          p3 = cdr(p3);
          while (iscons(p3)) {
            push(car(p3));
            gcd();
            p3 = cdr(p3);
          }
          p3 = pop();
          p4 = cdr(p2);
          push(car(p4));
          p4 = cdr(p4);
          while (iscons(p4)) {
            push(car(p4));
            gcd();
            p4 = cdr(p4);
          }
          p4 = pop();
          push(p1);
          push(p3);
          divide();
          p5 = pop();
          push(p2);
          push(p4);
          divide();
          p6 = pop();
          if (equal(p5, p6)) {
            push(p5);
            push(p3);
            push(p4);
            gcd();
            return multiply();
          } else {
            return push(one);
          }
        };
        gcd_sum = function(p11) {
          var results;
          p11 = cdr(p11);
          push(car(p11));
          p11 = cdr(p11);
          results = [];
          while (iscons(p11)) {
            push(car(p11));
            gcd();
            results.push(p11 = cdr(p11));
          }
          return results;
        };
        gcd_sum_product = function() {
          var results;
          push(one);
          p3 = cdr(p1);
          results = [];
          while (iscons(p3)) {
            push(car(p3));
            push(p2);
            gcd();
            multiply();
            results.push(p3 = cdr(p3));
          }
          return results;
        };
        gcd_product_sum = function() {
          var results;
          push(one);
          p4 = cdr(p2);
          results = [];
          while (iscons(p4)) {
            push(p1);
            push(car(p4));
            gcd();
            multiply();
            results.push(p4 = cdr(p4));
          }
          return results;
        };
        guess = function() {
          var p11;
          p11 = pop();
          push(p11);
          if (Find(p11, symbol(SYMBOL_X))) {
            return push_symbol(SYMBOL_X);
          } else if (Find(p11, symbol(SYMBOL_Y))) {
            return push_symbol(SYMBOL_Y);
          } else if (Find(p11, symbol(SYMBOL_Z))) {
            return push_symbol(SYMBOL_Z);
          } else if (Find(p11, symbol(SYMBOL_T))) {
            return push_symbol(SYMBOL_T);
          } else if (Find(p11, symbol(SYMBOL_S))) {
            return push_symbol(SYMBOL_S);
          } else {
            return push_symbol(SYMBOL_X);
          }
        };
        hermite = function() {
          save();
          yyhermite();
          return restore();
        };
        yyhermite = function() {
          var n9;
          n9 = 0;
          p2 = pop();
          p1 = pop();
          push(p2);
          n9 = pop_integer();
          if (n9 < 0 || isNaN(n9)) {
            push_symbol(HERMITE);
            push(p1);
            push(p2);
            list(3);
            return;
          }
          if (issymbol(p1)) {
            return yyhermite2(n9);
          } else {
            p3 = p1;
            p1 = symbol(SECRETX);
            yyhermite2(n9);
            p1 = p3;
            push(symbol(SECRETX));
            push(p1);
            subst();
            return Eval();
          }
        };
        yyhermite2 = function(n9) {
          var i5, o12, ref2, results;
          i5 = 0;
          push_integer(1);
          push_integer(0);
          p4 = pop();
          results = [];
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            p5 = p4;
            p4 = pop();
            push(p1);
            push(p4);
            multiply();
            push_integer(i5);
            push(p5);
            multiply();
            subtract();
            push_integer(2);
            results.push(multiply());
          }
          return results;
        };
        hilbert = function() {
          var i5, i12, j2, n9, o12, ref2, ref12;
          i5 = 0;
          j2 = 0;
          n9 = 0;
          save();
          p2 = pop();
          push(p2);
          n9 = pop_integer();
          if (n9 < 2) {
            push_symbol(HILBERT);
            push(p2);
            list(2);
            restore();
            return;
          }
          push_zero_matrix(n9, n9);
          p1 = pop();
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            for (j2 = i12 = 0, ref12 = n9; 0 <= ref12 ? i12 < ref12 : i12 > ref12; j2 = 0 <= ref12 ? ++i12 : --i12) {
              push_integer(i5 + j2 + 1);
              inverse();
              p1.tensor.elem[i5 * n9 + j2] = pop();
            }
          }
          push(p1);
          return restore();
        };
        DEBUG_IMAG = false;
        Eval_imag = function() {
          push(cadr(p1));
          Eval();
          return imag();
        };
        imag = function() {
          save();
          rect();
          p1 = pop();
          if (DEBUG_IMAG) {
            console.log("IMAGE of " + p1);
          }
          push(p1);
          push(p1);
          conjugate();
          if (DEBUG_IMAG) {
            console.log(" image: conjugate result: " + stack[tos - 1]);
          }
          subtract();
          push_integer(2);
          divide();
          if (DEBUG_IMAG) {
            console.log(" image: 1st divide result: " + stack[tos - 1]);
          }
          push(imaginaryunit);
          divide();
          if (DEBUG_IMAG) {
            console.log(" image: 2nd divide result: " + stack[tos - 1]);
          }
          return restore();
        };
        index_function = function(n9) {
          var i5, i12, j12, k3, l1, m3, m1, ndim, nelem, o12, ref2, ref12, ref22, ref3, ref4, ref5, ref6, ref7, s8, t5;
          i5 = 0;
          k3 = 0;
          m3 = 0;
          ndim = 0;
          nelem = 0;
          t5 = 0;
          save();
          s8 = tos - n9;
          p1 = stack[s8];
          ndim = p1.tensor.ndim;
          m3 = n9 - 1;
          if (m3 > ndim) {
            stop("too many indices for tensor");
          }
          k3 = 0;
          for (i5 = o12 = 0, ref2 = m3; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            push(stack[s8 + i5 + 1]);
            t5 = pop_integer();
            if (t5 < 1 || t5 > p1.tensor.dim[i5]) {
              stop("index out of range");
            }
            k3 = k3 * p1.tensor.dim[i5] + t5 - 1;
          }
          if (ndim === m3) {
            moveTos(tos - n9);
            push(p1.tensor.elem[k3]);
            restore();
            return;
          }
          for (i5 = i12 = ref12 = m3, ref22 = ndim; ref12 <= ref22 ? i12 < ref22 : i12 > ref22; i5 = ref12 <= ref22 ? ++i12 : --i12) {
            k3 = k3 * p1.tensor.dim[i5] + 0;
          }
          nelem = 1;
          for (i5 = j12 = ref3 = m3, ref4 = ndim; ref3 <= ref4 ? j12 < ref4 : j12 > ref4; i5 = ref3 <= ref4 ? ++j12 : --j12) {
            nelem *= p1.tensor.dim[i5];
          }
          p2 = alloc_tensor(nelem);
          p2.tensor.ndim = ndim - m3;
          for (i5 = l1 = ref5 = m3, ref6 = ndim; ref5 <= ref6 ? l1 < ref6 : l1 > ref6; i5 = ref5 <= ref6 ? ++l1 : --l1) {
            p2.tensor.dim[i5 - m3] = p1.tensor.dim[i5];
          }
          for (i5 = m1 = 0, ref7 = nelem; 0 <= ref7 ? m1 < ref7 : m1 > ref7; i5 = 0 <= ref7 ? ++m1 : --m1) {
            p2.tensor.elem[i5] = p1.tensor.elem[k3 + i5];
          }
          check_tensor_dimensions(p1);
          check_tensor_dimensions(p2);
          moveTos(tos - n9);
          push(p2);
          return restore();
        };
        set_component = function(n9) {
          var i5, i12, j12, k3, l1, m3, m1, n1, ndim, o12, ref2, ref12, ref22, ref3, ref4, ref5, ref6, s8, t5;
          i5 = 0;
          k3 = 0;
          m3 = 0;
          ndim = 0;
          t5 = 0;
          save();
          if (n9 < 3) {
            stop("error in indexed assign");
          }
          s8 = tos - n9;
          p2 = stack[s8];
          p1 = stack[s8 + 1];
          if (!istensor(p1)) {
            stop("error in indexed assign: assigning to something that is not a tensor");
          }
          ndim = p1.tensor.ndim;
          m3 = n9 - 2;
          if (m3 > ndim) {
            stop("error in indexed assign");
          }
          k3 = 0;
          for (i5 = o12 = 0, ref2 = m3; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            push(stack[s8 + i5 + 2]);
            t5 = pop_integer();
            if (t5 < 1 || t5 > p1.tensor.dim[i5]) {
              stop("error in indexed assign\n");
            }
            k3 = k3 * p1.tensor.dim[i5] + t5 - 1;
          }
          for (i5 = i12 = ref12 = m3, ref22 = ndim; ref12 <= ref22 ? i12 < ref22 : i12 > ref22; i5 = ref12 <= ref22 ? ++i12 : --i12) {
            k3 = k3 * p1.tensor.dim[i5] + 0;
          }
          p3 = alloc_tensor(p1.tensor.nelem);
          p3.tensor.ndim = p1.tensor.ndim;
          for (i5 = j12 = 0, ref3 = p1.tensor.ndim; 0 <= ref3 ? j12 < ref3 : j12 > ref3; i5 = 0 <= ref3 ? ++j12 : --j12) {
            p3.tensor.dim[i5] = p1.tensor.dim[i5];
          }
          for (i5 = l1 = 0, ref4 = p1.tensor.nelem; 0 <= ref4 ? l1 < ref4 : l1 > ref4; i5 = 0 <= ref4 ? ++l1 : --l1) {
            p3.tensor.elem[i5] = p1.tensor.elem[i5];
          }
          check_tensor_dimensions(p1);
          check_tensor_dimensions(p3);
          p1 = p3;
          if (ndim === m3) {
            if (istensor(p2)) {
              stop("error in indexed assign");
            }
            p1.tensor.elem[k3] = p2;
            check_tensor_dimensions(p1);
            moveTos(tos - n9);
            push(p1);
            restore();
            return;
          }
          if (!istensor(p2)) {
            stop("error in indexed assign");
          }
          if (ndim - m3 !== p2.tensor.ndim) {
            stop("error in indexed assign");
          }
          for (i5 = m1 = 0, ref5 = p2.tensor.ndim; 0 <= ref5 ? m1 < ref5 : m1 > ref5; i5 = 0 <= ref5 ? ++m1 : --m1) {
            if (p1.tensor.dim[m3 + i5] !== p2.tensor.dim[i5]) {
              stop("error in indexed assign");
            }
          }
          for (i5 = n1 = 0, ref6 = p2.tensor.nelem; 0 <= ref6 ? n1 < ref6 : n1 > ref6; i5 = 0 <= ref6 ? ++n1 : --n1) {
            p1.tensor.elem[k3 + i5] = p2.tensor.elem[i5];
          }
          check_tensor_dimensions(p1);
          check_tensor_dimensions(p2);
          moveTos(tos - n9);
          push(p1);
          return restore();
        };
        Eval_inner = function() {
          var difference2, i5, i12, j12, l1, moretheArguments, o12, operands, ref2, ref12, ref22, ref3, refinedOperands, results, secondArgument, shift, theArguments;
          theArguments = [];
          theArguments.push(car(cdr(p1)));
          secondArgument = car(cdr(cdr(p1)));
          if (secondArgument === symbol(NIL)) {
            stop("pattern needs at least a template and a transformed version");
          }
          moretheArguments = cdr(cdr(p1));
          while (moretheArguments !== symbol(NIL)) {
            theArguments.push(car(moretheArguments));
            moretheArguments = cdr(moretheArguments);
          }
          if (theArguments.length > 2) {
            push_symbol(INNER);
            push(theArguments[theArguments.length - 2]);
            push(theArguments[theArguments.length - 1]);
            list(3);
            for (i5 = o12 = 2, ref2 = theArguments.length; 2 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 2 <= ref2 ? ++o12 : --o12) {
              push_symbol(INNER);
              swap();
              push(theArguments[theArguments.length - i5 - 1]);
              swap();
              list(3);
            }
            p1 = pop();
            Eval_inner();
            return;
          }
          operands = [];
          get_innerprod_factors(p1, operands);
          refinedOperands = [];
          for (i5 = i12 = 0, ref12 = operands.length; 0 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
            if (operands[i5] === symbol(SYMBOL_IDENTITY_MATRIX)) {
              continue;
            } else {
              refinedOperands.push(operands[i5]);
            }
          }
          operands = refinedOperands;
          refinedOperands = [];
          if (operands.length > 1) {
            shift = 0;
            for (i5 = j12 = 0, ref22 = operands.length; 0 <= ref22 ? j12 < ref22 : j12 > ref22; i5 = 0 <= ref22 ? ++j12 : --j12) {
              if (i5 + shift + 1 <= operands.length - 1) {
                if (!(isNumericAtomOrTensor(operands[i5 + shift]) || isNumericAtomOrTensor(operands[i5 + shift + 1]))) {
                  push(operands[i5 + shift]);
                  Eval();
                  inv();
                  push(operands[i5 + shift + 1]);
                  Eval();
                  subtract();
                  difference2 = pop();
                  if (isZeroAtomOrTensor(difference2)) {
                    shift += 1;
                  } else {
                    refinedOperands.push(operands[i5 + shift]);
                  }
                } else {
                  refinedOperands.push(operands[i5 + shift]);
                }
              } else {
                break;
              }
              if (i5 + shift === operands.length - 2) {
                refinedOperands.push(operands[operands.length - 1]);
              }
              if (i5 + shift >= operands.length - 1) {
                break;
              }
            }
            operands = refinedOperands;
          }
          push(symbol(INNER));
          if (operands.length > 0) {
            for (i5 = l1 = 0, ref3 = operands.length; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i5 = 0 <= ref3 ? ++l1 : --l1) {
              push(operands[i5]);
            }
          } else {
            pop();
            push(symbol(SYMBOL_IDENTITY_MATRIX));
            return;
          }
          list(operands.length + 1);
          p1 = pop();
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p1 = cdr(p1);
          results = [];
          while (iscons(p1)) {
            push(car(p1));
            Eval();
            inner();
            results.push(p1 = cdr(p1));
          }
          return results;
        };
        inner = function() {
          var arg1, arg2, arg3, subtractionResult;
          save();
          p2 = pop();
          p1 = pop();
          if (isnegativeterm(p2) && isnegativeterm(p1)) {
            push(p2);
            negate();
            p2 = pop();
            push(p1);
            negate();
            p1 = pop();
          }
          if (isinnerordot(p1)) {
            arg1 = car(cdr(p1));
            arg2 = car(cdr(cdr(p1)));
            arg3 = p2;
            p1 = arg1;
            push(arg2);
            push(arg3);
            inner();
            p2 = pop();
          }
          if (p1 === symbol(SYMBOL_IDENTITY_MATRIX)) {
            push(p2);
            restore();
            return;
          } else if (p2 === symbol(SYMBOL_IDENTITY_MATRIX)) {
            push(p1);
            restore();
            return;
          }
          if (istensor(p1) && istensor(p2)) {
            inner_f();
          } else {
            if (!(isNumericAtomOrTensor(p1) || isNumericAtomOrTensor(p2))) {
              push(p1);
              push(p2);
              inv();
              subtract();
              subtractionResult = pop();
              if (isZeroAtomOrTensor(subtractionResult)) {
                push_symbol(SYMBOL_IDENTITY_MATRIX);
                restore();
                return;
              }
            }
            if (expanding && isadd(p1)) {
              p1 = cdr(p1);
              push(zero);
              while (iscons(p1)) {
                push(car(p1));
                push(p2);
                inner();
                add();
                p1 = cdr(p1);
              }
              restore();
              return;
            }
            if (expanding && isadd(p2)) {
              p2 = cdr(p2);
              push(zero);
              while (iscons(p2)) {
                push(p1);
                push(car(p2));
                inner();
                add();
                p2 = cdr(p2);
              }
              restore();
              return;
            }
            push(p1);
            push(p2);
            if (istensor(p1) && isNumericAtom(p2)) {
              tensor_times_scalar();
            } else if (isNumericAtom(p1) && istensor(p2)) {
              scalar_times_tensor();
            } else {
              if (isNumericAtom(p1) || isNumericAtom(p2)) {
                multiply();
              } else {
                pop();
                pop();
                push_symbol(INNER);
                push(p1);
                push(p2);
                list(3);
                restore();
                return;
              }
            }
          }
          return restore();
        };
        inner_f = function() {
          var a5, ak, b2, bk, c9, i5, i12, j2, j12, k3, l1, m1, n9, n1, ndim, o12, o1, ref2, ref12, ref22, ref3, ref4, ref5, ref6;
          i5 = 0;
          n9 = p1.tensor.dim[p1.tensor.ndim - 1];
          if (n9 !== p2.tensor.dim[0]) {
            debugger;
            stop("inner: tensor dimension check");
          }
          ndim = p1.tensor.ndim + p2.tensor.ndim - 2;
          if (ndim > MAXDIM) {
            stop("inner: rank of result exceeds maximum");
          }
          a5 = p1.tensor.elem;
          b2 = p2.tensor.elem;
          ak = 1;
          for (i5 = o12 = 0, ref2 = p1.tensor.ndim - 1; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            ak *= p1.tensor.dim[i5];
          }
          bk = 1;
          for (i5 = i12 = 1, ref12 = p2.tensor.ndim; 1 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 1 <= ref12 ? ++i12 : --i12) {
            bk *= p2.tensor.dim[i5];
          }
          p3 = alloc_tensor(ak * bk);
          c9 = p3.tensor.elem;
          for (i5 = j12 = 0, ref22 = ak; 0 <= ref22 ? j12 < ref22 : j12 > ref22; i5 = 0 <= ref22 ? ++j12 : --j12) {
            for (j2 = l1 = 0, ref3 = n9; 0 <= ref3 ? l1 < ref3 : l1 > ref3; j2 = 0 <= ref3 ? ++l1 : --l1) {
              if (isZeroAtomOrTensor(a5[i5 * n9 + j2])) {
                continue;
              }
              for (k3 = m1 = 0, ref4 = bk; 0 <= ref4 ? m1 < ref4 : m1 > ref4; k3 = 0 <= ref4 ? ++m1 : --m1) {
                push(a5[i5 * n9 + j2]);
                push(b2[j2 * bk + k3]);
                multiply();
                push(c9[i5 * bk + k3]);
                add();
                c9[i5 * bk + k3] = pop();
              }
            }
          }
          if (ndim === 0) {
            return push(p3.tensor.elem[0]);
          } else {
            p3.tensor.ndim = ndim;
            j2 = 0;
            for (i5 = n1 = 0, ref5 = p1.tensor.ndim - 1; 0 <= ref5 ? n1 < ref5 : n1 > ref5; i5 = 0 <= ref5 ? ++n1 : --n1) {
              p3.tensor.dim[i5] = p1.tensor.dim[i5];
            }
            j2 = p1.tensor.ndim - 1;
            for (i5 = o1 = 0, ref6 = p2.tensor.ndim - 1; 0 <= ref6 ? o1 < ref6 : o1 > ref6; i5 = 0 <= ref6 ? ++o1 : --o1) {
              p3.tensor.dim[j2 + i5] = p2.tensor.dim[i5 + 1];
            }
            return push(p3);
          }
        };
        get_innerprod_factors = function(tree2, factors_accumulator) {
          if (!iscons(tree2)) {
            add_factor_to_accumulator(tree2, factors_accumulator);
            return;
          }
          if (cdr(tree2) === symbol(NIL)) {
            tree2 = get_innerprod_factors(car(tree2), factors_accumulator);
            return;
          }
          if (isinnerordot(tree2)) {
            get_innerprod_factors(car(cdr(tree2)), factors_accumulator);
            get_innerprod_factors(cdr(cdr(tree2)), factors_accumulator);
            return;
          }
          return add_factor_to_accumulator(tree2, factors_accumulator);
        };
        add_factor_to_accumulator = function(tree2, factors_accumulator) {
          if (tree2 !== symbol(NIL)) {
            return factors_accumulator.push(tree2);
          }
        };
        itab = [
          // 1
          "f(a,a*x)",
          // 9 (need a caveat for 7 so we can put 9 after 7)
          "f(1/x,log(x))",
          // 7
          "f(x^a,x^(a+1)/(a+1))",
          // five specialisations of case 7 for speed.
          // Covers often-occurring exponents: each of
          // these case ends up in a dedicated entry, so we
          // only have to do one sure-shot match.
          "f(x^(-2),-x^(-1))",
          "f(x^(-1/2),2*x^(1/2))",
          "f(x^(1/2),2/3*x^(3/2))",
          "f(x,x^2/2)",
          "f(x^2,x^3/3)",
          // 12
          "f(exp(a*x),1/a*exp(a*x))",
          "f(exp(a*x+b),1/a*exp(a*x+b))",
          "f(x*exp(a*x^2),exp(a*x^2)/(2*a))",
          "f(x*exp(a*x^2+b),exp(a*x^2+b)/(2*a))",
          // 14
          "f(log(a*x),x*log(a*x)-x)",
          // 15
          "f(a^x,a^x/log(a),or(not(number(a)),a>0))",
          // 16
          "f(1/(a+x^2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))",
          // 17
          "f(1/(a-x^2),1/sqrt(a)*arctanh(x/sqrt(a)))",
          // 19
          "f(1/sqrt(a-x^2),arcsin(x/(sqrt(a))))",
          // 20
          "f(1/sqrt(a+x^2),log(x+sqrt(a+x^2)))",
          // 27
          "f(1/(a+b*x),1/b*log(a+b*x))",
          // 28
          "f(1/(a+b*x)^2,-1/(b*(a+b*x)))",
          // 29
          "f(1/(a+b*x)^3,-1/(2*b)*1/(a+b*x)^2)",
          // 30
          "f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)",
          // 31
          "f(x/(a+b*x)^2,1/b^2*(log(a+b*x)+a/(a+b*x)))",
          // 33
          "f(x^2/(a+b*x),1/b^2*(1/2*(a+b*x)^2-2*a*(a+b*x)+a^2*log(a+b*x)))",
          // 34
          "f(x^2/(a+b*x)^2,1/b^3*(a+b*x-2*a*log(a+b*x)-a^2/(a+b*x)))",
          // 35
          "f(x^2/(a+b*x)^3,1/b^3*(log(a+b*x)+2*a/(a+b*x)-1/2*a^2/(a+b*x)^2))",
          // 37
          "f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))",
          // 38
          "f(1/x*1/(a+b*x)^2,1/a*1/(a+b*x)-1/a^2*log((a+b*x)/x))",
          // 39
          "f(1/x*1/(a+b*x)^3,1/a^3*(1/2*((2*a+b*x)/(a+b*x))^2+log(x/(a+b*x))))",
          // 40
          "f(1/x^2*1/(a+b*x),-1/(a*x)+b/a^2*log((a+b*x)/x))",
          // 41
          "f(1/x^3*1/(a+b*x),(2*b*x-a)/(2*a^2*x^2)+b^2/a^3*log(x/(a+b*x)))",
          // 42
          "f(1/x^2*1/(a+b*x)^2,-(a+2*b*x)/(a^2*x*(a+b*x))+2*b/a^3*log((a+b*x)/x))",
          // 60
          "f(1/(a+b*x^2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))",
          // 61
          "f(1/(a+b*x^2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))",
          // 62 is the same as 60
          // 63
          "f(x/(a+b*x^2),1/2*1/b*log(a+b*x^2))",
          //64
          "f(x^2/(a+b*x^2),x/b-a/b*integral(1/(a+b*x^2),x))",
          //65
          "f(1/(a+b*x^2)^2,x/(2*a*(a+b*x^2))+1/2*1/a*integral(1/(a+b*x^2),x))",
          //66 is covered by 61
          //70
          "f(1/x*1/(a+b*x^2),1/2*1/a*log(x^2/(a+b*x^2)))",
          //71
          "f(1/x^2*1/(a+b*x^2),-1/(a*x)-b/a*integral(1/(a+b*x^2),x))",
          //74
          "f(1/(a+b*x^3),1/3*1/a*(a/b)^(1/3)*(1/2*log(((a/b)^(1/3)+x)^3/(a+b*x^3))+sqrt(3)*arctan((2*x-(a/b)^(1/3))*(a/b)^(-1/3)/sqrt(3))))",
          //76
          "f(x^2/(a+b*x^3),1/3*1/b*log(a+b*x^3))",
          // float(defint(1/(2+3*X^4),X,0,pi)) gave wrong result.
          // Also, the tests related to the indefinite integral
          // fail since we rationalise expressions "better", so I'm thinking
          // to take this out completely as it seemed to give the
          // wrong results in the first place.
          //77
          //"f(1/(a+b*x^4),1/2*1/a*(a/b/4)^(1/4)*(1/2*log((x^2+2*(a/b/4)^(1/4)*x+2*(a/b/4)^(1/2))/(x^2-2*(a/b/4)^(1/4)*x+2*(a/b/4)^(1/2)))+arctan(2*(a/b/4)^(1/4)*x/(2*(a/b/4)^(1/2)-x^2))),or(not(number(a*b)),a*b>0))",
          //78
          //"f(1/(a+b*x^4),1/2*(-a/b)^(1/4)/a*(1/2*log((x+(-a/b)^(1/4))/(x-(-a/b)^(1/4)))+arctan(x*(-a/b)^(-1/4))),or(not(number(a*b)),a*b<0))",
          //79
          "f(x/(a+b*x^4),1/2*sqrt(b/a)/b*arctan(x^2*sqrt(b/a)),or(not(number(a*b)),a*b>0))",
          //80
          "f(x/(a+b*x^4),1/4*sqrt(-b/a)/b*log((x^2-sqrt(-a/b))/(x^2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))",
          // float(defint(X^2/(2+3*X^4),X,0,pi)) gave wrong result.
          // Also, the tests related to the indefinite integral
          // fail since we rationalise expressions "better", so I'm thinking
          // to take this out completely as it seemed to give the
          // wrong results in the first place.
          //81
          //"f(x^2/(a+b*x^4),1/4*1/b*(a/b/4)^(-1/4)*(1/2*log((x^2-2*(a/b/4)^(1/4)*x+2*sqrt(a/b/4))/(x^2+2*(a/b/4)^(1/4)*x+2*sqrt(a/b/4)))+arctan(2*(a/b/4)^(1/4)*x/(2*sqrt(a/b/4)-x^2))),or(not(number(a*b)),a*b>0))",
          //82
          //"f(x^2/(a+b*x^4),1/4*1/b*(-a/b)^(-1/4)*(log((x-(-a/b)^(1/4))/(x+(-a/b)^(1/4)))+2*arctan(x*(-a/b)^(-1/4))),or(not(number(a*b)),a*b<0))",
          //83
          "f(x^3/(a+b*x^4),1/4*1/b*log(a+b*x^4))",
          //124
          "f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))",
          //125
          "f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)^3)/15/b^2)",
          //126
          "f(x^2*sqrt(a+b*x),2*(8*a^2-12*a*b*x+15*b^2*x^2)*sqrt((a+b*x)^3)/105/b^3)",
          //128
          "f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))",
          //129
          "f(sqrt(a+b*x)/x^2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))",
          //131
          "f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)",
          //132
          "f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b^2)",
          //133
          "f(x^2/sqrt(a+b*x),2/15*(8*a^2-4*a*b*x+3*b^2*x^2)*sqrt(a+b*x)/b^3)",
          //135
          "f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))",
          //136
          "f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))",
          //137
          "f(1/x^2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))",
          //156
          "f(sqrt(x^2+a),1/2*(x*sqrt(x^2+a)+a*log(x+sqrt(x^2+a))))",
          //157
          "f(1/sqrt(x^2+a),log(x+sqrt(x^2+a)))",
          //158
          "f(1/x*1/sqrt(x^2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))",
          //159
          "f(1/x*1/sqrt(x^2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))",
          //160
          "f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))",
          //161
          "f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))",
          //162
          "f(x/sqrt(x^2+a),sqrt(x^2+a))",
          //163
          "f(x*sqrt(x^2+a),1/3*sqrt((x^2+a)^3))",
          //164 need an unexpanded version?
          "f(sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2+a^(1/3))^3)+3/2*a^(1/3)*x*sqrt(x^2+a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2+a^(1/3)))))",
          // match doesn't work for the following
          "f(sqrt(-a+x^6-3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2-a^(1/3))^3)-3/2*a^(1/3)*x*sqrt(x^2-a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2-a^(1/3)))))",
          //165
          "f(1/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),x/a^(1/3)/sqrt(x^2+a^(1/3)))",
          //166
          "f(x/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),-1/sqrt(x^2+a^(1/3)))",
          //167
          "f(x*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/5*sqrt((x^2+a^(1/3))^5))",
          //168
          "f(x^2*sqrt(x^2+a),1/4*x*sqrt((x^2+a)^3)-1/8*a*x*sqrt(x^2+a)-1/8*a^2*log(x+sqrt(x^2+a)))",
          //169
          "f(x^3*sqrt(x^2+a),(1/5*x^2-2/15*a)*sqrt((x^2+a)^3),and(number(a),a>0))",
          //170
          "f(x^3*sqrt(x^2+a),sqrt((x^2+a)^5)/5-a*sqrt((x^2+a)^3)/3,and(number(a),a<0))",
          //171
          "f(x^2/sqrt(x^2+a),1/2*x*sqrt(x^2+a)-1/2*a*log(x+sqrt(x^2+a)))",
          //172
          "f(x^3/sqrt(x^2+a),1/3*sqrt((x^2+a)^3)-a*sqrt(x^2+a))",
          //173
          "f(1/x^2*1/sqrt(x^2+a),-sqrt(x^2+a)/a/x)",
          //174
          "f(1/x^3*1/sqrt(x^2+a),-1/2*sqrt(x^2+a)/a/x^2+1/2*log((sqrt(a)+sqrt(x^2+a))/x)/a^(3/2),or(not(number(a)),a>0))",
          //175
          "f(1/x^3*1/sqrt(x^2-a),1/2*sqrt(x^2-a)/a/x^2+1/2*1/(a^(3/2))*arcsec(x/(a^(1/2))),or(not(number(a)),a>0))",
          //176+
          "f(x^2*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/6*x*sqrt((x^2+a^(1/3))^5)-1/24*a^(1/3)*x*sqrt((x^2+a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2+a^(1/3))-1/16*a*log(x+sqrt(x^2+a^(1/3))),or(not(number(a)),a>0))",
          //176-
          "f(x^2*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/6*x*sqrt((x^2-a^(1/3))^5)+1/24*a^(1/3)*x*sqrt((x^2-a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2-a^(1/3))+1/16*a*log(x+sqrt(x^2-a^(1/3))),or(not(number(a)),a>0))",
          //177+
          "f(x^3*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/7*sqrt((x^2+a^(1/3))^7)-1/5*a^(1/3)*sqrt((x^2+a^(1/3))^5),or(not(number(a)),a>0))",
          //177-
          "f(x^3*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/7*sqrt((x^2-a^(1/3))^7)+1/5*a^(1/3)*sqrt((x^2-a^(1/3))^5),or(not(number(a)),a>0))",
          //196
          "f(1/(x-a)/sqrt(x^2-a^2),-sqrt(x^2-a^2)/a/(x-a))",
          //197
          "f(1/(x+a)/sqrt(x^2-a^2),sqrt(x^2-a^2)/a/(x+a))",
          //200+
          "f(sqrt(a-x^2),1/2*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(abs(a)))))",
          //201    (seems to be handled somewhere else)
          //202
          "f(1/x*1/sqrt(a-x^2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))",
          //203
          "f(sqrt(a-x^2)/x,sqrt(a-x^2)-sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))",
          //204
          "f(x/sqrt(a-x^2),-sqrt(a-x^2))",
          //205
          "f(x*sqrt(a-x^2),-1/3*sqrt((a-x^2)^3))",
          //210
          "f(x^2*sqrt(a-x^2),-x/4*sqrt((a-x^2)^3)+1/8*a*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))",
          //211
          "f(x^3*sqrt(a-x^2),(-1/5*x^2-2/15*a)*sqrt((a-x^2)^3),or(not(number(a)),a>0))",
          //214
          "f(x^2/sqrt(a-x^2),-x/2*sqrt(a-x^2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))",
          //215
          "f(1/x^2*1/sqrt(a-x^2),-sqrt(a-x^2)/a/x,or(not(number(a)),a>0))",
          //216
          "f(sqrt(a-x^2)/x^2,-sqrt(a-x^2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))",
          //217
          "f(sqrt(a-x^2)/x^3,-1/2*sqrt(a-x^2)/x^2+1/2*log((sqrt(a)+sqrt(a-x^2))/x)/sqrt(a),or(not(number(a)),a>0))",
          //218
          "f(sqrt(a-x^2)/x^4,-1/3*sqrt((a-x^2)^3)/a/x^3,or(not(number(a)),a>0))",
          // 273
          "f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*log(x*sqrt(a)+sqrt(a*x^2+b))/2/sqrt(a),and(number(a),a>0))",
          // 274
          "f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))",
          // 290
          "f(sin(a*x),-cos(a*x)/a)",
          // 291
          "f(cos(a*x),sin(a*x)/a)",
          // 292
          "f(tan(a*x),-log(cos(a*x))/a)",
          // 293
          "f(1/tan(a*x),log(sin(a*x))/a)",
          // 294
          "f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)",
          // 295
          "f(1/sin(a*x),log(tan(a*x/2))/a)",
          // 296
          "f(sin(a*x)^2,x/2-sin(2*a*x)/(4*a))",
          // 297
          "f(sin(a*x)^3,-cos(a*x)*(sin(a*x)^2+2)/(3*a))",
          // 298
          "f(sin(a*x)^4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))",
          // 302
          "f(cos(a*x)^2,x/2+sin(2*a*x)/(4*a))",
          // 303
          "f(cos(a*x)^3,sin(a*x)*(cos(a*x)^2+2)/(3*a))",
          // 304
          "f(cos(a*x)^4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))",
          // 308
          "f(1/sin(a*x)^2,-1/(a*tan(a*x)))",
          // 312
          "f(1/cos(a*x)^2,tan(a*x)/a)",
          // 318
          "f(sin(a*x)*cos(a*x),sin(a*x)^2/(2*a))",
          // 320
          "f(sin(a*x)^2*cos(a*x)^2,-sin(4*a*x)/(32*a)+x/8)",
          // 326
          "f(sin(a*x)/cos(a*x)^2,1/(a*cos(a*x)))",
          // 327
          "f(sin(a*x)^2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)",
          // 328
          "f(cos(a*x)/sin(a*x)^2,-1/(a*sin(a*x)))",
          // 329
          "f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)",
          // 330
          "f(1/(sin(a*x)*cos(a*x)^2),(1/cos(a*x)+log(tan(a*x/2)))/a)",
          // 331
          "f(1/(sin(a*x)^2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)",
          // 333
          "f(1/(sin(a*x)^2*cos(a*x)^2),-2/(a*tan(2*a*x)))",
          // 335
          "f(sin(a+b*x),-cos(a+b*x)/b)",
          // 336
          "f(cos(a+b*x),sin(a+b*x)/b)",
          // 337+ (with the addition of b)
          "f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)",
          // 337- (with the addition of b)
          "f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)",
          // 338 (with the addition of b)
          "f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)",
          // 339 (with the addition of b)
          "f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)",
          // 340
          "f(1/(a+b*sin(x)),1/sqrt(b^2-a^2)*log((a*tan(x/2)+b-sqrt(b^2-a^2))/(a*tan(x/2)+b+sqrt(b^2-a^2))),b^2-a^2)",
          // check that b^2-a^2 is not zero
          // 341
          "f(1/(a+b*cos(x)),1/sqrt(b^2-a^2)*log((sqrt(b^2-a^2)*tan(x/2)+a+b)/(sqrt(b^2-a^2)*tan(x/2)-a-b)),b^2-a^2)",
          // check that b^2-a^2 is not zero
          // 389
          "f(x*sin(a*x),sin(a*x)/a^2-x*cos(a*x)/a)",
          // 390
          "f(x^2*sin(a*x),2*x*sin(a*x)/a^2-(a^2*x^2-2)*cos(a*x)/a^3)",
          // 393
          "f(x*cos(a*x),cos(a*x)/a^2+x*sin(a*x)/a)",
          // 394
          "f(x^2*cos(a*x),2*x*cos(a*x)/a^2+(a^2*x^2-2)*sin(a*x)/a^3)",
          // 441
          "f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a^2*x^2)/a)",
          // 442
          "f(arccos(a*x),x*arccos(a*x)-sqrt(1-a^2*x^2)/a)",
          // 443
          "f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a^2*x^2)/a)",
          // 485 (with addition of a)
          // however commenting out since it's a duplicate of 14
          // "f(log(a*x),x*log(a*x)-x)",
          // 486 (with addition of a)
          "f(x*log(a*x),x^2*log(a*x)/2-x^2/4)",
          // 487 (with addition of a)
          "f(x^2*log(a*x),x^3*log(a*x)/3-1/9*x^3)",
          // 489
          "f(log(x)^2,x*log(x)^2-2*x*log(x)+2*x)",
          // 493 (with addition of a)
          "f(1/x*1/(a+log(x)),log(a+log(x)))",
          // 499
          "f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)",
          // 500
          "f(log(a*x+b)/x^2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)",
          // 554
          "f(sinh(x),cosh(x))",
          // 555
          "f(cosh(x),sinh(x))",
          // 556
          "f(tanh(x),log(cosh(x)))",
          // 560
          "f(x*sinh(x),x*cosh(x)-sinh(x))",
          // 562
          "f(x*cosh(x),x*sinh(x)-cosh(x))",
          // 566
          "f(sinh(x)^2,sinh(2*x)/4-x/2)",
          // 569
          "f(tanh(x)^2,x-tanh(x))",
          // 572
          "f(cosh(x)^2,sinh(2*x)/4+x/2)",
          // ?
          "f(x^3*exp(a*x^2),exp(a*x^2)*(x^2/a-1/(a^2))/2)",
          // ?
          "f(x^3*exp(a*x^2+b),exp(a*x^2)*exp(b)*(x^2/a-1/(a^2))/2)",
          // ?
          "f(exp(a*x^2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)",
          // ?
          "f(erf(a*x),x*erf(a*x)+exp(-a^2*x^2)/a/sqrt(pi))",
          // these are needed for the surface integral in the manual
          "f(x^2*(1-x^2)^(3/2),(x*sqrt(1-x^2)*(-8*x^4+14*x^2-3)+3*arcsin(x))/48)",
          "f(x^2*(1-x^2)^(5/2),(x*sqrt(1-x^2)*(48*x^6-136*x^4+118*x^2-15)+15*arcsin(x))/384)",
          "f(x^4*(1-x^2)^(3/2),(-x*sqrt(1-x^2)*(16*x^6-24*x^4+2*x^2+3)+3*arcsin(x))/128)",
          "f(x*exp(a*x),exp(a*x)*(a*x-1)/(a^2))",
          "f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a^2))",
          "f(x^2*exp(a*x),exp(a*x)*(a^2*x^2-2*a*x+2)/(a^3))",
          "f(x^2*exp(a*x+b),exp(a*x+b)*(a^2*x^2-2*a*x+2)/(a^3))",
          "f(x^3*exp(a*x),exp(a*x)*x^3/a-3/a*integral(x^2*exp(a*x),x))",
          "f(x^3*exp(a*x+b),exp(a*x+b)*x^3/a-3/a*integral(x^2*exp(a*x+b),x))",
          0
        ];
        Eval_integral = function() {
          var doNothing, i5, i12, n9, o12, ref2, ref12;
          i5 = 0;
          n9 = 0;
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p2 = pop();
          if (p2 === symbol(NIL)) {
            guess();
            push(symbol(NIL));
          } else if (isNumericAtom(p2)) {
            guess();
            push(p2);
          } else {
            push(p2);
            p1 = cdr(p1);
            push(car(p1));
            Eval();
          }
          p5 = pop();
          p4 = pop();
          p3 = pop();
          while (1) {
            if (isNumericAtom(p5)) {
              push(p5);
              n9 = pop_integer();
              if (isNaN(n9)) {
                stop("nth integral: check n");
              }
            } else {
              n9 = 1;
            }
            push(p3);
            if (n9 >= 0) {
              for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
                push(p4);
                integral();
              }
            } else {
              n9 = -n9;
              for (i5 = i12 = 0, ref12 = n9; 0 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
                push(p4);
                derivative();
              }
            }
            p3 = pop();
            if (p5 === symbol(NIL)) {
              break;
            }
            if (isNumericAtom(p5)) {
              p1 = cdr(p1);
              push(car(p1));
              Eval();
              p5 = pop();
              if (p5 === symbol(NIL)) {
                break;
              }
              if (isNumericAtom(p5)) {
                doNothing = 1;
              } else {
                p4 = p5;
                p1 = cdr(p1);
                push(car(p1));
                Eval();
                p5 = pop();
              }
            } else {
              p4 = p5;
              p1 = cdr(p1);
              push(car(p1));
              Eval();
              p5 = pop();
            }
          }
          return push(p3);
        };
        integral = function() {
          save();
          p2 = pop();
          p1 = pop();
          if (car(p1) === symbol(ADD)) {
            integral_of_sum();
          } else if (car(p1) === symbol(MULTIPLY)) {
            integral_of_product();
          } else {
            integral_of_form();
          }
          p1 = pop();
          if (Find(p1, symbol(INTEGRAL))) {
            stop("integral: sorry, could not find a solution");
          }
          push(p1);
          simplify();
          Eval();
          return restore();
        };
        integral_of_sum = function() {
          var results;
          p1 = cdr(p1);
          push(car(p1));
          push(p2);
          integral();
          p1 = cdr(p1);
          results = [];
          while (iscons(p1)) {
            push(car(p1));
            push(p2);
            integral();
            add();
            results.push(p1 = cdr(p1));
          }
          return results;
        };
        integral_of_product = function() {
          push(p1);
          push(p2);
          partition();
          p1 = pop();
          integral_of_form();
          return multiply();
        };
        integral_of_form = function() {
          var hc, tab;
          hc = italu_hashcode(p1, p2).toFixed(6);
          tab = hashed_itab[hc];
          if (!tab) {
            push_symbol(INTEGRAL);
            push(p1);
            push(p2);
            list(3);
            return;
          }
          push(p1);
          push(p2);
          transform(tab, false);
          p3 = pop();
          if (p3 === symbol(NIL)) {
            push_symbol(INTEGRAL);
            push(p1);
            push(p2);
            return list(3);
          } else {
            return push(p3);
          }
        };
        hashcode_values = {
          "x": 0.95532,
          "constexp": 1.43762,
          "constant": 1.1441659362941434,
          "constbase": 1.2036412230421882,
          "sin": 1.7330548251830322,
          "arcsin": 1.6483368529465805,
          "cos": 1.0586721236863401,
          "arccos": 1.8405225918106694,
          "tan": 1.1224943776292506,
          "arctan": 1.1297397925394963,
          "sinh": 1.8176164926060079,
          "cosh": 1.9404934661708022,
          "tanh": 1.6421307715103122,
          "log": 1.477443701354924,
          "erf": 1.0825269225702916
        };
        italu_hashcode = function(u7, x3) {
          var half;
          if (issymbol(u7)) {
            if (equal(u7, x3)) {
              return hashcode_values.x;
            } else {
              return hashcode_values.constant;
            }
          } else if (iscons(u7)) {
            switch (symnum(car(u7))) {
              case ADD:
                return hash_addition(cdr(u7), x3);
              case MULTIPLY:
                return hash_multiplication(cdr(u7), x3);
              case POWER:
                return hash_power(cadr(u7), caddr(u7), x3);
              case EXP:
                return hash_power(symbol(E), cadr(u7), x3);
              case SQRT:
                push_double(0.5);
                half = pop();
                return hash_power(cadr(u7), half, x3);
              default:
                return hash_function(u7, x3);
            }
          }
          return hashcode_values.constant;
        };
        hash_function = function(u7, x3) {
          var arg_hash, base, name;
          if (!Find(cadr(u7), x3)) {
            return hashcode_values.constant;
          }
          name = car(u7);
          arg_hash = italu_hashcode(cadr(u7), x3);
          base = hashcode_values[name.printname];
          if (!base) {
            throw new Error("Unsupported function " + name.printname);
          }
          return Math.pow(base, arg_hash);
        };
        hash_addition = function(terms, x3) {
          var k3, sum3, term, term_hash, term_set, v3;
          term_set = {};
          while (iscons(terms)) {
            term = car(terms);
            terms = cdr(terms);
            term_hash = 0;
            if (Find(term, x3)) {
              term_hash = italu_hashcode(term, x3);
            } else {
              term_hash = hashcode_values.constant;
            }
            term_set[term_hash.toFixed(6)] = true;
          }
          sum3 = 0;
          for (k3 in term_set) {
            if (!hasProp.call(term_set, k3)) continue;
            v3 = term_set[k3];
            sum3 = sum3 + parseFloat(k3, 10);
          }
          return sum3;
        };
        hash_multiplication = function(terms, x3) {
          var product, term;
          product = 1;
          while (iscons(terms)) {
            term = car(terms);
            terms = cdr(terms);
            if (Find(term, x3)) {
              product = product * italu_hashcode(term, x3);
            }
          }
          return product;
        };
        hash_power = function(base, power2, x3) {
          var base_hash, exp_hash;
          base_hash = hashcode_values.constant;
          exp_hash = hashcode_values.constexp;
          if (Find(base, x3)) {
            base_hash = italu_hashcode(base, x3);
          }
          if (Find(power2, x3)) {
            exp_hash = italu_hashcode(power2, x3);
          } else {
            if (base_hash === hashcode_values.constant) {
              return hashcode_values.constant;
            }
            if (isminusone(power2)) {
              exp_hash = -1;
            } else if (isoneovertwo(power2)) {
              exp_hash = 0.5;
            } else if (isminusoneovertwo(power2)) {
              exp_hash = -0.5;
            } else if (equalq(power2, 2, 1)) {
              exp_hash = 2;
            } else if (equalq(power2, -2, 1)) {
              exp_hash = -2;
            }
          }
          return Math.pow(base_hash, exp_hash);
        };
        make_hashed_itab = function() {
          var f7, h5, key, len, o12, s8, tab, u7;
          tab = {};
          for (o12 = 0, len = itab.length; o12 < len; o12++) {
            s8 = itab[o12];
            if (!s8) {
              break;
            }
            scan_meta(s8);
            f7 = pop();
            u7 = cadr(f7);
            h5 = italu_hashcode(u7, symbol(METAX));
            key = h5.toFixed(6);
            if (!tab[key]) {
              tab[key] = [];
            }
            tab[key].push(s8);
          }
          console.log("hashed_itab = " + JSON.stringify(tab, null, 2));
          return tab;
        };
        $.make_hashed_itab = make_hashed_itab;
        hashed_itab = {
          "1.144166": ["f(a,a*x)"],
          "1.046770": ["f(1/x,log(x))"],
          "0.936400": ["f(x^a,x^(a+1)/(a+1))"],
          "1.095727": ["f(x^(-2),-x^(-1))"],
          "1.023118": ["f(x^(-1/2),2*x^(1/2))"],
          "0.977405": ["f(x^(1/2),2/3*x^(3/2))"],
          "0.955320": ["f(x,x^2/2)"],
          "0.912636": ["f(x^2,x^3/3)"],
          "1.137302": ["f(exp(a*x),1/a*exp(a*x))", "f(a^x,a^x/log(a),or(not(number(a)),a>0))"],
          "1.326774": ["f(exp(a*x+b),1/a*exp(a*x+b))"],
          "1.080259": ["f(x*exp(a*x^2),exp(a*x^2)/(2*a))"],
          "1.260228": ["f(x*exp(a*x^2+b),exp(a*x^2+b)/(2*a))"],
          "1.451902": ["f(log(a*x),x*log(a*x)-x)"],
          "0.486192": ["f(1/(a+x^2),1/sqrt(a)*arctan(x/sqrt(a)),or(not(number(a)),a>0))", "f(1/(a-x^2),1/sqrt(a)*arctanh(x/sqrt(a)))", "f(1/(a+b*x^2),1/sqrt(a*b)*arctan(x*sqrt(a*b)/a),or(not(number(a*b)),a*b>0))", "f(1/(a+b*x^2),1/(2*sqrt(-a*b))*log((a+x*sqrt(-a*b))/(a-x*sqrt(-a*b))),or(not(number(a*b)),a*b<0))"],
          "0.697274": ["f(1/sqrt(a-x^2),arcsin(x/(sqrt(a))))", "f(1/sqrt(a+x^2),log(x+sqrt(a+x^2)))", "f(1/sqrt(x^2+a),log(x+sqrt(x^2+a)))"],
          "0.476307": ["f(1/(a+b*x),1/b*log(a+b*x))"],
          "0.226868": ["f(1/(a+b*x)^2,-1/(b*(a+b*x)))"],
          "2.904531": ["f(1/(a+b*x)^3,-1/(2*b)*1/(a+b*x)^2)"],
          "0.455026": ["f(x/(a+b*x),x/b-a*log(a+b*x)/b/b)"],
          "0.216732": ["f(x/(a+b*x)^2,1/b^2*(log(a+b*x)+a/(a+b*x)))"],
          "0.434695": ["f(x^2/(a+b*x),1/b^2*(1/2*(a+b*x)^2-2*a*(a+b*x)+a^2*log(a+b*x)))"],
          "0.207048": ["f(x^2/(a+b*x)^2,1/b^3*(a+b*x-2*a*log(a+b*x)-a^2/(a+b*x)))"],
          "2.650781": ["f(x^2/(a+b*x)^3,1/b^3*(log(a+b*x)+2*a/(a+b*x)-1/2*a^2/(a+b*x)^2))"],
          "0.498584": ["f(1/x*1/(a+b*x),-1/a*log((a+b*x)/x))"],
          "0.237479": ["f(1/x*1/(a+b*x)^2,1/a*1/(a+b*x)-1/a^2*log((a+b*x)/x))"],
          "3.040375": ["f(1/x*1/(a+b*x)^3,1/a^3*(1/2*((2*a+b*x)/(a+b*x))^2+log(x/(a+b*x))))"],
          "0.521902": ["f(1/x^2*1/(a+b*x),-1/(a*x)+b/a^2*log((a+b*x)/x))"],
          "0.446014": ["f(1/x^3*1/(a+b*x),(2*b*x-a)/(2*a^2*x^2)+b^2/a^3*log(x/(a+b*x)))"],
          "0.248586": ["f(1/x^2*1/(a+b*x)^2,-(a+2*b*x)/(a^2*x*(a+b*x))+2*b/a^3*log((a+b*x)/x))"],
          "0.464469": ["f(x/(a+b*x^2),1/2*1/b*log(a+b*x^2))"],
          "0.443716": ["f(x^2/(a+b*x^2),x/b-a/b*integral(1/(a+b*x^2),x))"],
          "0.236382": ["f(1/(a+b*x^2)^2,x/(2*a*(a+b*x^2))+1/2*1/a*integral(1/(a+b*x^2),x))"],
          "0.508931": ["f(1/x*1/(a+b*x^2),1/2*1/a*log(x^2/(a+b*x^2)))"],
          "0.532733": ["f(1/x^2*1/(a+b*x^2),-1/(a*x)-b/a*integral(1/(a+b*x^2),x))"],
          "0.480638": ["f(1/(a+b*x^3),1/3*1/a*(a/b)^(1/3)*(1/2*log(((a/b)^(1/3)+x)^3/(a+b*x^3))+sqrt(3)*arctan((2*x-(a/b)^(1/3))*(a/b)^(-1/3)/sqrt(3))))"],
          "0.438648": ["f(x^2/(a+b*x^3),1/3*1/b*log(a+b*x^3))"],
          "0.459164": ["f(x/(a+b*x^4),1/2*sqrt(b/a)/b*arctan(x^2*sqrt(b/a)),or(not(number(a*b)),a*b>0))", "f(x/(a+b*x^4),1/4*sqrt(-b/a)/b*log((x^2-sqrt(-a/b))/(x^2+sqrt(-a/b))),or(not(number(a*b)),a*b<0))"],
          "0.450070": ["f(x^3/(a+b*x^4),1/4*1/b*log(a+b*x^4))"],
          "1.448960": ["f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))"],
          "1.384221": ["f(x*sqrt(a+b*x),-2*(2*a-3*b*x)*sqrt((a+b*x)^3)/15/b^2)"],
          "1.322374": ["f(x^2*sqrt(a+b*x),2*(8*a^2-12*a*b*x+15*b^2*x^2)*sqrt((a+b*x)^3)/105/b^3)"],
          "1.516728": ["f(sqrt(a+b*x)/x,2*sqrt(a+b*x)+a*integral(1/x*1/sqrt(a+b*x),x))"],
          "1.587665": ["f(sqrt(a+b*x)/x^2,-sqrt(a+b*x)/x+b/2*integral(1/x*1/sqrt(a+b*x),x))"],
          "0.690150": ["f(1/sqrt(a+b*x),2*sqrt(a+b*x)/b)"],
          "0.659314": ["f(x/sqrt(a+b*x),-2/3*(2*a-b*x)*sqrt(a+b*x)/b^2)"],
          "0.629856": ["f(x^2/sqrt(a+b*x),2/15*(8*a^2-4*a*b*x+3*b^2*x^2)*sqrt(a+b*x)/b^3)"],
          "0.722428": ["f(1/x*1/sqrt(a+b*x),1/sqrt(a)*log((sqrt(a+b*x)-sqrt(a))/(sqrt(a+b*x)+sqrt(a))),or(not(number(a)),a>0))", "f(1/x*1/sqrt(a+b*x),2/sqrt(-a)*arctan(sqrt(-(a+b*x)/a)),or(not(number(a)),a<0))"],
          "0.756216": ["f(1/x^2*1/sqrt(a+b*x),-sqrt(a+b*x)/a/x-1/2*b/a*integral(1/x*1/sqrt(a+b*x),x))"],
          "1.434156": ["f(sqrt(x^2+a),1/2*(x*sqrt(x^2+a)+a*log(x+sqrt(x^2+a))))", "f(sqrt(a-x^2),1/2*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(abs(a)))))", "f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*log(x*sqrt(a)+sqrt(a*x^2+b))/2/sqrt(a),and(number(a),a>0))", "f(sqrt(a*x^2+b),x*sqrt(a*x^2+b)/2+b*arcsin(x*sqrt(-a/b))/2/sqrt(-a),and(number(a),a<0))"],
          "0.729886": ["f(1/x*1/sqrt(x^2+a),arcsec(x/sqrt(-a))/sqrt(-a),or(not(number(a)),a<0))", "f(1/x*1/sqrt(x^2+a),-1/sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))", "f(1/x*1/sqrt(a-x^2),-1/sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))"],
          "1.501230": ["f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(a)*log((sqrt(a)+sqrt(x^2+a))/x),or(not(number(a)),a>0))", "f(sqrt(x^2+a)/x,sqrt(x^2+a)-sqrt(-a)*arcsec(x/sqrt(-a)),or(not(number(a)),a<0))", "f(sqrt(a-x^2)/x,sqrt(a-x^2)-sqrt(a)*log((sqrt(a)+sqrt(a-x^2))/x),or(not(number(a)),a>0))"],
          "0.666120": ["f(x/sqrt(x^2+a),sqrt(x^2+a))", "f(x/sqrt(a-x^2),-sqrt(a-x^2))"],
          "1.370077": ["f(x*sqrt(x^2+a),1/3*sqrt((x^2+a)^3))", "f(x*sqrt(a-x^2),-1/3*sqrt((a-x^2)^3))"],
          "1.730087": ["f(sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2+a^(1/3))^3)+3/2*a^(1/3)*x*sqrt(x^2+a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2+a^(1/3)))))", "f(sqrt(-a+x^6-3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/4*(x*sqrt((x^2-a^(1/3))^3)-3/2*a^(1/3)*x*sqrt(x^2-a^(1/3))+3/2*a^(2/3)*log(x+sqrt(x^2-a^(1/3)))))"],
          "0.578006": ["f(1/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),x/a^(1/3)/sqrt(x^2+a^(1/3)))"],
          "0.552180": ["f(x/sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),-1/sqrt(x^2+a^(1/3)))"],
          "1.652787": ["f(x*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/5*sqrt((x^2+a^(1/3))^5))"],
          "1.308862": ["f(x^2*sqrt(x^2+a),1/4*x*sqrt((x^2+a)^3)-1/8*a*x*sqrt(x^2+a)-1/8*a^2*log(x+sqrt(x^2+a)))", "f(x^2*sqrt(a-x^2),-x/4*sqrt((a-x^2)^3)+1/8*a*(x*sqrt(a-x^2)+a*arcsin(x/sqrt(a))),or(not(number(a)),a>0))"],
          "1.342944": ["f(x^3*sqrt(x^2+a),(1/5*x^2-2/15*a)*sqrt((x^2+a)^3),and(number(a),a>0))", "f(x^3*sqrt(x^2+a),sqrt((x^2+a)^5)/5-a*sqrt((x^2+a)^3)/3,and(number(a),a<0))", "f(x^3*sqrt(a-x^2),(-1/5*x^2-2/15*a)*sqrt((a-x^2)^3),or(not(number(a)),a>0))", "f(sqrt(a-x^2)/x^3,-1/2*sqrt(a-x^2)/x^2+1/2*log((sqrt(a)+sqrt(a-x^2))/x)/sqrt(a),or(not(number(a)),a>0))", "f(sqrt(a-x^2)/x^4,-1/3*sqrt((a-x^2)^3)/a/x^3,or(not(number(a)),a>0))"],
          "0.636358": ["f(x^2/sqrt(x^2+a),1/2*x*sqrt(x^2+a)-1/2*a*log(x+sqrt(x^2+a)))", "f(x^2/sqrt(a-x^2),-x/2*sqrt(a-x^2)+a/2*arcsin(x/sqrt(a)),or(not(number(a)),a>0))"],
          "0.652928": ["f(x^3/sqrt(x^2+a),1/3*sqrt((x^2+a)^3)-a*sqrt(x^2+a))", "f(1/x^3*1/sqrt(x^2+a),-1/2*sqrt(x^2+a)/a/x^2+1/2*log((sqrt(a)+sqrt(x^2+a))/x)/a^(3/2),or(not(number(a)),a>0))", "f(1/x^3*1/sqrt(x^2-a),1/2*sqrt(x^2-a)/a/x^2+1/2*1/(a^(3/2))*arcsec(x/(a^(1/2))),or(not(number(a)),a>0))"],
          "0.764022": ["f(1/x^2*1/sqrt(x^2+a),-sqrt(x^2+a)/a/x)", "f(1/x^2*1/sqrt(a-x^2),-sqrt(a-x^2)/a/x,or(not(number(a)),a>0))"],
          "1.578940": ["f(x^2*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/6*x*sqrt((x^2+a^(1/3))^5)-1/24*a^(1/3)*x*sqrt((x^2+a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2+a^(1/3))-1/16*a*log(x+sqrt(x^2+a^(1/3))),or(not(number(a)),a>0))", "f(x^2*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/6*x*sqrt((x^2-a^(1/3))^5)+1/24*a^(1/3)*x*sqrt((x^2-a^(1/3))^3)-1/16*a^(2/3)*x*sqrt(x^2-a^(1/3))+1/16*a*log(x+sqrt(x^2-a^(1/3))),or(not(number(a)),a>0))"],
          "1.620055": ["f(x^3*sqrt(a+x^6+3*a^(1/3)*x^4+3*a^(2/3)*x^2),1/7*sqrt((x^2+a^(1/3))^7)-1/5*a^(1/3)*sqrt((x^2+a^(1/3))^5),or(not(number(a)),a>0))", "f(x^3*sqrt(-a-3*a^(1/3)*x^4+3*a^(2/3)*x^2+x^6),1/7*sqrt((x^2-a^(1/3))^7)+1/5*a^(1/3)*sqrt((x^2-a^(1/3))^5),or(not(number(a)),a>0))"],
          "0.332117": ["f(1/(x-a)/sqrt(x^2-a^2),-sqrt(x^2-a^2)/a/(x-a))", "f(1/(x+a)/sqrt(x^2-a^2),sqrt(x^2-a^2)/a/(x+a))"],
          "1.571443": ["f(sqrt(a-x^2)/x^2,-sqrt(a-x^2)/x-arcsin(x/sqrt(a)),or(not(number(a)),a>0))"],
          "1.690994": ["f(sin(a*x),-cos(a*x)/a)"],
          "1.055979": ["f(cos(a*x),sin(a*x)/a)"],
          "1.116714": ["f(tan(a*x),-log(cos(a*x))/a)"],
          "0.895484": ["f(1/tan(a*x),log(sin(a*x))/a)"],
          "0.946989": ["f(1/cos(a*x),log(tan(pi/4+a*x/2))/a)"],
          "0.591368": ["f(1/sin(a*x),log(tan(a*x/2))/a)"],
          "2.859462": ["f(sin(a*x)^2,x/2-sin(2*a*x)/(4*a))"],
          "2.128050": ["f(sin(a*x)^3,-cos(a*x)*(sin(a*x)^2+2)/(3*a))", "f(sin(a*x)^4,3/8*x-sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))"],
          "1.115091": ["f(cos(a*x)^2,x/2+sin(2*a*x)/(4*a))"],
          "1.081452": ["f(cos(a*x)^3,sin(a*x)*(cos(a*x)^2+2)/(3*a))", "f(cos(a*x)^4,3/8*x+sin(2*a*x)/(4*a)+sin(4*a*x)/(32*a))"],
          "0.349716": ["f(1/sin(a*x)^2,-1/(a*tan(a*x)))"],
          "0.896788": ["f(1/cos(a*x)^2,tan(a*x)/a)"],
          "1.785654": ["f(sin(a*x)*cos(a*x),sin(a*x)^2/(2*a))"],
          "3.188560": ["f(sin(a*x)^2*cos(a*x)^2,-sin(4*a*x)/(32*a)+x/8)"],
          "1.516463": ["f(sin(a*x)/cos(a*x)^2,1/(a*cos(a*x)))"],
          "2.707879": ["f(sin(a*x)^2/cos(a*x),(log(tan(pi/4+a*x/2))-sin(a*x))/a)"],
          "0.369293": ["f(cos(a*x)/sin(a*x)^2,-1/(a*sin(a*x)))"],
          "0.560019": ["f(1/(sin(a*x)*cos(a*x)),log(tan(a*x))/a)"],
          "0.530332": ["f(1/(sin(a*x)*cos(a*x)^2),(1/cos(a*x)+log(tan(a*x/2)))/a)"],
          "0.331177": ["f(1/(sin(a*x)^2*cos(a*x)),(log(tan(pi/4+a*x/2))-1/sin(a*x))/a)"],
          "0.313621": ["f(1/(sin(a*x)^2*cos(a*x)^2),-2/(a*tan(2*a*x)))"],
          "3.172365": ["f(sin(a+b*x),-cos(a+b*x)/b)"],
          "1.127162": ["f(cos(a+b*x),sin(a+b*x)/b)"],
          "0.352714": ["f(1/(b+b*sin(a*x)),-tan(pi/4-a*x/2)/a/b)", "f(1/(b-b*sin(a*x)),tan(pi/4+a*x/2)/a/b)", "f(1/(a+b*sin(x)),1/sqrt(b^2-a^2)*log((a*tan(x/2)+b-sqrt(b^2-a^2))/(a*tan(x/2)+b+sqrt(b^2-a^2))),b^2-a^2)"],
          "0.454515": ["f(1/(b+b*cos(a*x)),tan(a*x/2)/a/b)", "f(1/(b-b*cos(a*x)),-1/tan(a*x/2)/a/b)", "f(1/(a+b*cos(x)),1/sqrt(b^2-a^2)*log((sqrt(b^2-a^2)*tan(x/2)+a+b)/(sqrt(b^2-a^2)*tan(x/2)-a-b)),b^2-a^2)"],
          "1.615441": ["f(x*sin(a*x),sin(a*x)/a^2-x*cos(a*x)/a)"],
          "1.543263": ["f(x^2*sin(a*x),2*x*sin(a*x)/a^2-(a^2*x^2-2)*cos(a*x)/a^3)"],
          "1.008798": ["f(x*cos(a*x),cos(a*x)/a^2+x*sin(a*x)/a)"],
          "0.963724": ["f(x^2*cos(a*x),2*x*cos(a*x)/a^2+(a^2*x^2-2)*sin(a*x)/a^3)"],
          "1.611938": ["f(arcsin(a*x),x*arcsin(a*x)+sqrt(1-a^2*x^2)/a)"],
          "1.791033": ["f(arccos(a*x),x*arccos(a*x)-sqrt(1-a^2*x^2)/a)"],
          "1.123599": ["f(arctan(a*x),x*arctan(a*x)-1/2*log(1+a^2*x^2)/a)"],
          "1.387031": ["f(x*log(a*x),x^2*log(a*x)/2-x^2/4)"],
          "1.325058": ["f(x^2*log(a*x),x^3*log(a*x)/3-1/9*x^3)"],
          "2.108018": ["f(log(x)^2,x*log(x)^2-2*x*log(x)+2*x)"],
          "0.403214": ["f(1/x*1/(a+log(x)),log(a+log(x)))"],
          "2.269268": ["f(log(a*x+b),(a*x+b)*log(a*x+b)/a-x)"],
          "2.486498": ["f(log(a*x+b)/x^2,a/b*log(x)-(a*x+b)*log(a*x+b)/b/x)"],
          "1.769733": ["f(sinh(x),cosh(x))"],
          "1.883858": ["f(cosh(x),sinh(x))"],
          "1.606140": ["f(tanh(x),log(cosh(x)))"],
          "1.690661": ["f(x*sinh(x),x*cosh(x)-sinh(x))"],
          "1.799688": ["f(x*cosh(x),x*sinh(x)-cosh(x))"],
          "3.131954": ["f(sinh(x)^2,sinh(2*x)/4-x/2)"],
          "2.579685": ["f(tanh(x)^2,x-tanh(x))"],
          "3.548923": ["f(cosh(x)^2,sinh(2*x)/4+x/2)"],
          "1.058866": ["f(x^3*exp(a*x^2),exp(a*x^2)*(x^2/a-1/(a^2))/2)"],
          "1.235270": ["f(x^3*exp(a*x^2+b),exp(a*x^2)*exp(b)*(x^2/a-1/(a^2))/2)"],
          "1.130783": ["f(exp(a*x^2),-i*sqrt(pi)*erf(i*sqrt(a)*x)/sqrt(a)/2)"],
          "1.078698": ["f(erf(a*x),x*erf(a*x)+exp(-a^2*x^2)/a/sqrt(pi))"],
          "2.573650": ["f(x^2*(1-x^2)^(3/2),(x*sqrt(1-x^2)*(-8*x^4+14*x^2-3)+3*arcsin(x))/48)", "f(x^2*(1-x^2)^(5/2),(x*sqrt(1-x^2)*(48*x^6-136*x^4+118*x^2-15)+15*arcsin(x))/384)"],
          "2.640666": ["f(x^4*(1-x^2)^(3/2),(-x*sqrt(1-x^2)*(16*x^6-24*x^4+2*x^2+3)+3*arcsin(x))/128)"],
          "1.086487": ["f(x*exp(a*x),exp(a*x)*(a*x-1)/(a^2))"],
          "1.267493": ["f(x*exp(a*x+b),exp(a*x+b)*(a*x-1)/(a^2))"],
          "1.037943": ["f(x^2*exp(a*x),exp(a*x)*(a^2*x^2-2*a*x+2)/(a^3))"],
          "1.210862": ["f(x^2*exp(a*x+b),exp(a*x+b)*(a^2*x^2-2*a*x+2)/(a^3))"],
          "1.064970": ["f(x^3*exp(a*x),exp(a*x)*x^3/a-3/a*integral(x^2*exp(a*x),x))"],
          "1.242392": ["f(x^3*exp(a*x+b),exp(a*x+b)*x^3/a-3/a*integral(x^2*exp(a*x+b),x))"]
        };
        INV_check_arg = function() {
          if (!istensor(p1)) {
            return 0;
          } else if (p1.tensor.ndim !== 2) {
            return 0;
          } else if (p1.tensor.dim[0] !== p1.tensor.dim[1]) {
            return 0;
          } else {
            return 1;
          }
        };
        inv = function() {
          var accumulator, eachEntry, i5, n9, o12, ref2;
          i5 = 0;
          n9 = 0;
          save();
          p1 = pop();
          if (isinv(p1)) {
            push(car(cdr(p1)));
            restore();
            return;
          }
          if (isidentitymatrix(p1)) {
            push(p1);
            restore();
            return;
          }
          if (expanding && isinnerordot(p1)) {
            p1 = cdr(p1);
            accumulator = [];
            while (iscons(p1)) {
              accumulator.push(car(p1));
              p1 = cdr(p1);
            }
            for (eachEntry = o12 = ref2 = accumulator.length - 1; ref2 <= 0 ? o12 <= 0 : o12 >= 0; eachEntry = ref2 <= 0 ? ++o12 : --o12) {
              push(accumulator[eachEntry]);
              inv();
              if (eachEntry !== accumulator.length - 1) {
                inner();
              }
            }
            restore();
            return;
          }
          if (INV_check_arg() === 0) {
            push_symbol(INV);
            push(p1);
            list(2);
            restore();
            return;
          }
          if (isNumericAtomOrTensor(p1)) {
            yyinvg();
          } else {
            push(p1);
            adj();
            push(p1);
            det();
            p2 = pop();
            if (isZeroAtomOrTensor(p2)) {
              stop("inverse of singular matrix");
            }
            push(p2);
            divide();
          }
          return restore();
        };
        invg = function() {
          save();
          p1 = pop();
          if (INV_check_arg() === 0) {
            push_symbol(INVG);
            push(p1);
            list(2);
            restore();
            return;
          }
          yyinvg();
          return restore();
        };
        yyinvg = function() {
          var h5, i5, i12, j2, j12, l1, n9, o12, ref2, ref12, ref22, ref3;
          h5 = 0;
          i5 = 0;
          j2 = 0;
          n9 = 0;
          n9 = p1.tensor.dim[0];
          h5 = tos;
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            for (j2 = i12 = 0, ref12 = n9; 0 <= ref12 ? i12 < ref12 : i12 > ref12; j2 = 0 <= ref12 ? ++i12 : --i12) {
              if (i5 === j2) {
                push(one);
              } else {
                push(zero);
              }
            }
          }
          for (i5 = j12 = 0, ref22 = n9 * n9; 0 <= ref22 ? j12 < ref22 : j12 > ref22; i5 = 0 <= ref22 ? ++j12 : --j12) {
            push(p1.tensor.elem[i5]);
          }
          INV_decomp(n9);
          p1 = alloc_tensor(n9 * n9);
          p1.tensor.ndim = 2;
          p1.tensor.dim[0] = n9;
          p1.tensor.dim[1] = n9;
          for (i5 = l1 = 0, ref3 = n9 * n9; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i5 = 0 <= ref3 ? ++l1 : --l1) {
            p1.tensor.elem[i5] = stack[h5 + i5];
          }
          moveTos(tos - 2 * n9 * n9);
          return push(p1);
        };
        INV_decomp = function(n9) {
          var a5, d3, i5, i12, j2, j12, l1, o12, ref2, ref12, ref22, ref3, ref4, results, u7;
          a5 = 0;
          d3 = 0;
          i5 = 0;
          j2 = 0;
          u7 = 0;
          a5 = tos - n9 * n9;
          u7 = a5 - n9 * n9;
          results = [];
          for (d3 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; d3 = 0 <= ref2 ? ++o12 : --o12) {
            if (equal(stack[a5 + n9 * d3 + d3], zero)) {
              for (i5 = i12 = ref12 = d3 + 1, ref22 = n9; ref12 <= ref22 ? i12 < ref22 : i12 > ref22; i5 = ref12 <= ref22 ? ++i12 : --i12) {
                if (!equal(stack[a5 + n9 * i5 + d3], zero)) {
                  break;
                }
              }
              if (i5 === n9) {
                stop("inverse of singular matrix");
              }
              for (j2 = j12 = 0, ref3 = n9; 0 <= ref3 ? j12 < ref3 : j12 > ref3; j2 = 0 <= ref3 ? ++j12 : --j12) {
                p2 = stack[a5 + n9 * d3 + j2];
                stack[a5 + n9 * d3 + j2] = stack[a5 + n9 * i5 + j2];
                stack[a5 + n9 * i5 + j2] = p2;
                p2 = stack[u7 + n9 * d3 + j2];
                stack[u7 + n9 * d3 + j2] = stack[u7 + n9 * i5 + j2];
                stack[u7 + n9 * i5 + j2] = p2;
              }
            }
            p2 = stack[a5 + n9 * d3 + d3];
            for (j2 = l1 = 0, ref4 = n9; 0 <= ref4 ? l1 < ref4 : l1 > ref4; j2 = 0 <= ref4 ? ++l1 : --l1) {
              if (j2 > d3) {
                push(stack[a5 + n9 * d3 + j2]);
                push(p2);
                divide();
                stack[a5 + n9 * d3 + j2] = pop();
              }
              push(stack[u7 + n9 * d3 + j2]);
              push(p2);
              divide();
              stack[u7 + n9 * d3 + j2] = pop();
            }
            results.push(function() {
              var m1, ref5, results1;
              results1 = [];
              for (i5 = m1 = 0, ref5 = n9; 0 <= ref5 ? m1 < ref5 : m1 > ref5; i5 = 0 <= ref5 ? ++m1 : --m1) {
                if (i5 === d3) {
                  continue;
                }
                p2 = stack[a5 + n9 * i5 + d3];
                results1.push(function() {
                  var n1, ref6, results2;
                  results2 = [];
                  for (j2 = n1 = 0, ref6 = n9; 0 <= ref6 ? n1 < ref6 : n1 > ref6; j2 = 0 <= ref6 ? ++n1 : --n1) {
                    if (j2 > d3) {
                      push(stack[a5 + n9 * i5 + j2]);
                      push(stack[a5 + n9 * d3 + j2]);
                      push(p2);
                      multiply();
                      subtract();
                      stack[a5 + n9 * i5 + j2] = pop();
                    }
                    push(stack[u7 + n9 * i5 + j2]);
                    push(stack[u7 + n9 * d3 + j2]);
                    push(p2);
                    multiply();
                    subtract();
                    results2.push(stack[u7 + n9 * i5 + j2] = pop());
                  }
                  return results2;
                }());
              }
              return results1;
            }());
          }
          return results;
        };
        DEBUG_IS = false;
        isZeroAtom = function(p11) {
          switch (p11.k) {
            case NUM:
              return MZERO(p11.q.a);
            case DOUBLE:
              return p11.d === 0;
            default:
              return false;
          }
        };
        isZeroTensor = function(p11) {
          var i5, o12, ref2;
          if (p11.k !== TENSOR) {
            return 0;
          }
          for (i5 = o12 = 0, ref2 = p11.tensor.nelem; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            if (!isZeroAtomOrTensor(p11.tensor.elem[i5])) {
              return 0;
            }
          }
          return 1;
        };
        isZeroAtomOrTensor = function(p11) {
          return isZeroAtom(p11) || isZeroTensor(p11);
        };
        isZeroLikeOrNonZeroLikeOrUndetermined = function(valueOrPredicate) {
          var evalledArgument;
          push(valueOrPredicate);
          Eval_predicate();
          evalledArgument = pop();
          if (isZeroAtomOrTensor(evalledArgument)) {
            return 0;
          }
          if (isNumericAtomOrTensor(evalledArgument)) {
            return 1;
          }
          push(evalledArgument);
          zzfloat();
          evalledArgument = pop();
          if (isZeroAtomOrTensor(evalledArgument)) {
            return 0;
          }
          if (isNumericAtomOrTensor(evalledArgument)) {
            return 1;
          }
          if (Find(evalledArgument, imaginaryunit)) {
            push(evalledArgument);
            absValFloat();
            Eval_predicate();
            evalledArgument = pop();
            if (isZeroAtomOrTensor(evalledArgument)) {
              return 0;
            }
            if (isNumericAtomOrTensor(evalledArgument)) {
              return 1;
            }
          }
          return null;
        };
        isnegativenumber = function(p11) {
          switch (p11.k) {
            case NUM:
              if (MSIGN(p11.q.a) === -1) {
                return 1;
              }
              break;
            case DOUBLE:
              if (p11.d < 0) {
                return 1;
              }
          }
          return 0;
        };
        ispositivenumber = function(p11) {
          switch (p11.k) {
            case NUM:
              if (MSIGN(p11.q.a) === 1) {
                return 1;
              }
              break;
            case DOUBLE:
              if (p11.d > 0) {
                return 1;
              }
          }
          return 0;
        };
        isplustwo = function(p11) {
          switch (p11.k) {
            case NUM:
              if (MEQUAL(p11.q.a, 2) && MEQUAL(p11.q.b, 1)) {
                return 1;
              }
              break;
            case DOUBLE:
              if (p11.d === 2) {
                return 1;
              }
          }
          return 0;
        };
        isplusone = function(p11) {
          switch (p11.k) {
            case NUM:
              if (MEQUAL(p11.q.a, 1) && MEQUAL(p11.q.b, 1)) {
                return 1;
              }
              break;
            case DOUBLE:
              if (p11.d === 1) {
                return 1;
              }
          }
          return 0;
        };
        isminusone = function(p11) {
          switch (p11.k) {
            case NUM:
              if (MEQUAL(p11.q.a, -1) && MEQUAL(p11.q.b, 1)) {
                return 1;
              }
              break;
            case DOUBLE:
              if (p11.d === -1) {
                return 1;
              }
          }
          return 0;
        };
        isone = function(p11) {
          return isplusone(p11) || isminusone(p11);
        };
        isinteger = function(p11) {
          if (p11.k === NUM && MEQUAL(p11.q.b, 1)) {
            return 1;
          } else {
            return 0;
          }
        };
        isintegerorintegerfloat = function(p11) {
          if (p11.k === DOUBLE) {
            if (p11.d === Math.round(p11.d)) {
              return 1;
            }
            return 0;
          }
          return isinteger(p11);
        };
        isnonnegativeinteger = function(p11) {
          if (isrational(p11) && MEQUAL(p11.q.b, 1) && MSIGN(p11.q.a) === 1) {
            return 1;
          } else {
            return 0;
          }
        };
        isposint = function(p11) {
          if (isinteger(p11) && MSIGN(p11.q.a) === 1) {
            return 1;
          } else {
            return 0;
          }
        };
        isunivarpolyfactoredorexpandedform = function(p11, x3) {
          if (DEBUG) {
            console.log("isunivarpolyfactoredorexpandedform: p: " + p11 + " x: " + x3);
          }
          if (x3 == null) {
            push(p11);
            guess();
            x3 = pop();
            pop();
          }
          if (ispolyfactoredorexpandedform(p11, x3) && Find(p11, symbol(SYMBOL_X)) + Find(p11, symbol(SYMBOL_Y)) + Find(p11, symbol(SYMBOL_Z)) === 1) {
            return x3;
          } else {
            return 0;
          }
        };
        ispolyfactoredorexpandedform = function(p11, x3) {
          return ispolyfactoredorexpandedform_factor(p11, x3);
        };
        ispolyfactoredorexpandedform_factor = function(p11, x3) {
          if (car(p11) === symbol(MULTIPLY)) {
            p11 = cdr(p11);
            while (iscons(p11)) {
              if (DEBUG) {
                console.log("ispolyfactoredorexpandedform_factor testing " + car(p11));
              }
              if (!ispolyfactoredorexpandedform_power(car(p11), x3)) {
                if (DEBUG) {
                  console.log("... tested negative:" + car(p11));
                }
                return 0;
              }
              p11 = cdr(p11);
            }
            return 1;
          } else {
            return ispolyfactoredorexpandedform_power(p11, x3);
          }
        };
        ispolyfactoredorexpandedform_power = function(p11, x3) {
          if (car(p11) === symbol(POWER)) {
            if (DEBUG) {
              console.log("ispolyfactoredorexpandedform_power (isposint(caddr(p)) " + (isposint(caddr(p11)), DEBUG ? console.log("ispolyfactoredorexpandedform_power ispolyexpandedform_expr(cadr(p), x)) " + ispolyexpandedform_expr(cadr(p11), x3)) : void 0));
            }
            return isposint(caddr(p11)) && ispolyexpandedform_expr(cadr(p11), x3);
          } else {
            if (DEBUG) {
              console.log("ispolyfactoredorexpandedform_power not a power, testing if this is exp form: " + p11);
            }
            return ispolyexpandedform_expr(p11, x3);
          }
        };
        ispolyexpandedform = function(p11, x3) {
          if (Find(p11, x3)) {
            return ispolyexpandedform_expr(p11, x3);
          } else {
            return 0;
          }
        };
        ispolyexpandedform_expr = function(p11, x3) {
          if (car(p11) === symbol(ADD)) {
            p11 = cdr(p11);
            while (iscons(p11)) {
              if (!ispolyexpandedform_term(car(p11), x3)) {
                return 0;
              }
              p11 = cdr(p11);
            }
            return 1;
          } else {
            return ispolyexpandedform_term(p11, x3);
          }
        };
        ispolyexpandedform_term = function(p11, x3) {
          if (car(p11) === symbol(MULTIPLY)) {
            p11 = cdr(p11);
            while (iscons(p11)) {
              if (!ispolyexpandedform_factor(car(p11), x3)) {
                return 0;
              }
              p11 = cdr(p11);
            }
            return 1;
          } else {
            return ispolyexpandedform_factor(p11, x3);
          }
        };
        ispolyexpandedform_factor = function(p11, x3) {
          if (equal(p11, x3)) {
            return 1;
          }
          if (car(p11) === symbol(POWER) && equal(cadr(p11), x3)) {
            if (isposint(caddr(p11))) {
              return 1;
            } else {
              return 0;
            }
          }
          if (Find(p11, x3)) {
            return 0;
          } else {
            return 1;
          }
        };
        isnegativeterm = function(p11) {
          if (isnegativenumber(p11)) {
            return 1;
          } else if (car(p11) === symbol(MULTIPLY) && isnegativenumber(cadr(p11))) {
            return 1;
          } else {
            return 0;
          }
        };
        hasNegativeRationalExponent = function(p11) {
          if (car(p11) === symbol(POWER) && isrational(car(cdr(cdr(p11)))) && isnegativenumber(car(cdr(p11)))) {
            if (DEBUG_IS) {
              console.log("hasNegativeRationalExponent: " + p11.toString() + " has imaginary component");
            }
            return 1;
          } else {
            if (DEBUG_IS) {
              console.log("hasNegativeRationalExponent: " + p11.toString() + " has NO imaginary component");
            }
            return 0;
          }
        };
        isimaginarynumberdouble = function(p11) {
          if (car(p11) === symbol(MULTIPLY) && length(p11) === 3 && isdouble(cadr(p11)) && hasNegativeRationalExponent(caddr(p11)) || equal(p11, imaginaryunit)) {
            return 1;
          } else {
            return 0;
          }
        };
        isimaginarynumber = function(p11) {
          if (car(p11) === symbol(MULTIPLY) && length(p11) === 3 && isNumericAtom(cadr(p11)) && equal(caddr(p11), imaginaryunit) || equal(p11, imaginaryunit) || hasNegativeRationalExponent(caddr(p11))) {
            if (DEBUG_IS) {
              console.log("isimaginarynumber: " + p11.toString() + " is imaginary number");
            }
            return 1;
          } else {
            if (DEBUG_IS) {
              console.log("isimaginarynumber: " + p11.toString() + " isn't an imaginary number");
            }
            return 0;
          }
        };
        iscomplexnumberdouble = function(p11) {
          if (car(p11) === symbol(ADD) && length(p11) === 3 && isdouble(cadr(p11)) && isimaginarynumberdouble(caddr(p11)) || isimaginarynumberdouble(p11)) {
            return 1;
          } else {
            return 0;
          }
        };
        iscomplexnumber = function(p11) {
          if (DEBUG_IS) {
            debugger;
          }
          if (car(p11) === symbol(ADD) && length(p11) === 3 && isNumericAtom(cadr(p11)) && isimaginarynumber(caddr(p11)) || isimaginarynumber(p11)) {
            if (DEBUG) {
              console.log("iscomplexnumber: " + p11.toString() + " is imaginary number");
            }
            return 1;
          } else {
            if (DEBUG) {
              console.log("iscomplexnumber: " + p11.toString() + " is imaginary number");
            }
            return 0;
          }
        };
        iseveninteger = function(p11) {
          if (isinteger(p11) && p11.q.a.isEven()) {
            return 1;
          } else {
            return 0;
          }
        };
        isnegative = function(p11) {
          if (car(p11) === symbol(ADD) && isnegativeterm(cadr(p11))) {
            return 1;
          } else if (isnegativeterm(p11)) {
            return 1;
          } else {
            return 0;
          }
        };
        issymbolic = function(p11) {
          if (issymbol(p11)) {
            return 1;
          } else {
            while (iscons(p11)) {
              if (issymbolic(car(p11))) {
                return 1;
              }
              p11 = cdr(p11);
            }
            return 0;
          }
        };
        isintegerfactor = function(p11) {
          return isinteger(p11) || car(p11) === symbol(POWER) && isinteger(cadr(p11)) && isinteger(caddr(p11));
        };
        isNumberOneOverSomething = function(p11) {
          return isfraction(p11) && MEQUAL(p11.q.a.abs(), 1);
        };
        isoneover = function(p11) {
          return car(p11) === symbol(POWER) && isminusone(caddr(p11));
        };
        isfraction = function(p11) {
          return p11.k === NUM && !MEQUAL(p11.q.b, 1);
        };
        equaln = function(p11, n9) {
          switch (p11.k) {
            case NUM:
              return MEQUAL(p11.q.a, n9) && MEQUAL(p11.q.b, 1);
            case DOUBLE:
              return p11.d === n9;
            default:
              return false;
          }
        };
        equalq = function(p11, a5, b2) {
          switch (p11.k) {
            case NUM:
              return MEQUAL(p11.q.a, a5) && MEQUAL(p11.q.b, b2);
            case DOUBLE:
              return p11.d === a5 / b2;
            default:
              return false;
          }
        };
        isoneovertwo = function(p11) {
          return equalq(p11, 1, 2);
        };
        isminusoneovertwo = function(p11) {
          return equalq(p11, -1, 2);
        };
        isoneoversqrttwo = function(p11) {
          return car(p11) === symbol(POWER) && equaln(cadr(p11), 2) && equalq(caddr(p11), -1, 2);
        };
        isminusoneoversqrttwo = function(p11) {
          return car(p11) === symbol(MULTIPLY) && equaln(cadr(p11), -1) && isoneoversqrttwo(caddr(p11)) && length(p11) === 3;
        };
        issqrtthreeovertwo = function(p11) {
          return car(p11) === symbol(MULTIPLY) && isoneovertwo(cadr(p11)) && issqrtthree(caddr(p11)) && length(p11) === 3;
        };
        isminussqrtthreeovertwo = function(p11) {
          return car(p11) === symbol(MULTIPLY) && isminusoneovertwo(cadr(p11)) && issqrtthree(caddr(p11)) && length(p11) === 3;
        };
        issqrtthree = function(p11) {
          return car(p11) === symbol(POWER) && equaln(cadr(p11), 3) && isoneovertwo(caddr(p11));
        };
        isfloating = function(p11) {
          if (p11.k === DOUBLE || p11 === symbol(FLOATF)) {
            return 1;
          }
          while (iscons(p11)) {
            if (isfloating(car(p11))) {
              return 1;
            }
            p11 = cdr(p11);
          }
          return 0;
        };
        isimaginaryunit = function(p11) {
          if (equal(p11, imaginaryunit)) {
            return 1;
          } else {
            return 0;
          }
        };
        isquarterturn = function(p11) {
          var minussign, n9;
          n9 = 0;
          minussign = 0;
          if (car(p11) !== symbol(MULTIPLY)) {
            return 0;
          }
          if (equal(cadr(p11), imaginaryunit)) {
            if (caddr(p11) !== symbol(PI)) {
              return 0;
            }
            if (length(p11) !== 3) {
              return 0;
            }
            return 2;
          }
          if (!isNumericAtom(cadr(p11))) {
            return 0;
          }
          if (!equal(caddr(p11), imaginaryunit)) {
            return 0;
          }
          if (cadddr(p11) !== symbol(PI)) {
            return 0;
          }
          if (length(p11) !== 4) {
            return 0;
          }
          push(cadr(p11));
          push_integer(2);
          multiply();
          n9 = pop_integer();
          if (isNaN(n9)) {
            return 0;
          }
          if (n9 < 1) {
            minussign = 1;
            n9 = -n9;
          }
          switch (n9 % 4) {
            case 0:
              n9 = 1;
              break;
            case 1:
              if (minussign) {
                n9 = 4;
              } else {
                n9 = 3;
              }
              break;
            case 2:
              n9 = 2;
              break;
            case 3:
              if (minussign) {
                n9 = 3;
              } else {
                n9 = 4;
              }
          }
          return n9;
        };
        isnpi = function(p11) {
          var doNothing, n9;
          n9 = 0;
          if (p11 === symbol(PI)) {
            return 2;
          }
          if (car(p11) === symbol(MULTIPLY) && isNumericAtom(cadr(p11)) && caddr(p11) === symbol(PI) && length(p11) === 3) {
            doNothing = 0;
          } else {
            return 0;
          }
          push(cadr(p11));
          push_integer(2);
          multiply();
          n9 = pop_integer();
          if (isNaN(n9)) {
            return 0;
          }
          if (n9 < 0) {
            n9 = 4 - -n9 % 4;
          } else {
            n9 = 1 + (n9 - 1) % 4;
          }
          return n9;
        };
        $.isZeroAtomOrTensor = isZeroAtomOrTensor;
        $.isnegativenumber = isnegativenumber;
        $.isplusone = isplusone;
        $.isminusone = isminusone;
        $.isinteger = isinteger;
        $.isnonnegativeinteger = isnonnegativeinteger;
        $.isposint = isposint;
        $.isnegativeterm = isnegativeterm;
        $.isimaginarynumber = isimaginarynumber;
        $.iscomplexnumber = iscomplexnumber;
        $.iseveninteger = iseveninteger;
        $.isnegative = isnegative;
        $.issymbolic = issymbolic;
        $.isintegerfactor = isintegerfactor;
        $.isoneover = isoneover;
        $.isfraction = isfraction;
        $.isoneoversqrttwo = isoneoversqrttwo;
        $.isminusoneoversqrttwo = isminusoneoversqrttwo;
        $.isfloating = isfloating;
        $.isimaginaryunit = isimaginaryunit;
        $.isquarterturn = isquarterturn;
        $.isnpi = isnpi;
        Eval_isprime = function() {
          push(cadr(p1));
          Eval();
          p1 = pop();
          if (isnonnegativeinteger(p1) && mprime(p1.q.a)) {
            return push_integer(1);
          } else {
            return push_integer(0);
          }
        };
        Eval_laguerre = function() {
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          push(cadddr(p1));
          Eval();
          p2 = pop();
          if (p2 === symbol(NIL)) {
            push_integer(0);
          } else {
            push(p2);
          }
          return laguerre();
        };
        laguerre = function() {
          var n9;
          n9 = 0;
          save();
          p3 = pop();
          p2 = pop();
          p1 = pop();
          push(p2);
          n9 = pop_integer();
          if (n9 < 0 || isNaN(n9)) {
            push_symbol(LAGUERRE);
            push(p1);
            push(p2);
            push(p3);
            list(4);
            restore();
            return;
          }
          if (issymbol(p1)) {
            laguerre2(n9);
          } else {
            p4 = p1;
            p1 = symbol(SECRETX);
            laguerre2(n9);
            p1 = p4;
            push(symbol(SECRETX));
            push(p1);
            subst();
            Eval();
          }
          return restore();
        };
        laguerre2 = function(n9) {
          var i5, o12, ref2, results;
          i5 = 0;
          push_integer(1);
          push_integer(0);
          p6 = pop();
          results = [];
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            p5 = p6;
            p6 = pop();
            push_integer(2 * i5 + 1);
            push(p1);
            subtract();
            push(p3);
            add();
            push(p6);
            multiply();
            push_integer(i5);
            push(p3);
            add();
            push(p5);
            multiply();
            subtract();
            push_integer(i5 + 1);
            results.push(divide());
          }
          return results;
        };
        Eval_lcm = function() {
          var results;
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p1 = cdr(p1);
          results = [];
          while (iscons(p1)) {
            push(car(p1));
            Eval();
            lcm();
            results.push(p1 = cdr(p1));
          }
          return results;
        };
        lcm = function() {
          var prev_expanding;
          prev_expanding = expanding;
          save();
          yylcm();
          restore();
          return expanding = prev_expanding;
        };
        yylcm = function() {
          expanding = 1;
          p2 = pop();
          p1 = pop();
          push(p1);
          push(p2);
          gcd();
          push(p1);
          divide();
          push(p2);
          divide();
          return inverse();
        };
        Eval_leading = function() {
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          p1 = pop();
          if (p1 === symbol(NIL)) {
            guess();
          } else {
            push(p1);
          }
          return leading();
        };
        leading = function() {
          save();
          p2 = pop();
          p1 = pop();
          push(p1);
          push(p2);
          degree();
          p3 = pop();
          push(p1);
          push(p2);
          push(p3);
          power();
          divide();
          push(p2);
          filter();
          return restore();
        };
        Eval_legendre = function() {
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          push(cadddr(p1));
          Eval();
          p2 = pop();
          if (p2 === symbol(NIL)) {
            push_integer(0);
          } else {
            push(p2);
          }
          return legendre();
        };
        legendre = function() {
          save();
          __legendre();
          return restore();
        };
        __legendre = function() {
          var m3, n9;
          m3 = 0;
          n9 = 0;
          p3 = pop();
          p2 = pop();
          p1 = pop();
          push(p2);
          n9 = pop_integer();
          push(p3);
          m3 = pop_integer();
          if (n9 < 0 || isNaN(n9) || m3 < 0 || isNaN(m3)) {
            push_symbol(LEGENDRE);
            push(p1);
            push(p2);
            push(p3);
            list(4);
            return;
          }
          if (issymbol(p1)) {
            __legendre2(n9, m3);
          } else {
            p4 = p1;
            p1 = symbol(SECRETX);
            __legendre2(n9, m3);
            p1 = p4;
            push(symbol(SECRETX));
            push(p1);
            subst();
            Eval();
          }
          return __legendre3(m3);
        };
        __legendre2 = function(n9, m3) {
          var i5, i12, o12, ref2, ref12, results;
          i5 = 0;
          push_integer(1);
          push_integer(0);
          p6 = pop();
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            p5 = p6;
            p6 = pop();
            push_integer(2 * i5 + 1);
            push(p1);
            multiply();
            push(p6);
            multiply();
            push_integer(i5);
            push(p5);
            multiply();
            subtract();
            push_integer(i5 + 1);
            divide();
          }
          results = [];
          for (i5 = i12 = 0, ref12 = m3; 0 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
            push(p1);
            results.push(derivative());
          }
          return results;
        };
        __legendre3 = function(m3) {
          if (m3 === 0) {
            return;
          }
          if (car(p1) === symbol(COS)) {
            push(cadr(p1));
            sine();
            square();
          } else if (car(p1) === symbol(SIN)) {
            push(cadr(p1));
            cosine();
            square();
          } else {
            push_integer(1);
            push(p1);
            square();
            subtract();
          }
          push_integer(m3);
          push_rational(1, 2);
          multiply();
          power();
          multiply();
          if (m3 % 2) {
            return negate();
          }
        };
        list = function(n9) {
          var listIterator, o12, ref2, results;
          listIterator = 0;
          push(symbol(NIL));
          results = [];
          for (listIterator = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; listIterator = 0 <= ref2 ? ++o12 : --o12) {
            results.push(cons());
          }
          return results;
        };
        Eval_log = function() {
          push(cadr(p1));
          Eval();
          return logarithm();
        };
        logarithm = function() {
          save();
          yylog();
          return restore();
        };
        yylog = function() {
          var d3;
          d3 = 0;
          p1 = pop();
          if (p1 === symbol(E)) {
            push_integer(1);
            return;
          }
          if (equaln(p1, 1)) {
            push_integer(0);
            return;
          }
          if (isnegativenumber(p1)) {
            push(p1);
            negate();
            logarithm();
            push(imaginaryunit);
            if (evaluatingAsFloats) {
              push_double(Math.PI);
            } else {
              push_symbol(PI);
            }
            multiply();
            add();
            return;
          }
          if (isdouble(p1)) {
            d3 = Math.log(p1.d);
            push_double(d3);
            return;
          }
          if (isfraction(p1)) {
            push(p1);
            numerator();
            logarithm();
            push(p1);
            denominator();
            logarithm();
            subtract();
            return;
          }
          if (car(p1) === symbol(POWER)) {
            push(caddr(p1));
            push(cadr(p1));
            logarithm();
            multiply();
            return;
          }
          if (car(p1) === symbol(MULTIPLY)) {
            push_integer(0);
            p1 = cdr(p1);
            while (iscons(p1)) {
              push(car(p1));
              logarithm();
              add();
              p1 = cdr(p1);
            }
            return;
          }
          push_symbol(LOG);
          push(p1);
          return list(2);
        };
        Eval_lookup = function() {
          p1 = cadr(p1);
          if (!iscons(p1) && cadr(p1).k === SYM) {
            p1 = get_binding(p1);
          }
          return push(p1);
        };
        madd = function(a5, b2) {
          return a5.add(b2);
        };
        msub = function(a5, b2) {
          return a5.subtract(b2);
        };
        addf = function(a5, b2) {
          return a5.add(b2);
        };
        subf = function(a5, b2) {
          return a5.subtract(b2);
        };
        ucmp = function(a5, b2) {
          return a5.compareAbs(b2);
        };
        mgcd = function(u7, v3) {
          return bigInt.gcd(u7, v3);
        };
        new_string = function(s8) {
          var theNewString;
          theNewString = new U();
          theNewString.k = STR;
          theNewString.str = s8;
          return theNewString;
        };
        out_of_memory = function() {
          return stop("out of memory");
        };
        push_zero_matrix = function(i5, j2) {
          push(alloc_tensor(i5 * j2));
          stack[tos - 1].tensor.ndim = 2;
          stack[tos - 1].tensor.dim[0] = i5;
          return stack[tos - 1].tensor.dim[1] = j2;
        };
        push_identity_matrix = function(n9) {
          var i5, o12, ref2;
          push_zero_matrix(n9, n9);
          for (i5 = o12 = 0, ref2 = n9; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            stack[tos - 1].tensor.elem[i5 * n9 + i5] = one;
          }
          return check_tensor_dimensions(stack[tos - 1]);
        };
        push_cars = function(p11) {
          var results;
          results = [];
          while (iscons(p11)) {
            push(car(p11));
            results.push(p11 = cdr(p11));
          }
          return results;
        };
        equal = function(p12, p22) {
          if (cmp_expr(p12, p22) === 0) {
            return 1;
          } else {
            return 0;
          }
        };
        lessp = function(p12, p22) {
          if (cmp_expr(p12, p22) < 0) {
            return 1;
          } else {
            return 0;
          }
        };
        sign = function(n9) {
          if (n9 < 0) {
            return -1;
          } else if (n9 > 0) {
            return 1;
          } else {
            return 0;
          }
        };
        cmp_expr = function(p12, p22) {
          var n9;
          n9 = 0;
          if (p12 === p22) {
            return 0;
          }
          if (p12 === symbol(NIL)) {
            return -1;
          }
          if (p22 === symbol(NIL)) {
            return 1;
          }
          if (isNumericAtom(p12) && isNumericAtom(p22)) {
            return sign(compare_numbers(p12, p22));
          }
          if (isNumericAtom(p12)) {
            return -1;
          }
          if (isNumericAtom(p22)) {
            return 1;
          }
          if (isstr(p12) && isstr(p22)) {
            return sign(strcmp(p12.str, p22.str));
          }
          if (isstr(p12)) {
            return -1;
          }
          if (isstr(p22)) {
            return 1;
          }
          if (issymbol(p12) && issymbol(p22)) {
            return sign(strcmp(get_printname(p12), get_printname(p22)));
          }
          if (issymbol(p12)) {
            return -1;
          }
          if (issymbol(p22)) {
            return 1;
          }
          if (istensor(p12) && istensor(p22)) {
            return compare_tensors(p12, p22);
          }
          if (istensor(p12)) {
            return -1;
          }
          if (istensor(p22)) {
            return 1;
          }
          while (iscons(p12) && iscons(p22)) {
            n9 = cmp_expr(car(p12), car(p22));
            if (n9 !== 0) {
              return n9;
            }
            p12 = cdr(p12);
            p22 = cdr(p22);
          }
          if (iscons(p22)) {
            return -1;
          }
          if (iscons(p12)) {
            return 1;
          }
          return 0;
        };
        length = function(p11) {
          var n9;
          n9 = 0;
          while (iscons(p11)) {
            p11 = cdr(p11);
            n9++;
          }
          return n9;
        };
        unique = function(p11) {
          save();
          p1 = symbol(NIL);
          p2 = symbol(NIL);
          unique_f(p11);
          if (p2 !== symbol(NIL)) {
            p1 = symbol(NIL);
          }
          p11 = p1;
          restore();
          return p11;
        };
        unique_f = function(p11) {
          if (isstr(p11)) {
            if (p1 === symbol(NIL)) {
              p1 = p11;
            } else if (p11 !== p1) {
              p2 = p11;
            }
            return;
          }
          while (iscons(p11)) {
            unique_f(car(p11));
            if (p2 !== symbol(NIL)) {
              return;
            }
            p11 = cdr(p11);
          }
        };
        ssqrt = function() {
          push_rational(1, 2);
          return power();
        };
        yyexpand = function() {
          var prev_expanding;
          prev_expanding = expanding;
          expanding = 1;
          Eval();
          return expanding = prev_expanding;
        };
        exponential = function() {
          push_symbol(E);
          swap();
          return power();
        };
        square = function() {
          push_integer(2);
          return power();
        };
        sort_stack = function(n9) {
          var h5, subsetOfStack;
          h5 = tos - n9;
          subsetOfStack = stack.slice(h5, h5 + n9);
          subsetOfStack.sort(cmp_expr);
          return stack = stack.slice(0, h5).concat(subsetOfStack).concat(stack.slice(h5 + n9));
        };
        $.equal = equal;
        $.length = length;
        mmul = function(a5, b2) {
          return a5.multiply(b2);
        };
        mdiv = function(a5, b2) {
          return a5.divide(b2);
        };
        mmod = function(a5, b2) {
          return a5.mod(b2);
        };
        mdivrem = function(a5, b2) {
          var toReturn;
          toReturn = a5.divmod(b2);
          return [toReturn.quotient, toReturn.remainder];
        };
        Eval_mod = function() {
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          return mod();
        };
        mod = function() {
          var n9;
          n9 = 0;
          save();
          p2 = pop();
          p1 = pop();
          if (isZeroAtomOrTensor(p2)) {
            stop("mod function: divide by zero");
          }
          if (!isNumericAtom(p1) || !isNumericAtom(p2)) {
            push_symbol(MOD);
            push(p1);
            push(p2);
            list(3);
            restore();
            return;
          }
          if (isdouble(p1)) {
            push(p1);
            n9 = pop_integer();
            if (isNaN(n9)) {
              stop("mod function: cannot convert float value to integer");
            }
            push_integer(n9);
            p1 = pop();
          }
          if (isdouble(p2)) {
            push(p2);
            n9 = pop_integer();
            if (isNaN(n9)) {
              stop("mod function: cannot convert float value to integer");
            }
            push_integer(n9);
            p2 = pop();
          }
          if (!isinteger(p1) || !isinteger(p2)) {
            stop("mod function: integer arguments expected");
          }
          p3 = new U();
          p3.k = NUM;
          p3.q.a = mmod(p1.q.a, p2.q.a);
          p3.q.b = mint(1);
          push(p3);
          return restore();
        };
        mpow = function(a5, n9) {
          return a5.pow(n9);
        };
        mprime = function(n9) {
          return n9.isProbablePrime();
        };
        mroot = function(n9, index2) {
          var i5, j2, k3, o12, ref2, x3, y3;
          n9 = n9.abs();
          i5 = 0;
          j2 = 0;
          k3 = 0;
          if (index2 === 0) {
            stop("root index is zero");
          }
          k3 = 0;
          while (n9.shiftRight(k3) > 0) {
            k3++;
          }
          if (k3 === 0) {
            return mint(0);
          }
          k3 = Math.floor((k3 - 1) / index2);
          j2 = Math.floor(k3 / 32 + 1);
          x3 = bigInt(j2);
          for (i5 = o12 = 0, ref2 = j2; 0 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 0 <= ref2 ? ++o12 : --o12) {
            x3 = x3.and(bigInt(1).shiftLeft(i5).not());
          }
          while (k3 >= 0) {
            x3 = x3.or(bigInt(1).shiftLeft(k3));
            y3 = mpow(x3, index2);
            switch (mcmp(y3, n9)) {
              case 0:
                return x3;
              case 1:
                x3 = x3.and(bigInt(1).shiftLeft(k3).not());
            }
            k3--;
          }
          return 0;
        };
        DEBUG_MULTIPLY = false;
        Eval_multiply = function() {
          var results;
          push(cadr(p1));
          Eval();
          p1 = cddr(p1);
          results = [];
          while (iscons(p1)) {
            push(car(p1));
            Eval();
            multiply();
            results.push(p1 = cdr(p1));
          }
          return results;
        };
        multiply = function() {
          if (esc_flag) {
            stop("escape key stop");
          }
          if (isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {
            return multiply_numbers();
          } else {
            save();
            yymultiply();
            return restore();
          }
        };
        yymultiply = function() {
          var h5, i5, n9, o12, ref2, ref12;
          h5 = 0;
          i5 = 0;
          n9 = 0;
          p2 = pop();
          p1 = pop();
          h5 = tos;
          if (isZeroAtom(p1) || isZeroAtom(p2)) {
            if (evaluatingAsFloats) {
              push_double(0);
            } else {
              push(zero);
            }
            return;
          }
          if (expanding && isadd(p1)) {
            p1 = cdr(p1);
            if (evaluatingAsFloats) {
              push_double(0);
            } else {
              push(zero);
            }
            while (iscons(p1)) {
              push(car(p1));
              push(p2);
              multiply();
              add();
              p1 = cdr(p1);
            }
            return;
          }
          if (expanding && isadd(p2)) {
            p2 = cdr(p2);
            if (evaluatingAsFloats) {
              push_double(0);
            } else {
              push(zero);
            }
            while (iscons(p2)) {
              push(p1);
              push(car(p2));
              multiply();
              add();
              p2 = cdr(p2);
            }
            return;
          }
          if (!istensor(p1) && istensor(p2)) {
            push(p1);
            push(p2);
            scalar_times_tensor();
            return;
          }
          if (istensor(p1) && !istensor(p2)) {
            push(p1);
            push(p2);
            tensor_times_scalar();
            return;
          }
          if (car(p1) === symbol(MULTIPLY)) {
            p1 = cdr(p1);
          } else {
            push(p1);
            list(1);
            p1 = pop();
          }
          if (car(p2) === symbol(MULTIPLY)) {
            p2 = cdr(p2);
          } else {
            push(p2);
            list(1);
            p2 = pop();
          }
          if (isNumericAtom(car(p1)) && isNumericAtom(car(p2))) {
            push(car(p1));
            push(car(p2));
            multiply_numbers();
            p1 = cdr(p1);
            p2 = cdr(p2);
          } else if (isNumericAtom(car(p1))) {
            push(car(p1));
            p1 = cdr(p1);
          } else if (isNumericAtom(car(p2))) {
            push(car(p2));
            p2 = cdr(p2);
          } else {
            if (evaluatingAsFloats) {
              push_double(1);
            } else {
              push(one);
            }
          }
          parse_p1();
          parse_p2();
          while (iscons(p1) && iscons(p2)) {
            if (caar(p1) === symbol(OPERATOR) && caar(p2) === symbol(OPERATOR)) {
              push_symbol(OPERATOR);
              push(cdar(p1));
              push(cdar(p2));
              append();
              cons();
              p1 = cdr(p1);
              p2 = cdr(p2);
              parse_p1();
              parse_p2();
              continue;
            }
            switch (cmp_expr(p3, p4)) {
              case -1:
                push(car(p1));
                p1 = cdr(p1);
                parse_p1();
                break;
              case 1:
                push(car(p2));
                p2 = cdr(p2);
                parse_p2();
                break;
              case 0:
                combine_factors(h5);
                p1 = cdr(p1);
                p2 = cdr(p2);
                parse_p1();
                parse_p2();
                break;
              default:
                stop("internal error 2");
            }
          }
          while (iscons(p1)) {
            push(car(p1));
            p1 = cdr(p1);
          }
          while (iscons(p2)) {
            push(car(p2));
            p2 = cdr(p2);
          }
          __normalize_radical_factors(h5);
          if (expanding) {
            for (i5 = o12 = ref2 = h5, ref12 = tos; ref2 <= ref12 ? o12 < ref12 : o12 > ref12; i5 = ref2 <= ref12 ? ++o12 : --o12) {
              if (isadd(stack[i5])) {
                multiply_all(tos - h5);
                return;
              }
            }
          }
          n9 = tos - h5;
          if (n9 === 1) {
            return;
          }
          if (isrational(stack[h5]) && equaln(stack[h5], 1)) {
            if (n9 === 2) {
              p7 = pop();
              pop();
              push(p7);
            } else {
              stack[h5] = symbol(MULTIPLY);
              list(n9);
            }
            return;
          }
          list(n9);
          p7 = pop();
          push_symbol(MULTIPLY);
          push(p7);
          return cons();
        };
        parse_p1 = function() {
          p3 = car(p1);
          p5 = evaluatingAsFloats ? one_as_double : one;
          if (car(p3) === symbol(POWER)) {
            p5 = caddr(p3);
            return p3 = cadr(p3);
          }
        };
        parse_p2 = function() {
          p4 = car(p2);
          p6 = evaluatingAsFloats ? one_as_double : one;
          if (car(p4) === symbol(POWER)) {
            p6 = caddr(p4);
            return p4 = cadr(p4);
          }
        };
        combine_factors = function(h5) {
          push(p4);
          push(p5);
          push(p6);
          add();
          power();
          p7 = pop();
          if (isNumericAtom(p7)) {
            push(stack[h5]);
            push(p7);
            multiply_numbers();
            return stack[h5] = pop();
          } else if (car(p7) === symbol(MULTIPLY)) {
            if (isNumericAtom(cadr(p7)) && cdddr(p7) === symbol(NIL)) {
              push(stack[h5]);
              push(cadr(p7));
              multiply_numbers();
              stack[h5] = pop();
              return push(caddr(p7));
            } else {
              return push(p7);
            }
          } else {
            return push(p7);
          }
        };
        gp = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, -6, -7, -8, -3, -4, -5, 13, 14, 15, -16, 9, 10, 11, -12], [0, 0, 6, -1, -11, 10, -2, -15, 14, 12, -5, 4, -9, 16, -8, 7, -13], [0, 0, 7, 11, -1, -9, 15, -2, -13, 5, 12, -3, -10, 8, 16, -6, -14], [0, 0, 8, -10, 9, -1, -14, 13, -2, -4, 3, 12, -11, -7, 6, 16, -15], [0, 0, 3, 2, 15, -14, 1, 11, -10, 16, -8, 7, 13, 12, -5, 4, 9], [0, 0, 4, -15, 2, 13, -11, 1, 9, 8, 16, -6, 14, 5, 12, -3, 10], [0, 0, 5, 14, -13, 2, 10, -9, 1, -7, 6, 16, 15, -4, 3, 12, 11], [0, 0, 13, 12, -5, 4, 16, -8, 7, -1, -11, 10, -3, -2, -15, 14, -6], [0, 0, 14, 5, 12, -3, 8, 16, -6, 11, -1, -9, -4, 15, -2, -13, -7], [0, 0, 15, -4, 3, 12, -7, 6, 16, -10, 9, -1, -5, -14, 13, -2, -8], [0, 0, 16, -9, -10, -11, -13, -14, -15, -3, -4, -5, 1, -6, -7, -8, 2], [0, 0, 9, -16, 8, -7, -12, 5, -4, -2, -15, 14, 6, -1, -11, 10, 3], [0, 0, 10, -8, -16, 6, -5, -12, 3, 15, -2, -13, 7, 11, -1, -9, 4], [0, 0, 11, 7, -6, -16, 4, -3, -12, -14, 13, -2, 8, -10, 9, -1, 5], [0, 0, 12, 13, 14, 15, 9, 10, 11, -6, -7, -8, -2, -3, -4, -5, -1]];
        combine_gammas = function(h5) {
          var n9;
          n9 = gp[Math.floor(p1.gamma)][Math.floor(p2.gamma)];
          if (n9 < 0) {
            n9 = -n9;
            push(stack[h5]);
            negate();
            stack[h5] = pop();
          }
          if (n9 > 1) {
            return push(_gamma[n9]);
          }
        };
        multiply_noexpand = function() {
          var prev_expanding;
          prev_expanding = expanding;
          expanding = 0;
          multiply();
          return expanding = prev_expanding;
        };
        multiply_all = function(n9) {
          var h5, i5, o12, ref2;
          i5 = 0;
          if (n9 === 1) {
            return;
          }
          if (n9 === 0) {
            push(evaluatingAsFloats ? one_as_double : one);
            return;
          }
          h5 = tos - n9;
          push(stack[h5]);
          for (i5 = o12 = 1, ref2 = n9; 1 <= ref2 ? o12 < ref2 : o12 > ref2; i5 = 1 <= ref2 ? ++o12 : --o12) {
            push(stack[h5 + i5]);
            multiply();
          }
          stack[h5] = pop();
          return moveTos(h5 + 1);
        };
        multiply_all_noexpand = function(n9) {
          var prev_expanding;
          prev_expanding = expanding;
          expanding = 0;
          multiply_all(n9);
          return expanding = prev_expanding;
        };
        divide = function() {
          if (isNumericAtom(stack[tos - 2]) && isNumericAtom(stack[tos - 1])) {
            return divide_numbers();
          } else {
            inverse();
            return multiply();
          }
        };
        inverse = function() {
          if (isNumericAtom(stack[tos - 1])) {
            return invert_number();
          } else {
            push_integer(-1);
            return power();
          }
        };
        reciprocate = function() {
          return inverse();
        };
        negate = function() {
          if (isNumericAtom(stack[tos - 1])) {
            return negate_number();
          } else {
            if (evaluatingAsFloats) {
              push_double(-1);
            } else {
              push_integer(-1);
            }
            return multiply();
          }
        };
        negate_expand = function() {
          var prev_expanding;
          prev_expanding = expanding;
          expanding = 1;
          negate();
          return expanding = prev_expanding;
        };
        negate_noexpand = function() {
          var prev_expanding;
          prev_expanding = expanding;
          expanding = 0;
          negate();
          return expanding = prev_expanding;
        };
        __normalize_radical_factors = function(h5) {
          var i5, i12, j12, o12, ref2, ref12, ref22, ref3, ref4, ref5;
          i5 = 0;
          if (isplusone(stack[h5]) || isminusone(stack[h5]) || isdouble(stack[h5])) {
            return;
          }
          for (i5 = o12 = ref2 = h5 + 1, ref12 = tos; ref2 <= ref12 ? o12 < ref12 : o12 > ref12; i5 = ref2 <= ref12 ? ++o12 : --o12) {
            if (__is_radical_number(stack[i5])) {
              break;
            }
          }
          if (i5 === tos) {
            return;
          }
          save();
          push(stack[h5]);
          mp_numerator();
          if (DEBUG_MULTIPLY) {
            console.log("__normalize_radical_factors numerator: " + stack[tos - 1]);
          }
          p1 = pop();
          for (i5 = i12 = ref22 = h5 + 1, ref3 = tos; ref22 <= ref3 ? i12 < ref3 : i12 > ref3; i5 = ref22 <= ref3 ? ++i12 : --i12) {
            if (isplusone(p1) || isminusone(p1)) {
              break;
            }
            if (!__is_radical_number(stack[i5])) {
              continue;
            }
            p3 = cadr(stack[i5]);
            p4 = caddr(stack[i5]);
            if (!isnegativenumber(p4)) {
              continue;
            }
            push(p1);
            push(p3);
            divide();
            p5 = pop();
            if (!isinteger(p5)) {
              continue;
            }
            p1 = p5;
            push_symbol(POWER);
            push(p3);
            push(evaluatingAsFloats ? one_as_double : one);
            push(p4);
            add();
            list(3);
            stack[i5] = pop();
          }
          push(stack[h5]);
          mp_denominator();
          if (DEBUG_MULTIPLY) {
            console.log("__normalize_radical_factors denominator: " + stack[tos - 1]);
          }
          p2 = pop();
          for (i5 = j12 = ref4 = h5 + 1, ref5 = tos; ref4 <= ref5 ? j12 < ref5 : j12 > ref5; i5 = ref4 <= ref5 ? ++j12 : --j12) {
            if (isplusone(p2)) {
              break;
            }
            if (!__is_radical_number(stack[i5])) {
              continue;
            }
            p3 = cadr(stack[i5]);
            p4 = caddr(stack[i5]);
            if (isnegativenumber(p4)) {
              continue;
            }
            push(p2);
            push(p3);
            divide();
            p5 = pop();
            if (!isinteger(p5)) {
              continue;
            }
            if (DEBUG_MULTIPLY) {
              console.log("__new radical p5: " + p5.toString());
            }
            if (DEBUG_MULTIPLY) {
              console.log("__new radical top stack: " + stack[tos - 1]);
            }
            p2 = p5;
            push_symbol(POWER);
            push(p3);
            push(p4);
            if (DEBUG_MULTIPLY) {
              console.log("__new radical p3: " + p3.toString());
            }
            if (DEBUG_MULTIPLY) {
              console.log("__new radical p4: " + p4.toString());
            }
            push(one);
            subtract();
            if (dontCreateNewRadicalsInDenominatorWhenEvalingMultiplication) {
              if (isinteger(p3) && !isinteger(stack[tos - 1]) && isnegativenumber(stack[tos - 1])) {
                pop();
                pop();
                pop();
                push(p1);
                push(p3);
                divide();
                p1 = pop();
                break;
              }
            }
            if (DEBUG_MULTIPLY) {
              console.log("__new radical exponent: " + stack[tos - 1]);
            }
            list(3);
            stack[i5] = pop();
          }
          push(p1);
          push(p2);
          divide();
          stack[h5] = pop();
          return restore();
        };
        __is_radical_number = function(p11) {
          return car(p11) === symbol(POWER) && isNumericAtom(cadr(p11)) && isfraction(caddr(p11)) && !isminusone(cadr(p11));
        };
        NROOTS_YMAX = 101;
        NROOTS_DELTA = 1e-6;
        NROOTS_EPSILON = 1e-9;
        NROOTS_ABS = function(z2) {
          return Math.sqrt(z2.r * z2.r + z2.i * z2.i);
        };
        theRandom = 0;
        NROOTS_RANDOM = function() {
          return 4 * Math.random() - 2;
        };
        numericRootOfPolynomial = function() {
          class numericRootOfPolynomial2 {
          }
          ;
          numericRootOfPolynomial2.prototype.r = 0;
          numericRootOfPolynomial2.prototype.i = 0;
          return numericRootOfPolynomial2;
        }.call(this);
        nroots_a = new numericRootOfPolynomial();
        nroots_b = new numericRootOfPolynomial();
        nroots_x = new numericRootOfPolynomial();
        nroots_y = new numericRootOfPolynomial();
        nroots_fa = new numericRootOfPolynomial();
        nroots_fb = new numericRootOfPolynomial();
        nroots_dx = new numericRootOfPolynomial();
        nroots_df = new numericRootOfPolynomial();
        nroots_c = [];
        for (initNRoots = o = 0, ref = NROOTS_YMAX; 0 <= ref ? o < ref : o > ref; initNRoots = 0 <= ref ? ++o : --o) {
          nroots_c[initNRoots] = new numericRootOfPolynomial();
        }
        Eval_nroots = function() {
          var h5, i5, i12, j12, k3, l1, n9, ref12, ref2, ref3;
          h5 = 0;
          i5 = 0;
          k3 = 0;
          n9 = 0;
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          p2 = pop();
          if (p2 === symbol(NIL)) {
            guess();
          } else {
            push(p2);
          }
          p2 = pop();
          p1 = pop();
          if (!ispolyexpandedform(p1, p2)) {
            stop("nroots: polynomial?");
          }
          h5 = tos;
          n9 = coeff(p2, p1);
          if (n9 > NROOTS_YMAX) {
            stop("nroots: degree?");
          }
          for (i5 = i12 = 0, ref12 = n9; 0 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
            push(stack[h5 + i5]);
            real();
            yyfloat();
            Eval();
            p1 = pop();
            push(stack[h5 + i5]);
            imag();
            yyfloat();
            Eval();
            p2 = pop();
            if (!isdouble(p1) || !isdouble(p2)) {
              stop("nroots: coefficients?");
            }
            nroots_c[i5].r = p1.d;
            nroots_c[i5].i = p2.d;
          }
          moveTos(h5);
          monic(n9);
          for (k3 = j12 = ref2 = n9; j12 > 1; k3 = j12 += -1) {
            findroot(k3);
            if (Math.abs(nroots_a.r) < NROOTS_DELTA) {
              nroots_a.r = 0;
            }
            if (Math.abs(nroots_a.i) < NROOTS_DELTA) {
              nroots_a.i = 0;
            }
            push_double(nroots_a.r);
            push_double(nroots_a.i);
            push(imaginaryunit);
            multiply();
            add();
            NROOTS_divpoly(k3);
          }
          n9 = tos - h5;
          if (n9 > 1) {
            sort_stack(n9);
            p1 = alloc_tensor(n9);
            p1.tensor.ndim = 1;
            p1.tensor.dim[0] = n9;
            for (i5 = l1 = 0, ref3 = n9; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i5 = 0 <= ref3 ? ++l1 : --l1) {
              p1.tensor.elem[i5] = stack[h5 + i5];
            }
            moveTos(h5);
            return push(p1);
          }
        };
        monic = function(n9) {
          var i12, k3, ref12, t5;
          k3 = 0;
          t5 = 0;
          nroots_y.r = nroots_c[n9 - 1].r;
          nroots_y.i = nroots_c[n9 - 1].i;
          t5 = nroots_y.r * nroots_y.r + nroots_y.i * nroots_y.i;
          for (k3 = i12 = 0, ref12 = n9 - 1; 0 <= ref12 ? i12 < ref12 : i12 > ref12; k3 = 0 <= ref12 ? ++i12 : --i12) {
            nroots_c[k3].r = (nroots_c[k3].r * nroots_y.r + nroots_c[k3].i * nroots_y.i) / t5;
            nroots_c[k3].i = (nroots_c[k3].i * nroots_y.r - nroots_c[k3].r * nroots_y.i) / t5;
          }
          nroots_c[n9 - 1].r = 1;
          return nroots_c[n9 - 1].i = 0;
        };
        findroot = function(n9) {
          var i12, j2, j12, k3, nrabs, t5;
          j2 = 0;
          k3 = 0;
          t5 = 0;
          if (NROOTS_ABS(nroots_c[0]) < NROOTS_DELTA) {
            nroots_a.r = 0;
            nroots_a.i = 0;
            return;
          }
          for (j2 = i12 = 0; i12 < 100; j2 = ++i12) {
            nroots_a.r = NROOTS_RANDOM();
            nroots_a.i = NROOTS_RANDOM();
            compute_fa(n9);
            nroots_b.r = nroots_a.r;
            nroots_b.i = nroots_a.i;
            nroots_fb.r = nroots_fa.r;
            nroots_fb.i = nroots_fa.i;
            nroots_a.r = NROOTS_RANDOM();
            nroots_a.i = NROOTS_RANDOM();
            for (k3 = j12 = 0; j12 < 1e3; k3 = ++j12) {
              compute_fa(n9);
              nrabs = NROOTS_ABS(nroots_fa);
              if (DEBUG) {
                console.log("nrabs: " + nrabs);
              }
              if (nrabs < NROOTS_EPSILON) {
                return;
              }
              if (NROOTS_ABS(nroots_fa) < NROOTS_ABS(nroots_fb)) {
                nroots_x.r = nroots_a.r;
                nroots_x.i = nroots_a.i;
                nroots_a.r = nroots_b.r;
                nroots_a.i = nroots_b.i;
                nroots_b.r = nroots_x.r;
                nroots_b.i = nroots_x.i;
                nroots_x.r = nroots_fa.r;
                nroots_x.i = nroots_fa.i;
                nroots_fa.r = nroots_fb.r;
                nroots_fa.i = nroots_fb.i;
                nroots_fb.r = nroots_x.r;
                nroots_fb.i = nroots_x.i;
              }
              nroots_dx.r = nroots_b.r - nroots_a.r;
              nroots_dx.i = nroots_b.i - nroots_a.i;
              nroots_df.r = nroots_fb.r - nroots_fa.r;
              nroots_df.i = nroots_fb.i - nroots_fa.i;
              t5 = nroots_df.r * nroots_df.r + nroots_df.i * nroots_df.i;
              if (t5 === 0) {
                break;
              }
              nroots_y.r = (nroots_dx.r * nroots_df.r + nroots_dx.i * nroots_df.i) / t5;
              nroots_y.i = (nroots_dx.i * nroots_df.r - nroots_dx.r * nroots_df.i) / t5;
              nroots_a.r = nroots_b.r - (nroots_y.r * nroots_fb.r - nroots_y.i * nroots_fb.i);
              nroots_a.i = nroots_b.i - (nroots_y.r * nroots_fb.i + nroots_y.i * nroots_fb.r);
            }
          }
          return stop("nroots: convergence error");
        };
        compute_fa = function(n9) {
          var i12, k3, ref12, results, t5;
          k3 = 0;
          t5 = 0;
          nroots_x.r = nroots_a.r;
          nroots_x.i = nroots_a.i;
          nroots_fa.r = nroots_c[0].r + nroots_c[1].r * nroots_x.r - nroots_c[1].i * nroots_x.i;
          nroots_fa.i = nroots_c[0].i + nroots_c[1].r * nroots_x.i + nroots_c[1].i * nroots_x.r;
          results = [];
          for (k3 = i12 = 2, ref12 = n9; 2 <= ref12 ? i12 < ref12 : i12 > ref12; k3 = 2 <= ref12 ? ++i12 : --i12) {
            t5 = nroots_a.r * nroots_x.r - nroots_a.i * nroots_x.i;
            nroots_x.i = nroots_a.r * nroots_x.i + nroots_a.i * nroots_x.r;
            nroots_x.r = t5;
            nroots_fa.r += nroots_c[k3].r * nroots_x.r - nroots_c[k3].i * nroots_x.i;
            results.push(nroots_fa.i += nroots_c[k3].r * nroots_x.i + nroots_c[k3].i * nroots_x.r);
          }
          return results;
        };
        NROOTS_divpoly = function(n9) {
          var i12, j12, k3, ref12, ref2, results;
          k3 = 0;
          for (k3 = i12 = ref12 = n9 - 1; ref12 <= 0 ? i12 < 0 : i12 > 0; k3 = ref12 <= 0 ? ++i12 : --i12) {
            nroots_c[k3 - 1].r += nroots_c[k3].r * nroots_a.r - nroots_c[k3].i * nroots_a.i;
            nroots_c[k3 - 1].i += nroots_c[k3].i * nroots_a.r + nroots_c[k3].r * nroots_a.i;
          }
          if (NROOTS_ABS(nroots_c[0]) > NROOTS_DELTA) {
            stop("nroots: residual error");
          }
          results = [];
          for (k3 = j12 = 0, ref2 = n9 - 1; 0 <= ref2 ? j12 < ref2 : j12 > ref2; k3 = 0 <= ref2 ? ++j12 : --j12) {
            nroots_c[k3].r = nroots_c[k3 + 1].r;
            results.push(nroots_c[k3].i = nroots_c[k3 + 1].i);
          }
          return results;
        };
        Eval_numerator = function() {
          push(cadr(p1));
          Eval();
          return numerator();
        };
        numerator = function() {
          var h5, theArgument2;
          h5 = 0;
          theArgument2 = pop();
          if (car(theArgument2) === symbol(ADD)) {
            push(theArgument2);
            rationalize();
            theArgument2 = pop();
          }
          if (car(theArgument2) === symbol(MULTIPLY) && !isplusone(car(cdr(theArgument2)))) {
            h5 = tos;
            theArgument2 = cdr(theArgument2);
            while (iscons(theArgument2)) {
              push(car(theArgument2));
              numerator();
              theArgument2 = cdr(theArgument2);
            }
            return multiply_all(tos - h5);
          } else if (isrational(theArgument2)) {
            push(theArgument2);
            return mp_numerator();
          } else if (car(theArgument2) === symbol(POWER) && isnegativeterm(caddr(theArgument2))) {
            return push(one);
          } else {
            return push(theArgument2);
          }
        };
        Eval_outer = function() {
          var results;
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p1 = cdr(p1);
          results = [];
          while (iscons(p1)) {
            push(car(p1));
            Eval();
            outer();
            results.push(p1 = cdr(p1));
          }
          return results;
        };
        outer = function() {
          save();
          p2 = pop();
          p1 = pop();
          if (istensor(p1) && istensor(p2)) {
            yyouter();
          } else {
            push(p1);
            push(p2);
            if (istensor(p1)) {
              tensor_times_scalar();
            } else if (istensor(p2)) {
              scalar_times_tensor();
            } else {
              multiply();
            }
          }
          return restore();
        };
        yyouter = function() {
          var i5, i12, j2, j12, k3, l1, m1, ndim, nelem, ref12, ref2, ref3, ref4;
          i5 = 0;
          j2 = 0;
          k3 = 0;
          ndim = 0;
          nelem = 0;
          ndim = p1.tensor.ndim + p2.tensor.ndim;
          if (ndim > MAXDIM) {
            stop("outer: rank of result exceeds maximum");
          }
          nelem = p1.tensor.nelem * p2.tensor.nelem;
          p3 = alloc_tensor(nelem);
          p3.tensor.ndim = ndim;
          for (i5 = i12 = 0, ref12 = p1.tensor.ndim; 0 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
            p3.tensor.dim[i5] = p1.tensor.dim[i5];
          }
          j2 = i5;
          for (i5 = j12 = 0, ref2 = p2.tensor.ndim; 0 <= ref2 ? j12 < ref2 : j12 > ref2; i5 = 0 <= ref2 ? ++j12 : --j12) {
            p3.tensor.dim[j2 + i5] = p2.tensor.dim[i5];
          }
          k3 = 0;
          for (i5 = l1 = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i5 = 0 <= ref3 ? ++l1 : --l1) {
            for (j2 = m1 = 0, ref4 = p2.tensor.nelem; 0 <= ref4 ? m1 < ref4 : m1 > ref4; j2 = 0 <= ref4 ? ++m1 : --m1) {
              push(p1.tensor.elem[i5]);
              push(p2.tensor.elem[j2]);
              multiply();
              p3.tensor.elem[k3++] = pop();
            }
          }
          return push(p3);
        };
        partition = function() {
          save();
          p2 = pop();
          p1 = pop();
          push_integer(1);
          p3 = pop();
          p4 = p3;
          p1 = cdr(p1);
          while (iscons(p1)) {
            if (Find(car(p1), p2)) {
              push(p4);
              push(car(p1));
              multiply();
              p4 = pop();
            } else {
              push(p3);
              push(car(p1));
              multiply();
              p3 = pop();
            }
            p1 = cdr(p1);
          }
          push(p3);
          push(p4);
          return restore();
        };
        Eval_silentpattern = function() {
          Eval_pattern();
          pop();
          return push_symbol(NIL);
        };
        Eval_pattern = function() {
          var firstArgument, patternPosition, secondArgument, stringKey, thirdArgument;
          if (!iscons(cdr(p1))) {
            stop("pattern needs at least a template and a transformed version");
          }
          firstArgument = car(cdr(p1));
          secondArgument = car(cdr(cdr(p1)));
          if (secondArgument === symbol(NIL)) {
            stop("pattern needs at least a template and a transformed version");
          }
          if (!iscons(cdr(cdr(p1)))) {
            thirdArgument = symbol(NIL);
          } else {
            thirdArgument = car(cdr(cdr(cdr(p1))));
          }
          if (equal(firstArgument, secondArgument)) {
            stop("recursive pattern");
          }
          stringKey = "template: " + print_list(firstArgument);
          stringKey += " tests: " + print_list(thirdArgument);
          if (DEBUG) {
            console.log("pattern stringkey: " + stringKey);
          }
          patternPosition = userSimplificationsInStringForm.indexOf(stringKey);
          if (patternPosition === -1) {
            userSimplificationsInStringForm.push(stringKey);
            userSimplificationsInListForm.push(cdr(p1));
          } else {
            if (DEBUG) {
              console.log("pattern already exists, replacing. " + cdr(p1));
            }
            userSimplificationsInStringForm[patternPosition] = stringKey;
            userSimplificationsInListForm[patternPosition] = cdr(p1);
          }
          push_symbol(PATTERN);
          push(cdr(p1));
          return list(2);
        };
        do_clearPatterns = function() {
          userSimplificationsInListForm = [];
          return userSimplificationsInStringForm = [];
        };
        Eval_clearpatterns = function() {
          do_clearPatterns();
          return push_symbol(NIL);
        };
        Eval_patternsinfo = function() {
          var patternsinfoToBePrinted;
          patternsinfoToBePrinted = patternsinfo();
          if (patternsinfoToBePrinted !== "") {
            return push(new_string(patternsinfoToBePrinted));
          } else {
            return push_symbol(NIL);
          }
        };
        patternsinfo = function() {
          var i5, i12, len, patternsinfoToBePrinted;
          patternsinfoToBePrinted = "";
          for (i12 = 0, len = userSimplificationsInListForm.length; i12 < len; i12++) {
            i5 = userSimplificationsInListForm[i12];
            patternsinfoToBePrinted += userSimplificationsInListForm + "\n";
          }
          return patternsinfoToBePrinted;
        };
        Eval_polar = function() {
          push(cadr(p1));
          Eval();
          return polar();
        };
        polar = function() {
          evaluatingPolar++;
          save();
          p1 = pop();
          push(p1);
          abs();
          push(imaginaryunit);
          push(p1);
          arg();
          multiply();
          exponential();
          multiply();
          evaluatingPolar--;
          return restore();
        };
        n_factor_number = 0;
        factor_number = function() {
          var h5;
          h5 = 0;
          save();
          p1 = pop();
          if (equaln(p1, 0) || equaln(p1, 1) || equaln(p1, -1)) {
            push(p1);
            restore();
            return;
          }
          n_factor_number = p1.q.a;
          h5 = tos;
          factor_a();
          if (tos - h5 > 1) {
            list(tos - h5);
            push_symbol(MULTIPLY);
            swap();
            cons();
          }
          return restore();
        };
        factor_a = function() {
          var i12, k3;
          k3 = 0;
          if (n_factor_number.isNegative()) {
            n_factor_number = setSignTo(n_factor_number, 1);
            push_integer(-1);
          }
          for (k3 = i12 = 0; i12 < 1e4; k3 = ++i12) {
            try_kth_prime(k3);
            if (n_factor_number.compare(1) === 0) {
              return;
            }
          }
          return factor_b();
        };
        try_kth_prime = function(k3) {
          var count4, d3, q, r6;
          count4 = 0;
          d3 = mint(primetab[k3]);
          count4 = 0;
          while (1) {
            if (n_factor_number.compare(1) === 0) {
              if (count4) {
                push_factor(d3, count4);
              }
              return;
            }
            [q, r6] = mdivrem(n_factor_number, d3);
            if (r6.isZero()) {
              count4++;
              n_factor_number = q;
            } else {
              break;
            }
          }
          if (count4) {
            push_factor(d3, count4);
          }
          if (mcmp(q, d3) === -1) {
            push_factor(n_factor_number, 1);
            return n_factor_number = mint(1);
          }
        };
        factor_b = function() {
          var bigint_one, g2, k3, l8, t5, x3, xprime;
          k3 = 0;
          l8 = 0;
          bigint_one = mint(1);
          x3 = mint(5);
          xprime = mint(2);
          k3 = 1;
          l8 = 1;
          while (1) {
            if (mprime(n_factor_number)) {
              push_factor(n_factor_number, 1);
              return 0;
            }
            while (1) {
              if (esc_flag) {
                stop("esc");
              }
              t5 = msub(xprime, x3);
              t5 = setSignTo(t5, 1);
              g2 = mgcd(t5, n_factor_number);
              if (MEQUAL(g2, 1)) {
                if (--k3 === 0) {
                  xprime = x3;
                  l8 *= 2;
                  k3 = l8;
                }
                t5 = mmul(x3, x3);
                x3 = madd(t5, bigint_one);
                t5 = mmod(x3, n_factor_number);
                x3 = t5;
                continue;
              }
              push_factor(g2, 1);
              if (mcmp(g2, n_factor_number) === 0) {
                return -1;
              }
              t5 = mdiv(n_factor_number, g2);
              n_factor_number = t5;
              t5 = mmod(x3, n_factor_number);
              x3 = t5;
              t5 = mmod(xprime, n_factor_number);
              xprime = t5;
              break;
            }
          }
        };
        push_factor = function(d3, count4) {
          p1 = new U();
          p1.k = NUM;
          p1.q.a = d3;
          p1.q.b = mint(1);
          push(p1);
          if (count4 > 1) {
            push_symbol(POWER);
            swap();
            p1 = new U();
            p1.k = NUM;
            p1.q.a = mint(count4);
            p1.q.b = mint(1);
            push(p1);
            return list(3);
          }
        };
        DEBUG_POWER = false;
        Eval_power = function() {
          if (DEBUG_POWER) {
            debugger;
          }
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          return power();
        };
        power = function() {
          save();
          yypower();
          return restore();
        };
        yypower = function() {
          var b_isEven_and_c_isItsInverse, hopefullySimplified, inputBase, inputExp, isThisOne, is_a_moreThanZero, n9;
          if (DEBUG_POWER) {
            debugger;
          }
          n9 = 0;
          p2 = pop();
          p1 = pop();
          inputExp = p2;
          inputBase = p1;
          if (DEBUG_POWER) {
            console.log("POWER: " + p1 + " ^ " + p2);
          }
          if (equal(p1, one) || isZeroAtomOrTensor(p2)) {
            if (evaluatingAsFloats) {
              push_double(1);
            } else {
              push(one);
            }
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          if (equal(p2, one)) {
            push(p1);
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          if (isminusone(p1) && isminusone(p2)) {
            if (evaluatingAsFloats) {
              push_double(1);
            } else {
              push(one);
            }
            negate();
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          if (isminusone(p1) && isoneovertwo(p2)) {
            push(imaginaryunit);
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          if (isminusone(p1) && isminusoneovertwo(p2)) {
            push(imaginaryunit);
            negate();
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          if (isminusone(p1) && !isdouble(p1) && isrational(p2) && !isinteger(p2) && ispositivenumber(p2) && !evaluatingAsFloats) {
            if (DEBUG_POWER) {
              console.log("   power: -1 ^ rational");
            }
            if (DEBUG_POWER) {
              console.log(" trick: p2.q.a , p2.q.b " + p2.q.a + " , " + p2.q.b);
            }
            if (p2.q.a < p2.q.b) {
              push_symbol(POWER);
              push(p1);
              push(p2);
              list(3);
            } else {
              push_symbol(MULTIPLY);
              push(p1);
              push_symbol(POWER);
              push(p1);
              push_rational(p2.q.a.mod(p2.q.b), p2.q.b);
              list(3);
              list(3);
              if (DEBUG_POWER) {
                console.log(" trick applied : " + stack[tos - 1]);
              }
            }
            rect();
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          if (isrational(p1) && isrational(p2)) {
            if (DEBUG_POWER) {
              console.log("   power: isrational(p1) && isrational(p2)");
            }
            push(p1);
            push(p2);
            qpow();
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          if (isNumericAtom(p1) && isNumericAtom(p2)) {
            if (DEBUG_POWER) {
              console.log("   power: both base and exponent are either rational or double ");
            }
            if (DEBUG_POWER) {
              console.log("POWER - isNumericAtom(p1) && isNumericAtom(p2)");
            }
            push(p1);
            push(p2);
            dpow();
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          if (istensor(p1)) {
            if (DEBUG_POWER) {
              console.log("   power: istensor(p1) ");
            }
            power_tensor();
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          if (car(p1) === symbol(ABS) && iseveninteger(p2) && !isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {
            if (DEBUG_POWER) {
              console.log("   power: even power of absolute of real value ");
            }
            push(cadr(p1));
            push(p2);
            power();
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          if (p1 === symbol(E) && car(p2) === symbol(LOG)) {
            push(cadr(p2));
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          if (p1 === symbol(E) && isdouble(p2)) {
            if (DEBUG_POWER) {
              console.log("   power: p1 == symbol(E) && isdouble(p2) ");
            }
            push_double(Math.exp(p2.d));
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          if (p1 === symbol(E) && Find(p2, imaginaryunit) !== 0 && Find(p2, symbol(PI)) !== 0 && !evaluatingPolar) {
            push_symbol(POWER);
            push(p1);
            push(p2);
            list(3);
            if (DEBUG_POWER) {
              console.log("   power: turning complex exponential to rect: " + stack[tos - 1]);
            }
            rect();
            hopefullySimplified = pop();
            if (Find(hopefullySimplified, symbol(PI)) === 0) {
              if (DEBUG_POWER) {
                console.log("   power: turned complex exponential to rect: " + hopefullySimplified);
              }
              push(hopefullySimplified);
              return;
            }
          }
          if (car(p1) === symbol(MULTIPLY) && isinteger(p2)) {
            if (DEBUG_POWER) {
              console.log("   power: (a * b) ^ c  ->  (a ^ c) * (b ^ c) ");
            }
            p1 = cdr(p1);
            push(car(p1));
            push(p2);
            power();
            p1 = cdr(p1);
            while (iscons(p1)) {
              push(car(p1));
              push(p2);
              power();
              multiply();
              p1 = cdr(p1);
            }
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          is_a_moreThanZero = false;
          if (isNumericAtom(cadr(p1))) {
            is_a_moreThanZero = sign(compare_numbers(cadr(p1), zero));
          }
          if (car(p1) === symbol(POWER) && (isinteger(p2) || is_a_moreThanZero)) {
            push(cadr(p1));
            push(caddr(p1));
            push(p2);
            multiply();
            power();
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          b_isEven_and_c_isItsInverse = false;
          if (iseveninteger(caddr(p1))) {
            push(caddr(p1));
            push(p2);
            multiply();
            isThisOne = pop();
            if (isone(isThisOne)) {
              b_isEven_and_c_isItsInverse = true;
            }
          }
          if (car(p1) === symbol(POWER) && b_isEven_and_c_isItsInverse) {
            if (DEBUG_POWER) {
              console.log("   power: car(p1) == symbol(POWER) && b_isEven_and_c_isItsInverse ");
            }
            push(cadr(p1));
            abs();
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          if (expanding && isadd(p1) && isNumericAtom(p2)) {
            push(p2);
            n9 = pop_integer();
            if (n9 > 1 && !isNaN(n9)) {
              if (DEBUG_POWER) {
                console.log("   power: expanding && isadd(p1) && isNumericAtom(p2) ");
              }
              power_sum(n9);
              if (DEBUG_POWER) {
                console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
              }
              return;
            }
          }
          if (trigmode === 1 && car(p1) === symbol(SIN) && iseveninteger(p2)) {
            if (DEBUG_POWER) {
              console.log("   power: trigmode == 1 && car(p1) == symbol(SIN) && iseveninteger(p2) ");
            }
            push_integer(1);
            push(cadr(p1));
            cosine();
            push_integer(2);
            power();
            subtract();
            push(p2);
            push_rational(1, 2);
            multiply();
            power();
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          if (trigmode === 2 && car(p1) === symbol(COS) && iseveninteger(p2)) {
            if (DEBUG_POWER) {
              console.log("   power: trigmode == 2 && car(p1) == symbol(COS) && iseveninteger(p2) ");
            }
            push_integer(1);
            push(cadr(p1));
            sine();
            push_integer(2);
            power();
            subtract();
            push(p2);
            push_rational(1, 2);
            multiply();
            power();
            if (DEBUG_POWER) {
              console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
            }
            return;
          }
          if (iscomplexnumber(p1)) {
            if (DEBUG_POWER) {
              console.log(" power - handling the case (a + ib) ^ n");
            }
            if (isinteger(p2)) {
              push(p1);
              conjugate();
              p3 = pop();
              push(p3);
              push(p3);
              push(p1);
              multiply();
              divide();
              if (!isone(p2)) {
                push(p2);
                negate();
                power();
              }
              if (DEBUG_POWER) {
                console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
              }
              return;
            }
            if (isNumericAtom(p2)) {
              push(p1);
              abs();
              push(p2);
              power();
              push_integer(-1);
              push(p1);
              arg();
              push(p2);
              multiply();
              if (evaluatingAsFloats || iscomplexnumberdouble(p1) && isdouble(p2)) {
                push_double(Math.PI);
              } else {
                push(symbol(PI));
              }
              divide();
              power();
              multiply();
              if (avoidCalculatingPowersIntoArctans) {
                if (Find(stack[tos - 1], symbol(ARCTAN))) {
                  pop();
                  push_symbol(POWER);
                  push(p1);
                  push(p2);
                  list(3);
                }
              }
              if (DEBUG_POWER) {
                console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
              }
              return;
            }
          }
          if (simplify_polar()) {
            if (DEBUG_POWER) {
              console.log("   power: using simplify_polar");
            }
            return;
          }
          if (DEBUG_POWER) {
            console.log("   power: nothing can be done ");
          }
          push_symbol(POWER);
          push(p1);
          push(p2);
          list(3);
          if (DEBUG_POWER) {
            return console.log("   power of " + inputBase + " ^ " + inputExp + ": " + stack[tos - 1]);
          }
        };
        power_sum = function(n9) {
          var a5, i5, i12, j2, j12, k3, l1, ref12, ref2, ref3;
          a5 = [];
          i5 = 0;
          j2 = 0;
          k3 = 0;
          k3 = length(p1) - 1;
          push_frame(k3 * (n9 + 1));
          p1 = cdr(p1);
          for (i5 = i12 = 0, ref12 = k3; 0 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
            for (j2 = j12 = 0, ref2 = n9; 0 <= ref2 ? j12 <= ref2 : j12 >= ref2; j2 = 0 <= ref2 ? ++j12 : --j12) {
              push(car(p1));
              push_integer(j2);
              power();
              stack[frame + i5 * (n9 + 1) + j2] = pop();
            }
            p1 = cdr(p1);
          }
          push_integer(n9);
          factorial();
          p1 = pop();
          for (i5 = l1 = 0, ref3 = k3; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i5 = 0 <= ref3 ? ++l1 : --l1) {
            a5[i5] = 0;
          }
          push(zero);
          multinomial_sum(k3, n9, a5, 0, n9);
          return pop_frame(k3 * (n9 + 1));
        };
        multinomial_sum = function(k3, n9, a5, i5, m3) {
          var i12, j2, j12, l1, ref12, ref2, ref3;
          j2 = 0;
          if (i5 < k3 - 1) {
            for (j2 = i12 = 0, ref12 = m3; 0 <= ref12 ? i12 <= ref12 : i12 >= ref12; j2 = 0 <= ref12 ? ++i12 : --i12) {
              a5[i5] = j2;
              multinomial_sum(k3, n9, a5, i5 + 1, m3 - j2);
            }
            return;
          }
          a5[i5] = m3;
          push(p1);
          for (j2 = j12 = 0, ref2 = k3; 0 <= ref2 ? j12 < ref2 : j12 > ref2; j2 = 0 <= ref2 ? ++j12 : --j12) {
            push_integer(a5[j2]);
            factorial();
            divide();
          }
          for (j2 = l1 = 0, ref3 = k3; 0 <= ref3 ? l1 < ref3 : l1 > ref3; j2 = 0 <= ref3 ? ++l1 : --l1) {
            push(stack[frame + j2 * (n9 + 1) + a5[j2]]);
            multiply();
          }
          return add();
        };
        simplify_polar = function() {
          var doNothing, n9;
          n9 = 0;
          n9 = isquarterturn(p2);
          switch (n9) {
            case 0:
              doNothing = 1;
              break;
            case 1:
              push_integer(1);
              return 1;
            case 2:
              push_integer(-1);
              return 1;
            case 3:
              push(imaginaryunit);
              return 1;
            case 4:
              push(imaginaryunit);
              negate();
              return 1;
          }
          if (car(p2) === symbol(ADD)) {
            p3 = cdr(p2);
            while (iscons(p3)) {
              n9 = isquarterturn(car(p3));
              if (n9) {
                break;
              }
              p3 = cdr(p3);
            }
            switch (n9) {
              case 0:
                return 0;
              case 1:
                push_integer(1);
                break;
              case 2:
                push_integer(-1);
                break;
              case 3:
                push(imaginaryunit);
                break;
              case 4:
                push(imaginaryunit);
                negate();
            }
            push(p2);
            push(car(p3));
            subtract();
            exponential();
            multiply();
            return 1;
          }
          return 0;
        };
        Eval_prime = function() {
          push(cadr(p1));
          Eval();
          return prime();
        };
        prime = function() {
          var n9;
          n9 = 0;
          n9 = pop_integer();
          if (n9 < 1 || n9 > MAXPRIMETAB) {
            stop("prime: Argument out of range.");
          }
          n9 = primetab[n9 - 1];
          return push_integer(n9);
        };
        power_str = "^";
        codeGen = false;
        Eval_print = function() {
          stringsEmittedByUserPrintouts += _print(cdr(p1), printMode);
          return push(symbol(NIL));
        };
        Eval_print2dascii = function() {
          stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_2DASCII);
          return push(symbol(NIL));
        };
        Eval_printcomputer = function() {
          stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_COMPUTER);
          return push(symbol(NIL));
        };
        Eval_printlatex = function() {
          stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_LATEX);
          return push(symbol(NIL));
        };
        Eval_printhuman = function() {
          var original_test_flag;
          original_test_flag = test_flag;
          test_flag = 0;
          stringsEmittedByUserPrintouts += _print(cdr(p1), PRINTMODE_HUMAN);
          test_flag = original_test_flag;
          return push(symbol(NIL));
        };
        Eval_printlist = function() {
          var beenPrinted;
          beenPrinted = _print(cdr(p1), PRINTMODE_LIST);
          stringsEmittedByUserPrintouts += beenPrinted;
          return push(symbol(NIL));
        };
        _print = function(p11, passedPrintMode) {
          var accumulator, origPrintMode;
          accumulator = "";
          while (iscons(p11)) {
            push(car(p11));
            Eval();
            p2 = pop();
            origPrintMode = printMode;
            if (passedPrintMode === PRINTMODE_COMPUTER) {
              printMode = PRINTMODE_COMPUTER;
              accumulator = printline(p2);
              rememberPrint(accumulator, LAST_FULL_PRINT);
            } else if (passedPrintMode === PRINTMODE_HUMAN) {
              printMode = PRINTMODE_HUMAN;
              accumulator = printline(p2);
              rememberPrint(accumulator, LAST_PLAIN_PRINT);
            } else if (passedPrintMode === PRINTMODE_2DASCII) {
              printMode = PRINTMODE_2DASCII;
              accumulator = print2dascii(p2);
              rememberPrint(accumulator, LAST_2DASCII_PRINT);
            } else if (passedPrintMode === PRINTMODE_LATEX) {
              printMode = PRINTMODE_LATEX;
              accumulator = printline(p2);
              rememberPrint(accumulator, LAST_LATEX_PRINT);
            } else if (passedPrintMode === PRINTMODE_LIST) {
              printMode = PRINTMODE_LIST;
              accumulator = print_list(p2);
              rememberPrint(accumulator, LAST_LIST_PRINT);
            }
            printMode = origPrintMode;
            p11 = cdr(p11);
          }
          if (DEBUG) {
            console.log("emttedString from display: " + stringsEmittedByUserPrintouts);
          }
          return accumulator;
        };
        rememberPrint = function(theString, theTypeOfPrint) {
          var parsedString;
          scan('"' + theString + '"');
          parsedString = pop();
          return set_binding(symbol(theTypeOfPrint), parsedString);
        };
        print_str = function(s8) {
          if (DEBUG) {
            console.log("emttedString from print_str: " + stringsEmittedByUserPrintouts);
          }
          return s8;
        };
        print_char = function(c9) {
          return c9;
        };
        collectLatexStringFromReturnValue = function(p11) {
          var origPrintMode, originalCodeGen, returnedString;
          origPrintMode = printMode;
          printMode = PRINTMODE_LATEX;
          originalCodeGen = codeGen;
          codeGen = false;
          returnedString = print_expr(p11);
          returnedString = returnedString.replace(/_/g, "\\_");
          printMode = origPrintMode;
          codeGen = originalCodeGen;
          if (DEBUG) {
            console.log("emttedString from collectLatexStringFromReturnValue: " + stringsEmittedByUserPrintouts);
          }
          return returnedString;
        };
        printline = function(p11) {
          var accumulator;
          accumulator = "";
          accumulator += print_expr(p11);
          return accumulator;
        };
        print_base_of_denom = function(p12) {
          var accumulator;
          accumulator = "";
          if (isfraction(p12) || car(p12) === symbol(ADD) || car(p12) === symbol(MULTIPLY) || car(p12) === symbol(POWER) || lessp(p12, zero)) {
            accumulator += print_char("(");
            accumulator += print_expr(p12);
            accumulator += print_char(")");
          } else {
            accumulator += print_expr(p12);
          }
          return accumulator;
        };
        print_expo_of_denom = function(p22) {
          var accumulator;
          accumulator = "";
          if (isfraction(p22) || car(p22) === symbol(ADD) || car(p22) === symbol(MULTIPLY) || car(p22) === symbol(POWER)) {
            accumulator += print_char("(");
            accumulator += print_expr(p22);
            accumulator += print_char(")");
          } else {
            accumulator += print_expr(p22);
          }
          return accumulator;
        };
        print_denom = function(p11, d3) {
          var accumulator;
          accumulator = "";
          save();
          p1 = cadr(p11);
          p2 = caddr(p11);
          if (isminusone(p2)) {
            accumulator += print_base_of_denom(p1);
            restore();
            return accumulator;
          }
          if (d3 === 1) {
            accumulator += print_char("(");
          }
          push(p2);
          negate();
          p2 = pop();
          accumulator += print_power(p1, p2);
          if (d3 === 1) {
            accumulator += print_char(")");
          }
          restore();
          return accumulator;
        };
        print_a_over_b = function(p11) {
          var accumulator, d3, doNothing, n9;
          accumulator = "";
          flag = 0;
          n9 = 0;
          d3 = 0;
          save();
          n9 = 0;
          d3 = 0;
          p1 = cdr(p11);
          p2 = car(p1);
          if (isrational(p2)) {
            push(p2);
            mp_numerator();
            absval();
            p3 = pop();
            push(p2);
            mp_denominator();
            p4 = pop();
            if (!isplusone(p3)) {
              n9++;
            }
            if (!isplusone(p4)) {
              d3++;
            }
            p1 = cdr(p1);
          } else {
            p3 = one;
            p4 = one;
          }
          while (iscons(p1)) {
            p2 = car(p1);
            if (is_denominator(p2)) {
              d3++;
            } else {
              n9++;
            }
            p1 = cdr(p1);
          }
          if (printMode === PRINTMODE_LATEX) {
            accumulator += print_str("\\frac{");
          }
          if (n9 === 0) {
            accumulator += print_char("1");
          } else {
            flag = 0;
            p1 = cdr(p11);
            if (isrational(car(p1))) {
              p1 = cdr(p1);
            }
            if (!isplusone(p3)) {
              accumulator += print_factor(p3);
              flag = 1;
            }
            while (iscons(p1)) {
              p2 = car(p1);
              if (is_denominator(p2)) {
                doNothing = 1;
              } else {
                if (flag) {
                  accumulator += print_multiply_sign();
                }
                accumulator += print_factor(p2);
                flag = 1;
              }
              p1 = cdr(p1);
            }
          }
          if (printMode === PRINTMODE_LATEX) {
            accumulator += print_str("}{");
          } else if (printMode === PRINTMODE_HUMAN && !test_flag) {
            accumulator += print_str(" / ");
          } else {
            accumulator += print_str("/");
          }
          if (d3 > 1 && printMode !== PRINTMODE_LATEX) {
            accumulator += print_char("(");
          }
          flag = 0;
          p1 = cdr(p11);
          if (isrational(car(p1))) {
            p1 = cdr(p1);
          }
          if (!isplusone(p4)) {
            accumulator += print_factor(p4);
            flag = 1;
          }
          while (iscons(p1)) {
            p2 = car(p1);
            if (is_denominator(p2)) {
              if (flag) {
                accumulator += print_multiply_sign();
              }
              accumulator += print_denom(p2, d3);
              flag = 1;
            }
            p1 = cdr(p1);
          }
          if (d3 > 1 && printMode !== PRINTMODE_LATEX) {
            accumulator += print_char(")");
          }
          if (printMode === PRINTMODE_LATEX) {
            accumulator += print_str("}");
          }
          restore();
          return accumulator;
        };
        print_expr = function(p11) {
          var accumulator;
          accumulator = "";
          if (isadd(p11)) {
            p11 = cdr(p11);
            if (sign_of_term(car(p11)) === "-") {
              accumulator += print_str("-");
            }
            accumulator += print_term(car(p11));
            p11 = cdr(p11);
            while (iscons(p11)) {
              if (sign_of_term(car(p11)) === "+") {
                if (printMode === PRINTMODE_HUMAN && !test_flag) {
                  accumulator += print_str(" + ");
                } else {
                  accumulator += print_str("+");
                }
              } else {
                if (printMode === PRINTMODE_HUMAN && !test_flag) {
                  accumulator += print_str(" - ");
                } else {
                  accumulator += print_str("-");
                }
              }
              accumulator += print_term(car(p11));
              p11 = cdr(p11);
            }
          } else {
            if (sign_of_term(p11) === "-") {
              accumulator += print_str("-");
            }
            accumulator += print_term(p11);
          }
          return accumulator;
        };
        sign_of_term = function(p11) {
          var accumulator;
          accumulator = "";
          if (car(p11) === symbol(MULTIPLY) && isNumericAtom(cadr(p11)) && lessp(cadr(p11), zero)) {
            accumulator += "-";
          } else if (isNumericAtom(p11) && lessp(p11, zero)) {
            accumulator += "-";
          } else {
            accumulator += "+";
          }
          return accumulator;
        };
        print_term = function(p11) {
          var accumulator, denom, numberOneOverSomething, origAccumulator, previousFactorWasANumber;
          accumulator = "";
          if (car(p11) === symbol(MULTIPLY) && any_denominators(p11)) {
            accumulator += print_a_over_b(p11);
            return accumulator;
          }
          if (car(p11) === symbol(MULTIPLY)) {
            p11 = cdr(p11);
            if (isminusone(car(p11))) {
              p11 = cdr(p11);
            }
            previousFactorWasANumber = false;
            if (isNumericAtom(car(p11))) {
              previousFactorWasANumber = true;
            }
            numberOneOverSomething = false;
            if (printMode === PRINTMODE_LATEX && iscons(cdr(p11)) && isNumberOneOverSomething(car(p11))) {
              numberOneOverSomething = true;
              denom = car(p11).q.b.toString();
            }
            if (numberOneOverSomething) {
              origAccumulator = accumulator;
              accumulator = "";
            } else {
              accumulator += print_factor(car(p11));
            }
            p11 = cdr(p11);
            while (iscons(p11)) {
              if (printMode === PRINTMODE_LATEX) {
                if (previousFactorWasANumber) {
                  if (caar(p11) === symbol(POWER)) {
                    if (isNumericAtom(car(cdr(car(p11))))) {
                      if (!isfraction(car(cdr(cdr(car(p11)))))) {
                        accumulator += " \\cdot ";
                      }
                    }
                  }
                }
              }
              accumulator += print_multiply_sign();
              accumulator += print_factor(car(p11), false, true);
              previousFactorWasANumber = false;
              if (isNumericAtom(car(p11))) {
                previousFactorWasANumber = true;
              }
              p11 = cdr(p11);
            }
            if (numberOneOverSomething) {
              accumulator = origAccumulator + "\\frac{" + accumulator + "}{" + denom + "}";
            }
          } else {
            accumulator += print_factor(p11);
          }
          return accumulator;
        };
        print_subexpr = function(p11) {
          var accumulator;
          accumulator = "";
          accumulator += print_char("(");
          accumulator += print_expr(p11);
          accumulator += print_char(")");
          return accumulator;
        };
        print_factorial_function = function(p11) {
          var accumulator;
          accumulator = "";
          p11 = cadr(p11);
          if (isfraction(p11) || car(p11) === symbol(ADD) || car(p11) === symbol(MULTIPLY) || car(p11) === symbol(POWER) || car(p11) === symbol(FACTORIAL)) {
            accumulator += print_subexpr(p11);
          } else {
            accumulator += print_expr(p11);
          }
          accumulator += print_char("!");
          return accumulator;
        };
        print_ABS_latex = function(p11) {
          var accumulator;
          accumulator = "";
          accumulator += print_str("\\left |");
          accumulator += print_expr(cadr(p11));
          accumulator += print_str(" \\right |");
          return accumulator;
        };
        print_BINOMIAL_latex = function(p11) {
          var accumulator;
          accumulator = "";
          accumulator += print_str("\\binom{");
          accumulator += print_expr(cadr(p11));
          accumulator += print_str("}{");
          accumulator += print_expr(caddr(p11));
          accumulator += print_str("} ");
          return accumulator;
        };
        print_DOT_latex = function(p11) {
          var accumulator;
          accumulator = "";
          accumulator += print_expr(cadr(p11));
          accumulator += print_str(" \\cdot ");
          accumulator += print_expr(caddr(p11));
          return accumulator;
        };
        print_DOT_codegen = function(p11) {
          var accumulator;
          accumulator = "dot(";
          accumulator += print_expr(cadr(p11));
          accumulator += ", ";
          accumulator += print_expr(caddr(p11));
          accumulator += ")";
          return accumulator;
        };
        print_SIN_codegen = function(p11) {
          var accumulator;
          accumulator = "Math.sin(";
          accumulator += print_expr(cadr(p11));
          accumulator += ")";
          return accumulator;
        };
        print_COS_codegen = function(p11) {
          var accumulator;
          accumulator = "Math.cos(";
          accumulator += print_expr(cadr(p11));
          accumulator += ")";
          return accumulator;
        };
        print_TAN_codegen = function(p11) {
          var accumulator;
          accumulator = "Math.tan(";
          accumulator += print_expr(cadr(p11));
          accumulator += ")";
          return accumulator;
        };
        print_ARCSIN_codegen = function(p11) {
          var accumulator;
          accumulator = "Math.asin(";
          accumulator += print_expr(cadr(p11));
          accumulator += ")";
          return accumulator;
        };
        print_ARCCOS_codegen = function(p11) {
          var accumulator;
          accumulator = "Math.acos(";
          accumulator += print_expr(cadr(p11));
          accumulator += ")";
          return accumulator;
        };
        print_ARCTAN_codegen = function(p11) {
          var accumulator;
          accumulator = "Math.atan(";
          accumulator += print_expr(cadr(p11));
          accumulator += ")";
          return accumulator;
        };
        print_SQRT_latex = function(p11) {
          var accumulator;
          accumulator = "";
          accumulator += print_str("\\sqrt{");
          accumulator += print_expr(cadr(p11));
          accumulator += print_str("} ");
          return accumulator;
        };
        print_TRANSPOSE_latex = function(p11) {
          var accumulator;
          accumulator = "";
          accumulator += print_str("{");
          if (iscons(cadr(p11))) {
            accumulator += print_str("(");
          }
          accumulator += print_expr(cadr(p11));
          if (iscons(cadr(p11))) {
            accumulator += print_str(")");
          }
          accumulator += print_str("}");
          accumulator += print_str("^T");
          return accumulator;
        };
        print_TRANSPOSE_codegen = function(p11) {
          var accumulator;
          accumulator = "";
          accumulator += print_str("transpose(");
          accumulator += print_expr(cadr(p11));
          accumulator += print_str(")");
          return accumulator;
        };
        print_UNIT_codegen = function(p11) {
          var accumulator;
          accumulator = "";
          accumulator += print_str("identity(");
          accumulator += print_expr(cadr(p11));
          accumulator += print_str(")");
          return accumulator;
        };
        print_INV_latex = function(p11) {
          var accumulator;
          accumulator = "";
          accumulator += print_str("{");
          if (iscons(cadr(p11))) {
            accumulator += print_str("(");
          }
          accumulator += print_expr(cadr(p11));
          if (iscons(cadr(p11))) {
            accumulator += print_str(")");
          }
          accumulator += print_str("}");
          accumulator += print_str("^{-1}");
          return accumulator;
        };
        print_INV_codegen = function(p11) {
          var accumulator;
          accumulator = "";
          accumulator += print_str("inv(");
          accumulator += print_expr(cadr(p11));
          accumulator += print_str(")");
          return accumulator;
        };
        print_DEFINT_latex = function(p11) {
          var accumulator, functionBody, i5, i12, numberOfIntegrals, originalIntegral, ref12, theIntegral, theVariable;
          accumulator = "";
          functionBody = car(cdr(p11));
          p11 = cdr(p11);
          originalIntegral = p11;
          numberOfIntegrals = 0;
          while (iscons(cdr(cdr(p11)))) {
            numberOfIntegrals++;
            theIntegral = cdr(cdr(p11));
            accumulator += print_str("\\int^{");
            accumulator += print_expr(car(cdr(theIntegral)));
            accumulator += print_str("}_{");
            accumulator += print_expr(car(theIntegral));
            accumulator += print_str("} \\! ");
            p11 = cdr(theIntegral);
          }
          accumulator += print_expr(functionBody);
          accumulator += print_str(" \\,");
          p11 = originalIntegral;
          for (i5 = i12 = 1, ref12 = numberOfIntegrals; 1 <= ref12 ? i12 <= ref12 : i12 >= ref12; i5 = 1 <= ref12 ? ++i12 : --i12) {
            theVariable = cdr(p11);
            accumulator += print_str(" \\mathrm{d} ");
            accumulator += print_expr(car(theVariable));
            if (i5 < numberOfIntegrals) {
              accumulator += print_str(" \\, ");
            }
            p11 = cdr(cdr(theVariable));
          }
          return accumulator;
        };
        print_tensor = function(p11) {
          var accumulator;
          accumulator = "";
          accumulator += print_tensor_inner(p11, 0, 0)[1];
          return accumulator;
        };
        print_tensor_inner = function(p11, j2, k3) {
          var accumulator, i5, i12, j12, ref12, ref2, retString;
          accumulator = "";
          accumulator += print_str("[");
          if (j2 < p11.tensor.ndim - 1) {
            for (i5 = i12 = 0, ref12 = p11.tensor.dim[j2]; 0 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
              [k3, retString] = print_tensor_inner(p11, j2 + 1, k3);
              accumulator += retString;
              if (i5 !== p11.tensor.dim[j2] - 1) {
                accumulator += print_str(",");
              }
            }
          } else {
            for (i5 = j12 = 0, ref2 = p11.tensor.dim[j2]; 0 <= ref2 ? j12 < ref2 : j12 > ref2; i5 = 0 <= ref2 ? ++j12 : --j12) {
              accumulator += print_expr(p11.tensor.elem[k3]);
              if (i5 !== p11.tensor.dim[j2] - 1) {
                accumulator += print_str(",");
              }
              k3++;
            }
          }
          accumulator += print_str("]");
          return [k3, accumulator];
        };
        print_tensor_latex = function(p11) {
          var accumulator;
          accumulator = "";
          if (p11.tensor.ndim <= 2) {
            accumulator += print_tensor_inner_latex(true, p11, 0, 0)[1];
          }
          return accumulator;
        };
        print_tensor_inner_latex = function(firstLevel, p11, j2, k3) {
          var accumulator, i5, i12, j12, ref12, ref2, retString;
          accumulator = "";
          if (firstLevel) {
            accumulator += "\\begin{bmatrix} ";
          }
          if (j2 < p11.tensor.ndim - 1) {
            for (i5 = i12 = 0, ref12 = p11.tensor.dim[j2]; 0 <= ref12 ? i12 < ref12 : i12 > ref12; i5 = 0 <= ref12 ? ++i12 : --i12) {
              [k3, retString] = print_tensor_inner_latex(0, p11, j2 + 1, k3);
              accumulator += retString;
              if (i5 !== p11.tensor.dim[j2] - 1) {
                accumulator += print_str(" \\\\ ");
              }
            }
          } else {
            for (i5 = j12 = 0, ref2 = p11.tensor.dim[j2]; 0 <= ref2 ? j12 < ref2 : j12 > ref2; i5 = 0 <= ref2 ? ++j12 : --j12) {
              accumulator += print_expr(p11.tensor.elem[k3]);
              if (i5 !== p11.tensor.dim[j2] - 1) {
                accumulator += print_str(" & ");
              }
              k3++;
            }
          }
          if (firstLevel) {
            accumulator += " \\end{bmatrix}";
          }
          return [k3, accumulator];
        };
        print_SUM_latex = function(p11) {
          var accumulator;
          accumulator = "\\sum_{";
          accumulator += print_expr(caddr(p11));
          accumulator += "=";
          accumulator += print_expr(cadddr(p11));
          accumulator += "}^{";
          accumulator += print_expr(caddddr(p11));
          accumulator += "}{";
          accumulator += print_expr(cadr(p11));
          accumulator += "}";
          return accumulator;
        };
        print_SUM_codegen = function(p11) {
          var accumulator, body, lowerlimit, upperlimit, variable;
          body = cadr(p11);
          variable = caddr(p11);
          lowerlimit = cadddr(p11);
          upperlimit = caddddr(p11);
          accumulator = "(function(){ var " + variable + ";  var holderSum = 0;  var lowerlimit = " + print_expr(lowerlimit) + ";  var upperlimit = " + print_expr(upperlimit) + ";  for (" + variable + " = lowerlimit; " + variable + " < upperlimit; " + variable + "++) {    holderSum += " + print_expr(body) + "; }  return holderSum;})()";
          return accumulator;
        };
        print_TEST_latex = function(p11) {
          var accumulator;
          accumulator = "\\left\\{ \\begin{array}{ll}";
          p11 = cdr(p11);
          while (iscons(p11)) {
            if (cdr(p11) === symbol(NIL)) {
              accumulator += "{";
              accumulator += print_expr(car(p11));
              accumulator += "} & otherwise ";
              accumulator += " \\\\\\\\";
              break;
            }
            accumulator += "{";
            accumulator += print_expr(cadr(p11));
            accumulator += "} & if & ";
            accumulator += print_expr(car(p11));
            accumulator += " \\\\\\\\";
            p11 = cddr(p11);
          }
          accumulator = accumulator.substring(0, accumulator.length - 4);
          return accumulator += "\\end{array} \\right.";
        };
        print_TEST_codegen = function(p11) {
          var accumulator, howManyIfs;
          accumulator = "(function(){";
          p11 = cdr(p11);
          howManyIfs = 0;
          while (iscons(p11)) {
            if (cdr(p11) === symbol(NIL)) {
              accumulator += "else {";
              accumulator += "return (" + print_expr(car(p11)) + ");";
              accumulator += "}";
              break;
            }
            if (howManyIfs) {
              accumulator += " else ";
            }
            accumulator += "if (" + print_expr(car(p11)) + "){";
            accumulator += "return (" + print_expr(cadr(p11)) + ");";
            accumulator += "}";
            howManyIfs++;
            p11 = cddr(p11);
          }
          accumulator += "})()";
          return accumulator;
        };
        print_TESTLT_latex = function(p11) {
          var accumulator;
          accumulator = "{";
          accumulator += print_expr(cadr(p11));
          accumulator += "}";
          accumulator += " < ";
          accumulator += "{";
          accumulator += print_expr(caddr(p11));
          return accumulator += "}";
        };
        print_TESTLE_latex = function(p11) {
          var accumulator;
          accumulator = "{";
          accumulator += print_expr(cadr(p11));
          accumulator += "}";
          accumulator += " \\leq ";
          accumulator += "{";
          accumulator += print_expr(caddr(p11));
          return accumulator += "}";
        };
        print_TESTGT_latex = function(p11) {
          var accumulator;
          accumulator = "{";
          accumulator += print_expr(cadr(p11));
          accumulator += "}";
          accumulator += " > ";
          accumulator += "{";
          accumulator += print_expr(caddr(p11));
          return accumulator += "}";
        };
        print_TESTGE_latex = function(p11) {
          var accumulator;
          accumulator = "{";
          accumulator += print_expr(cadr(p11));
          accumulator += "}";
          accumulator += " \\geq ";
          accumulator += "{";
          accumulator += print_expr(caddr(p11));
          return accumulator += "}";
        };
        print_TESTEQ_latex = function(p11) {
          var accumulator;
          accumulator = "{";
          accumulator += print_expr(cadr(p11));
          accumulator += "}";
          accumulator += " = ";
          accumulator += "{";
          accumulator += print_expr(caddr(p11));
          return accumulator += "}";
        };
        print_FOR_codegen = function(p11) {
          var accumulator, body, lowerlimit, upperlimit, variable;
          body = cadr(p11);
          variable = caddr(p11);
          lowerlimit = cadddr(p11);
          upperlimit = caddddr(p11);
          accumulator = "(function(){ var " + variable + ";  var lowerlimit = " + print_expr(lowerlimit) + ";  var upperlimit = " + print_expr(upperlimit) + ";  for (" + variable + " = lowerlimit; " + variable + " < upperlimit; " + variable + "++) {    " + print_expr(body) + " } })()";
          return accumulator;
        };
        print_DO_codegen = function(p11) {
          var accumulator;
          accumulator = "";
          p11 = cdr(p11);
          while (iscons(p11)) {
            accumulator += print_expr(car(p11));
            p11 = cdr(p11);
          }
          return accumulator;
        };
        print_SETQ_codegen = function(p11) {
          var accumulator;
          accumulator = "";
          accumulator += print_expr(cadr(p11));
          accumulator += " = ";
          accumulator += print_expr(caddr(p11));
          accumulator += "; ";
          return accumulator;
        };
        print_PRODUCT_latex = function(p11) {
          var accumulator;
          accumulator = "\\prod_{";
          accumulator += print_expr(caddr(p11));
          accumulator += "=";
          accumulator += print_expr(cadddr(p11));
          accumulator += "}^{";
          accumulator += print_expr(caddddr(p11));
          accumulator += "}{";
          accumulator += print_expr(cadr(p11));
          accumulator += "}";
          return accumulator;
        };
        print_PRODUCT_codegen = function(p11) {
          var accumulator, body, lowerlimit, upperlimit, variable;
          body = cadr(p11);
          variable = caddr(p11);
          lowerlimit = cadddr(p11);
          upperlimit = caddddr(p11);
          accumulator = "(function(){ var " + variable + ";  var holderProduct = 1;  var lowerlimit = " + print_expr(lowerlimit) + ";  var upperlimit = " + print_expr(upperlimit) + ";  for (" + variable + " = lowerlimit; " + variable + " < upperlimit; " + variable + "++) {    holderProduct *= " + print_expr(body) + "; }  return holderProduct;})()";
          return accumulator;
        };
        print_base = function(p11) {
          var accumulator;
          accumulator = "";
          if (isadd(cadr(p11)) || caadr(p11) === symbol(MULTIPLY) || caadr(p11) === symbol(POWER) || isnegativenumber(cadr(p11))) {
            accumulator += print_str("(");
            accumulator += print_expr(cadr(p11));
            accumulator += print_str(")");
          } else if (isNumericAtom(cadr(p11)) && (lessp(cadr(p11), zero) || isfraction(cadr(p11)))) {
            accumulator += print_str("(");
            accumulator += print_factor(cadr(p11));
            accumulator += print_str(")");
          } else {
            accumulator += print_factor(cadr(p11));
          }
          return accumulator;
        };
        print_exponent = function(p11) {
          var accumulator;
          accumulator = "";
          if (iscons(caddr(p11)) || isfraction(caddr(p11)) || isNumericAtom(caddr(p11)) && lessp(caddr(p11), zero)) {
            accumulator += print_str("(");
            accumulator += print_expr(caddr(p11));
            accumulator += print_str(")");
          } else {
            accumulator += print_factor(caddr(p11));
          }
          return accumulator;
        };
        print_power = function(base, exponent) {
          var accumulator, denomExponent, newExponent, numExponent;
          accumulator = "";
          if (DEBUG) {
            console.log("power base: " + base + "  exponent: " + exponent);
          }
          if (isoneovertwo(exponent)) {
            if (equaln(base, 2)) {
              if (codeGen) {
                accumulator += print_str("Math.SQRT2");
                return accumulator;
              }
            } else {
              if (printMode === PRINTMODE_LATEX) {
                accumulator += print_str("\\sqrt{");
                accumulator += print_expr(base);
                accumulator += print_str("}");
                return accumulator;
              } else if (codeGen) {
                accumulator += print_str("Math.sqrt(");
                accumulator += print_expr(base);
                accumulator += print_str(")");
                return accumulator;
              }
            }
          }
          if (equaln(get_binding(symbol(PRINT_LEAVE_E_ALONE)), 1) && base === symbol(E)) {
            if (codeGen) {
              accumulator += print_str("Math.exp(");
              accumulator += print_expo_of_denom(exponent);
              accumulator += print_str(")");
              return accumulator;
            }
            if (printMode === PRINTMODE_LATEX) {
              accumulator += print_str("e^{");
              accumulator += print_expr(exponent);
              accumulator += print_str("}");
            } else {
              accumulator += print_str("exp(");
              accumulator += print_expr(exponent);
              accumulator += print_str(")");
            }
            return accumulator;
          }
          if (codeGen) {
            accumulator += print_str("Math.pow(");
            accumulator += print_base_of_denom(base);
            accumulator += print_str(", ");
            accumulator += print_expo_of_denom(exponent);
            accumulator += print_str(")");
            return accumulator;
          }
          if (equaln(get_binding(symbol(PRINT_LEAVE_X_ALONE)), 0) || base.printname !== "x") {
            if (base !== symbol(E)) {
              if (isminusone(exponent)) {
                if (printMode === PRINTMODE_LATEX) {
                  accumulator += print_str("\\frac{1}{");
                } else if (printMode === PRINTMODE_HUMAN && !test_flag) {
                  accumulator += print_str("1 / ");
                } else {
                  accumulator += print_str("1/");
                }
                if (iscons(base) && printMode !== PRINTMODE_LATEX) {
                  accumulator += print_str("(");
                  accumulator += print_expr(base);
                  accumulator += print_str(")");
                } else {
                  accumulator += print_expr(base);
                }
                if (printMode === PRINTMODE_LATEX) {
                  accumulator += print_str("}");
                }
                return accumulator;
              }
              if (isnegativeterm(exponent)) {
                if (printMode === PRINTMODE_LATEX) {
                  accumulator += print_str("\\frac{1}{");
                } else if (printMode === PRINTMODE_HUMAN && !test_flag) {
                  accumulator += print_str("1 / ");
                } else {
                  accumulator += print_str("1/");
                }
                push(exponent);
                push_integer(-1);
                multiply();
                newExponent = pop();
                if (iscons(base) && printMode !== PRINTMODE_LATEX) {
                  accumulator += print_str("(");
                  accumulator += print_power(base, newExponent);
                  accumulator += print_str(")");
                } else {
                  accumulator += print_power(base, newExponent);
                }
                if (printMode === PRINTMODE_LATEX) {
                  accumulator += print_str("}");
                }
                return accumulator;
              }
            }
            if (isfraction(exponent) && printMode === PRINTMODE_LATEX) {
              accumulator += print_str("\\sqrt");
              push(exponent);
              denominator();
              denomExponent = pop();
              if (!isplustwo(denomExponent)) {
                accumulator += print_str("[");
                accumulator += print_expr(denomExponent);
                accumulator += print_str("]");
              }
              accumulator += print_str("{");
              push(exponent);
              numerator();
              numExponent = pop();
              exponent = numExponent;
              accumulator += print_power(base, exponent);
              accumulator += print_str("}");
              return accumulator;
            }
          }
          if (printMode === PRINTMODE_LATEX && isplusone(exponent)) {
            accumulator += print_expr(base);
          } else {
            if (isadd(base) || isnegativenumber(base)) {
              accumulator += print_str("(");
              accumulator += print_expr(base);
              accumulator += print_str(")");
            } else if (car(base) === symbol(MULTIPLY) || car(base) === symbol(POWER)) {
              if (printMode !== PRINTMODE_LATEX) {
                accumulator += print_str("(");
              }
              accumulator += print_factor(base, true);
              if (printMode !== PRINTMODE_LATEX) {
                accumulator += print_str(")");
              }
            } else if (isNumericAtom(base) && (lessp(base, zero) || isfraction(base))) {
              accumulator += print_str("(");
              accumulator += print_factor(base);
              accumulator += print_str(")");
            } else {
              accumulator += print_factor(base);
            }
            if (printMode === PRINTMODE_HUMAN && !test_flag) {
              accumulator += print_str(power_str);
            } else {
              accumulator += print_str("^");
            }
            if (printMode === PRINTMODE_LATEX) {
              if (print_expr(exponent).length > 1) {
                accumulator += print_str("{");
                accumulator += print_expr(exponent);
                accumulator += print_str("}");
              } else {
                accumulator += print_expr(exponent);
              }
            } else if (iscons(exponent) || isfraction(exponent) || isNumericAtom(exponent) && lessp(exponent, zero)) {
              accumulator += print_str("(");
              accumulator += print_expr(exponent);
              accumulator += print_str(")");
            } else {
              accumulator += print_factor(exponent);
            }
          }
          return accumulator;
        };
        print_index_function = function(p11) {
          var accumulator;
          accumulator = "";
          p11 = cdr(p11);
          if (caar(p11) === symbol(ADD) || caar(p11) === symbol(MULTIPLY) || caar(p11) === symbol(POWER) || caar(p11) === symbol(FACTORIAL)) {
            accumulator += print_subexpr(car(p11));
          } else {
            accumulator += print_expr(car(p11));
          }
          accumulator += print_str("[");
          p11 = cdr(p11);
          if (iscons(p11)) {
            accumulator += print_expr(car(p11));
            p11 = cdr(p11);
            while (iscons(p11)) {
              accumulator += print_str(",");
              accumulator += print_expr(car(p11));
              p11 = cdr(p11);
            }
          }
          accumulator += print_str("]");
          return accumulator;
        };
        print_factor = function(p11, omitParens, pastFirstFactor) {
          var accumulator, base, exponent, fbody2, parameters, returned;
          accumulator = "";
          if (isNumericAtom(p11)) {
            if (pastFirstFactor && lessp(p11, zero)) {
              accumulator += "(";
            }
            accumulator += print_number(p11, pastFirstFactor);
            if (pastFirstFactor && lessp(p11, zero)) {
              accumulator += ")";
            }
            return accumulator;
          }
          if (isstr(p11)) {
            accumulator += print_str('"');
            accumulator += print_str(p11.str);
            accumulator += print_str('"');
            return accumulator;
          }
          if (istensor(p11)) {
            if (printMode === PRINTMODE_LATEX) {
              accumulator += print_tensor_latex(p11);
            } else {
              accumulator += print_tensor(p11);
            }
            return accumulator;
          }
          if (car(p11) === symbol(MULTIPLY)) {
            if (!omitParens) {
              if (sign_of_term(p11) === "-" || printMode !== PRINTMODE_LATEX) {
                if (printMode === PRINTMODE_LATEX) {
                  accumulator += print_str(" \\left (");
                } else {
                  accumulator += print_str("(");
                }
              }
            }
            accumulator += print_expr(p11);
            if (!omitParens) {
              if (sign_of_term(p11) === "-" || printMode !== PRINTMODE_LATEX) {
                if (printMode === PRINTMODE_LATEX) {
                  accumulator += print_str(" \\right ) ");
                } else {
                  accumulator += print_str(")");
                }
              }
            }
            return accumulator;
          } else if (isadd(p11)) {
            if (!omitParens) {
              accumulator += print_str("(");
            }
            accumulator += print_expr(p11);
            if (!omitParens) {
              accumulator += print_str(")");
            }
            return accumulator;
          }
          if (car(p11) === symbol(POWER)) {
            base = cadr(p11);
            exponent = caddr(p11);
            accumulator += print_power(base, exponent);
            return accumulator;
          }
          if (car(p11) === symbol(FUNCTION)) {
            fbody2 = cadr(p11);
            if (!codeGen) {
              parameters = caddr(p11);
              accumulator += print_str("function ");
              if (DEBUG) {
                console.log("emittedString from print_factor " + stringsEmittedByUserPrintouts);
              }
              returned = print_list(parameters);
              accumulator += returned;
              accumulator += print_str(" -> ");
            }
            accumulator += print_expr(fbody2);
            return accumulator;
          }
          if (car(p11) === symbol(PATTERN)) {
            accumulator += print_expr(caadr(p11));
            if (printMode === PRINTMODE_LATEX) {
              accumulator += print_str(" \\rightarrow ");
            } else {
              if (printMode === PRINTMODE_HUMAN && !test_flag) {
                accumulator += print_str(" -> ");
              } else {
                accumulator += print_str("->");
              }
            }
            accumulator += print_expr(car(cdr(cadr(p11))));
            return accumulator;
          }
          if (car(p11) === symbol(INDEX) && issymbol(cadr(p11))) {
            accumulator += print_index_function(p11);
            return accumulator;
          }
          if (car(p11) === symbol(FACTORIAL)) {
            accumulator += print_factorial_function(p11);
            return accumulator;
          } else if (car(p11) === symbol(ABS) && printMode === PRINTMODE_LATEX) {
            accumulator += print_ABS_latex(p11);
            return accumulator;
          } else if (car(p11) === symbol(SQRT) && printMode === PRINTMODE_LATEX) {
            accumulator += print_SQRT_latex(p11);
            return accumulator;
          } else if (car(p11) === symbol(TRANSPOSE)) {
            if (printMode === PRINTMODE_LATEX) {
              accumulator += print_TRANSPOSE_latex(p11);
              return accumulator;
            } else if (codeGen) {
              accumulator += print_TRANSPOSE_codegen(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(UNIT)) {
            if (codeGen) {
              accumulator += print_UNIT_codegen(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(INV)) {
            if (printMode === PRINTMODE_LATEX) {
              accumulator += print_INV_latex(p11);
              return accumulator;
            } else if (codeGen) {
              accumulator += print_INV_codegen(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(BINOMIAL) && printMode === PRINTMODE_LATEX) {
            accumulator += print_BINOMIAL_latex(p11);
            return accumulator;
          } else if (car(p11) === symbol(DEFINT) && printMode === PRINTMODE_LATEX) {
            accumulator += print_DEFINT_latex(p11);
            return accumulator;
          } else if (isinnerordot(p11)) {
            if (printMode === PRINTMODE_LATEX) {
              accumulator += print_DOT_latex(p11);
              return accumulator;
            } else if (codeGen) {
              accumulator += print_DOT_codegen(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(SIN)) {
            if (codeGen) {
              accumulator += print_SIN_codegen(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(COS)) {
            if (codeGen) {
              accumulator += print_COS_codegen(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(TAN)) {
            if (codeGen) {
              accumulator += print_TAN_codegen(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(ARCSIN)) {
            if (codeGen) {
              accumulator += print_ARCSIN_codegen(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(ARCCOS)) {
            if (codeGen) {
              accumulator += print_ARCCOS_codegen(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(ARCTAN)) {
            if (codeGen) {
              accumulator += print_ARCTAN_codegen(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(SUM)) {
            if (printMode === PRINTMODE_LATEX) {
              accumulator += print_SUM_latex(p11);
              return accumulator;
            } else if (codeGen) {
              accumulator += print_SUM_codegen(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(PRODUCT)) {
            if (printMode === PRINTMODE_LATEX) {
              accumulator += print_PRODUCT_latex(p11);
              return accumulator;
            } else if (codeGen) {
              accumulator += print_PRODUCT_codegen(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(FOR)) {
            if (codeGen) {
              accumulator += print_FOR_codegen(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(DO)) {
            if (codeGen) {
              accumulator += print_DO_codegen(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(TEST)) {
            if (codeGen) {
              accumulator += print_TEST_codegen(p11);
              return accumulator;
            }
            if (printMode === PRINTMODE_LATEX) {
              accumulator += print_TEST_latex(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(TESTLT)) {
            if (codeGen) {
              accumulator += "((" + print_expr(cadr(p11)) + ") < (" + print_expr(caddr(p11)) + "))";
              return accumulator;
            }
            if (printMode === PRINTMODE_LATEX) {
              accumulator += print_TESTLT_latex(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(TESTLE)) {
            if (codeGen) {
              accumulator += "((" + print_expr(cadr(p11)) + ") <= (" + print_expr(caddr(p11)) + "))";
              return accumulator;
            }
            if (printMode === PRINTMODE_LATEX) {
              accumulator += print_TESTLE_latex(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(TESTGT)) {
            if (codeGen) {
              accumulator += "((" + print_expr(cadr(p11)) + ") > (" + print_expr(caddr(p11)) + "))";
              return accumulator;
            }
            if (printMode === PRINTMODE_LATEX) {
              accumulator += print_TESTGT_latex(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(TESTGE)) {
            if (codeGen) {
              accumulator += "((" + print_expr(cadr(p11)) + ") >= (" + print_expr(caddr(p11)) + "))";
              return accumulator;
            }
            if (printMode === PRINTMODE_LATEX) {
              accumulator += print_TESTGE_latex(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(TESTEQ)) {
            if (codeGen) {
              accumulator += "((" + print_expr(cadr(p11)) + ") === (" + print_expr(caddr(p11)) + "))";
              return accumulator;
            }
            if (printMode === PRINTMODE_LATEX) {
              accumulator += print_TESTEQ_latex(p11);
              return accumulator;
            }
          } else if (car(p11) === symbol(FLOOR)) {
            if (codeGen) {
              accumulator += "Math.floor(" + print_expr(cadr(p11)) + ")";
              return accumulator;
            }
            if (printMode === PRINTMODE_LATEX) {
              accumulator += " \\lfloor {" + print_expr(cadr(p11)) + "} \\rfloor ";
              return accumulator;
            }
          } else if (car(p11) === symbol(CEILING)) {
            if (codeGen) {
              accumulator += "Math.ceiling(" + print_expr(cadr(p11)) + ")";
              return accumulator;
            }
            if (printMode === PRINTMODE_LATEX) {
              accumulator += " \\lceil {" + print_expr(cadr(p11)) + "} \\rceil ";
              return accumulator;
            }
          } else if (car(p11) === symbol(ROUND)) {
            if (codeGen) {
              accumulator += "Math.round(" + print_expr(cadr(p11)) + ")";
              return accumulator;
            }
          } else if (car(p11) === symbol(SETQ)) {
            if (codeGen) {
              accumulator += print_SETQ_codegen(p11);
              return accumulator;
            } else {
              accumulator += print_expr(cadr(p11));
              accumulator += print_str("=");
              accumulator += print_expr(caddr(p11));
              return accumulator;
            }
          }
          if (iscons(p11)) {
            accumulator += print_factor(car(p11));
            p11 = cdr(p11);
            if (!omitParens) {
              accumulator += print_str("(");
            }
            if (iscons(p11)) {
              accumulator += print_expr(car(p11));
              p11 = cdr(p11);
              while (iscons(p11)) {
                accumulator += print_str(",");
                accumulator += print_expr(car(p11));
                p11 = cdr(p11);
              }
            }
            if (!omitParens) {
              accumulator += print_str(")");
            }
            return accumulator;
          }
          if (p11 === symbol(DERIVATIVE)) {
            accumulator += print_char("d");
          } else if (p11 === symbol(E)) {
            if (codeGen) {
              accumulator += print_str("Math.E");
            } else {
              accumulator += print_str("e");
            }
          } else if (p11 === symbol(PI)) {
            if (printMode === PRINTMODE_LATEX) {
              accumulator += print_str("\\pi");
            } else {
              accumulator += print_str("pi");
            }
          } else {
            accumulator += print_str(get_printname(p11));
          }
          return accumulator;
        };
        print_list = function(p11) {
          var accumulator;
          accumulator = "";
          switch (p11.k) {
            case CONS:
              accumulator += "(";
              accumulator += print_list(car(p11));
              if (p11 === cdr(p11) && p11 !== symbol(NIL)) {
                console.log("oh no recursive!");
                debugger;
              }
              p11 = cdr(p11);
              while (iscons(p11)) {
                accumulator += " ";
                accumulator += print_list(car(p11));
                p11 = cdr(p11);
                if (p11 === cdr(p11) && p11 !== symbol(NIL)) {
                  console.log("oh no recursive!");
                  debugger;
                }
              }
              if (p11 !== symbol(NIL)) {
                accumulator += " . ";
                accumulator += print_list(p11);
              }
              accumulator += ")";
              break;
            case STR:
              accumulator += p11.str;
              break;
            //print_str("\"")
            case NUM:
            case DOUBLE:
              accumulator += print_number(p11, true);
              break;
            case SYM:
              accumulator += get_printname(p11);
              break;
            default:
              accumulator += "<tensor>";
          }
          return accumulator;
        };
        print_multiply_sign = function() {
          var accumulator;
          accumulator = "";
          if (printMode === PRINTMODE_LATEX) {
            if (printMode === PRINTMODE_HUMAN && !test_flag) {
              accumulator += print_str(" ");
            } else {
              return accumulator;
            }
          }
          if (printMode === PRINTMODE_HUMAN && !test_flag && !codeGen) {
            accumulator += print_str(" ");
          } else {
            accumulator += print_str("*");
          }
          return accumulator;
        };
        is_denominator = function(p11) {
          if (car(p11) === symbol(POWER) && cadr(p11) !== symbol(E) && isnegativeterm(caddr(p11))) {
            return 1;
          } else {
            return 0;
          }
        };
        any_denominators = function(p11) {
          var q;
          p11 = cdr(p11);
          while (iscons(p11)) {
            q = car(p11);
            if (is_denominator(q)) {
              return 1;
            }
            p11 = cdr(p11);
          }
          return 0;
        };
        YMAX = 1e4;
        glyph = function() {
          class glyph2 {
          }
          ;
          glyph2.prototype.c = 0;
          glyph2.prototype.x = 0;
          glyph2.prototype.y = 0;
          return glyph2;
        }.call(this);
        chartab = [];
        for (charTabIndex = i1 = 0, ref1 = YMAX; 0 <= ref1 ? i1 < ref1 : i1 > ref1; charTabIndex = 0 <= ref1 ? ++i1 : --i1) {
          chartab[charTabIndex] = new glyph();
        }
        yindex = 0;
        level = 0;
        emit_x = 0;
        expr_level = 0;
        display_flag = 0;
        printchar_nowrap = function(character) {
          var accumulator;
          accumulator = "";
          accumulator += character;
          return accumulator;
        };
        printchar = function(character) {
          return printchar_nowrap(character);
        };
        print2dascii = function(p11) {
          var beenPrinted, h5, w2, y3;
          h5 = 0;
          w2 = 0;
          y3 = 0;
          save();
          yindex = 0;
          level = 0;
          emit_x = 0;
          emit_top_expr(p11);
          [h5, w2, y3] = get_size(0, yindex);
          if (w2 > 100) {
            printline(p11);
            restore();
            return;
          }
          beenPrinted = print_glyphs();
          restore();
          return beenPrinted;
        };
        emit_top_expr = function(p11) {
          if (car(p11) === symbol(SETQ)) {
            emit_expr(cadr(p11));
            __emit_str(" = ");
            emit_expr(caddr(p11));
            return;
          }
          if (istensor(p11)) {
            return emit_tensor(p11);
          } else {
            return emit_expr(p11);
          }
        };
        will_be_displayed_as_fraction = function(p11) {
          if (level > 0) {
            return 0;
          }
          if (isfraction(p11)) {
            return 1;
          }
          if (car(p11) !== symbol(MULTIPLY)) {
            return 0;
          }
          if (isfraction(cadr(p11))) {
            return 1;
          }
          while (iscons(p11)) {
            if (isdenominator(car(p11))) {
              return 1;
            }
            p11 = cdr(p11);
          }
          return 0;
        };
        emit_expr = function(p11) {
          expr_level++;
          if (car(p11) === symbol(ADD)) {
            p11 = cdr(p11);
            if (__is_negative(car(p11))) {
              __emit_char("-");
              if (will_be_displayed_as_fraction(car(p11))) {
                __emit_char(" ");
              }
            }
            emit_term(car(p11));
            p11 = cdr(p11);
            while (iscons(p11)) {
              if (__is_negative(car(p11))) {
                __emit_char(" ");
                __emit_char("-");
                __emit_char(" ");
              } else {
                __emit_char(" ");
                __emit_char("+");
                __emit_char(" ");
              }
              emit_term(car(p11));
              p11 = cdr(p11);
            }
          } else {
            if (__is_negative(p11)) {
              __emit_char("-");
              if (will_be_displayed_as_fraction(p11)) {
                __emit_char(" ");
              }
            }
            emit_term(p11);
          }
          return expr_level--;
        };
        emit_unsigned_expr = function(p11) {
          var results;
          if (car(p11) === symbol(ADD)) {
            p11 = cdr(p11);
            emit_term(car(p11));
            p11 = cdr(p11);
            results = [];
            while (iscons(p11)) {
              if (__is_negative(car(p11))) {
                __emit_char(" ");
                __emit_char("-");
                __emit_char(" ");
              } else {
                __emit_char(" ");
                __emit_char("+");
                __emit_char(" ");
              }
              emit_term(car(p11));
              results.push(p11 = cdr(p11));
            }
            return results;
          } else {
            return emit_term(p11);
          }
        };
        __is_negative = function(p11) {
          if (isnegativenumber(p11)) {
            return 1;
          }
          if (car(p11) === symbol(MULTIPLY) && isnegativenumber(cadr(p11))) {
            return 1;
          }
          return 0;
        };
        emit_term = function(p11) {
          var n9;
          if (car(p11) === symbol(MULTIPLY)) {
            n9 = count_denominators(p11);
            if (n9 && level === 0) {
              return emit_fraction(p11, n9);
            } else {
              return emit_multiply(p11, n9);
            }
          } else {
            return emit_factor(p11);
          }
        };
        isdenominator = function(p11) {
          if (car(p11) === symbol(POWER) && cadr(p11) !== symbol(E) && __is_negative(caddr(p11))) {
            return 1;
          } else {
            return 0;
          }
        };
        count_denominators = function(p11) {
          var count4, q;
          count4 = 0;
          p11 = cdr(p11);
          while (iscons(p11)) {
            q = car(p11);
            if (isdenominator(q)) {
              count4++;
            }
            p11 = cdr(p11);
          }
          return count4;
        };
        emit_multiply = function(p11, n9) {
          var results;
          if (n9 === 0) {
            p11 = cdr(p11);
            if (isplusone(car(p11)) || isminusone(car(p11))) {
              p11 = cdr(p11);
            }
            emit_factor(car(p11));
            p11 = cdr(p11);
            results = [];
            while (iscons(p11)) {
              __emit_char(" ");
              emit_factor(car(p11));
              results.push(p11 = cdr(p11));
            }
            return results;
          } else {
            emit_numerators(p11);
            __emit_char("/");
            if (n9 > 1 || isfraction(cadr(p11))) {
              __emit_char("(");
              emit_denominators(p11);
              return __emit_char(")");
            } else {
              return emit_denominators(p11);
            }
          }
        };
        emit_fraction = function(p11, d3) {
          var count4, doNothing, k1, k22, n9, x3;
          count4 = 0;
          k1 = 0;
          k22 = 0;
          n9 = 0;
          x3 = 0;
          save();
          p3 = one;
          p4 = one;
          if (isrational(cadr(p11))) {
            push(cadr(p11));
            mp_numerator();
            absval();
            p3 = pop();
            push(cadr(p11));
            mp_denominator();
            p4 = pop();
          }
          if (isdouble(cadr(p11))) {
            push(cadr(p11));
            absval();
            p3 = pop();
          }
          if (isplusone(p3)) {
            n9 = 0;
          } else {
            n9 = 1;
          }
          p1 = cdr(p11);
          if (isNumericAtom(car(p1))) {
            p1 = cdr(p1);
          }
          while (iscons(p1)) {
            p2 = car(p1);
            if (isdenominator(p2)) {
              doNothing = 1;
            } else {
              n9++;
            }
            p1 = cdr(p1);
          }
          x3 = emit_x;
          k1 = yindex;
          count4 = 0;
          if (!isplusone(p3)) {
            emit_number(p3, 0);
            count4++;
          }
          p1 = cdr(p11);
          if (isNumericAtom(car(p1))) {
            p1 = cdr(p1);
          }
          while (iscons(p1)) {
            p2 = car(p1);
            if (isdenominator(p2)) {
              doNothing = 1;
            } else {
              if (count4 > 0) {
                __emit_char(" ");
              }
              if (n9 === 1) {
                emit_expr(p2);
              } else {
                emit_factor(p2);
              }
              count4++;
            }
            p1 = cdr(p1);
          }
          if (count4 === 0) {
            __emit_char("1");
          }
          k22 = yindex;
          count4 = 0;
          if (!isplusone(p4)) {
            emit_number(p4, 0);
            count4++;
            d3++;
          }
          p1 = cdr(p11);
          if (isrational(car(p1))) {
            p1 = cdr(p1);
          }
          while (iscons(p1)) {
            p2 = car(p1);
            if (isdenominator(p2)) {
              if (count4 > 0) {
                __emit_char(" ");
              }
              emit_denominator(p2, d3);
              count4++;
            }
            p1 = cdr(p1);
          }
          fixup_fraction(x3, k1, k22);
          return restore();
        };
        emit_numerators = function(p11) {
          var doNothing, n9;
          save();
          n9 = 0;
          p1 = one;
          p11 = cdr(p11);
          if (isrational(car(p11))) {
            push(car(p11));
            mp_numerator();
            absval();
            p1 = pop();
            p11 = cdr(p11);
          } else if (isdouble(car(p11))) {
            push(car(p11));
            absval();
            p1 = pop();
            p11 = cdr(p11);
          }
          n9 = 0;
          if (!isplusone(p1)) {
            emit_number(p1, 0);
            n9++;
          }
          while (iscons(p11)) {
            if (isdenominator(car(p11))) {
              doNothing = 1;
            } else {
              if (n9 > 0) {
                __emit_char(" ");
              }
              emit_factor(car(p11));
              n9++;
            }
            p11 = cdr(p11);
          }
          if (n9 === 0) {
            __emit_char("1");
          }
          return restore();
        };
        emit_denominators = function(p11) {
          var n9;
          save();
          n9 = 0;
          p11 = cdr(p11);
          if (isfraction(car(p11))) {
            push(car(p11));
            mp_denominator();
            p1 = pop();
            emit_number(p1, 0);
            n9++;
            p11 = cdr(p11);
          }
          while (iscons(p11)) {
            if (isdenominator(car(p11))) {
              if (n9 > 0) {
                __emit_char(" ");
              }
              emit_denominator(car(p11), 0);
              n9++;
            }
            p11 = cdr(p11);
          }
          return restore();
        };
        emit_factor = function(p11) {
          if (istensor(p11)) {
            if (level === 0) {
              emit_flat_tensor(p11);
            } else {
              emit_flat_tensor(p11);
            }
            return;
          }
          if (isdouble(p11)) {
            emit_number(p11, 0);
            return;
          }
          if (car(p11) === symbol(ADD) || car(p11) === symbol(MULTIPLY)) {
            emit_subexpr(p11);
            return;
          }
          if (car(p11) === symbol(POWER)) {
            emit_power(p11);
            return;
          }
          if (iscons(p11)) {
            emit_function(p11);
            return;
          }
          if (isNumericAtom(p11)) {
            if (level === 0) {
              emit_numerical_fraction(p11);
            } else {
              emit_number(p11, 0);
            }
            return;
          }
          if (issymbol(p11)) {
            emit_symbol(p11);
            return;
          }
          if (isstr(p11)) {
            emit_string(p11);
          }
        };
        emit_numerical_fraction = function(p11) {
          var k1, k22, x3;
          k1 = 0;
          k22 = 0;
          x3 = 0;
          save();
          push(p11);
          mp_numerator();
          absval();
          p3 = pop();
          push(p11);
          mp_denominator();
          p4 = pop();
          if (isplusone(p4)) {
            emit_number(p3, 0);
            restore();
            return;
          }
          x3 = emit_x;
          k1 = yindex;
          emit_number(p3, 0);
          k22 = yindex;
          emit_number(p4, 0);
          fixup_fraction(x3, k1, k22);
          return restore();
        };
        isfactor = function(p11) {
          if (iscons(p11) && car(p11) !== symbol(ADD) && car(p11) !== symbol(MULTIPLY) && car(p11) !== symbol(POWER)) {
            return 1;
          }
          if (issymbol(p11)) {
            return 1;
          }
          if (isfraction(p11)) {
            return 0;
          }
          if (isnegativenumber(p11)) {
            return 0;
          }
          if (isNumericAtom(p11)) {
            return 1;
          }
          return 0;
        };
        emit_power = function(p11) {
          var k1, k22, x3;
          k1 = 0;
          k22 = 0;
          x3 = 0;
          if (cadr(p11) === symbol(E)) {
            __emit_str("exp(");
            emit_expr(caddr(p11));
            __emit_char(")");
            return;
          }
          if (level > 0) {
            if (isminusone(caddr(p11))) {
              __emit_char("1");
              __emit_char("/");
              if (isfactor(cadr(p11))) {
                emit_factor(cadr(p11));
              } else {
                emit_subexpr(cadr(p11));
              }
            } else {
              if (isfactor(cadr(p11))) {
                emit_factor(cadr(p11));
              } else {
                emit_subexpr(cadr(p11));
              }
              __emit_char("^");
              if (isfactor(caddr(p11))) {
                emit_factor(caddr(p11));
              } else {
                emit_subexpr(caddr(p11));
              }
            }
            return;
          }
          if (__is_negative(caddr(p11))) {
            x3 = emit_x;
            k1 = yindex;
            __emit_char("1");
            k22 = yindex;
            emit_denominator(p11, 1);
            fixup_fraction(x3, k1, k22);
            return;
          }
          k1 = yindex;
          if (isfactor(cadr(p11))) {
            emit_factor(cadr(p11));
          } else {
            emit_subexpr(cadr(p11));
          }
          k22 = yindex;
          level++;
          emit_expr(caddr(p11));
          level--;
          return fixup_power(k1, k22);
        };
        emit_denominator = function(p11, n9) {
          var k1, k22;
          k1 = 0;
          k22 = 0;
          if (isminusone(caddr(p11))) {
            if (n9 === 1) {
              emit_expr(cadr(p11));
            } else {
              emit_factor(cadr(p11));
            }
            return;
          }
          k1 = yindex;
          if (isfactor(cadr(p11))) {
            emit_factor(cadr(p11));
          } else {
            emit_subexpr(cadr(p11));
          }
          k22 = yindex;
          level++;
          emit_unsigned_expr(caddr(p11));
          level--;
          return fixup_power(k1, k22);
        };
        emit_function = function(p11) {
          if (car(p11) === symbol(INDEX) && issymbol(cadr(p11))) {
            emit_index_function(p11);
            return;
          }
          if (car(p11) === symbol(FACTORIAL)) {
            emit_factorial_function(p11);
            return;
          }
          if (car(p11) === symbol(DERIVATIVE)) {
            __emit_char("d");
          } else {
            emit_symbol(car(p11));
          }
          __emit_char("(");
          p11 = cdr(p11);
          if (iscons(p11)) {
            emit_expr(car(p11));
            p11 = cdr(p11);
            while (iscons(p11)) {
              __emit_char(",");
              emit_expr(car(p11));
              p11 = cdr(p11);
            }
          }
          return __emit_char(")");
        };
        emit_index_function = function(p11) {
          p11 = cdr(p11);
          if (caar(p11) === symbol(ADD) || caar(p11) === symbol(MULTIPLY) || caar(p11) === symbol(POWER) || caar(p11) === symbol(FACTORIAL)) {
            emit_subexpr(car(p11));
          } else {
            emit_expr(car(p11));
          }
          __emit_char("[");
          p11 = cdr(p11);
          if (iscons(p11)) {
            emit_expr(car(p11));
            p11 = cdr(p11);
            while (iscons(p11)) {
              __emit_char(",");
              emit_expr(car(p11));
              p11 = cdr(p11);
            }
          }
          return __emit_char("]");
        };
        emit_factorial_function = function(p11) {
          p11 = cadr(p11);
          if (isfraction(p11) || car(p11) === symbol(ADD) || car(p11) === symbol(MULTIPLY) || car(p11) === symbol(POWER) || car(p11) === symbol(FACTORIAL)) {
            emit_subexpr(p11);
          } else {
            emit_expr(p11);
          }
          return __emit_char("!");
        };
        emit_subexpr = function(p11) {
          __emit_char("(");
          emit_expr(p11);
          return __emit_char(")");
        };
        emit_symbol = function(p11) {
          var i5, j12, pPrintName, ref2, results;
          i5 = 0;
          if (p11 === symbol(E)) {
            __emit_str("exp(1)");
            return;
          }
          pPrintName = get_printname(p11);
          results = [];
          for (i5 = j12 = 0, ref2 = pPrintName.length; 0 <= ref2 ? j12 < ref2 : j12 > ref2; i5 = 0 <= ref2 ? ++j12 : --j12) {
            results.push(__emit_char(pPrintName[i5]));
          }
          return results;
        };
        emit_string = function(p11) {
          var i5, j12, pString, ref2;
          i5 = 0;
          pString = p11.str;
          __emit_char('"');
          for (i5 = j12 = 0, ref2 = pString.length; 0 <= ref2 ? j12 < ref2 : j12 > ref2; i5 = 0 <= ref2 ? ++j12 : --j12) {
            __emit_char(pString[i5]);
          }
          return __emit_char('"');
        };
        fixup_fraction = function(x3, k1, k22) {
          var dx, dy, h1, h22, i5, j12, ref2, results, w2, w1, w22, y3, y12, y22;
          dx = 0;
          dy = 0;
          i5 = 0;
          w2 = 0;
          y3 = 0;
          h1 = 0;
          w1 = 0;
          y12 = 0;
          h22 = 0;
          w22 = 0;
          y22 = 0;
          [h1, w1, y12] = get_size(k1, k22);
          [h22, w22, y22] = get_size(k22, yindex);
          if (w22 > w1) {
            dx = (w22 - w1) / 2;
          } else {
            dx = 0;
          }
          dx++;
          y3 = y12 + h1 - 1;
          dy = -y3 - 1;
          move(k1, k22, dx, dy);
          if (w22 > w1) {
            dx = -w1;
          } else {
            dx = -w1 + (w1 - w22) / 2;
          }
          dx++;
          dy = -y22 + 1;
          move(k22, yindex, dx, dy);
          if (w22 > w1) {
            w2 = w22;
          } else {
            w2 = w1;
          }
          w2 += 2;
          emit_x = x3;
          results = [];
          for (i5 = j12 = 0, ref2 = w2; 0 <= ref2 ? j12 < ref2 : j12 > ref2; i5 = 0 <= ref2 ? ++j12 : --j12) {
            results.push(__emit_char("-"));
          }
          return results;
        };
        fixup_power = function(k1, k22) {
          var dy, h1, h22, w1, w2, y12, y22;
          dy = 0;
          h1 = 0;
          w1 = 0;
          y12 = 0;
          h22 = 0;
          w2 = 0;
          y22 = 0;
          [h1, w1, y12] = get_size(k1, k22);
          [h22, w2, y22] = get_size(k22, yindex);
          dy = -y22 - h22 + 1;
          dy += y12 - 1;
          return move(k22, yindex, 0, dy);
        };
        move = function(j2, k3, dx, dy) {
          var i5, j12, ref2, ref3, results;
          i5 = 0;
          results = [];
          for (i5 = j12 = ref2 = j2, ref3 = k3; ref2 <= ref3 ? j12 < ref3 : j12 > ref3; i5 = ref2 <= ref3 ? ++j12 : --j12) {
            chartab[i5].x += dx;
            results.push(chartab[i5].y += dy);
          }
          return results;
        };
        get_size = function(j2, k3) {
          var h5, i5, j12, max_x, max_y, min_x, min_y, ref2, ref3, w2, y3;
          i5 = 0;
          min_x = chartab[j2].x;
          max_x = chartab[j2].x;
          min_y = chartab[j2].y;
          max_y = chartab[j2].y;
          for (i5 = j12 = ref2 = j2 + 1, ref3 = k3; ref2 <= ref3 ? j12 < ref3 : j12 > ref3; i5 = ref2 <= ref3 ? ++j12 : --j12) {
            if (chartab[i5].x < min_x) {
              min_x = chartab[i5].x;
            }
            if (chartab[i5].x > max_x) {
              max_x = chartab[i5].x;
            }
            if (chartab[i5].y < min_y) {
              min_y = chartab[i5].y;
            }
            if (chartab[i5].y > max_y) {
              max_y = chartab[i5].y;
            }
          }
          h5 = max_y - min_y + 1;
          w2 = max_x - min_x + 1;
          y3 = min_y;
          return [h5, w2, y3];
        };
        displaychar = function(c9) {
          return __emit_char(c9);
        };
        __emit_char = function(c9) {
          if (yindex === YMAX) {
            return;
          }
          if (chartab[yindex] == null) {
            debugger;
          }
          chartab[yindex].c = c9;
          chartab[yindex].x = emit_x;
          chartab[yindex].y = 0;
          yindex++;
          return emit_x++;
        };
        __emit_str = function(s8) {
          var i5, j12, ref2, results;
          i5 = 0;
          results = [];
          for (i5 = j12 = 0, ref2 = s8.length; 0 <= ref2 ? j12 < ref2 : j12 > ref2; i5 = 0 <= ref2 ? ++j12 : --j12) {
            results.push(__emit_char(s8[i5]));
          }
          return results;
        };
        emit_number = function(p11, emit_sign) {
          var i5, j12, l1, m1, ref2, ref3, ref4, results, results1, tmpString;
          tmpString = "";
          i5 = 0;
          switch (p11.k) {
            case NUM:
              tmpString = p11.q.a.toString();
              if (tmpString[0] === "-" && emit_sign === 0) {
                tmpString = tmpString.substring(1);
              }
              for (i5 = j12 = 0, ref2 = tmpString.length; 0 <= ref2 ? j12 < ref2 : j12 > ref2; i5 = 0 <= ref2 ? ++j12 : --j12) {
                __emit_char(tmpString[i5]);
              }
              tmpString = p11.q.b.toString();
              if (tmpString === "1") {
                break;
              }
              __emit_char("/");
              results = [];
              for (i5 = l1 = 0, ref3 = tmpString.length; 0 <= ref3 ? l1 < ref3 : l1 > ref3; i5 = 0 <= ref3 ? ++l1 : --l1) {
                results.push(__emit_char(tmpString[i5]));
              }
              return results;
              break;
            case DOUBLE:
              tmpString = doubleToReasonableString(p11.d);
              if (tmpString[0] === "-" && emit_sign === 0) {
                tmpString = tmpString.substring(1);
              }
              results1 = [];
              for (i5 = m1 = 0, ref4 = tmpString.length; 0 <= ref4 ? m1 < ref4 : m1 > ref4; i5 = 0 <= ref4 ? ++m1 : --m1) {
                results1.push(__emit_char(tmpString[i5]));
              }
              return results1;
          }
        };
        cmpGlyphs = function(a5, b2) {
          if (a5.y < b2.y) {
            return -1;
          }
          if (a5.y > b2.y) {
            return 1;
          }
          if (a5.x < b2.x) {
            return -1;
          }
          if (a5.x > b2.x) {
            return 1;
          }
          return 0;
        };
        print_glyphs = function() {
          var accumulator, i5, j12, ref2, subsetOfStack, x3, y3;
          i5 = 0;
          accumulator = "";
          subsetOfStack = chartab.slice(0, yindex);
          subsetOfStack.sort(cmpGlyphs);
          chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));
          x3 = 0;
          y3 = chartab[0].y;
          for (i5 = j12 = 0, ref2 = yindex; 0 <= ref2 ? j12 < ref2 : j12 > ref2; i5 = 0 <= ref2 ? ++j12 : --j12) {
            while (chartab[i5].y > y3) {
              accumulator += printchar("\n");
              x3 = 0;
              y3++;
            }
            while (chartab[i5].x > x3) {
              accumulator += printchar_nowrap(" ");
              x3++;
            }
            accumulator += printchar_nowrap(chartab[i5].c);
            x3++;
          }
          return accumulator;
        };
        buffer = "";
        getdisplaystr = function() {
          yindex = 0;
          level = 0;
          emit_x = 0;
          emit_expr(pop());
          fill_buf();
          return buffer;
        };
        fill_buf = function() {
          var i5, j12, ref2, sIndex, subsetOfStack, tmpBuffer, x3, y3;
          tmpBuffer = buffer;
          sIndex = 0;
          i5 = 0;
          subsetOfStack = chartab.slice(0, yindex);
          subsetOfStack.sort(cmpGlyphs);
          chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));
          x3 = 0;
          y3 = chartab[0].y;
          for (i5 = j12 = 0, ref2 = yindex; 0 <= ref2 ? j12 < ref2 : j12 > ref2; i5 = 0 <= ref2 ? ++j12 : --j12) {
            while (chartab[i5].y > y3) {
              tmpBuffer[sIndex++] = "\n";
              x3 = 0;
              y3++;
            }
            while (chartab[i5].x > x3) {
              tmpBuffer[sIndex++] = " ";
              x3++;
            }
            tmpBuffer[sIndex++] = chartab[i5].c;
            x3++;
          }
          return tmpBuffer[sIndex++] = "\n";
        };
        N = 100;
        oneElement = function() {
          class oneElement2 {
          }
          ;
          oneElement2.prototype.x = 0;
          oneElement2.prototype.y = 0;
          oneElement2.prototype.h = 0;
          oneElement2.prototype.w = 0;
          oneElement2.prototype.index = 0;
          oneElement2.prototype.count = 0;
          return oneElement2;
        }.call(this);
        elem = [];
        for (elelmIndex = j1 = 0; j1 < 1e4; elelmIndex = ++j1) {
          elem[elelmIndex] = new oneElement();
        }
        SPACE_BETWEEN_COLUMNS = 3;
        SPACE_BETWEEN_ROWS = 1;
        emit_tensor = function(p11) {
          var col, dx, dy, eh, ew, h5, i5, l1, m1, n9, n1, ncol, nrow, o1, ref2, ref3, ref4, ref5, row, w2, x3, y3;
          i5 = 0;
          n9 = 0;
          nrow = 0;
          ncol = 0;
          x3 = 0;
          y3 = 0;
          h5 = 0;
          w2 = 0;
          dx = 0;
          dy = 0;
          eh = 0;
          ew = 0;
          row = 0;
          col = 0;
          if (p11.tensor.ndim > 2) {
            emit_flat_tensor(p11);
            return;
          }
          nrow = p11.tensor.dim[0];
          if (p11.tensor.ndim === 2) {
            ncol = p11.tensor.dim[1];
          } else {
            ncol = 1;
          }
          n9 = nrow * ncol;
          if (n9 > N) {
            emit_flat_tensor(p11);
            return;
          }
          x3 = emit_x;
          for (i5 = l1 = 0, ref2 = n9; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            elem[i5].index = yindex;
            elem[i5].x = emit_x;
            emit_expr(p11.tensor.elem[i5]);
            elem[i5].count = yindex - elem[i5].index;
            [elem[i5].h, elem[i5].w, elem[i5].y] = get_size(elem[i5].index, yindex);
          }
          eh = 0;
          ew = 0;
          for (i5 = m1 = 0, ref3 = n9; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i5 = 0 <= ref3 ? ++m1 : --m1) {
            if (elem[i5].h > eh) {
              eh = elem[i5].h;
            }
            if (elem[i5].w > ew) {
              ew = elem[i5].w;
            }
          }
          h5 = nrow * eh + (nrow - 1) * SPACE_BETWEEN_ROWS;
          w2 = ncol * ew + (ncol - 1) * SPACE_BETWEEN_COLUMNS;
          y3 = -(h5 / 2);
          for (row = n1 = 0, ref4 = nrow; 0 <= ref4 ? n1 < ref4 : n1 > ref4; row = 0 <= ref4 ? ++n1 : --n1) {
            for (col = o1 = 0, ref5 = ncol; 0 <= ref5 ? o1 < ref5 : o1 > ref5; col = 0 <= ref5 ? ++o1 : --o1) {
              i5 = row * ncol + col;
              dx = x3 - elem[i5].x;
              dy = y3 - elem[i5].y;
              move(elem[i5].index, elem[i5].index + elem[i5].count, dx, dy);
              dx = 0;
              if (col > 0) {
                dx = col * (ew + SPACE_BETWEEN_COLUMNS);
              }
              dy = 0;
              if (row > 0) {
                dy = row * (eh + SPACE_BETWEEN_ROWS);
              }
              dx += (ew - elem[i5].w) / 2;
              dy += (eh - elem[i5].h) / 2;
              move(elem[i5].index, elem[i5].index + elem[i5].count, dx, dy);
            }
          }
          return emit_x = x3 + w2;
        };
        emit_flat_tensor = function(p11) {
          return emit_tensor_inner(p11, 0, 0);
        };
        emit_tensor_inner = function(p11, j2, k3) {
          var i5, l1, ref2;
          i5 = 0;
          __emit_char("(");
          for (i5 = l1 = 0, ref2 = p11.tensor.dim[j2]; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            if (j2 + 1 === p11.tensor.ndim) {
              emit_expr(p11.tensor.elem[k3]);
              k3 = k3 + 1;
            } else {
              k3 = emit_tensor_inner(p11, j2 + 1, k3);
            }
            if (i5 + 1 < p11.tensor.dim[j2]) {
              __emit_char(",");
            }
          }
          __emit_char(")");
          return k3;
        };
        Eval_product = function() {
          var body, i5, indexVariable, j2, k3, l1, oldIndexVariableValue, ref2, ref3;
          i5 = 0;
          j2 = 0;
          k3 = 0;
          body = cadr(p1);
          indexVariable = caddr(p1);
          if (!issymbol(indexVariable)) {
            stop("sum: 2nd arg?");
          }
          push(cadddr(p1));
          Eval();
          j2 = pop_integer();
          if (isNaN(j2)) {
            push(p1);
            return;
          }
          push(caddddr(p1));
          Eval();
          k3 = pop_integer();
          if (isNaN(k3)) {
            push(p1);
            return;
          }
          oldIndexVariableValue = get_binding(indexVariable);
          push_integer(1);
          for (i5 = l1 = ref2 = j2, ref3 = k3; ref2 <= ref3 ? l1 <= ref3 : l1 >= ref3; i5 = ref2 <= ref3 ? ++l1 : --l1) {
            push_integer(i5);
            p5 = pop();
            set_binding(indexVariable, p5);
            push(body);
            Eval();
            if (DEBUG) {
              console.log("product - factor 1: " + stack[tos - 1].toString());
              console.log("product - factor 2: " + stack[tos - 2].toString());
            }
            multiply();
            if (DEBUG) {
              console.log("product - result: " + stack[tos - 1].toString());
            }
          }
          return set_binding(indexVariable, oldIndexVariableValue);
        };
        qadd = function() {
          var gcdBetweenNumeratorAndDenominator, qadd_ab, qadd_ba, qadd_denominator, qadd_frac1, qadd_frac2, qadd_numerator, resultSum;
          qadd_frac2 = pop();
          qadd_frac1 = pop();
          qadd_ab = mmul(qadd_frac1.q.a, qadd_frac2.q.b);
          qadd_ba = mmul(qadd_frac1.q.b, qadd_frac2.q.a);
          qadd_numerator = madd(qadd_ab, qadd_ba);
          if (MZERO(qadd_numerator)) {
            push(zero);
            return;
          }
          qadd_denominator = mmul(qadd_frac1.q.b, qadd_frac2.q.b);
          gcdBetweenNumeratorAndDenominator = mgcd(qadd_numerator, qadd_denominator);
          gcdBetweenNumeratorAndDenominator = makeSignSameAs(gcdBetweenNumeratorAndDenominator, qadd_denominator);
          resultSum = new U();
          resultSum.k = NUM;
          resultSum.q.a = mdiv(qadd_numerator, gcdBetweenNumeratorAndDenominator);
          resultSum.q.b = mdiv(qadd_denominator, gcdBetweenNumeratorAndDenominator);
          return push(resultSum);
        };
        qdiv = function() {
          var aa2, bb2, c9;
          save();
          p2 = pop();
          p1 = pop();
          if (MZERO(p2.q.a)) {
            stop("divide by zero");
          }
          if (MZERO(p1.q.a)) {
            push(zero);
            restore();
            return;
          }
          aa2 = mmul(p1.q.a, p2.q.b);
          bb2 = mmul(p1.q.b, p2.q.a);
          c9 = mgcd(aa2, bb2);
          c9 = makeSignSameAs(c9, bb2);
          p1 = new U();
          p1.k = NUM;
          p1.q.a = mdiv(aa2, c9);
          p1.q.b = mdiv(bb2, c9);
          push(p1);
          return restore();
        };
        qmul = function() {
          var aa2, bb2, c9;
          save();
          p2 = pop();
          p1 = pop();
          if (MZERO(p1.q.a) || MZERO(p2.q.a)) {
            push(zero);
            restore();
            return;
          }
          aa2 = mmul(p1.q.a, p2.q.a);
          bb2 = mmul(p1.q.b, p2.q.b);
          c9 = mgcd(aa2, bb2);
          c9 = makeSignSameAs(c9, bb2);
          p1 = new U();
          p1.k = NUM;
          p1.q.a = mdiv(aa2, c9);
          p1.q.b = mdiv(bb2, c9);
          push(p1);
          return restore();
        };
        qpow = function() {
          save();
          qpowf();
          return restore();
        };
        qpowf = function() {
          var a5, b2, expo, t5, x3, y3;
          expo = 0;
          p2 = pop();
          p1 = pop();
          if (isplusone(p1) || isZeroAtomOrTensor(p2)) {
            push_integer(1);
            return;
          }
          if (isminusone(p1) && isoneovertwo(p2)) {
            push(imaginaryunit);
            return;
          }
          if (isZeroAtomOrTensor(p1)) {
            if (isnegativenumber(p2)) {
              stop("divide by zero");
            }
            push(zero);
            return;
          }
          if (isplusone(p2)) {
            push(p1);
            return;
          }
          if (isinteger(p2)) {
            push(p2);
            expo = pop_integer();
            if (isNaN(expo)) {
              push_symbol(POWER);
              push(p1);
              push(p2);
              list(3);
              return;
            }
            x3 = mpow(p1.q.a, Math.abs(expo));
            y3 = mpow(p1.q.b, Math.abs(expo));
            if (expo < 0) {
              t5 = x3;
              x3 = y3;
              y3 = t5;
              x3 = makeSignSameAs(x3, y3);
              y3 = makePositive(y3);
            }
            p3 = new U();
            p3.k = NUM;
            p3.q.a = x3;
            p3.q.b = y3;
            push(p3);
            return;
          }
          if (isminusone(p1)) {
            push(p2);
            normalize_angle();
            return;
          }
          if (isnegativenumber(p1)) {
            push(p1);
            negate();
            push(p2);
            qpow();
            push_integer(-1);
            push(p2);
            qpow();
            multiply();
            return;
          }
          if (!isinteger(p1)) {
            push(p1);
            mp_numerator();
            push(p2);
            qpow();
            push(p1);
            mp_denominator();
            push(p2);
            negate();
            qpow();
            multiply();
            return;
          }
          if (is_small_integer(p1)) {
            push(p1);
            push(p2);
            quickfactor();
            return;
          }
          if (!isSmall(p2.q.a) || !isSmall(p2.q.b)) {
            push_symbol(POWER);
            push(p1);
            push(p2);
            list(3);
            return;
          }
          a5 = p2.q.a;
          b2 = p2.q.b;
          x3 = mroot(p1.q.a, b2);
          if (x3 === 0) {
            push_symbol(POWER);
            push(p1);
            push(p2);
            list(3);
            return;
          }
          y3 = mpow(x3, a5);
          p3 = new U();
          p3.k = NUM;
          if (p2.q.a.isNegative()) {
            p3.q.a = bigInt(1);
            p3.q.b = y3;
          } else {
            p3.q.a = y3;
            p3.q.b = bigInt(1);
          }
          return push(p3);
        };
        normalize_angle = function() {
          save();
          p1 = pop();
          if (isinteger(p1)) {
            if (p1.q.a.isOdd()) {
              push_integer(-1);
            } else {
              push_integer(1);
            }
            restore();
            return;
          }
          push(p1);
          bignum_truncate();
          p2 = pop();
          if (isnegativenumber(p1)) {
            push(p2);
            push_integer(-1);
            add();
            p2 = pop();
          }
          push(p1);
          push(p2);
          subtract();
          p3 = pop();
          push_symbol(POWER);
          push_integer(-1);
          push(p3);
          list(3);
          if (p2.q.a.isOdd()) {
            negate();
          }
          return restore();
        };
        is_small_integer = function(p11) {
          return isSmall(p11.q.a);
        };
        quickfactor = function() {
          var h5, i5, l1, n9, ref2, stackIndex;
          i5 = 0;
          save();
          p2 = pop();
          p1 = pop();
          h5 = tos;
          push(p1);
          factor_small_number();
          n9 = tos - h5;
          stackIndex = h5;
          for (i5 = l1 = 0, ref2 = n9; l1 < ref2; i5 = l1 += 2) {
            push(stack[stackIndex + i5]);
            push(stack[stackIndex + i5 + 1]);
            push(p2);
            multiply();
            quickpower();
          }
          multiply_all(tos - h5 - n9);
          p1 = pop();
          moveTos(h5);
          push(p1);
          return restore();
        };
        quickpower = function() {
          var expo;
          expo = 0;
          save();
          p2 = pop();
          p1 = pop();
          push(p2);
          bignum_truncate();
          p3 = pop();
          push(p2);
          push(p3);
          subtract();
          p4 = pop();
          if (!isZeroAtomOrTensor(p4)) {
            push_symbol(POWER);
            push(p1);
            push(p4);
            list(3);
          }
          push(p3);
          expo = pop_integer();
          if (isNaN(expo)) {
            push_symbol(POWER);
            push(p1);
            push(p3);
            list(3);
            restore();
            return;
          }
          if (expo === 0) {
            restore();
            return;
          }
          push(p1);
          bignum_power_number(expo);
          return restore();
        };
        Eval_quotient = function() {
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          push(cadddr(p1));
          Eval();
          p1 = pop();
          if (p1 === symbol(NIL)) {
            p1 = symbol(SYMBOL_X);
          }
          push(p1);
          return divpoly();
        };
        divpoly = function() {
          var dividend, divisor, h5, i5, l1, m3, n9, ref2, x3;
          h5 = 0;
          i5 = 0;
          m3 = 0;
          n9 = 0;
          x3 = 0;
          save();
          p3 = pop();
          p2 = pop();
          p1 = pop();
          h5 = tos;
          dividend = tos;
          m3 = coeff(p3, p1) - 1;
          divisor = tos;
          n9 = coeff(p3, p2) - 1;
          x3 = m3 - n9;
          push_integer(0);
          p5 = pop();
          while (x3 >= 0) {
            push(stack[dividend + m3]);
            push(stack[divisor + n9]);
            divide();
            p4 = pop();
            for (i5 = l1 = 0, ref2 = n9; 0 <= ref2 ? l1 <= ref2 : l1 >= ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
              push(stack[dividend + x3 + i5]);
              push(stack[divisor + i5]);
              push(p4);
              multiply();
              subtract();
              stack[dividend + x3 + i5] = pop();
            }
            push(p5);
            push(p4);
            push(p3);
            push_integer(x3);
            power();
            multiply();
            add();
            p5 = pop();
            m3--;
            x3--;
          }
          moveTos(h5);
          push(p5);
          return restore();
        };
        DEBUG_RATIONALIZE = false;
        Eval_rationalize = function() {
          push(cadr(p1));
          Eval();
          return rationalize();
        };
        rationalize = function() {
          var x3;
          x3 = expanding;
          yyrationalize();
          return expanding = x3;
        };
        yyrationalize = function() {
          var commonDenominator, eachTerm, theArgument2;
          theArgument2 = pop();
          if (istensor(theArgument2)) {
            __rationalize_tensor(theArgument2);
            return;
          }
          expanding = 0;
          if (car(theArgument2) !== symbol(ADD)) {
            push(theArgument2);
            return;
          }
          if (DEBUG_RATIONALIZE) {
            console.log("rationalize: this is the input expr: " + theArgument2);
          }
          push(one);
          multiply_denominators(theArgument2);
          commonDenominator = pop();
          if (DEBUG_RATIONALIZE) {
            console.log("rationalize: this is the new denominator: " + commonDenominator);
          }
          push(zero);
          eachTerm = cdr(theArgument2);
          while (iscons(eachTerm)) {
            if (DEBUG_RATIONALIZE) {
              console.log("term: " + car(eachTerm));
            }
            push(commonDenominator);
            push(car(eachTerm));
            multiply();
            add();
            eachTerm = cdr(eachTerm);
          }
          if (DEBUG_RATIONALIZE) {
            console.log("rationalize: original terms times new denominator: " + stack[tos - 1]);
          }
          Condense();
          if (DEBUG_RATIONALIZE) {
            console.log("rationalize: after factoring: " + stack[tos - 1]);
          }
          push(commonDenominator);
          divide();
          if (DEBUG_RATIONALIZE) {
            return console.log("rationalize: after dividing by new denom. (and we're done): " + stack[tos - 1]);
          }
        };
        multiply_denominators = function(p11) {
          var results;
          if (car(p11) === symbol(ADD)) {
            p11 = cdr(p11);
            results = [];
            while (iscons(p11)) {
              multiply_denominators_term(car(p11));
              results.push(p11 = cdr(p11));
            }
            return results;
          } else {
            return multiply_denominators_term(p11);
          }
        };
        multiply_denominators_term = function(p11) {
          var results;
          if (car(p11) === symbol(MULTIPLY)) {
            p11 = cdr(p11);
            results = [];
            while (iscons(p11)) {
              multiply_denominators_factor(car(p11));
              results.push(p11 = cdr(p11));
            }
            return results;
          } else {
            return multiply_denominators_factor(p11);
          }
        };
        multiply_denominators_factor = function(p11) {
          if (car(p11) !== symbol(POWER)) {
            return;
          }
          push(p11);
          p11 = caddr(p11);
          if (isnegativenumber(p11)) {
            inverse();
            __lcm();
            return;
          }
          if (car(p11) === symbol(MULTIPLY) && isnegativenumber(cadr(p11))) {
            inverse();
            __lcm();
            return;
          }
          return pop();
        };
        __rationalize_tensor = function(theTensor) {
          var i5, l1, n9, ref2;
          i5 = 0;
          push(theTensor);
          Eval();
          theTensor = pop();
          if (!istensor(theTensor)) {
            push(theTensor);
            return;
          }
          n9 = theTensor.tensor.nelem;
          for (i5 = l1 = 0, ref2 = n9; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            push(theTensor.tensor.elem[i5]);
            rationalize();
            theTensor.tensor.elem[i5] = pop();
          }
          check_tensor_dimensions(theTensor);
          return push(theTensor);
        };
        __lcm = function() {
          save();
          p1 = pop();
          p2 = pop();
          push(p1);
          push(p2);
          multiply();
          push(p1);
          push(p2);
          gcd();
          divide();
          return restore();
        };
        Eval_real = function() {
          push(cadr(p1));
          Eval();
          return real();
        };
        real = function() {
          save();
          rect();
          p1 = pop();
          push(p1);
          push(p1);
          conjugate();
          add();
          push_integer(2);
          divide();
          return restore();
        };
        DEBUG_RECT = false;
        Eval_rect = function() {
          push(cadr(p1));
          Eval();
          return rect();
        };
        rect = function() {
          var input;
          save();
          p1 = pop();
          input = p1;
          if (DEBUG_RECT) {
            console.log("RECT of " + input);
          }
          if (DEBUG_RECT) {
            console.log("any clock forms in : " + input + " ? " + findPossibleClockForm(input));
          }
          if (issymbol(p1)) {
            if (DEBUG_RECT) {
              console.log(" rect: simple symbol: " + input);
            }
            if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {
              push(p1);
            } else {
              push_symbol(YYRECT);
              push(p1);
              list(2);
            }
          } else if (!isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES))) && !findPossibleExponentialForm(p1) && !findPossibleClockForm(p1) && !(Find(p1, symbol(SIN)) && Find(p1, symbol(COS)) && Find(p1, imaginaryunit))) {
            if (DEBUG_RECT) {
              console.log(" rect: simple symbol: " + input);
            }
            push(p1);
          } else if (car(p1) === symbol(MULTIPLY) && isimaginaryunit(cadr(p1)) && !isZeroAtomOrTensor(get_binding(symbol(ASSUME_REAL_VARIABLES)))) {
            push(p1);
          } else if (car(p1) === symbol(ADD)) {
            if (DEBUG_RECT) {
              console.log(" rect - " + input + " is a sum ");
            }
            push_integer(0);
            p1 = cdr(p1);
            while (iscons(p1)) {
              push(car(p1));
              rect();
              add();
              p1 = cdr(p1);
            }
          } else {
            if (DEBUG_RECT) {
              console.log(" rect - " + input + " is NOT a sum ");
            }
            push(p1);
            abs();
            if (DEBUG_RECT) {
              console.log(" rect - " + input + " abs: " + stack[tos - 1].toString());
            }
            push(p1);
            arg();
            if (DEBUG_RECT) {
              console.log(" rect - " + input + " arg of " + p1 + " : " + stack[tos - 1].toString());
            }
            p1 = pop();
            push(p1);
            cosine();
            if (DEBUG_RECT) {
              console.log(" rect - " + input + " cosine: " + stack[tos - 1].toString());
            }
            push(imaginaryunit);
            push(p1);
            sine();
            if (DEBUG_RECT) {
              console.log(" rect - " + input + " sine: " + stack[tos - 1].toString());
            }
            multiply();
            if (DEBUG_RECT) {
              console.log(" rect - " + input + " i * sine: " + stack[tos - 1].toString());
            }
            add();
            if (DEBUG_RECT) {
              console.log(" rect - " + input + " cos + i * sine: " + stack[tos - 1].toString());
            }
            multiply();
          }
          restore();
          if (DEBUG_RECT) {
            return console.log("rect of " + input + " : " + stack[tos - 1]);
          }
        };
        show_power_debug = false;
        performing_roots = false;
        Eval_roots = function() {
          p2 = cadr(p1);
          if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {
            push(cadr(p2));
            Eval();
            push(caddr(p2));
            Eval();
            subtract();
          } else {
            push(p2);
            Eval();
            p2 = pop();
            if (car(p2) === symbol(SETQ) || car(p2) === symbol(TESTEQ)) {
              push(cadr(p2));
              Eval();
              push(caddr(p2));
              Eval();
              subtract();
            } else {
              push(p2);
            }
          }
          push(caddr(p1));
          Eval();
          p2 = pop();
          if (p2 === symbol(NIL)) {
            guess();
          } else {
            push(p2);
          }
          p2 = pop();
          p1 = pop();
          if (!ispolyexpandedform(p1, p2)) {
            stop("roots: 1st argument is not a polynomial in the variable " + p2);
          }
          push(p1);
          push(p2);
          return roots();
        };
        hasImaginaryCoeff = function(k3) {
          var h5, i5, imaginaryCoefficients, l1, ref2;
          imaginaryCoefficients = false;
          h5 = tos;
          for (i5 = l1 = ref2 = k3; l1 > 0; i5 = l1 += -1) {
            if (iscomplexnumber(stack[tos - i5])) {
              imaginaryCoefficients = true;
              break;
            }
          }
          return imaginaryCoefficients;
        };
        isSimpleRoot = function(k3) {
          var h5, i5, isSimpleRootPolynomial, l1, ref2;
          if (k3 > 2) {
            isSimpleRootPolynomial = true;
            h5 = tos;
            if (isZeroAtomOrTensor(stack[tos - k3])) {
              isSimpleRootPolynomial = false;
            }
            for (i5 = l1 = ref2 = k3 - 1; l1 > 1; i5 = l1 += -1) {
              if (!isZeroAtomOrTensor(stack[tos - i5])) {
                isSimpleRootPolynomial = false;
                break;
              }
            }
          } else {
            isSimpleRootPolynomial = false;
          }
          return isSimpleRootPolynomial;
        };
        normalisedCoeff = function(variable, polynomial) {
          var divideBy, i5, k3, l1, m1, miniStack, ref2, ref3;
          k3 = coeff(variable, polynomial);
          divideBy = stack[tos - 1];
          miniStack = [];
          for (i5 = l1 = 1, ref2 = k3; 1 <= ref2 ? l1 <= ref2 : l1 >= ref2; i5 = 1 <= ref2 ? ++l1 : --l1) {
            miniStack.push(pop());
          }
          for (i5 = m1 = ref3 = k3 - 1; ref3 <= 0 ? m1 <= 0 : m1 >= 0; i5 = ref3 <= 0 ? ++m1 : --m1) {
            push(miniStack[i5]);
            push(divideBy);
            divide();
          }
          return k3;
        };
        roots = function() {
          var h5, i5, k3, l1, lastCoeff, leadingCoeff, n9, ref2;
          h5 = 0;
          i5 = 0;
          n9 = 0;
          if (DEBUG) {
            console.log("roots: " + stack[tos - 1].toString() + " " + stack[tos - 2].toString());
          }
          save();
          if (recursionLevelNestedRadicalsRemoval > 1) {
            pop();
            pop();
            push(symbol(NIL));
            restore();
            return;
          }
          performing_roots = true;
          h5 = tos - 2;
          if (DEBUG) {
            console.log("roots checking if " + stack[tos - 1].toString() + " is a case of simple roots");
          }
          p2 = pop();
          p1 = pop();
          push(p1);
          push(p2);
          k3 = normalisedCoeff(p2, p1);
          if (isSimpleRoot(k3)) {
            if (DEBUG) {
              console.log("yes, " + stack[tos - 1].toString() + " is a case of simple roots");
            }
            lastCoeff = stack[tos - k3];
            leadingCoeff = stack[tos - 1];
            moveTos(tos - k3);
            pop();
            pop();
            getSimpleRoots(k3, leadingCoeff, lastCoeff);
          } else {
            moveTos(tos - k3);
            roots2();
          }
          n9 = tos - h5;
          if (n9 === 0) {
            stop("roots: the polynomial is not factorable, try nroots");
          }
          if (n9 === 1) {
            performing_roots = false;
            restore();
            return;
          }
          sort_stack(n9);
          p1 = alloc_tensor(n9);
          p1.tensor.ndim = 1;
          p1.tensor.dim[0] = n9;
          for (i5 = l1 = 0, ref2 = n9; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            p1.tensor.elem[i5] = stack[h5 + i5];
          }
          moveTos(h5);
          push(p1);
          restore();
          return performing_roots = false;
        };
        getSimpleRoots = function(n9, leadingCoeff, lastCoeff) {
          var aSol, commonPart, l1, m1, ref2, ref3, rootsOfOne;
          if (DEBUG) {
            console.log("getSimpleRoots");
          }
          save();
          n9 = n9 - 1;
          push(lastCoeff);
          push_rational(1, n9);
          power();
          push(leadingCoeff);
          push_rational(1, n9);
          power();
          divide();
          commonPart = pop();
          if (n9 % 2 === 0) {
            for (rootsOfOne = l1 = 1, ref2 = n9; l1 <= ref2; rootsOfOne = l1 += 2) {
              push(commonPart);
              push_integer(-1);
              push_rational(rootsOfOne, n9);
              power();
              multiply();
              aSol = pop();
              push(aSol);
              push(aSol);
              negate();
            }
          } else {
            for (rootsOfOne = m1 = 1, ref3 = n9; 1 <= ref3 ? m1 <= ref3 : m1 >= ref3; rootsOfOne = 1 <= ref3 ? ++m1 : --m1) {
              push(commonPart);
              push_integer(-1);
              push_rational(rootsOfOne, n9);
              power();
              multiply();
              if (rootsOfOne % 2 === 0) {
                negate();
              }
            }
          }
          return restore();
        };
        roots2 = function() {
          var k3;
          save();
          if (DEBUG) {
            console.log("roots2: " + stack[tos - 1].toString() + " " + stack[tos - 2].toString());
          }
          p2 = pop();
          p1 = pop();
          push(p1);
          push(p2);
          k3 = normalisedCoeff(p2, p1);
          if (!hasImaginaryCoeff(k3)) {
            moveTos(tos - k3);
            factorpoly();
            p1 = pop();
          } else {
            moveTos(tos - k3);
            pop();
            pop();
          }
          if (car(p1) === symbol(MULTIPLY)) {
            p1 = cdr(p1);
            while (iscons(p1)) {
              push(car(p1));
              push(p2);
              roots3();
              p1 = cdr(p1);
            }
          } else {
            push(p1);
            push(p2);
            roots3();
          }
          return restore();
        };
        roots3 = function() {
          var n9;
          save();
          p2 = pop();
          p1 = pop();
          if (car(p1) === symbol(POWER) && ispolyexpandedform(cadr(p1), p2) && isposint(caddr(p1))) {
            n9 = normalisedCoeff(p2, cadr(p1));
            mini_solve(n9);
          } else if (ispolyexpandedform(p1, p2)) {
            n9 = normalisedCoeff(p2, p1);
            mini_solve(n9);
          }
          return restore();
        };
        mini_solve = function(n9) {
          var C_CHECKED_AS_NOT_ZERO, Q_CHECKED_AS_NOT_ZERO, R_18_a_b_c_d, R_27_a2_d, R_2_b3, R_3_a, R_3_a_C, R_3_a_c, R_4_DELTA03, R_6_a, R_6_a_C, R_C, R_C_over_3a, R_C_simplified_toCheckIfZero, R_DELTA0, R_DELTA0_simplified_toCheckIfZero, R_DELTA0_toBeCheckedIfZero, R_DELTA1, R_Q, R_Q_simplified_toCheckIfZero, R_S, R_S_simplified_toCheckIfZero, R_a2, R_a2_d, R_a2_d2, R_a3, R_a_b_c, R_a_b_c_d, R_a_c, R_b2, R_b2_c2, R_b3, R_b3_d, R_c2, R_c3, R_d2, R_determinant, R_determinant_simplified_toCheckIfZero, R_e2, R_e3, R_m, R_m27_a2_d2, R_m4_a_c3, R_m4_b3_d, R_m9_a_b_c, R_m_b_over_3a, R_minus_4S2_minus_2p, R_minus_b_over_4a, R_p, R_principalCubicRoot, R_q, R_q_over_S, R_r, S_CHECKED_AS_NOT_ZERO, ThreePPlus2M, TwoQOversqrtPPlus2M, biquadraticSolutions, choiceOfRadicalInQSoSIsNotZero, coeff2, coeff3, coeff4, depressedSolutions, eachSolution, flipSignOFQSoCIsNotZero, flipSignOFRadicalSoQIsNotZero, i_sqrt3, l1, len, len1, len2, m1, n1, one_minus_i_sqrt3, one_plus_i_sqrt3, ref2, ref3, ref4, resolventCubicSolutions, root_solution, sqrtPPlus2M, toBeCheckedIFZero;
          save();
          if (n9 === 2) {
            p3 = pop();
            p4 = pop();
            push(p4);
            push(p3);
            divide();
            negate();
            restore();
            return;
          }
          if (n9 === 3) {
            p3 = pop();
            p4 = pop();
            p5 = pop();
            push(p4);
            push_integer(2);
            power();
            push_integer(4);
            push(p3);
            multiply();
            push(p5);
            multiply();
            subtract();
            push_rational(1, 2);
            power();
            p6 = pop();
            push(p6);
            push(p4);
            subtract();
            push(p3);
            push_integer(2);
            multiply();
            divide();
            push(p6);
            push(p4);
            add();
            negate();
            push(p3);
            divide();
            push_rational(1, 2);
            multiply();
            restore();
            return;
          }
          if (n9 === 4 || n9 === 5) {
            p3 = pop();
            p4 = pop();
            p5 = pop();
            p6 = pop();
            push(p5);
            push(p5);
            multiply();
            R_c2 = pop();
            push(R_c2);
            push(p5);
            multiply();
            R_c3 = pop();
            push(p4);
            push(p4);
            multiply();
            R_b2 = pop();
            push(R_b2);
            push(p4);
            multiply();
            R_b3 = pop();
            push(R_b3);
            push(p6);
            multiply();
            R_b3_d = pop();
            push(R_b3_d);
            push_integer(-4);
            multiply();
            R_m4_b3_d = pop();
            push(R_b3);
            push_integer(2);
            multiply();
            R_2_b3 = pop();
            push(p3);
            push(p3);
            multiply();
            R_a2 = pop();
            push(R_a2);
            push(p3);
            multiply();
            R_a3 = pop();
            push_integer(3);
            push(p3);
            multiply();
            R_3_a = pop();
            push(R_a2);
            push(p6);
            multiply();
            R_a2_d = pop();
            push(R_a2_d);
            push(p6);
            multiply();
            R_a2_d2 = pop();
            push(R_a2_d);
            push_integer(27);
            multiply();
            R_27_a2_d = pop();
            push(R_a2_d2);
            push_integer(-27);
            multiply();
            R_m27_a2_d2 = pop();
            push(R_3_a);
            push_integer(2);
            multiply();
            R_6_a = pop();
            push(p3);
            push(p5);
            multiply();
            R_a_c = pop();
            push(R_a_c);
            push(p4);
            multiply();
            R_a_b_c = pop();
            push(R_a_b_c);
            push(p6);
            multiply();
            R_a_b_c_d = pop();
            push(R_a_c);
            push_integer(3);
            multiply();
            R_3_a_c = pop();
            push_integer(-4);
            push(p3);
            push(R_c3);
            multiply();
            multiply();
            R_m4_a_c3 = pop();
            push(R_a_b_c);
            push_integer(9);
            multiply();
            negate();
            R_m9_a_b_c = pop();
            push(R_a_b_c_d);
            push_integer(18);
            multiply();
            R_18_a_b_c_d = pop();
            push(R_b2);
            push(R_3_a_c);
            subtract();
            R_DELTA0 = pop();
            push(R_b2);
            push(R_c2);
            multiply();
            R_b2_c2 = pop();
            push(p4);
            negate();
            push(R_3_a);
            divide();
            R_m_b_over_3a = pop();
            if (n9 === 4) {
              if (DEBUG) {
                console.log(">>>>>>>>>>>>>>>> actually using cubic formula <<<<<<<<<<<<<<< ");
              }
              if (DEBUG) {
                console.log("cubic: D0: " + R_DELTA0.toString());
              }
              push(R_DELTA0);
              push_integer(3);
              power();
              push_integer(4);
              multiply();
              R_4_DELTA03 = pop();
              push(R_DELTA0);
              simplify();
              absValFloat();
              R_DELTA0_toBeCheckedIfZero = pop();
              if (DEBUG) {
                console.log("cubic: D0 as float: " + R_DELTA0_toBeCheckedIfZero.toString());
              }
              push(R_18_a_b_c_d);
              push(R_m4_b3_d);
              push(R_b2_c2);
              push(R_m4_a_c3);
              push(R_m27_a2_d2);
              add();
              add();
              add();
              add();
              simplify();
              absValFloat();
              R_determinant = pop();
              if (DEBUG) {
                console.log("cubic: DETERMINANT: " + R_determinant.toString());
              }
              push(R_2_b3);
              push(R_m9_a_b_c);
              push(R_27_a2_d);
              add();
              add();
              R_DELTA1 = pop();
              if (DEBUG) {
                console.log("cubic: D1: " + R_DELTA1.toString());
              }
              push(R_DELTA1);
              push_integer(2);
              power();
              push(R_4_DELTA03);
              subtract();
              push_rational(1, 2);
              power();
              simplify();
              R_Q = pop();
              if (isZeroAtomOrTensor(R_determinant)) {
                if (isZeroAtomOrTensor(R_DELTA0_toBeCheckedIfZero)) {
                  if (DEBUG) {
                    console.log(" cubic: DETERMINANT IS ZERO and delta0 is zero");
                  }
                  push(R_m_b_over_3a);
                  restore();
                  return;
                } else {
                  if (DEBUG) {
                    console.log(" cubic: DETERMINANT IS ZERO and delta0 is not zero");
                  }
                  push(p3);
                  push(p6);
                  push_integer(9);
                  multiply();
                  multiply();
                  push(p4);
                  push(p5);
                  multiply();
                  subtract();
                  push(R_DELTA0);
                  push_integer(2);
                  multiply();
                  divide();
                  root_solution = pop();
                  push(root_solution);
                  push(root_solution);
                  push(R_a_b_c);
                  push_integer(4);
                  multiply();
                  push(p3);
                  push(p3);
                  push(p6);
                  push_integer(9);
                  multiply();
                  multiply();
                  multiply();
                  negate();
                  push(R_b3);
                  negate();
                  add();
                  add();
                  push(p3);
                  push(R_DELTA0);
                  multiply();
                  divide();
                  restore();
                  return;
                }
              }
              C_CHECKED_AS_NOT_ZERO = false;
              flipSignOFQSoCIsNotZero = false;
              while (!C_CHECKED_AS_NOT_ZERO) {
                push(R_Q);
                if (flipSignOFQSoCIsNotZero) {
                  negate();
                }
                push(R_DELTA1);
                add();
                push_rational(1, 2);
                multiply();
                push_rational(1, 3);
                power();
                simplify();
                R_C = pop();
                if (DEBUG) {
                  console.log("cubic: C: " + R_C.toString());
                }
                push(R_C);
                simplify();
                absValFloat();
                R_C_simplified_toCheckIfZero = pop();
                if (DEBUG) {
                  console.log("cubic: C as absval and float: " + R_C_simplified_toCheckIfZero.toString());
                }
                if (isZeroAtomOrTensor(R_C_simplified_toCheckIfZero)) {
                  if (DEBUG) {
                    console.log(" cubic: C IS ZERO flipping the sign");
                  }
                  flipSignOFQSoCIsNotZero = true;
                } else {
                  C_CHECKED_AS_NOT_ZERO = true;
                }
              }
              push(R_C);
              push(R_3_a);
              multiply();
              R_3_a_C = pop();
              push(R_3_a_C);
              push_integer(2);
              multiply();
              R_6_a_C = pop();
              push(imaginaryunit);
              push_integer(3);
              push_rational(1, 2);
              power();
              multiply();
              i_sqrt3 = pop();
              push_integer(1);
              push(i_sqrt3);
              add();
              one_plus_i_sqrt3 = pop();
              push_integer(1);
              push(i_sqrt3);
              subtract();
              one_minus_i_sqrt3 = pop();
              push(R_C);
              push(R_3_a);
              divide();
              R_C_over_3a = pop();
              push(R_m_b_over_3a);
              push(R_C_over_3a);
              negate();
              push(R_DELTA0);
              push(R_3_a_C);
              divide();
              negate();
              add();
              add();
              simplify();
              push(R_m_b_over_3a);
              push(R_C_over_3a);
              push(one_plus_i_sqrt3);
              multiply();
              push_integer(2);
              divide();
              push(one_minus_i_sqrt3);
              push(R_DELTA0);
              multiply();
              push(R_6_a_C);
              divide();
              add();
              add();
              simplify();
              push(R_m_b_over_3a);
              push(R_C_over_3a);
              push(one_minus_i_sqrt3);
              multiply();
              push_integer(2);
              divide();
              push(one_plus_i_sqrt3);
              push(R_DELTA0);
              multiply();
              push(R_6_a_C);
              divide();
              add();
              add();
              simplify();
              restore();
              return;
            }
            if (n9 === 5) {
              if (DEBUG) {
                console.log(">>>>>>>>>>>>>>>> actually using quartic formula <<<<<<<<<<<<<<< ");
              }
              p7 = pop();
              if (isZeroAtomOrTensor(p4) && isZeroAtomOrTensor(p6) && !isZeroAtomOrTensor(p5) && !isZeroAtomOrTensor(p7)) {
                if (DEBUG) {
                  console.log("biquadratic case");
                }
                push(p3);
                push(symbol(SECRETX));
                push_integer(2);
                power();
                multiply();
                push(p5);
                push(symbol(SECRETX));
                multiply();
                push(p7);
                add();
                add();
                push(symbol(SECRETX));
                roots();
                biquadraticSolutions = pop();
                ref2 = biquadraticSolutions.tensor.elem;
                for (l1 = 0, len = ref2.length; l1 < len; l1++) {
                  eachSolution = ref2[l1];
                  push(eachSolution);
                  push_rational(1, 2);
                  power();
                  simplify();
                  push(eachSolution);
                  push_rational(1, 2);
                  power();
                  negate();
                  simplify();
                }
                restore();
                return;
              }
              push(p6);
              push(p6);
              multiply();
              R_d2 = pop();
              push(p7);
              push(p7);
              multiply();
              R_e2 = pop();
              push(R_e2);
              push(p7);
              multiply();
              R_e3 = pop();
              push_integer(256);
              push(R_a3);
              push(R_e3);
              multiply();
              multiply();
              push_integer(-192);
              push(R_a2_d);
              push(R_e2);
              push(p4);
              multiply();
              multiply();
              multiply();
              push_integer(-128);
              push(R_a2);
              push(R_c2);
              push(R_e2);
              multiply();
              multiply();
              multiply();
              push_integer(144);
              push(R_a2_d2);
              push(p5);
              push(p7);
              multiply();
              multiply();
              multiply();
              push(R_m27_a2_d2);
              push(R_d2);
              multiply();
              push_integer(144);
              push(R_a_b_c);
              push(p4);
              push(R_e2);
              multiply();
              multiply();
              multiply();
              push_integer(-6);
              push(p3);
              push(R_b2);
              push(R_d2);
              push(p7);
              multiply();
              multiply();
              multiply();
              multiply();
              push_integer(-80);
              push(R_a_b_c_d);
              push(p5);
              push(p7);
              multiply();
              multiply();
              multiply();
              push_integer(18);
              push(R_a_b_c_d);
              push(R_d2);
              multiply();
              multiply();
              push_integer(16);
              push(R_a_c);
              push(R_c3);
              push(p7);
              multiply();
              multiply();
              multiply();
              push_integer(-4);
              push(R_a_c);
              push(R_c2);
              push(R_d2);
              multiply();
              multiply();
              multiply();
              push_integer(-27);
              push(R_b3);
              push(p4);
              push(R_e2);
              multiply();
              multiply();
              multiply();
              push_integer(18);
              push(R_b3_d);
              push(p5);
              push(p7);
              multiply();
              multiply();
              multiply();
              push(R_m4_b3_d);
              push(R_d2);
              multiply();
              push_integer(-4);
              push(R_b2_c2);
              push(p5);
              push(p7);
              multiply();
              multiply();
              multiply();
              push(R_b2_c2);
              push(R_d2);
              multiply();
              add();
              add();
              add();
              add();
              add();
              add();
              add();
              add();
              add();
              add();
              add();
              add();
              add();
              add();
              add();
              R_determinant = pop();
              if (DEBUG) {
                console.log("R_determinant: " + R_determinant.toString());
              }
              push(R_c2);
              push_integer(-3);
              push(p4);
              push(p6);
              multiply();
              multiply();
              push_integer(12);
              push(p3);
              push(p7);
              multiply();
              multiply();
              add();
              add();
              R_DELTA0 = pop();
              if (DEBUG) {
                console.log("R_DELTA0: " + R_DELTA0.toString());
              }
              push_integer(2);
              push(R_c3);
              multiply();
              push_integer(-9);
              push(p4);
              push(p5);
              push(p6);
              multiply();
              multiply();
              multiply();
              push_integer(27);
              push(R_b2);
              push(p7);
              multiply();
              multiply();
              push_integer(27);
              push(p3);
              push(R_d2);
              multiply();
              multiply();
              push_integer(-72);
              push(R_a_c);
              push(p7);
              multiply();
              multiply();
              add();
              add();
              add();
              add();
              R_DELTA1 = pop();
              if (DEBUG) {
                console.log("R_DELTA1: " + R_DELTA1.toString());
              }
              push_integer(8);
              push(R_a_c);
              multiply();
              push_integer(-3);
              push(R_b2);
              multiply();
              add();
              push_integer(8);
              push(R_a2);
              multiply();
              divide();
              R_p = pop();
              if (DEBUG) {
                console.log("p: " + R_p.toString());
              }
              push(R_b3);
              push_integer(-4);
              push(R_a_b_c);
              multiply();
              push_integer(8);
              push(R_a2_d);
              multiply();
              add();
              add();
              push_integer(8);
              push(R_a3);
              multiply();
              divide();
              R_q = pop();
              if (DEBUG) {
                console.log("q: " + R_q.toString());
              }
              if (DEBUG) {
                console.log("tos 1 " + tos);
              }
              if (!isZeroAtomOrTensor(p4)) {
                if (DEBUG) {
                  console.log("tos 2 " + tos);
                }
                push_integer(8);
                push(p5);
                push(p3);
                multiply();
                multiply();
                push_integer(-3);
                push(p4);
                push_integer(2);
                power();
                multiply();
                add();
                push_integer(8);
                push(p3);
                push_integer(2);
                power();
                multiply();
                divide();
                R_p = pop();
                if (DEBUG) {
                  console.log("p for depressed quartic: " + R_p.toString());
                }
                push(p4);
                push_integer(3);
                power();
                push_integer(-4);
                push(p3);
                push(p4);
                push(p5);
                multiply();
                multiply();
                multiply();
                push_integer(8);
                push(p6);
                push(p3);
                push_integer(2);
                power();
                multiply();
                multiply();
                add();
                add();
                push_integer(8);
                push(p3);
                push_integer(3);
                power();
                multiply();
                divide();
                R_q = pop();
                if (DEBUG) {
                  console.log("q for depressed quartic: " + R_q.toString());
                }
                push(p4);
                push_integer(4);
                power();
                push_integer(-3);
                multiply();
                push_integer(256);
                push(R_a3);
                push(p7);
                multiply();
                multiply();
                push_integer(-64);
                push(R_a2_d);
                push(p4);
                multiply();
                multiply();
                push_integer(16);
                push(R_b2);
                push(p3);
                push(p5);
                multiply();
                multiply();
                multiply();
                add();
                add();
                add();
                push_integer(256);
                push(p3);
                push_integer(4);
                power();
                multiply();
                divide();
                R_r = pop();
                if (DEBUG) {
                  console.log("r for depressed quartic: " + R_r.toString());
                }
                if (DEBUG) {
                  console.log("tos 4 " + tos);
                }
                push(symbol(SECRETX));
                push_integer(4);
                power();
                if (DEBUG) {
                  console.log("4 * x^4: " + stack[tos - 1].toString());
                }
                push(R_p);
                push(symbol(SECRETX));
                push_integer(2);
                power();
                multiply();
                if (DEBUG) {
                  console.log("R_p * x^2: " + stack[tos - 1].toString());
                }
                push(R_q);
                push(symbol(SECRETX));
                multiply();
                if (DEBUG) {
                  console.log("R_q * x: " + stack[tos - 1].toString());
                }
                push(R_r);
                if (DEBUG) {
                  console.log("R_r: " + stack[tos - 1].toString());
                }
                add();
                add();
                add();
                simplify();
                if (DEBUG) {
                  console.log("solving depressed quartic: " + stack[tos - 1].toString());
                }
                push(symbol(SECRETX));
                roots();
                depressedSolutions = pop();
                if (DEBUG) {
                  console.log("depressedSolutions: " + depressedSolutions);
                }
                ref3 = depressedSolutions.tensor.elem;
                for (m1 = 0, len1 = ref3.length; m1 < len1; m1++) {
                  eachSolution = ref3[m1];
                  push(eachSolution);
                  push(p4);
                  push_integer(4);
                  push(p3);
                  multiply();
                  divide();
                  subtract();
                  simplify();
                  if (DEBUG) {
                    console.log("solution from depressed: " + stack[tos - 1].toString());
                  }
                }
                restore();
                return;
              } else {
                R_p = p5;
                R_q = p6;
                R_r = p7;
                push_rational(5, 2);
                push(R_p);
                multiply();
                coeff2 = pop();
                push_integer(2);
                push(R_p);
                push_integer(2);
                power();
                multiply();
                push(R_r);
                subtract();
                coeff3 = pop();
                push(R_p);
                push_integer(3);
                power();
                push_integer(2);
                divide();
                push_rational(-1, 2);
                push(R_p);
                push(R_r);
                multiply();
                multiply();
                push_rational(-1, 8);
                push(R_q);
                push_integer(2);
                power();
                multiply();
                add();
                add();
                coeff4 = pop();
                push(symbol(SECRETX));
                push_integer(3);
                power();
                push(coeff2);
                push(symbol(SECRETX));
                push_integer(2);
                power();
                multiply();
                push(coeff3);
                push(symbol(SECRETX));
                multiply();
                push(coeff4);
                add();
                add();
                add();
                if (DEBUG) {
                  console.log("resolventCubic: " + stack[tos - 1].toString());
                }
                push(symbol(SECRETX));
                roots();
                resolventCubicSolutions = pop();
                if (DEBUG) {
                  console.log("resolventCubicSolutions: " + resolventCubicSolutions);
                }
                R_m = null;
                ref4 = resolventCubicSolutions.tensor.elem;
                for (n1 = 0, len2 = ref4.length; n1 < len2; n1++) {
                  eachSolution = ref4[n1];
                  if (DEBUG) {
                    console.log("examining solution: " + eachSolution);
                  }
                  push(eachSolution);
                  push_integer(2);
                  multiply();
                  push(R_p);
                  add();
                  absValFloat();
                  toBeCheckedIFZero = pop();
                  if (DEBUG) {
                    console.log("abs value is: " + eachSolution);
                  }
                  if (!isZeroAtomOrTensor(toBeCheckedIFZero)) {
                    R_m = eachSolution;
                    break;
                  }
                }
                if (DEBUG) {
                  console.log("chosen solution: " + R_m);
                }
                push(R_m);
                push_integer(2);
                multiply();
                push(R_p);
                add();
                push_rational(1, 2);
                power();
                simplify();
                sqrtPPlus2M = pop();
                push(R_q);
                push_integer(2);
                multiply();
                push(sqrtPPlus2M);
                divide();
                simplify();
                TwoQOversqrtPPlus2M = pop();
                push(R_p);
                push_integer(3);
                multiply();
                push(R_m);
                push_integer(2);
                multiply();
                add();
                ThreePPlus2M = pop();
                push(sqrtPPlus2M);
                push(ThreePPlus2M);
                push(TwoQOversqrtPPlus2M);
                add();
                negate();
                push_rational(1, 2);
                power();
                simplify();
                add();
                push_integer(2);
                divide();
                push(sqrtPPlus2M);
                push(ThreePPlus2M);
                push(TwoQOversqrtPPlus2M);
                add();
                negate();
                push_rational(1, 2);
                power();
                simplify();
                subtract();
                push_integer(2);
                divide();
                push(sqrtPPlus2M);
                negate();
                push(ThreePPlus2M);
                push(TwoQOversqrtPPlus2M);
                subtract();
                negate();
                push_rational(1, 2);
                power();
                simplify();
                add();
                push_integer(2);
                divide();
                push(sqrtPPlus2M);
                negate();
                push(ThreePPlus2M);
                push(TwoQOversqrtPPlus2M);
                subtract();
                negate();
                push_rational(1, 2);
                power();
                simplify();
                subtract();
                push_integer(2);
                divide();
                restore();
                return;
              }
              push(R_determinant);
              simplify();
              absValFloat();
              R_determinant_simplified_toCheckIfZero = pop();
              push(R_DELTA0);
              simplify();
              absValFloat();
              R_DELTA0_simplified_toCheckIfZero = pop();
              S_CHECKED_AS_NOT_ZERO = false;
              choiceOfRadicalInQSoSIsNotZero = 0;
              while (!S_CHECKED_AS_NOT_ZERO) {
                Q_CHECKED_AS_NOT_ZERO = false;
                flipSignOFRadicalSoQIsNotZero = false;
                while (!Q_CHECKED_AS_NOT_ZERO) {
                  push(R_DELTA1);
                  push(R_DELTA1);
                  push_integer(2);
                  power();
                  push_integer(-4);
                  push(R_DELTA0);
                  push_integer(3);
                  power();
                  multiply();
                  add();
                  push_rational(1, 2);
                  power();
                  if (flipSignOFRadicalSoQIsNotZero) {
                    negate();
                  }
                  add();
                  push_integer(2);
                  divide();
                  if (DEBUG) {
                    console.log("content of cubic root: " + stack[tos - 1].toString());
                  }
                  push_rational(1, 3);
                  power();
                  simplify();
                  R_principalCubicRoot = pop();
                  if (DEBUG) {
                    console.log("principal cubic root: " + R_principalCubicRoot.toString());
                  }
                  if (DEBUG) {
                    console.log("tos : " + tos);
                  }
                  if (choiceOfRadicalInQSoSIsNotZero === 0) {
                    if (DEBUG) {
                      console.log("chosing principal cubic root");
                    }
                    push(R_principalCubicRoot);
                  } else if (choiceOfRadicalInQSoSIsNotZero === 1) {
                    if (DEBUG) {
                      console.log("chosing cubic root beyond principal");
                    }
                    push(R_principalCubicRoot);
                    push_rational(-1, 2);
                    multiply();
                    push_integer(3);
                    push_rational(1, 2);
                    power();
                    push(imaginaryunit);
                    multiply();
                    push_rational(-1, 2);
                    multiply();
                    push(R_principalCubicRoot);
                    multiply();
                    add();
                  } else if (choiceOfRadicalInQSoSIsNotZero === 1) {
                    if (DEBUG) {
                      console.log("chosing cubic root beyond beyond principal");
                    }
                    push(R_principalCubicRoot);
                    push_rational(-1, 2);
                    multiply();
                    push_integer(3);
                    push_rational(1, 2);
                    power();
                    push(imaginaryunit);
                    multiply();
                    push_rational(1, 2);
                    multiply();
                    push(R_principalCubicRoot);
                    multiply();
                    add();
                  }
                  simplify();
                  R_Q = pop();
                  if (DEBUG) {
                    console.log("Q " + R_Q.toString());
                  }
                  if (DEBUG) {
                    console.log("tos: " + tos);
                  }
                  push(R_Q);
                  simplify();
                  absValFloat();
                  R_Q_simplified_toCheckIfZero = pop();
                  if (DEBUG) {
                    console.log("Q simplified and abs" + R_Q_simplified_toCheckIfZero.toString());
                  }
                  if (isZeroAtomOrTensor(R_Q_simplified_toCheckIfZero) && (!isZeroAtomOrTensor(R_determinant_simplified_toCheckIfZero) && isZeroAtomOrTensor(R_DELTA0_simplified_toCheckIfZero))) {
                    if (DEBUG) {
                      console.log(" *********************************** Q IS ZERO and it matters, flipping the sign");
                    }
                    flipSignOFRadicalSoQIsNotZero = true;
                  } else {
                    Q_CHECKED_AS_NOT_ZERO = true;
                  }
                  if (DEBUG) {
                    console.log("tos: " + tos);
                  }
                }
                push_rational(-2, 3);
                push(R_p);
                multiply();
                push(R_Q);
                push(R_DELTA0);
                push(R_Q);
                divide();
                add();
                push(R_3_a);
                divide();
                add();
                push_rational(1, 2);
                power();
                push_integer(2);
                divide();
                show_power_debug = true;
                simplify();
                R_S = pop();
                if (DEBUG) {
                  console.log("S " + R_S.toString());
                }
                push(R_S);
                simplify();
                absValFloat();
                R_S_simplified_toCheckIfZero = pop();
                if (DEBUG) {
                  console.log("S " + R_S_simplified_toCheckIfZero.toString());
                }
                if (isZeroAtomOrTensor(R_S_simplified_toCheckIfZero)) {
                  if (DEBUG) {
                    console.log(" *********************************** S IS ZERO chosing another cubic root");
                  }
                  choiceOfRadicalInQSoSIsNotZero++;
                } else {
                  S_CHECKED_AS_NOT_ZERO = true;
                }
                if (DEBUG) {
                  console.log("tos: " + tos);
                }
              }
              if (DEBUG) {
                console.log("tos: " + tos);
              }
              push(p4);
              negate();
              push(p3);
              push_integer(4);
              multiply();
              divide();
              R_minus_b_over_4a = pop();
              push_integer(-4);
              push(R_S);
              push_integer(2);
              power();
              multiply();
              push_integer(2);
              push(R_p);
              multiply();
              subtract();
              R_minus_4S2_minus_2p = pop();
              push(R_q);
              push(R_S);
              divide();
              R_q_over_S = pop();
              if (DEBUG) {
                console.log("tos before putting together the 4 solutions: " + tos);
              }
              push(R_minus_b_over_4a);
              push(R_S);
              subtract();
              push(R_minus_4S2_minus_2p);
              push(R_q_over_S);
              add();
              push_rational(1, 2);
              power();
              push_integer(2);
              divide();
              add();
              simplify();
              push(R_minus_b_over_4a);
              push(R_S);
              subtract();
              push(R_minus_4S2_minus_2p);
              push(R_q_over_S);
              add();
              push_rational(1, 2);
              power();
              push_integer(2);
              divide();
              subtract();
              simplify();
              push(R_minus_b_over_4a);
              push(R_S);
              add();
              push(R_minus_4S2_minus_2p);
              push(R_q_over_S);
              subtract();
              push_rational(1, 2);
              power();
              push_integer(2);
              divide();
              add();
              simplify();
              push(R_minus_b_over_4a);
              push(R_S);
              add();
              push(R_minus_4S2_minus_2p);
              push(R_q_over_S);
              subtract();
              push_rational(1, 2);
              power();
              push_integer(2);
              divide();
              subtract();
              simplify();
              restore();
              return;
            }
          }
          moveTos(tos - n9);
          return restore();
        };
        Eval_round = function() {
          push(cadr(p1));
          Eval();
          return yround();
        };
        yround = function() {
          save();
          yyround();
          return restore();
        };
        yyround = function() {
          var d3;
          d3 = 0;
          p1 = pop();
          if (!isNumericAtom(p1)) {
            push_symbol(ROUND);
            push(p1);
            list(2);
            return;
          }
          if (isdouble(p1)) {
            d3 = Math.round(p1.d);
            push_double(d3);
            return;
          }
          if (isinteger(p1)) {
            push(p1);
            return;
          }
          push(p1);
          yyfloat();
          p1 = pop();
          return push_integer(Math.round(p1.d));
        };
        T_INTEGER = 1001;
        T_DOUBLE = 1002;
        T_SYMBOL = 1003;
        T_FUNCTION = 1004;
        T_NEWLINE = 1006;
        T_STRING = 1007;
        T_GTEQ = 1008;
        T_LTEQ = 1009;
        T_EQ = 1010;
        T_NEQ = 1011;
        T_QUOTASSIGN = 1012;
        token = "";
        newline_flag = 0;
        meta_mode = 0;
        input_str = 0;
        scan_str = 0;
        token_str = 0;
        token_buf = 0;
        lastFoundSymbol = null;
        symbolsRightOfAssignment = null;
        symbolsLeftOfAssignment = null;
        isSymbolLeftOfAssignment = null;
        scanningParameters = null;
        functionInvokationsScanningStack = null;
        skipRootVariableToBeSolved = false;
        assignmentFound = null;
        scanned = "";
        scan = function(s8) {
          if (DEBUG) {
            console.log("#### scanning " + s8);
          }
          lastFoundSymbol = null;
          symbolsRightOfAssignment = [];
          symbolsLeftOfAssignment = [];
          isSymbolLeftOfAssignment = true;
          scanningParameters = [];
          functionInvokationsScanningStack = [""];
          assignmentFound = false;
          scanned = s8;
          meta_mode = 0;
          expanding++;
          input_str = 0;
          scan_str = 0;
          get_next_token();
          if (token === "") {
            push(symbol(NIL));
            expanding--;
            return 0;
          }
          scan_stmt();
          expanding--;
          if (!assignmentFound) {
            symbolsInExpressionsWithoutAssignments = symbolsInExpressionsWithoutAssignments.concat(symbolsLeftOfAssignment);
          }
          return token_str - input_str;
        };
        scan_meta = function(s8) {
          scanned = s8;
          meta_mode = 1;
          expanding++;
          input_str = 0;
          scan_str = 0;
          get_next_token();
          if (token === "") {
            push(symbol(NIL));
            expanding--;
            return 0;
          }
          scan_stmt();
          expanding--;
          return token_str - input_str;
        };
        scan_stmt = function() {
          var assignmentIsOfQuotedType, existingDependencies, i5, indexOfSymbolLeftOfAssignment, l1, len, len1, m1, symbolLeftOfAssignment;
          scan_relation();
          assignmentIsOfQuotedType = false;
          if (token === T_QUOTASSIGN) {
            assignmentIsOfQuotedType = true;
          }
          if (token === T_QUOTASSIGN || token === "=") {
            symbolLeftOfAssignment = lastFoundSymbol;
            if (DEBUG) {
              console.log("assignment!");
            }
            assignmentFound = true;
            isSymbolLeftOfAssignment = false;
            get_next_token();
            push_symbol(SETQ);
            swap();
            if (assignmentIsOfQuotedType) {
              push_symbol(QUOTE);
            }
            scan_relation();
            if (assignmentIsOfQuotedType) {
              list(2);
            }
            list(3);
            isSymbolLeftOfAssignment = true;
            if (codeGen) {
              indexOfSymbolLeftOfAssignment = symbolsRightOfAssignment.indexOf(symbolLeftOfAssignment);
              if (indexOfSymbolLeftOfAssignment !== -1) {
                symbolsRightOfAssignment.splice(indexOfSymbolLeftOfAssignment, 1);
                symbolsHavingReassignments.push(symbolLeftOfAssignment);
              }
              if (DEBUG) {
                console.log("locally, " + symbolLeftOfAssignment + " depends on: ");
                for (l1 = 0, len = symbolsRightOfAssignment.length; l1 < len; l1++) {
                  i5 = symbolsRightOfAssignment[l1];
                  console.log("  " + i5);
                }
              }
              if (symbolsDependencies[symbolLeftOfAssignment] == null) {
                symbolsDependencies[symbolLeftOfAssignment] = [];
              }
              existingDependencies = symbolsDependencies[symbolLeftOfAssignment];
              for (m1 = 0, len1 = symbolsRightOfAssignment.length; m1 < len1; m1++) {
                i5 = symbolsRightOfAssignment[m1];
                if (existingDependencies.indexOf(i5) === -1) {
                  existingDependencies.push(i5);
                }
              }
              return symbolsRightOfAssignment = [];
            }
          }
        };
        scan_relation = function() {
          scan_expression();
          switch (token) {
            case T_EQ:
              push_symbol(TESTEQ);
              swap();
              get_next_token();
              scan_expression();
              return list(3);
            case T_NEQ:
              push_symbol(NOT);
              swap();
              push_symbol(TESTEQ);
              swap();
              get_next_token();
              scan_expression();
              list(3);
              return list(2);
            case T_LTEQ:
              push_symbol(TESTLE);
              swap();
              get_next_token();
              scan_expression();
              return list(3);
            case T_GTEQ:
              push_symbol(TESTGE);
              swap();
              get_next_token();
              scan_expression();
              return list(3);
            case "<":
              push_symbol(TESTLT);
              swap();
              get_next_token();
              scan_expression();
              return list(3);
            case ">":
              push_symbol(TESTGT);
              swap();
              get_next_token();
              scan_expression();
              return list(3);
          }
        };
        scan_expression = function() {
          var h5;
          h5 = tos;
          switch (token) {
            case "+":
              get_next_token();
              scan_term();
              break;
            case "-":
              get_next_token();
              scan_term();
              negate();
              break;
            default:
              scan_term();
          }
          while (newline_flag === 0 && (token === "+" || token === "-")) {
            if (token === "+") {
              get_next_token();
              scan_term();
            } else {
              get_next_token();
              scan_term();
              negate();
            }
          }
          if (tos - h5 > 1) {
            list(tos - h5);
            push_symbol(ADD);
            swap();
            return cons();
          }
        };
        is_factor = function() {
          if ((typeof token.charCodeAt === "function" ? token.charCodeAt(0) : void 0) === dotprod_unicode) {
            return 1;
          }
          switch (token) {
            case "*":
            case "/":
              return 1;
            case "(":
            case T_SYMBOL:
            case T_FUNCTION:
            case T_INTEGER:
            case T_DOUBLE:
            case T_STRING:
              if (newline_flag) {
                scan_str = token_str;
                return 0;
              } else {
                return 1;
              }
          }
          return 0;
        };
        simplify_1_in_products = function(tos2, h5) {
          if (tos2 > h5 && isrational(stack[tos2 - 1]) && equaln(stack[tos2 - 1], 1)) {
            return pop();
          }
        };
        multiply_consecutive_constants = function(tos2, h5) {
          if (tos2 > h5 + 1 && isNumericAtom(stack[tos2 - 2]) && isNumericAtom(stack[tos2 - 1])) {
            return multiply();
          }
        };
        scan_term = function() {
          var h5;
          h5 = tos;
          scan_factor();
          if (parse_time_simplifications) {
            simplify_1_in_products(tos, h5);
          }
          while (is_factor()) {
            if (token === "*") {
              get_next_token();
              scan_factor();
            } else if (token === "/") {
              simplify_1_in_products(tos, h5);
              get_next_token();
              scan_factor();
              inverse();
            } else if ((typeof token.charCodeAt === "function" ? token.charCodeAt(0) : void 0) === dotprod_unicode) {
              get_next_token();
              push_symbol(INNER);
              swap();
              scan_factor();
              list(3);
            } else {
              scan_factor();
            }
            if (parse_time_simplifications) {
              multiply_consecutive_constants(tos, h5);
              simplify_1_in_products(tos, h5);
            }
          }
          if (h5 === tos) {
            return push_integer(1);
          } else if (tos - h5 > 1) {
            list(tos - h5);
            push_symbol(MULTIPLY);
            swap();
            return cons();
          }
        };
        scan_power = function() {
          if (token === "^") {
            get_next_token();
            push_symbol(POWER);
            swap();
            scan_factor();
            return list(3);
          }
        };
        scan_index = function(h5) {
          get_next_token();
          push_symbol(INDEX);
          swap();
          scan_expression();
          while (token === ",") {
            get_next_token();
            scan_expression();
          }
          if (token !== "]") {
            scan_error("] expected");
          }
          get_next_token();
          return list(tos - h5);
        };
        scan_factor = function() {
          var firstFactorIsNumber, h5;
          h5 = tos;
          firstFactorIsNumber = false;
          if (token === "(") {
            scan_subexpr();
          } else if (token === T_SYMBOL) {
            scan_symbol();
          } else if (token === T_FUNCTION) {
            scan_function_call_with_function_name();
          } else if (token === "[") {
            scan_tensor();
          } else if (token === T_INTEGER) {
            firstFactorIsNumber = true;
            bignum_scan_integer(token_buf);
            get_next_token();
          } else if (token === T_DOUBLE) {
            firstFactorIsNumber = true;
            bignum_scan_float(token_buf);
            get_next_token();
          } else if (token === T_STRING) {
            scan_string();
          } else {
            scan_error("syntax error");
          }
          while (token === "[" || token === "(" && newline_flag === 0 && !firstFactorIsNumber) {
            if (token === "[") {
              scan_index(h5);
            } else if (token === "(") {
              scan_function_call_without_function_name();
            }
          }
          while (token === "!") {
            get_next_token();
            push_symbol(FACTORIAL);
            swap();
            list(2);
          }
          while ((typeof token.charCodeAt === "function" ? token.charCodeAt(0) : void 0) === transpose_unicode) {
            get_next_token();
            push_symbol(TRANSPOSE);
            swap();
            list(2);
          }
          return scan_power();
        };
        addSymbolRightOfAssignment = function(theSymbol) {
          var i5, l1, prefixVar, ref2;
          if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 && symbolsRightOfAssignment.indexOf(theSymbol) === -1 && symbolsRightOfAssignment.indexOf("'" + theSymbol) === -1 && !skipRootVariableToBeSolved) {
            if (DEBUG) {
              console.log("... adding symbol: " + theSymbol + " to the set of the symbols right of assignment");
            }
            prefixVar = "";
            for (i5 = l1 = 1, ref2 = functionInvokationsScanningStack.length; 1 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 1 <= ref2 ? ++l1 : --l1) {
              if (functionInvokationsScanningStack[i5] !== "") {
                prefixVar += functionInvokationsScanningStack[i5] + "_" + i5 + "_";
              }
            }
            theSymbol = prefixVar + theSymbol;
            return symbolsRightOfAssignment.push(theSymbol);
          }
        };
        addSymbolLeftOfAssignment = function(theSymbol) {
          var i5, l1, prefixVar, ref2;
          if (predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(theSymbol) === -1 && symbolsLeftOfAssignment.indexOf(theSymbol) === -1 && symbolsLeftOfAssignment.indexOf("'" + theSymbol) === -1 && !skipRootVariableToBeSolved) {
            if (DEBUG) {
              console.log("... adding symbol: " + theSymbol + " to the set of the symbols left of assignment");
            }
            prefixVar = "";
            for (i5 = l1 = 1, ref2 = functionInvokationsScanningStack.length; 1 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 1 <= ref2 ? ++l1 : --l1) {
              if (functionInvokationsScanningStack[i5] !== "") {
                prefixVar += functionInvokationsScanningStack[i5] + "_" + i5 + "_";
              }
            }
            theSymbol = prefixVar + theSymbol;
            return symbolsLeftOfAssignment.push(theSymbol);
          }
        };
        scan_symbol = function() {
          if (token !== T_SYMBOL) {
            scan_error("symbol expected");
          }
          if (meta_mode && token_buf.length === 1) {
            switch (token_buf[0]) {
              case "a":
                push(symbol(METAA));
                break;
              case "b":
                push(symbol(METAB));
                break;
              case "x":
                push(symbol(METAX));
                break;
              default:
                push(usr_symbol(token_buf));
            }
          } else {
            push(usr_symbol(token_buf));
          }
          if (scanningParameters.length === 0) {
            if (DEBUG) {
              console.log("out of scanning parameters, processing " + token_buf);
            }
            lastFoundSymbol = token_buf;
            if (isSymbolLeftOfAssignment) {
              addSymbolLeftOfAssignment(token_buf);
            }
          } else {
            if (DEBUG) {
              console.log("still scanning parameters, skipping " + token_buf);
            }
            if (isSymbolLeftOfAssignment) {
              addSymbolRightOfAssignment("'" + token_buf);
            }
          }
          if (DEBUG) {
            console.log("found symbol: " + token_buf + " left of assignment: " + isSymbolLeftOfAssignment);
          }
          if (!isSymbolLeftOfAssignment) {
            addSymbolRightOfAssignment(token_buf);
          }
          return get_next_token();
        };
        scan_string = function() {
          push(new_string(token_buf));
          return get_next_token();
        };
        scan_function_call_with_function_name = function() {
          var functionName, i5, l1, n9, p11, ref2;
          if (DEBUG) {
            console.log("-- scan_function_call_with_function_name start");
          }
          n9 = 1;
          p11 = new U();
          p11 = usr_symbol(token_buf);
          push(p11);
          functionName = token_buf;
          if (functionName === "roots" || functionName === "defint" || functionName === "sum" || functionName === "product" || functionName === "for") {
            functionInvokationsScanningStack.push(token_buf);
          }
          lastFoundSymbol = token_buf;
          if (!isSymbolLeftOfAssignment) {
            addSymbolRightOfAssignment(token_buf);
          }
          get_next_token();
          get_next_token();
          scanningParameters.push(true);
          if (token !== ")") {
            scan_stmt();
            n9++;
            while (token === ",") {
              get_next_token();
              if (n9 === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf("roots") !== -1) {
                symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x3) {
                  return !new RegExp("roots_" + (functionInvokationsScanningStack.length - 1) + "_" + token_buf).test(x3);
                });
                skipRootVariableToBeSolved = true;
              }
              if (n9 === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf("sum") !== -1) {
                symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x3) {
                  return !new RegExp("sum_" + (functionInvokationsScanningStack.length - 1) + "_" + token_buf).test(x3);
                });
                skipRootVariableToBeSolved = true;
              }
              if (n9 === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf("product") !== -1) {
                symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x3) {
                  return !new RegExp("product_" + (functionInvokationsScanningStack.length - 1) + "_" + token_buf).test(x3);
                });
                skipRootVariableToBeSolved = true;
              }
              if (n9 === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf("for") !== -1) {
                symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x3) {
                  return !new RegExp("for_" + (functionInvokationsScanningStack.length - 1) + "_" + token_buf).test(x3);
                });
                skipRootVariableToBeSolved = true;
              }
              if (functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf("defint") !== -1 && (n9 === 2 || n9 > 2 && (n9 - 2) % 3 === 0)) {
                symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x3) {
                  return !new RegExp("defint_" + (functionInvokationsScanningStack.length - 1) + "_" + token_buf).test(x3);
                });
                skipRootVariableToBeSolved = true;
              }
              scan_stmt();
              skipRootVariableToBeSolved = false;
              n9++;
            }
            if (n9 === 2 && functionInvokationsScanningStack[functionInvokationsScanningStack.length - 1].indexOf("roots") !== -1) {
              symbolsRightOfAssignment = symbolsRightOfAssignment.filter(function(x3) {
                return !new RegExp("roots_" + (functionInvokationsScanningStack.length - 1) + "_x").test(x3);
              });
            }
          }
          scanningParameters.pop();
          for (i5 = l1 = 0, ref2 = symbolsRightOfAssignment.length; 0 <= ref2 ? l1 <= ref2 : l1 >= ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            if (symbolsRightOfAssignment[i5] != null) {
              if (functionName === "roots") {
                symbolsRightOfAssignment[i5] = symbolsRightOfAssignment[i5].replace(new RegExp("roots_" + (functionInvokationsScanningStack.length - 1) + "_"), "");
              }
              if (functionName === "defint") {
                symbolsRightOfAssignment[i5] = symbolsRightOfAssignment[i5].replace(new RegExp("defint_" + (functionInvokationsScanningStack.length - 1) + "_"), "");
              }
              if (functionName === "sum") {
                symbolsRightOfAssignment[i5] = symbolsRightOfAssignment[i5].replace(new RegExp("sum_" + (functionInvokationsScanningStack.length - 1) + "_"), "");
              }
              if (functionName === "product") {
                symbolsRightOfAssignment[i5] = symbolsRightOfAssignment[i5].replace(new RegExp("product_" + (functionInvokationsScanningStack.length - 1) + "_"), "");
              }
              if (functionName === "for") {
                symbolsRightOfAssignment[i5] = symbolsRightOfAssignment[i5].replace(new RegExp("for_" + (functionInvokationsScanningStack.length - 1) + "_"), "");
              }
            }
          }
          if (token !== ")") {
            scan_error(") expected");
          }
          get_next_token();
          list(n9);
          if (functionName === "roots" || functionName === "defint" || functionName === "sum" || functionName === "product" || functionName === "for") {
            functionInvokationsScanningStack.pop();
          }
          if (functionName === symbol(PATTERN).printname) {
            patternHasBeenFound = true;
          }
          if (DEBUG) {
            return console.log("-- scan_function_call_with_function_name end");
          }
        };
        scan_function_call_without_function_name = function() {
          var n9;
          if (DEBUG) {
            console.log("-- scan_function_call_without_function_name start");
          }
          push_symbol(EVAL);
          swap();
          list(2);
          n9 = 1;
          get_next_token();
          scanningParameters.push(true);
          if (token !== ")") {
            scan_stmt();
            n9++;
            while (token === ",") {
              get_next_token();
              scan_stmt();
              n9++;
            }
          }
          scanningParameters.pop();
          if (token !== ")") {
            scan_error(") expected");
          }
          get_next_token();
          list(n9);
          if (DEBUG) {
            return console.log("-- scan_function_call_without_function_name end: " + stack[tos - 1]);
          }
        };
        scan_subexpr = function() {
          var n9;
          n9 = 0;
          if (token !== "(") {
            scan_error("( expected");
          }
          get_next_token();
          scan_stmt();
          if (token !== ")") {
            scan_error(") expected");
          }
          return get_next_token();
        };
        scan_tensor = function() {
          var n9;
          n9 = 0;
          if (token !== "[") {
            scan_error("[ expected");
          }
          get_next_token();
          scan_stmt();
          n9 = 1;
          while (token === ",") {
            get_next_token();
            scan_stmt();
            n9++;
          }
          build_tensor(n9);
          if (token !== "]") {
            scan_error("] expected");
          }
          return get_next_token();
        };
        scan_error = function(errmsg) {
          errorMessage = "";
          while (input_str !== scan_str) {
            if ((scanned[input_str] === "\n" || scanned[input_str] === "\r") && input_str + 1 === scan_str) {
              break;
            }
            errorMessage += scanned[input_str++];
          }
          errorMessage += " ? ";
          while (scanned[input_str] && (scanned[input_str] !== "\n" && scanned[input_str] !== "\r")) {
            errorMessage += scanned[input_str++];
          }
          errorMessage += "\n";
          return stop(errmsg);
        };
        build_tensor = function(n9) {
          var i5, l1, ref2;
          i5 = 0;
          save();
          p2 = alloc_tensor(n9);
          p2.tensor.ndim = 1;
          p2.tensor.dim[0] = n9;
          for (i5 = l1 = 0, ref2 = n9; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            p2.tensor.elem[i5] = stack[tos - n9 + i5];
          }
          check_tensor_dimensions(p2);
          moveTos(tos - n9);
          push(p2);
          return restore();
        };
        get_next_token = function() {
          newline_flag = 0;
          while (1) {
            get_token();
            if (token !== T_NEWLINE) {
              break;
            }
            newline_flag = 1;
          }
          if (DEBUG) {
            return console.log("get_next_token token: " + token);
          }
        };
        get_token = function() {
          while (isspace(scanned[scan_str])) {
            if (scanned[scan_str] === "\n" || scanned[scan_str] === "\r") {
              token = T_NEWLINE;
              scan_str++;
              return;
            }
            scan_str++;
          }
          token_str = scan_str;
          if (scan_str === scanned.length) {
            token = "";
            return;
          }
          if (isdigit(scanned[scan_str]) || scanned[scan_str] === ".") {
            while (isdigit(scanned[scan_str])) {
              scan_str++;
            }
            if (scanned[scan_str] === ".") {
              scan_str++;
              while (isdigit(scanned[scan_str])) {
                scan_str++;
              }
              if (scanned[scan_str] === "e" && (scanned[scan_str + 1] === "+" || scanned[scan_str + 1] === "-" || isdigit(scanned[scan_str + 1]))) {
                scan_str += 2;
                while (isdigit(scanned[scan_str])) {
                  scan_str++;
                }
              }
              token = T_DOUBLE;
            } else {
              token = T_INTEGER;
            }
            update_token_buf(token_str, scan_str);
            return;
          }
          if (isalpha(scanned[scan_str])) {
            while (isalnumorunderscore(scanned[scan_str])) {
              scan_str++;
            }
            if (scanned[scan_str] === "(") {
              token = T_FUNCTION;
            } else {
              token = T_SYMBOL;
            }
            update_token_buf(token_str, scan_str);
            return;
          }
          if (scanned[scan_str] === '"') {
            scan_str++;
            while (scanned[scan_str] !== '"') {
              if (scan_str === scanned.length - 1) {
                scan_str++;
                scan_error("runaway string");
                scan_str--;
              }
              scan_str++;
            }
            scan_str++;
            token = T_STRING;
            update_token_buf(token_str + 1, scan_str - 1);
            return;
          }
          if (scanned[scan_str] === "#" || scanned[scan_str] === "-" && scanned[scan_str + 1] === "-") {
            while (scanned[scan_str] && scanned[scan_str] !== "\n" && scanned[scan_str] !== "\r") {
              scan_str++;
            }
            if (scanned[scan_str]) {
              scan_str++;
            }
            token = T_NEWLINE;
            return;
          }
          if (scanned[scan_str] === ":" && scanned[scan_str + 1] === "=") {
            scan_str += 2;
            token = T_QUOTASSIGN;
            return;
          }
          if (scanned[scan_str] === "=" && scanned[scan_str + 1] === "=") {
            scan_str += 2;
            token = T_EQ;
            return;
          }
          if (scanned[scan_str] === "!" && scanned[scan_str + 1] === "=") {
            scan_str += 2;
            token = T_NEQ;
            return;
          }
          if (scanned[scan_str] === "<" && scanned[scan_str + 1] === "=") {
            scan_str += 2;
            token = T_LTEQ;
            return;
          }
          if (scanned[scan_str] === ">" && scanned[scan_str + 1] === "=") {
            scan_str += 2;
            token = T_GTEQ;
            return;
          }
          return token = scanned[scan_str++];
        };
        update_token_buf = function(a5, b2) {
          return token_buf = scanned.substring(a5, b2);
        };
        $.scan = scan;
        Eval_sgn = function() {
          push(cadr(p1));
          Eval();
          return sgn();
        };
        sgn = function() {
          save();
          yysgn();
          return restore();
        };
        yysgn = function() {
          p1 = pop();
          if (isdouble(p1)) {
            if (p1.d > 0) {
              push_integer(1);
              return;
            } else {
              if (p1.d === 0) {
                push_integer(1);
                return;
              } else {
                push_integer(-1);
                return;
              }
            }
          }
          if (isrational(p1)) {
            if (MSIGN(mmul(p1.q.a, p1.q.b)) === -1) {
              push_integer(-1);
              return;
            } else {
              if (MZERO(mmul(p1.q.a, p1.q.b))) {
                push_integer(0);
                return;
              } else {
                push_integer(1);
                return;
              }
            }
          }
          if (iscomplexnumber(p1)) {
            push_integer(-1);
            push(p1);
            absval();
            power();
            push(p1);
            multiply();
            return;
          }
          if (isnegativeterm(p1)) {
            push_symbol(SGN);
            push(p1);
            negate();
            list(2);
            push_integer(-1);
            multiply();
            return;
          }
          push_symbol(SGN);
          push(p1);
          return list(2);
        };
        Eval_shape = function() {
          push(cadr(p1));
          Eval();
          return shape();
        };
        shape = function() {
          var ai, an, i5, l1, m1, ndim, ref2, ref3, t5;
          i5 = 0;
          ndim = 0;
          t5 = 0;
          ai = [];
          an = [];
          for (i5 = l1 = 0, ref2 = MAXDIM; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            ai[i5] = 0;
            an[i5] = 0;
          }
          save();
          p1 = pop();
          if (!istensor(p1)) {
            if (!isZeroAtomOrTensor(p1)) {
              stop("transpose: tensor expected, 1st arg is not a tensor");
            }
            push(zero);
            restore();
            return;
          }
          ndim = p1.tensor.ndim;
          p2 = alloc_tensor(ndim);
          p2.tensor.ndim = 1;
          p2.tensor.dim[0] = ndim;
          for (i5 = m1 = 0, ref3 = ndim; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i5 = 0 <= ref3 ? ++m1 : --m1) {
            push_integer(p1.tensor.dim[i5]);
            p2.tensor.elem[i5] = pop();
          }
          push(p2);
          return restore();
        };
        Eval_simfac = function() {
          push(cadr(p1));
          Eval();
          return simfac();
        };
        simfac = function() {
          var h5;
          h5 = 0;
          save();
          p1 = pop();
          if (car(p1) === symbol(ADD)) {
            h5 = tos;
            p1 = cdr(p1);
            while (p1 !== symbol(NIL)) {
              push(car(p1));
              simfac_term();
              p1 = cdr(p1);
            }
            add_all(tos - h5);
          } else {
            push(p1);
            simfac_term();
          }
          return restore();
        };
        simfac_term = function() {
          var doNothing, h5;
          h5 = 0;
          save();
          p1 = pop();
          if (car(p1) !== symbol(MULTIPLY)) {
            push(p1);
            restore();
            return;
          }
          h5 = tos;
          p1 = cdr(p1);
          while (p1 !== symbol(NIL)) {
            push(car(p1));
            p1 = cdr(p1);
          }
          while (yysimfac(h5)) {
            doNothing = 1;
          }
          multiply_all_noexpand(tos - h5);
          return restore();
        };
        yysimfac = function(h5) {
          var i5, j2, l1, m1, ref2, ref3, ref4, ref5;
          i5 = 0;
          j2 = 0;
          for (i5 = l1 = ref2 = h5, ref3 = tos; ref2 <= ref3 ? l1 < ref3 : l1 > ref3; i5 = ref2 <= ref3 ? ++l1 : --l1) {
            p1 = stack[i5];
            for (j2 = m1 = ref4 = h5, ref5 = tos; ref4 <= ref5 ? m1 < ref5 : m1 > ref5; j2 = ref4 <= ref5 ? ++m1 : --m1) {
              if (i5 === j2) {
                continue;
              }
              p2 = stack[j2];
              if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && equal(cadr(p1), cadr(p2))) {
                push(cadr(p1));
                push(one);
                subtract();
                factorial();
                stack[i5] = pop();
                stack[j2] = one;
                return 1;
              }
              if (car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL) && equal(p1, cadadr(p2))) {
                push(p1);
                push_integer(-1);
                add();
                factorial();
                reciprocate();
                stack[i5] = pop();
                stack[j2] = one;
                return 1;
              }
              if (car(p2) === symbol(FACTORIAL)) {
                push(p1);
                push(cadr(p2));
                subtract();
                p3 = pop();
                if (isplusone(p3)) {
                  push(p1);
                  factorial();
                  stack[i5] = pop();
                  stack[j2] = one;
                  return 1;
                }
              }
              if (car(p1) === symbol(POWER) && isminusone(caddr(p1)) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {
                push(cadr(p1));
                push(cadr(cadr(p2)));
                subtract();
                p3 = pop();
                if (isplusone(p3)) {
                  push(cadr(p1));
                  factorial();
                  reciprocate();
                  stack[i5] = pop();
                  stack[j2] = one;
                  return 1;
                }
              }
              if (car(p1) === symbol(FACTORIAL) && car(p2) === symbol(POWER) && isminusone(caddr(p2)) && caadr(p2) === symbol(FACTORIAL)) {
                push(cadr(p1));
                push(cadr(cadr(p2)));
                subtract();
                p3 = pop();
                if (isplusone(p3)) {
                  stack[i5] = cadr(p1);
                  stack[j2] = one;
                  return 1;
                }
                if (isminusone(p3)) {
                  push(cadr(cadr(p2)));
                  reciprocate();
                  stack[i5] = pop();
                  stack[j2] = one;
                  return 1;
                }
                if (equaln(p3, 2)) {
                  stack[i5] = cadr(p1);
                  push(cadr(p1));
                  push_integer(-1);
                  add();
                  stack[j2] = pop();
                  return 1;
                }
                if (equaln(p3, -2)) {
                  push(cadr(cadr(p2)));
                  reciprocate();
                  stack[i5] = pop();
                  push(cadr(cadr(p2)));
                  push_integer(-1);
                  add();
                  reciprocate();
                  stack[j2] = pop();
                  return 1;
                }
              }
            }
          }
          return 0;
        };
        DEBUG_SIMPLIFY = false;
        Eval_simplify = function() {
          push(cadr(p1));
          runUserDefinedSimplifications();
          Eval();
          return simplify();
        };
        runUserDefinedSimplifications = function() {
          var atLeastOneSuccessInRouldOfRulesApplications, eachConsecutiveRuleApplication, eachSimplification, l1, len, len1, m1, numberOfRulesApplications, originalexpanding, success;
          if (userSimplificationsInListForm.length !== 0 && !Find(cadr(p1), symbol(INTEGRAL))) {
            originalexpanding = expanding;
            expanding = false;
            if (DEBUG_SIMPLIFY) {
              console.log("runUserDefinedSimplifications passed: " + stack[tos - 1].toString());
            }
            Eval();
            if (DEBUG_SIMPLIFY) {
              console.log("runUserDefinedSimplifications after eval no expanding: " + stack[tos - 1].toString());
            }
            expanding = originalexpanding;
            p1 = stack[tos - 1];
            if (DEBUG_SIMPLIFY) {
              console.log("patterns to be checked: ");
            }
            for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {
              eachSimplification = userSimplificationsInListForm[l1];
              if (DEBUG_SIMPLIFY) {
                console.log("..." + eachSimplification);
              }
            }
            atLeastOneSuccessInRouldOfRulesApplications = true;
            numberOfRulesApplications = 0;
            while (atLeastOneSuccessInRouldOfRulesApplications && numberOfRulesApplications < MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES) {
              atLeastOneSuccessInRouldOfRulesApplications = false;
              numberOfRulesApplications++;
              for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {
                eachSimplification = userSimplificationsInListForm[m1];
                success = true;
                eachConsecutiveRuleApplication = 0;
                while (success && eachConsecutiveRuleApplication < MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE) {
                  eachConsecutiveRuleApplication++;
                  if (DEBUG_SIMPLIFY) {
                    console.log("simplify - tos: " + tos + " checking pattern: " + eachSimplification + " on: " + p1);
                  }
                  push_symbol(NIL);
                  success = transform(eachSimplification, true);
                  if (success) {
                    atLeastOneSuccessInRouldOfRulesApplications = true;
                  }
                  p1 = stack[tos - 1];
                  if (DEBUG_SIMPLIFY) {
                    console.log("p1 at this stage of simplification: " + p1);
                  }
                }
                if (eachConsecutiveRuleApplication === MAX_CONSECUTIVE_APPLICATIONS_OF_SINGLE_RULE) {
                  stop("maximum application of single transformation rule exceeded: " + eachSimplification);
                }
              }
            }
            if (numberOfRulesApplications === MAX_CONSECUTIVE_APPLICATIONS_OF_ALL_RULES) {
              stop("maximum application of all transformation rules exceeded ");
            }
            if (DEBUG_SIMPLIFY) {
              console.log("METAX = " + get_binding(symbol(METAX)));
            }
            if (DEBUG_SIMPLIFY) {
              console.log("METAA = " + get_binding(symbol(METAA)));
            }
            if (DEBUG_SIMPLIFY) {
              return console.log("METAB = " + get_binding(symbol(METAB)));
            }
          }
        };
        simplifyForCodeGeneration = function() {
          save();
          runUserDefinedSimplifications();
          codeGen = true;
          simplify_main();
          codeGen = false;
          return restore();
        };
        simplify = function() {
          save();
          simplify_main();
          return restore();
        };
        simplify_main = function() {
          var args, fbody;
          p1 = pop();
          if (codeGen && car(p1) === symbol(FUNCTION)) {
            fbody = cadr(p1);
            push(fbody);
            eval();
            simplify();
            p3 = pop();
            args = caddr(p1);
            push_symbol(FUNCTION);
            push(p3);
            push(args);
            list(3);
            p1 = pop();
          }
          if (istensor(p1)) {
            simplify_tensor();
            return;
          }
          if (Find(p1, symbol(FACTORIAL))) {
            push(p1);
            simfac();
            p2 = pop();
            push(p1);
            rationalize();
            simfac();
            p3 = pop();
            if (count(p2) < count(p3)) {
              p1 = p2;
            } else {
              p1 = p3;
            }
          }
          f10();
          if (DEBUG_SIMPLIFY) {
            console.log("f10: " + p1.toString());
          }
          f1();
          if (DEBUG_SIMPLIFY) {
            console.log("f1: " + p1.toString());
          }
          f2();
          if (DEBUG_SIMPLIFY) {
            console.log("f2: " + p1.toString());
          }
          f3();
          if (DEBUG_SIMPLIFY) {
            console.log("f3: " + p1.toString());
          }
          f4();
          if (DEBUG_SIMPLIFY) {
            console.log("f4: " + p1.toString());
          }
          f5();
          if (DEBUG_SIMPLIFY) {
            console.log("f5: " + p1.toString());
          }
          f9();
          if (DEBUG_SIMPLIFY) {
            console.log("f9: " + p1.toString());
          }
          simplify_polarRect();
          if (do_simplify_nested_radicals) {
            if (simplify_nested_radicals()) {
              if (DEBUG_SIMPLIFY) {
                console.log("de-nesting successful into: " + p1.toString());
              }
              push(p1);
              simplify();
              return;
            }
          }
          simplify_rectToClock();
          simplify_rational_expressions();
          return push(p1);
        };
        simplify_tensor = function() {
          var i5, l1, m1, ref2, ref3;
          i5 = 0;
          p2 = alloc_tensor(p1.tensor.nelem);
          p2.tensor.ndim = p1.tensor.ndim;
          for (i5 = l1 = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            p2.tensor.dim[i5] = p1.tensor.dim[i5];
          }
          for (i5 = m1 = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i5 = 0 <= ref3 ? ++m1 : --m1) {
            push(p1.tensor.elem[i5]);
            simplify();
            p2.tensor.elem[i5] = pop();
          }
          check_tensor_dimensions(p2);
          if (isZeroAtomOrTensor(p2)) {
            p2 = zero;
          }
          return push(p2);
        };
        f1 = function() {
          if (car(p1) !== symbol(ADD)) {
            return;
          }
          push(p1);
          rationalize();
          p2 = pop();
          if (count(p2) < count(p1)) {
            return p1 = p2;
          }
        };
        f2 = function() {
          if (car(p1) !== symbol(ADD)) {
            return;
          }
          push(p1);
          Condense();
          p2 = pop();
          if (count(p2) <= count(p1)) {
            return p1 = p2;
          }
        };
        f3 = function() {
          push(p1);
          rationalize();
          negate();
          rationalize();
          negate();
          rationalize();
          p2 = pop();
          if (count(p2) < count(p1)) {
            return p1 = p2;
          }
        };
        f10 = function() {
          var a5, b2, carp1, miao, originalexpanding;
          carp1 = car(p1);
          miao = cdr(p1);
          if (carp1 === symbol(MULTIPLY) || isinnerordot(p1)) {
            if (car(car(cdr(p1))) === symbol(TRANSPOSE) && car(car(cdr(cdr(p1)))) === symbol(TRANSPOSE)) {
              if (DEBUG_SIMPLIFY) {
                console.log("maybe collecting a transpose " + p1);
              }
              a5 = cadr(car(cdr(p1)));
              b2 = cadr(car(cdr(cdr(p1))));
              if (carp1 === symbol(MULTIPLY)) {
                push(a5);
                push(b2);
                multiply();
              } else if (isinnerordot(p1)) {
                push(b2);
                push(a5);
                inner();
              }
              push_integer(1);
              push_integer(2);
              originalexpanding = expanding;
              expanding = false;
              transpose();
              expanding = originalexpanding;
              p2 = pop();
              if (count(p2) < count(p1)) {
                p1 = p2;
              }
              if (DEBUG_SIMPLIFY) {
                return console.log("collecting a transpose " + p2);
              }
            }
          }
        };
        f4 = function() {
          if (isZeroAtomOrTensor(p1)) {
            return;
          }
          push(p1);
          rationalize();
          inverse();
          rationalize();
          inverse();
          rationalize();
          p2 = pop();
          if (count(p2) < count(p1)) {
            return p1 = p2;
          }
        };
        simplify_trig = function() {
          save();
          p1 = pop();
          f5();
          push(p1);
          return restore();
        };
        f5 = function() {
          if (Find(p1, symbol(SIN)) === 0 && Find(p1, symbol(COS)) === 0) {
            return;
          }
          p2 = p1;
          trigmode = 1;
          push(p2);
          Eval();
          p3 = pop();
          trigmode = 2;
          push(p2);
          Eval();
          p4 = pop();
          trigmode = 0;
          if (count(p4) < count(p3) || nterms(p4) < nterms(p3)) {
            p3 = p4;
          }
          if (count(p3) < count(p1) || nterms(p3) < nterms(p1)) {
            return p1 = p3;
          }
        };
        f9 = function() {
          var oldp1, oldp2;
          if (car(p1) !== symbol(ADD)) {
            return;
          }
          push_integer(0);
          p2 = cdr(p1);
          while (iscons(p2)) {
            push(car(p2));
            simplify();
            add();
            oldp1 = p1;
            oldp2 = p2;
            p1 = pop();
            simplify_rational_expressions();
            push(p1);
            p1 = oldp1;
            p2 = oldp2;
            p2 = cdr(p2);
          }
          p2 = pop();
          if (count(p2) < count(p1)) {
            return p1 = p2;
          }
        };
        simplify_rational_expressions = function() {
          var denom, num, polyVar, sasa, theGCD;
          push(p1);
          denominator();
          denom = pop();
          if (isone(denom)) {
            return;
          }
          push(p1);
          numerator();
          num = pop();
          if (isone(num)) {
            return;
          }
          if (!(polyVar = areunivarpolysfactoredorexpandedform(num, denom))) {
            return;
          }
          push(num);
          push(denom);
          gcd();
          push(polyVar);
          factor();
          theGCD = pop();
          if (isone(theGCD)) {
            return;
          }
          push(num);
          push(polyVar);
          factor();
          push(theGCD);
          inverse();
          multiply_noexpand();
          simplify();
          sasa = stack[tos - 1].toString();
          push(denom);
          push(polyVar);
          factor();
          push(theGCD);
          inverse();
          multiply_noexpand();
          simplify();
          sasa = stack[tos - 1].toString();
          divide();
          Condense();
          sasa = stack[tos - 1].toString();
          p2 = pop();
          if (count(p2) < count(p1)) {
            return p1 = p2;
          }
        };
        simplify_rectToClock = function() {
          if (Find(p1, symbol(SIN)) === 0 && Find(p1, symbol(COS)) === 0) {
            return;
          }
          push(p1);
          Eval();
          clockform();
          p2 = pop();
          if (DEBUG_SIMPLIFY) {
            console.log("before simplification clockform: " + p1 + " after: " + p2);
          }
          if (count(p2) < count(p1)) {
            return p1 = p2;
          }
        };
        simplify_polarRect = function() {
          push(p1);
          polarRectAMinusOneBase();
          Eval();
          p2 = pop();
          if (count(p2) < count(p1)) {
            return p1 = p2;
          }
        };
        polarRectAMinusOneBase = function() {
          var h5;
          save();
          p1 = pop();
          if (isimaginaryunit(p1)) {
            push(p1);
            restore();
            return;
          }
          if (equal(car(p1), symbol(POWER)) && isminusone(cadr(p1))) {
            push(one);
            negate();
            push(caddr(p1));
            polarRectAMinusOneBase();
            power();
            polar();
            rect();
          } else if (iscons(p1)) {
            h5 = tos;
            while (iscons(p1)) {
              push(car(p1));
              polarRectAMinusOneBase();
              p1 = cdr(p1);
            }
            list(tos - h5);
          } else {
            push(p1);
          }
          restore();
        };
        nterms = function(p11) {
          if (car(p11) !== symbol(ADD)) {
            return 1;
          } else {
            return length(p11) - 1;
          }
        };
        simplify_nested_radicals = function() {
          var prev_expanding, simplificationWithCondense, simplificationWithoutCondense, somethingSimplified;
          if (recursionLevelNestedRadicalsRemoval > 0) {
            if (DEBUG_SIMPLIFY) {
              console.log("denesting bailing out because of too much recursion");
            }
            return false;
          }
          push(p1);
          somethingSimplified = take_care_of_nested_radicals();
          simplificationWithoutCondense = stack[tos - 1];
          prev_expanding = expanding;
          expanding = 0;
          yycondense();
          expanding = prev_expanding;
          simplificationWithCondense = pop();
          if (countOccurrencesOfSymbol(symbol(POWER), simplificationWithoutCondense) < countOccurrencesOfSymbol(symbol(POWER), simplificationWithCondense)) {
            push(simplificationWithoutCondense);
          } else {
            push(simplificationWithCondense);
          }
          p1 = pop();
          return somethingSimplified;
        };
        take_care_of_nested_radicals = function() {
          var A5, B4, C8, SOLUTION, anyRadicalSimplificationWorked, base, checkSize, commonBases, commonInnerExponent, countingTerms, eachSolution, exponent, firstTerm, h5, i5, innerbase, innerexponent, l1, len, len1, len2, len3, lowercase_a, lowercase_b, m1, n1, numberOfTerms, o1, possibleNewExpression, possibleNewExpressionValue, possibleRationalSolutions, possibleSolutions, potentialPower, realOfpossibleRationalSolutions, ref2, secondTerm, secondTermFactor, termsThatAreNotPowers, whichRationalSolution;
          if (recursionLevelNestedRadicalsRemoval > 0) {
            if (DEBUG_SIMPLIFY) {
              console.log("denesting bailing out because of too much recursion");
            }
            return false;
          }
          save();
          p1 = pop();
          if (equal(car(p1), symbol(POWER))) {
            base = cadr(p1);
            exponent = caddr(p1);
            if (!isminusone(exponent) && equal(car(base), symbol(ADD)) && isfraction(exponent) && (equalq(exponent, 1, 3) || equalq(exponent, 1, 2))) {
              firstTerm = cadr(base);
              push(firstTerm);
              take_care_of_nested_radicals();
              pop();
              secondTerm = caddr(base);
              push(secondTerm);
              take_care_of_nested_radicals();
              pop();
              numberOfTerms = 0;
              countingTerms = base;
              while (cdr(countingTerms) !== symbol(NIL)) {
                numberOfTerms++;
                countingTerms = cdr(countingTerms);
              }
              if (numberOfTerms > 2) {
                push(p1);
                restore();
                return false;
              }
              commonInnerExponent = null;
              commonBases = [];
              termsThatAreNotPowers = [];
              if (car(secondTerm) === symbol(MULTIPLY)) {
                secondTermFactor = cdr(secondTerm);
                if (iscons(secondTermFactor)) {
                  while (iscons(secondTermFactor)) {
                    potentialPower = car(secondTermFactor);
                    if (car(potentialPower) === symbol(POWER)) {
                      innerbase = cadr(potentialPower);
                      innerexponent = caddr(potentialPower);
                      if (equalq(innerexponent, 1, 2)) {
                        if (commonInnerExponent == null) {
                          commonInnerExponent = innerexponent;
                          commonBases.push(innerbase);
                        } else {
                          if (equal(innerexponent, commonInnerExponent)) {
                            commonBases.push(innerbase);
                          } else {
                          }
                        }
                      }
                    } else {
                      termsThatAreNotPowers.push(potentialPower);
                    }
                    secondTermFactor = cdr(secondTermFactor);
                  }
                }
              } else if (car(secondTerm) === symbol(POWER)) {
                innerbase = cadr(secondTerm);
                innerexponent = caddr(secondTerm);
                if (commonInnerExponent == null && equalq(innerexponent, 1, 2)) {
                  commonInnerExponent = innerexponent;
                  commonBases.push(innerbase);
                }
              }
              if (commonBases.length === 0) {
                push(p1);
                restore();
                return false;
              }
              A5 = firstTerm;
              push_integer(1);
              for (l1 = 0, len = commonBases.length; l1 < len; l1++) {
                i5 = commonBases[l1];
                push(i5);
                multiply();
              }
              C8 = pop();
              push_integer(1);
              for (m1 = 0, len1 = termsThatAreNotPowers.length; m1 < len1; m1++) {
                i5 = termsThatAreNotPowers[m1];
                push(i5);
                multiply();
              }
              B4 = pop();
              if (equalq(exponent, 1, 3)) {
                push(A5);
                negate();
                push(C8);
                multiply();
                push(B4);
                divide();
                checkSize = pop();
                push(checkSize);
                real();
                yyfloat();
                if (Math.abs(pop().d) > Math.pow(2, 32)) {
                  push(p1);
                  restore();
                  return false;
                }
                push(checkSize);
                push_integer(3);
                push(C8);
                multiply();
                checkSize = pop();
                push(checkSize);
                real();
                yyfloat();
                if (Math.abs(pop().d) > Math.pow(2, 32)) {
                  pop();
                  push(p1);
                  restore();
                  return false;
                }
                push(checkSize);
                push(symbol(SECRETX));
                multiply();
                push_integer(-3);
                push(A5);
                multiply();
                push(B4);
                divide();
                checkSize = pop();
                push(checkSize);
                real();
                yyfloat();
                if (Math.abs(pop().d) > Math.pow(2, 32)) {
                  pop();
                  pop();
                  push(p1);
                  restore();
                  return false;
                }
                push(checkSize);
                push(symbol(SECRETX));
                push_integer(2);
                power();
                multiply();
                push_integer(1);
                push(symbol(SECRETX));
                push_integer(3);
                power();
                multiply();
                add();
                add();
                add();
              } else if (equalq(exponent, 1, 2)) {
                push(C8);
                checkSize = pop();
                push(checkSize);
                real();
                yyfloat();
                if (Math.abs(pop().d) > Math.pow(2, 32)) {
                  push(p1);
                  restore();
                  return false;
                }
                push(checkSize);
                push_integer(-2);
                push(A5);
                multiply();
                push(B4);
                divide();
                checkSize = pop();
                push(checkSize);
                real();
                yyfloat();
                if (Math.abs(pop().d) > Math.pow(2, 32)) {
                  pop();
                  push(p1);
                  restore();
                  return false;
                }
                push(checkSize);
                push(symbol(SECRETX));
                multiply();
                push_integer(1);
                push(symbol(SECRETX));
                push_integer(2);
                power();
                multiply();
                add();
                add();
              }
              push(symbol(SECRETX));
              recursionLevelNestedRadicalsRemoval++;
              roots();
              recursionLevelNestedRadicalsRemoval--;
              if (equal(stack[tos - 1], symbol(NIL))) {
                if (DEBUG_SIMPLIFY) {
                  console.log("roots bailed out because of too much recursion");
                }
                pop();
                push(p1);
                restore();
                return false;
              }
              possibleSolutions = [];
              ref2 = stack[tos - 1].tensor.elem;
              for (n1 = 0, len2 = ref2.length; n1 < len2; n1++) {
                eachSolution = ref2[n1];
                if (!Find(eachSolution, symbol(POWER))) {
                  possibleSolutions.push(eachSolution);
                }
              }
              pop();
              if (possibleSolutions.length === 0) {
                push(p1);
                restore();
                return false;
              }
              possibleRationalSolutions = [];
              realOfpossibleRationalSolutions = [];
              for (o1 = 0, len3 = possibleSolutions.length; o1 < len3; o1++) {
                i5 = possibleSolutions[o1];
                push(i5);
                real();
                yyfloat();
                possibleRationalSolutions.push(i5);
                realOfpossibleRationalSolutions.push(pop().d);
              }
              whichRationalSolution = realOfpossibleRationalSolutions.indexOf(Math.max.apply(Math, realOfpossibleRationalSolutions));
              SOLUTION = possibleRationalSolutions[whichRationalSolution];
              if (equalq(exponent, 1, 3)) {
                push(A5);
                push(SOLUTION);
                push_integer(3);
                power();
                push_integer(3);
                push(C8);
                multiply();
                push(SOLUTION);
                multiply();
                add();
                divide();
                push_rational(1, 3);
                power();
              } else if (equalq(exponent, 1, 2)) {
                push(A5);
                push(SOLUTION);
                push_integer(2);
                power();
                push(C8);
                add();
                divide();
                push_rational(1, 2);
                power();
              }
              lowercase_b = pop();
              if (lowercase_b == null) {
                push(p1);
                restore();
                return false;
              }
              push(lowercase_b);
              push(SOLUTION);
              multiply();
              if (equalq(exponent, 1, 3)) {
                lowercase_a = pop();
                push(lowercase_b);
                push(C8);
                push_rational(1, 2);
                power();
                multiply();
                push(lowercase_a);
                add();
                simplify();
              } else if (equalq(exponent, 1, 2)) {
                lowercase_a = pop();
                push(lowercase_b);
                push(C8);
                push_rational(1, 2);
                power();
                multiply();
                push(lowercase_a);
                add();
                simplify();
                possibleNewExpression = pop();
                push(possibleNewExpression);
                real();
                yyfloat();
                possibleNewExpressionValue = pop();
                if (!isnegativenumber(possibleNewExpressionValue)) {
                  push(possibleNewExpression);
                } else {
                  push(lowercase_b);
                  negate();
                  lowercase_b = pop();
                  push(lowercase_a);
                  negate();
                  lowercase_a = pop();
                  push(lowercase_b);
                  push(C8);
                  push_rational(1, 2);
                  power();
                  multiply();
                  push(lowercase_a);
                  add();
                  simplify();
                }
              }
              p1 = pop();
              push(p1);
              restore();
              return true;
            } else {
              push(p1);
              restore();
              return false;
            }
          } else if (iscons(p1)) {
            h5 = tos;
            anyRadicalSimplificationWorked = false;
            while (iscons(p1)) {
              push(car(p1));
              anyRadicalSimplificationWorked = anyRadicalSimplificationWorked || take_care_of_nested_radicals();
              p1 = cdr(p1);
            }
            list(tos - h5);
            restore();
            return anyRadicalSimplificationWorked;
          } else {
            push(p1);
            restore();
            return false;
          }
          throw new Error("control flow should never reach here");
        };
        Eval_sin = function() {
          push(cadr(p1));
          Eval();
          return sine();
        };
        sine = function() {
          save();
          p1 = pop();
          if (car(p1) === symbol(ADD)) {
            sine_of_angle_sum();
          } else {
            sine_of_angle();
          }
          return restore();
        };
        sine_of_angle_sum = function() {
          p2 = cdr(p1);
          while (iscons(p2)) {
            p4 = car(p2);
            if (isnpi(p4)) {
              push(p1);
              push(p4);
              subtract();
              p3 = pop();
              push(p3);
              sine();
              push(p4);
              cosine();
              multiply();
              push(p3);
              cosine();
              push(p4);
              sine();
              multiply();
              add();
              return;
            }
            p2 = cdr(p2);
          }
          return sine_of_angle();
        };
        sine_of_angle = function() {
          var d3, n9;
          if (car(p1) === symbol(ARCSIN)) {
            push(cadr(p1));
            return;
          }
          if (isdouble(p1)) {
            d3 = Math.sin(p1.d);
            if (Math.abs(d3) < 1e-10) {
              d3 = 0;
            }
            push_double(d3);
            return;
          }
          if (isnegative(p1)) {
            push(p1);
            negate();
            sine();
            negate();
            return;
          }
          if (car(p1) === symbol(ARCTAN)) {
            push(cadr(p1));
            push_integer(1);
            push(cadr(p1));
            push_integer(2);
            power();
            add();
            push_rational(-1, 2);
            power();
            multiply();
            return;
          }
          push(p1);
          push_integer(180);
          multiply();
          if (evaluatingAsFloats) {
            push_double(Math.PI);
          } else {
            push_symbol(PI);
          }
          divide();
          n9 = pop_integer();
          if (n9 < 0 || isNaN(n9)) {
            push(symbol(SIN));
            push(p1);
            list(2);
            return;
          }
          switch (n9 % 360) {
            case 0:
            case 180:
              return push_integer(0);
            case 30:
            case 150:
              return push_rational(1, 2);
            case 210:
            case 330:
              return push_rational(-1, 2);
            case 45:
            case 135:
              push_rational(1, 2);
              push_integer(2);
              push_rational(1, 2);
              power();
              return multiply();
            case 225:
            case 315:
              push_rational(-1, 2);
              push_integer(2);
              push_rational(1, 2);
              power();
              return multiply();
            case 60:
            case 120:
              push_rational(1, 2);
              push_integer(3);
              push_rational(1, 2);
              power();
              return multiply();
            case 240:
            case 300:
              push_rational(-1, 2);
              push_integer(3);
              push_rational(1, 2);
              power();
              return multiply();
            case 90:
              return push_integer(1);
            case 270:
              return push_integer(-1);
            default:
              push(symbol(SIN));
              push(p1);
              return list(2);
          }
        };
        Eval_sinh = function() {
          push(cadr(p1));
          Eval();
          return ysinh();
        };
        ysinh = function() {
          save();
          yysinh();
          return restore();
        };
        yysinh = function() {
          var d3;
          d3 = 0;
          p1 = pop();
          if (car(p1) === symbol(ARCSINH)) {
            push(cadr(p1));
            return;
          }
          if (isdouble(p1)) {
            d3 = Math.sinh(p1.d);
            if (Math.abs(d3) < 1e-10) {
              d3 = 0;
            }
            push_double(d3);
            return;
          }
          if (isZeroAtomOrTensor(p1)) {
            push(zero);
            return;
          }
          push_symbol(SINH);
          push(p1);
          return list(2);
        };
        subst = function() {
          var expr, i5, l1, m1, newExpr, newTensor, oldExpr, ref2, ref3;
          save();
          newExpr = pop();
          oldExpr = pop();
          if (oldExpr === symbol(NIL) || newExpr === symbol(NIL)) {
            restore();
            return;
          }
          expr = pop();
          if (istensor(expr)) {
            newTensor = alloc_tensor(expr.tensor.nelem);
            newTensor.tensor.ndim = expr.tensor.ndim;
            for (i5 = l1 = 0, ref2 = expr.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
              newTensor.tensor.dim[i5] = expr.tensor.dim[i5];
            }
            for (i5 = m1 = 0, ref3 = expr.tensor.nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i5 = 0 <= ref3 ? ++m1 : --m1) {
              push(expr.tensor.elem[i5]);
              push(oldExpr);
              push(newExpr);
              subst();
              newTensor.tensor.elem[i5] = pop();
              check_tensor_dimensions(newTensor);
            }
            push(newTensor);
          } else if (equal(expr, oldExpr)) {
            push(newExpr);
          } else if (iscons(expr)) {
            push(car(expr));
            push(oldExpr);
            push(newExpr);
            subst();
            push(cdr(expr));
            push(oldExpr);
            push(newExpr);
            subst();
            cons();
          } else {
            push(expr);
          }
          return restore();
        };
        Eval_sum = function() {
          var body, i5, indexVariable, j2, k3, l1, ref2, ref3;
          i5 = 0;
          j2 = 0;
          k3 = 0;
          body = cadr(p1);
          indexVariable = caddr(p1);
          if (!issymbol(indexVariable)) {
            stop("sum: 2nd arg?");
          }
          push(cadddr(p1));
          Eval();
          j2 = pop_integer();
          if (isNaN(j2)) {
            push(p1);
            return;
          }
          push(caddddr(p1));
          Eval();
          k3 = pop_integer();
          if (isNaN(k3)) {
            push(p1);
            return;
          }
          p4 = get_binding(indexVariable);
          push_integer(0);
          for (i5 = l1 = ref2 = j2, ref3 = k3; ref2 <= ref3 ? l1 <= ref3 : l1 >= ref3; i5 = ref2 <= ref3 ? ++l1 : --l1) {
            push_integer(i5);
            p5 = pop();
            set_binding(indexVariable, p5);
            push(body);
            Eval();
            add();
          }
          return set_binding(indexVariable, p4);
        };
        Eval_tan = function() {
          push(cadr(p1));
          Eval();
          return tangent();
        };
        tangent = function() {
          save();
          yytangent();
          return restore();
        };
        yytangent = function() {
          var d3, n9;
          n9 = 0;
          d3 = 0;
          p1 = pop();
          if (car(p1) === symbol(ARCTAN)) {
            push(cadr(p1));
            return;
          }
          if (isdouble(p1)) {
            d3 = Math.tan(p1.d);
            if (Math.abs(d3) < 1e-10) {
              d3 = 0;
            }
            push_double(d3);
            return;
          }
          if (isnegative(p1)) {
            push(p1);
            negate();
            tangent();
            negate();
            return;
          }
          push(p1);
          push_integer(180);
          multiply();
          if (evaluatingAsFloats) {
            push_double(Math.PI);
          } else {
            push_symbol(PI);
          }
          divide();
          n9 = pop_integer();
          if (n9 < 0 || isNaN(n9)) {
            push(symbol(TAN));
            push(p1);
            list(2);
            return;
          }
          switch (n9 % 360) {
            case 0:
            case 180:
              return push_integer(0);
            case 30:
            case 210:
              push_rational(1, 3);
              push_integer(3);
              push_rational(1, 2);
              power();
              return multiply();
            case 150:
            case 330:
              push_rational(-1, 3);
              push_integer(3);
              push_rational(1, 2);
              power();
              return multiply();
            case 45:
            case 225:
              return push_integer(1);
            case 135:
            case 315:
              return push_integer(-1);
            case 60:
            case 240:
              push_integer(3);
              push_rational(1, 2);
              return power();
            case 120:
            case 300:
              push_integer(3);
              push_rational(1, 2);
              power();
              return negate();
            default:
              push(symbol(TAN));
              push(p1);
              return list(2);
          }
        };
        Eval_tanh = function() {
          var d3;
          d3 = 0;
          push(cadr(p1));
          Eval();
          p1 = pop();
          if (car(p1) === symbol(ARCTANH)) {
            push(cadr(p1));
            return;
          }
          if (isdouble(p1)) {
            d3 = Math.tanh(p1.d);
            if (Math.abs(d3) < 1e-10) {
              d3 = 0;
            }
            push_double(d3);
            return;
          }
          if (isZeroAtomOrTensor(p1)) {
            push(zero);
            return;
          }
          push_symbol(TANH);
          push(p1);
          return list(2);
        };
        Eval_taylor = function() {
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p2 = pop();
          if (p2 === symbol(NIL)) {
            guess();
          } else {
            push(p2);
          }
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p2 = pop();
          if (p2 === symbol(NIL)) {
            push_integer(24);
          } else {
            push(p2);
          }
          p1 = cdr(p1);
          push(car(p1));
          Eval();
          p2 = pop();
          if (p2 === symbol(NIL)) {
            push_integer(0);
          } else {
            push(p2);
          }
          return taylor();
        };
        taylor = function() {
          var i5, k3, l1, ref2;
          i5 = 0;
          k3 = 0;
          save();
          p4 = pop();
          p3 = pop();
          p2 = pop();
          p1 = pop();
          push(p3);
          k3 = pop_integer();
          if (isNaN(k3)) {
            push_symbol(TAYLOR);
            push(p1);
            push(p2);
            push(p3);
            push(p4);
            list(5);
            restore();
            return;
          }
          push(p1);
          push(p2);
          push(p4);
          subst();
          Eval();
          push_integer(1);
          p5 = pop();
          for (i5 = l1 = 1, ref2 = k3; 1 <= ref2 ? l1 <= ref2 : l1 >= ref2; i5 = 1 <= ref2 ? ++l1 : --l1) {
            push(p1);
            push(p2);
            derivative();
            p1 = pop();
            if (isZeroAtomOrTensor(p1)) {
              break;
            }
            push(p5);
            push(p2);
            push(p4);
            subtract();
            multiply();
            p5 = pop();
            push(p1);
            push(p2);
            push(p4);
            subst();
            Eval();
            push(p5);
            multiply();
            push_integer(i5);
            factorial();
            divide();
            add();
          }
          return restore();
        };
        Eval_tensor = function() {
          var a5, b2, i5, l1, m1, ndim, nelem, ref2, ref3;
          i5 = 0;
          ndim = 0;
          nelem = 0;
          check_tensor_dimensions(p1);
          nelem = p1.tensor.nelem;
          ndim = p1.tensor.ndim;
          p2 = alloc_tensor(nelem);
          p2.tensor.ndim = ndim;
          for (i5 = l1 = 0, ref2 = ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            p2.tensor.dim[i5] = p1.tensor.dim[i5];
          }
          a5 = p1.tensor.elem;
          b2 = p2.tensor.elem;
          check_tensor_dimensions(p2);
          for (i5 = m1 = 0, ref3 = nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i5 = 0 <= ref3 ? ++m1 : --m1) {
            push(a5[i5]);
            Eval();
            b2[i5] = pop();
          }
          check_tensor_dimensions(p1);
          check_tensor_dimensions(p2);
          push(p2);
          return promote_tensor();
        };
        tensor_plus_tensor = function() {
          var a5, b2, c9, i5, l1, m1, n1, ndim, nelem, ref2, ref3, ref4;
          i5 = 0;
          ndim = 0;
          nelem = 0;
          save();
          p2 = pop();
          p1 = pop();
          ndim = p1.tensor.ndim;
          if (ndim !== p2.tensor.ndim) {
            push(symbol(NIL));
            restore();
            return;
          }
          for (i5 = l1 = 0, ref2 = ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            if (p1.tensor.dim[i5] !== p2.tensor.dim[i5]) {
              push(symbol(NIL));
              restore();
              return;
            }
          }
          nelem = p1.tensor.nelem;
          p3 = alloc_tensor(nelem);
          p3.tensor.ndim = ndim;
          for (i5 = m1 = 0, ref3 = ndim; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i5 = 0 <= ref3 ? ++m1 : --m1) {
            p3.tensor.dim[i5] = p1.tensor.dim[i5];
          }
          a5 = p1.tensor.elem;
          b2 = p2.tensor.elem;
          c9 = p3.tensor.elem;
          for (i5 = n1 = 0, ref4 = nelem; 0 <= ref4 ? n1 < ref4 : n1 > ref4; i5 = 0 <= ref4 ? ++n1 : --n1) {
            push(a5[i5]);
            push(b2[i5]);
            add();
            c9[i5] = pop();
          }
          push(p3);
          return restore();
        };
        tensor_times_scalar = function() {
          var a5, b2, i5, l1, m1, ndim, nelem, ref2, ref3;
          i5 = 0;
          ndim = 0;
          nelem = 0;
          save();
          p2 = pop();
          p1 = pop();
          ndim = p1.tensor.ndim;
          nelem = p1.tensor.nelem;
          p3 = alloc_tensor(nelem);
          p3.tensor.ndim = ndim;
          for (i5 = l1 = 0, ref2 = ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            p3.tensor.dim[i5] = p1.tensor.dim[i5];
          }
          a5 = p1.tensor.elem;
          b2 = p3.tensor.elem;
          for (i5 = m1 = 0, ref3 = nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i5 = 0 <= ref3 ? ++m1 : --m1) {
            push(a5[i5]);
            push(p2);
            multiply();
            b2[i5] = pop();
          }
          push(p3);
          return restore();
        };
        scalar_times_tensor = function() {
          var a5, b2, i5, l1, m1, ndim, nelem, ref2, ref3;
          i5 = 0;
          ndim = 0;
          nelem = 0;
          save();
          p2 = pop();
          p1 = pop();
          ndim = p2.tensor.ndim;
          nelem = p2.tensor.nelem;
          p3 = alloc_tensor(nelem);
          p3.tensor.ndim = ndim;
          for (i5 = l1 = 0, ref2 = ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            p3.tensor.dim[i5] = p2.tensor.dim[i5];
          }
          a5 = p2.tensor.elem;
          b2 = p3.tensor.elem;
          for (i5 = m1 = 0, ref3 = nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i5 = 0 <= ref3 ? ++m1 : --m1) {
            push(p1);
            push(a5[i5]);
            multiply();
            b2[i5] = pop();
          }
          push(p3);
          return restore();
        };
        check_tensor_dimensions = function(p11) {
          if (p11.tensor.nelem !== p11.tensor.elem.length) {
            console.log("something wrong in tensor dimensions");
            debugger;
          }
        };
        is_square_matrix = function(p11) {
          if (istensor(p11) && p11.tensor.ndim === 2 && p11.tensor.dim[0] === p11.tensor.dim[1]) {
            return 1;
          } else {
            return 0;
          }
        };
        d_tensor_tensor = function() {
          var a5, b2, c9, i5, j2, l1, m1, n1, ndim, nelem, ref2, ref3, ref4;
          i5 = 0;
          j2 = 0;
          ndim = 0;
          nelem = 0;
          ndim = p1.tensor.ndim;
          nelem = p1.tensor.nelem;
          if (ndim + 1 >= MAXDIM) {
            push_symbol(DERIVATIVE);
            push(p1);
            push(p2);
            list(3);
            return;
          }
          p3 = alloc_tensor(nelem * p2.tensor.nelem);
          p3.tensor.ndim = ndim + 1;
          for (i5 = l1 = 0, ref2 = ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            p3.tensor.dim[i5] = p1.tensor.dim[i5];
          }
          p3.tensor.dim[ndim] = p2.tensor.dim[0];
          a5 = p1.tensor.elem;
          b2 = p2.tensor.elem;
          c9 = p3.tensor.elem;
          for (i5 = m1 = 0, ref3 = nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i5 = 0 <= ref3 ? ++m1 : --m1) {
            for (j2 = n1 = 0, ref4 = p2.tensor.nelem; 0 <= ref4 ? n1 < ref4 : n1 > ref4; j2 = 0 <= ref4 ? ++n1 : --n1) {
              push(a5[i5]);
              push(b2[j2]);
              derivative();
              c9[i5 * p2.tensor.nelem + j2] = pop();
            }
          }
          return push(p3);
        };
        d_scalar_tensor = function() {
          var a5, b2, i5, l1, ref2;
          p3 = alloc_tensor(p2.tensor.nelem);
          p3.tensor.ndim = 1;
          p3.tensor.dim[0] = p2.tensor.dim[0];
          a5 = p2.tensor.elem;
          b2 = p3.tensor.elem;
          for (i5 = l1 = 0, ref2 = p2.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            push(p1);
            push(a5[i5]);
            derivative();
            b2[i5] = pop();
          }
          return push(p3);
        };
        d_tensor_scalar = function() {
          var a5, b2, i5, l1, m1, ref2, ref3;
          i5 = 0;
          p3 = alloc_tensor(p1.tensor.nelem);
          p3.tensor.ndim = p1.tensor.ndim;
          for (i5 = l1 = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            p3.tensor.dim[i5] = p1.tensor.dim[i5];
          }
          a5 = p1.tensor.elem;
          b2 = p3.tensor.elem;
          for (i5 = m1 = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i5 = 0 <= ref3 ? ++m1 : --m1) {
            push(a5[i5]);
            push(p2);
            derivative();
            b2[i5] = pop();
          }
          return push(p3);
        };
        compare_tensors = function(p12, p22) {
          var i5, l1, m1, ref2, ref3;
          i5 = 0;
          if (p12.tensor.ndim < p22.tensor.ndim) {
            return -1;
          }
          if (p12.tensor.ndim > p22.tensor.ndim) {
            return 1;
          }
          for (i5 = l1 = 0, ref2 = p12.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            if (p12.tensor.dim[i5] < p22.tensor.dim[i5]) {
              return -1;
            }
            if (p12.tensor.dim[i5] > p22.tensor.dim[i5]) {
              return 1;
            }
          }
          for (i5 = m1 = 0, ref3 = p12.tensor.nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i5 = 0 <= ref3 ? ++m1 : --m1) {
            if (equal(p12.tensor.elem[i5], p22.tensor.elem[i5])) {
              continue;
            }
            if (lessp(p12.tensor.elem[i5], p22.tensor.elem[i5])) {
              return -1;
            } else {
              return 1;
            }
          }
          return 0;
        };
        power_tensor = function() {
          var i5, k3, l1, m1, n9, ref2, ref3, results;
          i5 = 0;
          k3 = 0;
          n9 = 0;
          k3 = p1.tensor.ndim - 1;
          if (p1.tensor.dim[0] !== p1.tensor.dim[k3]) {
            push_symbol(POWER);
            push(p1);
            push(p2);
            list(3);
            return;
          }
          push(p2);
          n9 = pop_integer();
          if (isNaN(n9)) {
            push_symbol(POWER);
            push(p1);
            push(p2);
            list(3);
            return;
          }
          if (n9 === 0) {
            if (p1.tensor.ndim !== 2) {
              stop("power(tensor,0) with tensor rank not equal to 2");
            }
            n9 = p1.tensor.dim[0];
            p1 = alloc_tensor(n9 * n9);
            p1.tensor.ndim = 2;
            p1.tensor.dim[0] = n9;
            p1.tensor.dim[1] = n9;
            for (i5 = l1 = 0, ref2 = n9; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
              p1.tensor.elem[n9 * i5 + i5] = one;
            }
            check_tensor_dimensions(p1);
            push(p1);
            return;
          }
          if (n9 < 0) {
            n9 = -n9;
            push(p1);
            inv();
            p1 = pop();
          }
          push(p1);
          results = [];
          for (i5 = m1 = 1, ref3 = n9; 1 <= ref3 ? m1 < ref3 : m1 > ref3; i5 = 1 <= ref3 ? ++m1 : --m1) {
            push(p1);
            inner();
            if (isZeroAtomOrTensor(stack[tos - 1])) {
              break;
            } else {
              results.push(void 0);
            }
          }
          return results;
        };
        copy_tensor = function() {
          var i5, l1, m1, ref2, ref3;
          i5 = 0;
          save();
          p1 = pop();
          p2 = alloc_tensor(p1.tensor.nelem);
          p2.tensor.ndim = p1.tensor.ndim;
          for (i5 = l1 = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            p2.tensor.dim[i5] = p1.tensor.dim[i5];
          }
          for (i5 = m1 = 0, ref3 = p1.tensor.nelem; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i5 = 0 <= ref3 ? ++m1 : --m1) {
            p2.tensor.elem[i5] = p1.tensor.elem[i5];
          }
          check_tensor_dimensions(p1);
          check_tensor_dimensions(p2);
          push(p2);
          return restore();
        };
        promote_tensor = function() {
          var i5, j2, k3, l1, m1, n1, ndim, nelem, o1, q1, ref2, ref3, ref4, ref5, ref6;
          i5 = 0;
          j2 = 0;
          k3 = 0;
          nelem = 0;
          ndim = 0;
          save();
          p1 = pop();
          if (!istensor(p1)) {
            push(p1);
            restore();
            return;
          }
          p2 = p1.tensor.elem[0];
          for (i5 = l1 = 1, ref2 = p1.tensor.nelem; 1 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 1 <= ref2 ? ++l1 : --l1) {
            if (!compatible(p2, p1.tensor.elem[i5])) {
              stop("Cannot promote tensor due to inconsistent tensor components.");
            }
          }
          if (!istensor(p2)) {
            push(p1);
            restore();
            return;
          }
          ndim = p1.tensor.ndim + p2.tensor.ndim;
          if (ndim > MAXDIM) {
            stop("tensor rank > " + MAXDIM);
          }
          nelem = p1.tensor.nelem * p2.tensor.nelem;
          p3 = alloc_tensor(nelem);
          p3.tensor.ndim = ndim;
          for (i5 = m1 = 0, ref3 = p1.tensor.ndim; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i5 = 0 <= ref3 ? ++m1 : --m1) {
            p3.tensor.dim[i5] = p1.tensor.dim[i5];
          }
          for (j2 = n1 = 0, ref4 = p2.tensor.ndim; 0 <= ref4 ? n1 < ref4 : n1 > ref4; j2 = 0 <= ref4 ? ++n1 : --n1) {
            p3.tensor.dim[i5 + j2] = p2.tensor.dim[j2];
          }
          k3 = 0;
          for (i5 = o1 = 0, ref5 = p1.tensor.nelem; 0 <= ref5 ? o1 < ref5 : o1 > ref5; i5 = 0 <= ref5 ? ++o1 : --o1) {
            p2 = p1.tensor.elem[i5];
            for (j2 = q1 = 0, ref6 = p2.tensor.nelem; 0 <= ref6 ? q1 < ref6 : q1 > ref6; j2 = 0 <= ref6 ? ++q1 : --q1) {
              p3.tensor.elem[k3++] = p2.tensor.elem[j2];
            }
          }
          check_tensor_dimensions(p2);
          check_tensor_dimensions(p3);
          push(p3);
          return restore();
        };
        compatible = function(p11, q) {
          var i5, l1, ref2;
          if (!istensor(p11) && !istensor(q)) {
            return 1;
          }
          if (!istensor(p11) || !istensor(q)) {
            return 0;
          }
          if (p11.tensor.ndim !== q.tensor.ndim) {
            return 0;
          }
          for (i5 = l1 = 0, ref2 = p11.tensor.ndim; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            if (p11.tensor.dim[i5] !== q.tensor.dim[i5]) {
              return 0;
            }
          }
          return 1;
        };
        Eval_test = function() {
          var checkResult, orig;
          orig = p1;
          p1 = cdr(p1);
          while (iscons(p1)) {
            if (cdr(p1) === symbol(NIL)) {
              push(car(p1));
              Eval();
              return;
            }
            checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(p1));
            if (checkResult == null) {
              push(orig);
              return;
            } else if (checkResult) {
              push(cadr(p1));
              Eval();
              return;
            } else {
              p1 = cddr(p1);
            }
          }
          return push_integer(0);
        };
        Eval_testeq = function() {
          var checkResult, orig, subtractionResult;
          orig = p1;
          push(cadr(p1));
          Eval();
          push(caddr(p1));
          Eval();
          subtract();
          subtractionResult = pop();
          checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(subtractionResult);
          if (checkResult) {
            push_integer(0);
            return;
          } else if (checkResult != null && !checkResult) {
            push_integer(1);
            return;
          }
          push(cadr(p1));
          Eval();
          simplify();
          push(caddr(p1));
          Eval();
          simplify();
          subtract();
          subtractionResult = pop();
          checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(subtractionResult);
          if (checkResult) {
            push_integer(0);
            return;
          } else if (checkResult != null && !checkResult) {
            push_integer(1);
            return;
          }
          return push(orig);
        };
        Eval_testge = function() {
          var comparison, orig;
          orig = p1;
          comparison = cmp_args();
          if (comparison == null) {
            push(orig);
            return;
          }
          if (comparison >= 0) {
            return push_integer(1);
          } else {
            return push_integer(0);
          }
        };
        Eval_testgt = function() {
          var comparison, orig;
          orig = p1;
          comparison = cmp_args();
          if (comparison == null) {
            push(orig);
            return;
          }
          if (comparison > 0) {
            return push_integer(1);
          } else {
            return push_integer(0);
          }
        };
        Eval_testle = function() {
          var comparison, orig;
          orig = p1;
          comparison = cmp_args();
          if (comparison == null) {
            push(orig);
            return;
          }
          if (comparison <= 0) {
            return push_integer(1);
          } else {
            return push_integer(0);
          }
        };
        Eval_testlt = function() {
          var comparison, orig;
          orig = p1;
          comparison = cmp_args();
          if (comparison == null) {
            push(orig);
            return;
          }
          if (comparison < 0) {
            return push_integer(1);
          } else {
            return push_integer(0);
          }
        };
        Eval_not = function() {
          var checkResult, wholeAndExpression;
          wholeAndExpression = p1;
          checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(cadr(p1));
          if (checkResult == null) {
            return push(wholeAndExpression);
          } else if (checkResult) {
            return push_integer(0);
          } else {
            return push_integer(1);
          }
        };
        Eval_and = function() {
          var andPredicates, checkResult, somePredicateUnknown, wholeAndExpression;
          wholeAndExpression = p1;
          andPredicates = cdr(wholeAndExpression);
          somePredicateUnknown = false;
          while (iscons(andPredicates)) {
            checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(andPredicates));
            if (checkResult == null) {
              somePredicateUnknown = true;
              andPredicates = cdr(andPredicates);
            } else if (checkResult) {
              andPredicates = cdr(andPredicates);
            } else if (!checkResult) {
              push_integer(0);
              return;
            }
          }
          if (somePredicateUnknown) {
            return push(wholeAndExpression);
          } else {
            return push_integer(1);
          }
        };
        Eval_or = function() {
          var checkResult, orPredicates, somePredicateUnknown, wholeOrExpression;
          wholeOrExpression = p1;
          orPredicates = cdr(wholeOrExpression);
          somePredicateUnknown = false;
          while (iscons(orPredicates)) {
            checkResult = isZeroLikeOrNonZeroLikeOrUndetermined(car(orPredicates));
            if (checkResult == null) {
              somePredicateUnknown = true;
              orPredicates = cdr(orPredicates);
            } else if (checkResult) {
              push_integer(1);
              return;
            } else if (!checkResult) {
              orPredicates = cdr(orPredicates);
            }
          }
          if (somePredicateUnknown) {
            return push(wholeOrExpression);
          } else {
            return push_integer(0);
          }
        };
        cmp_args = function() {
          var t5;
          t5 = 0;
          push(cadr(p1));
          Eval();
          simplify();
          push(caddr(p1));
          Eval();
          simplify();
          subtract();
          p1 = pop();
          if (p1.k !== NUM && p1.k !== DOUBLE) {
            push(p1);
            yyfloat();
            Eval();
            p1 = pop();
          }
          if (isZeroAtomOrTensor(p1)) {
            return 0;
          }
          switch (p1.k) {
            case NUM:
              if (MSIGN(p1.q.a) === -1) {
                t5 = -1;
              } else {
                t5 = 1;
              }
              break;
            case DOUBLE:
              if (p1.d < 0) {
                t5 = -1;
              } else {
                t5 = 1;
              }
              break;
            default:
              t5 = null;
          }
          return t5;
        };
        transform = function(s8, generalTransform) {
          var bookmarkTosToPrintDecomps, eachTransformEntry, i5, l1, len, len1, m1, n1, numberOfDecomps, ref2, restTerm, secondTerm, success, theTransform, transform_h, transformationSuccessful, transformedTerms;
          transform_h = 0;
          save();
          p1 = null;
          p4 = pop();
          p3 = pop();
          if (DEBUG) {
            console.log("         !!!!!!!!!   transform on: " + p3);
          }
          saveMetaBindings();
          set_binding(symbol(METAX), p4);
          transform_h = tos;
          push_integer(1);
          push(p3);
          push(p4);
          polyform();
          push(p4);
          bookmarkTosToPrintDecomps = tos - 2;
          decomp(generalTransform);
          numberOfDecomps = tos - bookmarkTosToPrintDecomps;
          if (DEBUG) {
            console.log("  " + numberOfDecomps + " decomposed elements ====== ");
            for (i5 = l1 = 0, ref2 = numberOfDecomps; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
              console.log("  decomposition element " + i5 + ": " + stack[tos - 1 - i5]);
            }
          }
          transformationSuccessful = false;
          if (generalTransform) {
            if (!isNumericAtom(p3)) {
              theTransform = s8;
              if (DEBUG) {
                console.log("applying transform: " + theTransform);
              }
              if (DEBUG) {
                console.log("scanning table entry " + theTransform);
              }
              push(theTransform);
              push(symbol(SYMBOL_A_UNDERSCORE));
              push(symbol(METAA));
              subst();
              push(symbol(SYMBOL_B_UNDERSCORE));
              push(symbol(METAB));
              subst();
              push(symbol(SYMBOL_X_UNDERSCORE));
              push(symbol(METAX));
              subst();
              p1 = pop();
              p5 = car(p1);
              if (DEBUG) {
                console.log("template expression: " + p5);
              }
              p6 = cadr(p1);
              p7 = cddr(p1);
              if (f_equals_a(transform_h, generalTransform)) {
                transformationSuccessful = true;
              } else {
                if (DEBUG) {
                  console.log("p3 at this point: " + p3);
                }
                transformedTerms = [];
                if (DEBUG) {
                  console.log("car(p3): " + car(p3));
                }
                restTerm = p3;
                if (iscons(restTerm)) {
                  transformedTerms.push(car(p3));
                  restTerm = cdr(p3);
                }
                while (iscons(restTerm)) {
                  secondTerm = car(restTerm);
                  restTerm = cdr(restTerm);
                  if (DEBUG) {
                    console.log("tos before recursive transform: " + tos);
                  }
                  push(secondTerm);
                  push_symbol(NIL);
                  if (DEBUG) {
                    console.log("testing: " + secondTerm);
                  }
                  if (DEBUG) {
                    console.log("about to try to simplify other term: " + secondTerm);
                  }
                  success = transform(s8, generalTransform);
                  transformationSuccessful = transformationSuccessful || success;
                  transformedTerms.push(pop());
                  if (DEBUG) {
                    console.log("tried to simplify other term: " + secondTerm + " ...successful?: " + success + " ...transformed: " + transformedTerms[transformedTerms.length - 1]);
                  }
                }
                if (transformedTerms.length !== 0) {
                  for (m1 = 0, len = transformedTerms.length; m1 < len; m1++) {
                    i5 = transformedTerms[m1];
                    push(i5);
                  }
                  list(transformedTerms.length);
                  p6 = pop();
                }
              }
            }
          } else {
            for (n1 = 0, len1 = s8.length; n1 < len1; n1++) {
              eachTransformEntry = s8[n1];
              if (DEBUG) {
                console.log("scanning table entry " + eachTransformEntry);
                if ((eachTransformEntry + "").indexOf("f(sqrt(a+b*x),2/3*1/b*sqrt((a+b*x)^3))") !== -1) {
                  debugger;
                }
              }
              if (eachTransformEntry) {
                scan_meta(eachTransformEntry);
                p1 = pop();
                p5 = cadr(p1);
                p6 = caddr(p1);
                p7 = cdddr(p1);
                if (f_equals_a(transform_h, generalTransform)) {
                  transformationSuccessful = true;
                  break;
                }
              }
            }
          }
          moveTos(transform_h);
          if (transformationSuccessful) {
            push(p6);
            Eval();
            p1 = pop();
            transformationSuccessful = true;
          } else {
            if (generalTransform) {
              p1 = p3;
            } else {
              p1 = symbol(NIL);
            }
          }
          restoreMetaBindings();
          push(p1);
          restore();
          return transformationSuccessful;
        };
        saveMetaBindings = function() {
          push(get_binding(symbol(METAA)));
          push(get_binding(symbol(METAB)));
          return push(get_binding(symbol(METAX)));
        };
        restoreMetaBindings = function() {
          set_binding(symbol(METAX), pop());
          set_binding(symbol(METAB), pop());
          return set_binding(symbol(METAA), pop());
        };
        f_equals_a = function(h5, generalTransform) {
          var fea_i, fea_j, l1, m1, originalexpanding, ref2, ref3, ref4, ref5;
          fea_i = 0;
          fea_j = 0;
          for (fea_i = l1 = ref2 = h5, ref3 = tos; ref2 <= ref3 ? l1 < ref3 : l1 > ref3; fea_i = ref2 <= ref3 ? ++l1 : --l1) {
            set_binding(symbol(METAA), stack[fea_i]);
            if (DEBUG) {
              console.log("  binding METAA to " + get_binding(symbol(METAA)));
            }
            for (fea_j = m1 = ref4 = h5, ref5 = tos; ref4 <= ref5 ? m1 < ref5 : m1 > ref5; fea_j = ref4 <= ref5 ? ++m1 : --m1) {
              set_binding(symbol(METAB), stack[fea_j]);
              if (DEBUG) {
                console.log("  binding METAB to " + get_binding(symbol(METAB)));
              }
              p1 = p7;
              while (iscons(p1)) {
                push(car(p1));
                Eval();
                p2 = pop();
                if (isZeroAtomOrTensor(p2)) {
                  break;
                }
                p1 = cdr(p1);
              }
              if (iscons(p1)) {
                continue;
              }
              push(p3);
              if (DEBUG) {
                console.log("about to evaluate template expression: " + p5 + " binding METAA to " + get_binding(symbol(METAA)) + " and binding METAB to " + get_binding(symbol(METAB)) + " and binding METAX to " + get_binding(symbol(METAX)));
              }
              push(p5);
              if (generalTransform) {
                originalexpanding = expanding;
                expanding = false;
              }
              Eval();
              if (generalTransform) {
                expanding = originalexpanding;
              }
              if (DEBUG) {
                console.log("  comparing " + stack[tos - 1] + " to: " + stack[tos - 2]);
              }
              subtract();
              p1 = pop();
              if (isZeroAtomOrTensor(p1)) {
                if (DEBUG) {
                  console.log("binding METAA to " + get_binding(symbol(METAA)));
                  console.log("binding METAB to " + get_binding(symbol(METAB)));
                  console.log("binding METAX to " + get_binding(symbol(METAX)));
                  console.log("comparing " + p3 + " to: " + p5);
                }
                return 1;
              }
            }
          }
          return 0;
        };
        Eval_transpose = function() {
          push(cadr(p1));
          Eval();
          if (cddr(p1) === symbol(NIL)) {
            push_integer(1);
            push_integer(2);
          } else {
            push(caddr(p1));
            Eval();
            push(cadddr(p1));
            Eval();
          }
          return transpose();
        };
        transpose = function() {
          var a5, accumulator, ai, an, b2, eachEntry, i5, innerTranspSwitch1, innerTranspSwitch2, j2, k3, l8, l1, m3, m1, n1, ndim, nelem, o1, q1, r1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, s1, t5;
          i5 = 0;
          j2 = 0;
          k3 = 0;
          l8 = 0;
          m3 = 0;
          ndim = 0;
          nelem = 0;
          t5 = 0;
          ai = [];
          an = [];
          for (i5 = l1 = 0, ref2 = MAXDIM; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            ai[i5] = 0;
            an[i5] = 0;
          }
          save();
          p3 = pop();
          p2 = pop();
          p1 = pop();
          if (isNumericAtom(p1)) {
            push(p1);
            restore();
            return;
          }
          if (isplusone(p2) && isplustwo(p3) || isplusone(p3) && isplustwo(p2)) {
            if (isidentitymatrix(p1)) {
              push(p1);
              restore();
              return;
            }
          }
          if (istranspose(p1)) {
            innerTranspSwitch1 = car(cdr(cdr(p1)));
            innerTranspSwitch2 = car(cdr(cdr(cdr(p1))));
            if (equal(innerTranspSwitch1, p3) && equal(innerTranspSwitch2, p2) || equal(innerTranspSwitch2, p3) && equal(innerTranspSwitch1, p2) || equal(innerTranspSwitch1, symbol(NIL)) && equal(innerTranspSwitch2, symbol(NIL)) && (isplusone(p3) && isplustwo(p2) || isplusone(p2) && isplustwo(p3))) {
              push(car(cdr(p1)));
              restore();
              return;
            }
          }
          if (expanding && isadd(p1)) {
            p1 = cdr(p1);
            push(zero);
            while (iscons(p1)) {
              push(car(p1));
              push(p2);
              push(p3);
              transpose();
              add();
              p1 = cdr(p1);
            }
            restore();
            return;
          }
          if (expanding && ismultiply(p1)) {
            p1 = cdr(p1);
            push(one);
            while (iscons(p1)) {
              push(car(p1));
              push(p2);
              push(p3);
              transpose();
              multiply();
              p1 = cdr(p1);
            }
            restore();
            return;
          }
          if (expanding && isinnerordot(p1)) {
            p1 = cdr(p1);
            accumulator = [];
            while (iscons(p1)) {
              accumulator.push([car(p1), p2, p3]);
              p1 = cdr(p1);
            }
            for (eachEntry = m1 = ref3 = accumulator.length - 1; ref3 <= 0 ? m1 <= 0 : m1 >= 0; eachEntry = ref3 <= 0 ? ++m1 : --m1) {
              push(accumulator[eachEntry][0]);
              push(accumulator[eachEntry][1]);
              push(accumulator[eachEntry][2]);
              transpose();
              if (eachEntry !== accumulator.length - 1) {
                inner();
              }
            }
            restore();
            return;
          }
          if (!istensor(p1)) {
            if (!isZeroAtomOrTensor(p1)) {
              push_symbol(TRANSPOSE);
              push(p1);
              if ((!isplusone(p2) || !isplustwo(p3)) && (!isplusone(p3) || !isplustwo(p2))) {
                push(p2);
                push(p3);
                list(4);
              } else {
                list(2);
              }
              restore();
              return;
            }
            push(zero);
            restore();
            return;
          }
          ndim = p1.tensor.ndim;
          nelem = p1.tensor.nelem;
          if (ndim === 1) {
            push(p1);
            restore();
            return;
          }
          push(p2);
          l8 = pop_integer();
          push(p3);
          m3 = pop_integer();
          if (l8 < 1 || l8 > ndim || m3 < 1 || m3 > ndim) {
            stop("transpose: index out of range");
          }
          l8--;
          m3--;
          p2 = alloc_tensor(nelem);
          p2.tensor.ndim = ndim;
          for (i5 = n1 = 0, ref4 = ndim; 0 <= ref4 ? n1 < ref4 : n1 > ref4; i5 = 0 <= ref4 ? ++n1 : --n1) {
            p2.tensor.dim[i5] = p1.tensor.dim[i5];
          }
          p2.tensor.dim[l8] = p1.tensor.dim[m3];
          p2.tensor.dim[m3] = p1.tensor.dim[l8];
          a5 = p1.tensor.elem;
          b2 = p2.tensor.elem;
          for (i5 = o1 = 0, ref5 = ndim; 0 <= ref5 ? o1 < ref5 : o1 > ref5; i5 = 0 <= ref5 ? ++o1 : --o1) {
            ai[i5] = 0;
            an[i5] = p1.tensor.dim[i5];
          }
          for (i5 = q1 = 0, ref6 = nelem; 0 <= ref6 ? q1 < ref6 : q1 > ref6; i5 = 0 <= ref6 ? ++q1 : --q1) {
            t5 = ai[l8];
            ai[l8] = ai[m3];
            ai[m3] = t5;
            t5 = an[l8];
            an[l8] = an[m3];
            an[m3] = t5;
            k3 = 0;
            for (j2 = r1 = 0, ref7 = ndim; 0 <= ref7 ? r1 < ref7 : r1 > ref7; j2 = 0 <= ref7 ? ++r1 : --r1) {
              k3 = k3 * an[j2] + ai[j2];
            }
            t5 = ai[l8];
            ai[l8] = ai[m3];
            ai[m3] = t5;
            t5 = an[l8];
            an[l8] = an[m3];
            an[m3] = t5;
            b2[k3] = a5[i5];
            for (j2 = s1 = ref8 = ndim - 1; ref8 <= 0 ? s1 <= 0 : s1 >= 0; j2 = ref8 <= 0 ? ++s1 : --s1) {
              if (++ai[j2] < an[j2]) {
                break;
              }
              ai[j2] = 0;
            }
          }
          push(p2);
          return restore();
        };
        Eval_user_function = function() {
          var bodyAndFormalArguments, h5;
          if (DEBUG) {
            console.log("Eval_user_function evaluating: " + car(p1));
          }
          if (car(p1) === symbol(SYMBOL_D) && get_binding(symbol(SYMBOL_D)) === symbol(SYMBOL_D)) {
            Eval_derivative();
            return;
          }
          push(car(p1));
          Eval();
          bodyAndFormalArguments = pop();
          if (isNumericAtom(bodyAndFormalArguments)) {
            stop("expected function invocation, found multiplication instead. Use '*' symbol explicitly for multiplication.");
          } else if (istensor(bodyAndFormalArguments)) {
            stop("expected function invocation, found tensor product instead. Use 'dot/inner' explicitly.");
          } else if (isstr(bodyAndFormalArguments)) {
            stop("expected function, found string instead.");
          }
          p3 = car(cdr(bodyAndFormalArguments));
          p4 = car(cdr(cdr(bodyAndFormalArguments)));
          p5 = cdr(p1);
          if (car(bodyAndFormalArguments) !== symbol(FUNCTION) || bodyAndFormalArguments === car(p1)) {
            h5 = tos;
            push(bodyAndFormalArguments);
            p1 = p5;
            while (iscons(p1)) {
              push(car(p1));
              Eval();
              p1 = cdr(p1);
            }
            list(tos - h5);
            return;
          }
          p1 = p4;
          p2 = p5;
          h5 = tos;
          while (iscons(p1) && iscons(p2)) {
            push(car(p1));
            push(car(p2));
            p1 = cdr(p1);
            p2 = cdr(p2);
          }
          list(tos - h5);
          p6 = pop();
          push(p3);
          if (iscons(p6)) {
            push(p6);
            rewrite_args();
          }
          return Eval();
        };
        rewrite_args = function() {
          var h5, n9;
          n9 = 0;
          save();
          p2 = pop();
          p1 = pop();
          if (istensor(p1)) {
            n9 = rewrite_args_tensor();
            restore();
            return n9;
          }
          if (iscons(p1)) {
            h5 = tos;
            if (car(p1) === car(p2)) {
              push_symbol(EVAL);
              push(car(cdr(p2)));
              list(2);
            } else {
              push(car(p1));
            }
            p1 = cdr(p1);
            while (iscons(p1)) {
              push(car(p1));
              push(p2);
              n9 += rewrite_args();
              p1 = cdr(p1);
            }
            list(tos - h5);
            restore();
            return n9;
          }
          if (!issymbol(p1)) {
            push(p1);
            restore();
            return 0;
          }
          p3 = p2;
          while (iscons(p3)) {
            if (p1 === car(p3)) {
              push(cadr(p3));
              restore();
              return 1;
            }
            p3 = cddr(p3);
          }
          p3 = get_binding(p1);
          push(p3);
          if (p1 !== p3) {
            push(p2);
            n9 = rewrite_args();
            if (n9 === 0) {
              pop();
              push(p1);
            }
          }
          restore();
          return n9;
        };
        rewrite_args_tensor = function() {
          var i5, l1, n9, ref2;
          n9 = 0;
          i5 = 0;
          push(p1);
          copy_tensor();
          p1 = pop();
          for (i5 = l1 = 0, ref2 = p1.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            push(p1.tensor.elem[i5]);
            push(p2);
            n9 += rewrite_args();
            p1.tensor.elem[i5] = pop();
          }
          check_tensor_dimensions(p1);
          push(p1);
          return n9;
        };
        Eval_zero = function() {
          var i5, k3, l1, m3, m1, n9, ref2, ref3;
          i5 = 0;
          k3 = [];
          m3 = 0;
          n9 = 0;
          for (i5 = l1 = 0, ref2 = MAXDIM; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            k3[i5] = 0;
          }
          m3 = 1;
          n9 = 0;
          p2 = cdr(p1);
          while (iscons(p2)) {
            push(car(p2));
            Eval();
            i5 = pop_integer();
            if (i5 < 1 || isNaN(i5)) {
              push(zero);
              return;
            }
            m3 *= i5;
            k3[n9++] = i5;
            p2 = cdr(p2);
          }
          if (n9 === 0) {
            push(zero);
            return;
          }
          p1 = alloc_tensor(m3);
          p1.tensor.ndim = n9;
          for (i5 = m1 = 0, ref3 = n9; 0 <= ref3 ? m1 < ref3 : m1 > ref3; i5 = 0 <= ref3 ? ++m1 : --m1) {
            p1.tensor.dim[i5] = k3[i5];
          }
          return push(p1);
        };
        allocatedId = 0;
        alloc_tensor = function(nelem) {
          var i5, l1, p11, ref2;
          i5 = 0;
          p11 = new U();
          p11.k = TENSOR;
          p11.tensor = new tensor();
          p11.tensor.nelem = nelem;
          for (i5 = l1 = 0, ref2 = nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            p11.tensor.elem[i5] = zero;
          }
          p11.tensor.allocatedId = allocatedId;
          allocatedId++;
          check_tensor_dimensions(p11);
          return p11;
        };
        Find = function(p11, q) {
          var i5, l1, ref2;
          i5 = 0;
          if (equal(p11, q)) {
            return 1;
          }
          if (istensor(p11)) {
            for (i5 = l1 = 0, ref2 = p11.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
              if (Find(p11.tensor.elem[i5], q)) {
                return 1;
              }
            }
            return 0;
          }
          while (iscons(p11)) {
            if (Find(car(p11), q)) {
              return 1;
            }
            p11 = cdr(p11);
          }
          return 0;
        };
        findPossibleClockForm = function(p11) {
          var i5, l1, ref2;
          i5 = 0;
          if (isimaginaryunit(p11)) {
            return 0;
          }
          if (car(p11) === symbol(POWER) && !isinteger(caddr(p1))) {
            if (Find(cadr(p11), imaginaryunit)) {
              return 1;
            }
          }
          if (car(p11) === symbol(POWER) && equaln(cadr(p11), -1) && !isinteger(caddr(p1))) {
            return 1;
          }
          if (istensor(p11)) {
            for (i5 = l1 = 0, ref2 = p11.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
              if (findPossibleClockForm(p11.tensor.elem[i5])) {
                return 1;
              }
            }
            return 0;
          }
          while (iscons(p11)) {
            if (findPossibleClockForm(car(p11))) {
              return 1;
            }
            p11 = cdr(p11);
          }
          return 0;
        };
        findPossibleExponentialForm = function(p11) {
          var i5, l1, ref2;
          i5 = 0;
          if (car(p11) === symbol(POWER) && cadr(p11) === symbol(E)) {
            return Find(caddr(p11), imaginaryunit);
          }
          if (istensor(p11)) {
            for (i5 = l1 = 0, ref2 = p11.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
              if (findPossibleExponentialForm(p11.tensor.elem[i5])) {
                return 1;
              }
            }
            return 0;
          }
          while (iscons(p11)) {
            if (findPossibleExponentialForm(car(p11))) {
              return 1;
            }
            p11 = cdr(p11);
          }
          return 0;
        };
        $.Find = Find;
        init = function() {
          var i5, l1, ref2;
          i5 = 0;
          flag = 0;
          reset_after_error();
          chainOfUserSymbolsNotFunctionsBeingEvaluated = [];
          if (flag) {
            return;
          }
          flag = 1;
          for (i5 = l1 = 0, ref2 = NSYM; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            symtab[i5] = new U();
            symtab[i5].k = SYM;
            binding[i5] = symtab[i5];
            isSymbolReclaimable[i5] = false;
          }
          return defn();
        };
        defn_str = [
          'version="' + version + '"',
          "e=exp(1)",
          "i=sqrt(-1)",
          "autoexpand=1",
          "assumeRealVariables=1",
          "trange=[-pi,pi]",
          "xrange=[-10,10]",
          "yrange=[-10,10]",
          "last=0",
          "trace=0",
          "forceFixedPrintout=1",
          "maxFixedPrintoutDigits=6",
          "printLeaveEAlone=1",
          "printLeaveXAlone=0",
          // cross definition
          "cross(u,v)=[u[2]*v[3]-u[3]*v[2],u[3]*v[1]-u[1]*v[3],u[1]*v[2]-u[2]*v[1]]",
          // curl definition
          "curl(v)=[d(v[3],y)-d(v[2],z),d(v[1],z)-d(v[3],x),d(v[2],x)-d(v[1],y)]",
          // div definition
          "div(v)=d(v[1],x)+d(v[2],y)+d(v[3],z)",
          // Note that we use the mathematics / Javascript / Mathematica
          // convention that "log" is indeed the natural logarithm.
          // In engineering, biology, astronomy, "log" can stand instead
          // for the "common" logarithm i.e. base 10. Also note that Google
          // calculations use log for the common logarithm.
          "ln(x)=log(x)"
        ];
        defn = function() {
          var definitionOfInterest, defn_i, l1, originalCodeGen, ref2;
          p0 = symbol(NIL);
          p1 = symbol(NIL);
          p2 = symbol(NIL);
          p3 = symbol(NIL);
          p4 = symbol(NIL);
          p5 = symbol(NIL);
          p6 = symbol(NIL);
          p7 = symbol(NIL);
          p8 = symbol(NIL);
          p9 = symbol(NIL);
          std_symbol("abs", ABS);
          std_symbol("add", ADD);
          std_symbol("adj", ADJ);
          std_symbol("and", AND);
          std_symbol("approxratio", APPROXRATIO);
          std_symbol("arccos", ARCCOS);
          std_symbol("arccosh", ARCCOSH);
          std_symbol("arcsin", ARCSIN);
          std_symbol("arcsinh", ARCSINH);
          std_symbol("arctan", ARCTAN);
          std_symbol("arctanh", ARCTANH);
          std_symbol("arg", ARG);
          std_symbol("atomize", ATOMIZE);
          std_symbol("besselj", BESSELJ);
          std_symbol("bessely", BESSELY);
          std_symbol("binding", BINDING);
          std_symbol("binomial", BINOMIAL);
          std_symbol("ceiling", CEILING);
          std_symbol("check", CHECK);
          std_symbol("choose", CHOOSE);
          std_symbol("circexp", CIRCEXP);
          std_symbol("clear", CLEAR);
          std_symbol("clearall", CLEARALL);
          std_symbol("clearpatterns", CLEARPATTERNS);
          std_symbol("clock", CLOCK);
          std_symbol("coeff", COEFF);
          std_symbol("cofactor", COFACTOR);
          std_symbol("condense", CONDENSE);
          std_symbol("conj", CONJ);
          std_symbol("contract", CONTRACT);
          std_symbol("cos", COS);
          std_symbol("cosh", COSH);
          std_symbol("decomp", DECOMP);
          std_symbol("defint", DEFINT);
          std_symbol("deg", DEGREE);
          std_symbol("denominator", DENOMINATOR);
          std_symbol("det", DET);
          std_symbol("derivative", DERIVATIVE);
          std_symbol("dim", DIM);
          std_symbol("dirac", DIRAC);
          std_symbol("divisors", DIVISORS);
          std_symbol("do", DO);
          std_symbol("dot", DOT);
          std_symbol("draw", DRAW);
          std_symbol("dsolve", DSOLVE);
          std_symbol("erf", ERF);
          std_symbol("erfc", ERFC);
          std_symbol("eigen", EIGEN);
          std_symbol("eigenval", EIGENVAL);
          std_symbol("eigenvec", EIGENVEC);
          std_symbol("eval", EVAL);
          std_symbol("exp", EXP);
          std_symbol("expand", EXPAND);
          std_symbol("expcos", EXPCOS);
          std_symbol("expsin", EXPSIN);
          std_symbol("factor", FACTOR);
          std_symbol("factorial", FACTORIAL);
          std_symbol("factorpoly", FACTORPOLY);
          std_symbol("filter", FILTER);
          std_symbol("float", FLOATF);
          std_symbol("floor", FLOOR);
          std_symbol("for", FOR);
          std_symbol("function", FUNCTION);
          std_symbol("Gamma", GAMMA);
          std_symbol("gcd", GCD);
          std_symbol("hermite", HERMITE);
          std_symbol("hilbert", HILBERT);
          std_symbol("imag", IMAG);
          std_symbol("component", INDEX);
          std_symbol("inner", INNER);
          std_symbol("integral", INTEGRAL);
          std_symbol("inv", INV);
          std_symbol("invg", INVG);
          std_symbol("isinteger", ISINTEGER);
          std_symbol("isprime", ISPRIME);
          std_symbol("laguerre", LAGUERRE);
          std_symbol("lcm", LCM);
          std_symbol("leading", LEADING);
          std_symbol("legendre", LEGENDRE);
          std_symbol("log", LOG);
          std_symbol("lookup", LOOKUP);
          std_symbol("mod", MOD);
          std_symbol("multiply", MULTIPLY);
          std_symbol("not", NOT);
          std_symbol("nroots", NROOTS);
          std_symbol("number", NUMBER);
          std_symbol("numerator", NUMERATOR);
          std_symbol("operator", OPERATOR);
          std_symbol("or", OR);
          std_symbol("outer", OUTER);
          std_symbol("pattern", PATTERN);
          std_symbol("patternsinfo", PATTERNSINFO);
          std_symbol("polar", POLAR);
          std_symbol("power", POWER);
          std_symbol("prime", PRIME);
          std_symbol("print", PRINT);
          std_symbol("print2dascii", PRINT2DASCII);
          std_symbol("printcomputer", PRINTFULL);
          std_symbol("printlatex", PRINTLATEX);
          std_symbol("printlist", PRINTLIST);
          std_symbol("printhuman", PRINTPLAIN);
          std_symbol("printLeaveEAlone", PRINT_LEAVE_E_ALONE);
          std_symbol("printLeaveXAlone", PRINT_LEAVE_X_ALONE);
          std_symbol("product", PRODUCT);
          std_symbol("quote", QUOTE);
          std_symbol("quotient", QUOTIENT);
          std_symbol("rank", RANK);
          std_symbol("rationalize", RATIONALIZE);
          std_symbol("real", REAL);
          std_symbol("rect", YYRECT);
          std_symbol("roots", ROOTS);
          std_symbol("round", ROUND);
          std_symbol("equals", SETQ);
          std_symbol("sgn", SGN);
          std_symbol("silentpattern", SILENTPATTERN);
          std_symbol("simplify", SIMPLIFY);
          std_symbol("sin", SIN);
          std_symbol("sinh", SINH);
          std_symbol("shape", SHAPE);
          std_symbol("sqrt", SQRT);
          std_symbol("stop", STOP);
          std_symbol("subst", SUBST);
          std_symbol("sum", SUM);
          std_symbol("symbolsinfo", SYMBOLSINFO);
          std_symbol("tan", TAN);
          std_symbol("tanh", TANH);
          std_symbol("taylor", TAYLOR);
          std_symbol("test", TEST);
          std_symbol("testeq", TESTEQ);
          std_symbol("testge", TESTGE);
          std_symbol("testgt", TESTGT);
          std_symbol("testle", TESTLE);
          std_symbol("testlt", TESTLT);
          std_symbol("transpose", TRANSPOSE);
          std_symbol("unit", UNIT);
          std_symbol("zero", ZERO);
          std_symbol("nil", NIL);
          std_symbol("autoexpand", AUTOEXPAND);
          std_symbol("bake", BAKE);
          std_symbol("assumeRealVariables", ASSUME_REAL_VARIABLES);
          std_symbol("last", LAST);
          std_symbol("lastprint", LAST_PRINT);
          std_symbol("last2dasciiprint", LAST_2DASCII_PRINT);
          std_symbol("lastfullprint", LAST_FULL_PRINT);
          std_symbol("lastlatexprint", LAST_LATEX_PRINT);
          std_symbol("lastlistprint", LAST_LIST_PRINT);
          std_symbol("lastplainprint", LAST_PLAIN_PRINT);
          std_symbol("trace", TRACE);
          std_symbol("forceFixedPrintout", FORCE_FIXED_PRINTOUT);
          std_symbol("maxFixedPrintoutDigits", MAX_FIXED_PRINTOUT_DIGITS);
          std_symbol("~", YYE);
          std_symbol("$DRAWX", DRAWX);
          std_symbol("$METAA", METAA);
          std_symbol("$METAB", METAB);
          std_symbol("$METAX", METAX);
          std_symbol("$SECRETX", SECRETX);
          std_symbol("version", VERSION);
          std_symbol("pi", PI);
          std_symbol("a", SYMBOL_A);
          std_symbol("b", SYMBOL_B);
          std_symbol("c", SYMBOL_C);
          std_symbol("d", SYMBOL_D);
          std_symbol("i", SYMBOL_I);
          std_symbol("j", SYMBOL_J);
          std_symbol("n", SYMBOL_N);
          std_symbol("r", SYMBOL_R);
          std_symbol("s", SYMBOL_S);
          std_symbol("t", SYMBOL_T);
          std_symbol("x", SYMBOL_X);
          std_symbol("y", SYMBOL_Y);
          std_symbol("z", SYMBOL_Z);
          std_symbol("I", SYMBOL_IDENTITY_MATRIX);
          std_symbol("a_", SYMBOL_A_UNDERSCORE);
          std_symbol("b_", SYMBOL_B_UNDERSCORE);
          std_symbol("x_", SYMBOL_X_UNDERSCORE);
          std_symbol("$C1", C1);
          std_symbol("$C2", C2);
          std_symbol("$C3", C3);
          std_symbol("$C4", C4);
          std_symbol("$C5", C5);
          std_symbol("$C6", C6);
          defineSomeHandyConstants();
          originalCodeGen = codeGen;
          codeGen = false;
          for (defn_i = l1 = 0, ref2 = defn_str.length; 0 <= ref2 ? l1 < ref2 : l1 > ref2; defn_i = 0 <= ref2 ? ++l1 : --l1) {
            definitionOfInterest = defn_str[defn_i];
            scan(definitionOfInterest);
            if (DEBUG) {
              console.log("... evaling " + definitionOfInterest);
              console.log("top of stack:");
              console.log(print_list(stack[tos - 1]));
            }
            Eval();
            pop();
          }
          return codeGen = originalCodeGen;
        };
        defineSomeHandyConstants = function() {
          zero = new_integer(0);
          one = new_integer(1);
          push_double(1);
          one_as_double = pop();
          push_symbol(POWER);
          if (DEBUG) {
            console.log(print_list(stack[tos - 1]));
          }
          push_integer(-1);
          if (DEBUG) {
            console.log(print_list(stack[tos - 1]));
          }
          push_rational(1, 2);
          if (DEBUG) {
            console.log(print_list(stack[tos - 1]));
          }
          list(3);
          if (DEBUG) {
            console.log(print_list(stack[tos - 1]));
          }
          return imaginaryunit = pop();
        };
        mcmp = function(a5, b2) {
          return a5.compare(b2);
        };
        mcmpint = function(a5, n9) {
          var b2, t5;
          b2 = bigInt(n9);
          t5 = mcmp(a5, b2);
          return t5;
        };
        strcmp = function(str1, str2) {
          if (str1 === str2) {
            return 0;
          } else if (str1 > str2) {
            return 1;
          } else {
            return -1;
          }
        };
        doubleToReasonableString = function(d3) {
          var maxFixedPrintoutDigits, stringRepresentation;
          if (codeGen) {
            return "" + d3;
          }
          if (isZeroAtomOrTensor(get_binding(symbol(FORCE_FIXED_PRINTOUT)))) {
            stringRepresentation = "" + d3;
            if (printMode === PRINTMODE_LATEX) {
              if (/\d*\.\d*e.*/gm.test(stringRepresentation)) {
                stringRepresentation = stringRepresentation.replace(/e(.*)/gm, "\\mathrm{e}{$1}");
              } else {
                stringRepresentation = stringRepresentation.replace(/(\d+)e(.*)/gm, "$1.0\\mathrm{e}{$2}");
              }
            } else {
              if (/\d*\.\d*e.*/gm.test(stringRepresentation)) {
                stringRepresentation = stringRepresentation.replace(/e(.*)/gm, "*10^($1)");
              } else {
                stringRepresentation = stringRepresentation.replace(/(\d+)e(.*)/gm, "$1.0*10^($2)");
              }
            }
          } else {
            push(get_binding(symbol(MAX_FIXED_PRINTOUT_DIGITS)));
            maxFixedPrintoutDigits = pop_integer();
            stringRepresentation = "" + d3.toFixed(maxFixedPrintoutDigits);
            stringRepresentation = stringRepresentation.replace(/(\.\d*?[1-9])0+$/gm, "$1");
            stringRepresentation = stringRepresentation.replace(/\.0+$/gm, "");
            if (stringRepresentation.indexOf(".") === -1) {
              stringRepresentation += ".0";
            }
            if (parseFloat(stringRepresentation) !== d3) {
              stringRepresentation = d3.toFixed(maxFixedPrintoutDigits) + "...";
            }
          }
          return stringRepresentation;
        };
        clear_term = function() {
        };
        isspace = function(s8) {
          if (s8 == null) {
            return false;
          }
          return s8 === " " || s8 === "	" || s8 === "\n" || s8 === "\v" || s8 === "\f" || s8 === "\r";
        };
        isdigit = function(str) {
          if (str == null) {
            return false;
          }
          return /^\d+$/.test(str);
        };
        isalpha = function(str) {
          if (str == null) {
            return false;
          }
          return str.search(/[^A-Za-z]/) === -1;
        };
        isalphaOrUnderscore = function(str) {
          if (str == null) {
            return false;
          }
          return str.search(/[^A-Za-z_]/) === -1;
        };
        isunderscore = function(str) {
          if (str == null) {
            return false;
          }
          return str.search(/_/) === -1;
        };
        isalnumorunderscore = function(str) {
          if (str == null) {
            return false;
          }
          return isalphaOrUnderscore(str) || isdigit(str);
        };
        count = function(p11) {
          var n9;
          if (iscons(p11)) {
            n9 = 0;
            while (iscons(p11)) {
              n9 += count(car(p11)) + 1;
              p11 = cdr(p11);
            }
          } else {
            n9 = 1;
          }
          return n9;
        };
        countOccurrencesOfSymbol = function(needle, p11) {
          var n9;
          n9 = 0;
          if (iscons(p11)) {
            while (iscons(p11)) {
              n9 += countOccurrencesOfSymbol(needle, car(p11));
              p11 = cdr(p11);
            }
          } else {
            if (equal(needle, p11)) {
              n9 = 1;
            }
          }
          return n9;
        };
        countsize = function(p11) {
          var i5, l1, n9, ref2;
          n9 = 0;
          if (istensor(p11)) {
            for (i5 = l1 = 0, ref2 = p11.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
              n9 += p11.tensor.elem[i5];
            }
          } else if (iscons(p11)) {
            while (iscons(p11)) {
              n9 += count(car(p11)) + 1;
              p11 = cdr(p11);
            }
          } else {
            n9 = 1;
          }
          return n9;
        };
        stop = function(s8) {
          var message;
          errorMessage += "Stop: ";
          errorMessage += s8;
          message = errorMessage;
          errorMessage = "";
          moveTos(0);
          throw new Error(message);
        };
        findDependenciesInScript = function(stringToBeParsed, dontGenerateCode) {
          var allReturnedLatexStrings, allReturnedPlainStrings, bodyForReadableSummaryOfGeneratedCode, cyclesDescriptions, deQuotedDep, dependencyInfo, eachDependency, error, generatedBody, generatedCode, i5, indexOfEachReplacement, indexOfPartRemainingToBeParsed, inited2, key, l1, len, len1, len2, len3, len4, len5, len6, len7, m1, n9, n1, newUserSymbol, o1, origPrintMode, originalUserSymbol, parameters, q1, r1, readableSummaryOfGeneratedCode, recursedDependencies, ref2, replacementsFrom, replacementsTo, s1, scriptEvaluation, stringToBeRun, t13, testableString, timeStartFromAlgebra, toBePrinted, u1, userVariablesMentioned, value, variablesWithCycles;
          if (DEBUG) {
            console.log("stringToBeParsed: " + stringToBeParsed);
          }
          timeStartFromAlgebra = (/* @__PURE__ */ new Date()).getTime();
          inited2 = true;
          codeGen = true;
          symbolsDependencies = {};
          symbolsHavingReassignments = [];
          symbolsInExpressionsWithoutAssignments = [];
          patternHasBeenFound = false;
          indexOfPartRemainingToBeParsed = 0;
          allReturnedPlainStrings = "";
          allReturnedLatexStrings = "";
          n9 = 0;
          dependencyInfo = {
            affectsVariables: [],
            affectedBy: []
          };
          stringToBeRun = stringToBeParsed;
          while (1) {
            try {
              errorMessage = "";
              check_stack();
              if (DEBUG) {
                console.log("findDependenciesInScript: scanning");
              }
              n9 = scan(stringToBeParsed.substring(indexOfPartRemainingToBeParsed));
              if (DEBUG) {
                console.log("scanned");
              }
              pop();
              check_stack();
            } catch (error1) {
              error = error1;
              if (PRINTOUTRESULT) {
                console.log(error);
              }
              errorMessage = error + "";
              reset_after_error();
              break;
            }
            if (n9 === 0) {
              break;
            }
            indexOfPartRemainingToBeParsed += n9;
          }
          testableString = "";
          if (DEBUG) {
            console.log("all local dependencies ----------------");
          }
          testableString += "All local dependencies: ";
          for (key in symbolsDependencies) {
            value = symbolsDependencies[key];
            if (DEBUG) {
              console.log("variable " + key + " depends on: ");
            }
            dependencyInfo.affectsVariables.push(key);
            testableString += " variable " + key + " depends on: ";
            for (l1 = 0, len = value.length; l1 < len; l1++) {
              i5 = value[l1];
              if (DEBUG) {
                console.log("    " + i5);
              }
              if (i5[0] !== "'") {
                dependencyInfo.affectedBy.push(i5);
              }
              testableString += i5 + ", ";
            }
            testableString += "; ";
          }
          testableString += ". ";
          if (DEBUG) {
            console.log("Symbols with reassignments ----------------");
          }
          testableString += "Symbols with reassignments: ";
          for (m1 = 0, len1 = symbolsHavingReassignments.length; m1 < len1; m1++) {
            key = symbolsHavingReassignments[m1];
            if (dependencyInfo.affectedBy.indexOf(key) === -1) {
              dependencyInfo.affectedBy.push(key);
              testableString += key + ", ";
            }
          }
          testableString += ". ";
          if (DEBUG) {
            console.log("Symbols in expressions without assignments ----------------");
          }
          testableString += "Symbols in expressions without assignments: ";
          for (n1 = 0, len2 = symbolsInExpressionsWithoutAssignments.length; n1 < len2; n1++) {
            key = symbolsInExpressionsWithoutAssignments[n1];
            if (dependencyInfo.affectedBy.indexOf(key) === -1) {
              dependencyInfo.affectedBy.push(key);
              testableString += key + ", ";
            }
          }
          testableString += ". ";
          dependencyInfo.affectedBy.push("PATTERN_DEPENDENCY");
          if (patternHasBeenFound) {
            dependencyInfo.affectsVariables.push("PATTERN_DEPENDENCY");
            testableString += " - PATTERN_DEPENDENCY inserted - ";
          }
          if (DEBUG) {
            console.log("All dependencies recursively ----------------");
          }
          testableString += "All dependencies recursively: ";
          scriptEvaluation = ["", ""];
          generatedCode = "";
          readableSummaryOfGeneratedCode = "";
          if (errorMessage === "" && !dontGenerateCode) {
            try {
              allReturnedPlainStrings = "";
              allReturnedLatexStrings = "";
              scriptEvaluation = run(stringToBeParsed, true);
              allReturnedPlainStrings = "";
              allReturnedLatexStrings = "";
            } catch (error1) {
              error = error1;
              if (PRINTOUTRESULT) {
                console.log(error);
              }
              errorMessage = error + "";
              init();
            }
            if (errorMessage === "") {
              for (key in symbolsDependencies) {
                codeGen = true;
                if (DEBUG) {
                  console.log("  variable " + key + " is: " + get_binding(usr_symbol(key)).toString());
                }
                codeGen = false;
                if (DEBUG) {
                  console.log("  variable " + key + " depends on: ");
                }
                testableString += " variable " + key + " depends on: ";
                recursedDependencies = [];
                variablesWithCycles = [];
                cyclesDescriptions = [];
                recursiveDependencies(key, recursedDependencies, [], variablesWithCycles, [], cyclesDescriptions);
                for (o1 = 0, len3 = variablesWithCycles.length; o1 < len3; o1++) {
                  i5 = variablesWithCycles[o1];
                  if (DEBUG) {
                    console.log("    --> cycle through " + i5);
                  }
                }
                for (q1 = 0, len4 = recursedDependencies.length; q1 < len4; q1++) {
                  i5 = recursedDependencies[q1];
                  if (DEBUG) {
                    console.log("    " + i5);
                  }
                  testableString += i5 + ", ";
                }
                testableString += "; ";
                for (r1 = 0, len5 = cyclesDescriptions.length; r1 < len5; r1++) {
                  i5 = cyclesDescriptions[r1];
                  testableString += " " + i5 + ", ";
                }
                if (DEBUG) {
                  console.log("  code generation:" + key + " is: " + get_binding(usr_symbol(key)).toString());
                }
                push(get_binding(usr_symbol(key)));
                replacementsFrom = [];
                replacementsTo = [];
                for (s1 = 0, len6 = recursedDependencies.length; s1 < len6; s1++) {
                  eachDependency = recursedDependencies[s1];
                  if (eachDependency[0] === "'") {
                    deQuotedDep = eachDependency.substring(1);
                    originalUserSymbol = usr_symbol(deQuotedDep);
                    newUserSymbol = usr_symbol("AVOID_BINDING_TO_EXTERNAL_SCOPE_VALUE" + deQuotedDep);
                    replacementsFrom.push(originalUserSymbol);
                    replacementsTo.push(newUserSymbol);
                    push(originalUserSymbol);
                    push(newUserSymbol);
                    subst();
                    if (DEBUG) {
                      console.log("after substitution: " + stack[tos - 1]);
                    }
                  }
                }
                try {
                  simplifyForCodeGeneration();
                } catch (error1) {
                  error = error1;
                  if (PRINTOUTRESULT) {
                    console.log(error);
                  }
                  errorMessage = error + "";
                  init();
                }
                for (indexOfEachReplacement = t13 = 0, ref2 = replacementsFrom.length; 0 <= ref2 ? t13 < ref2 : t13 > ref2; indexOfEachReplacement = 0 <= ref2 ? ++t13 : --t13) {
                  push(replacementsTo[indexOfEachReplacement]);
                  push(replacementsFrom[indexOfEachReplacement]);
                  subst();
                }
                clearRenamedVariablesToAvoidBindingToExternalScope();
                if (errorMessage === "") {
                  toBePrinted = pop();
                  userVariablesMentioned = [];
                  collectUserSymbols(toBePrinted, userVariablesMentioned);
                  allReturnedPlainStrings = "";
                  allReturnedLatexStrings = "";
                  codeGen = true;
                  generatedBody = toBePrinted.toString();
                  codeGen = false;
                  origPrintMode = printMode;
                  printMode = PRINTMODE_LATEX;
                  bodyForReadableSummaryOfGeneratedCode = toBePrinted.toString();
                  printMode = origPrintMode;
                  if (variablesWithCycles.indexOf(key) !== -1) {
                    generatedCode += "// " + key + " is part of a cyclic dependency, no code generated.";
                    readableSummaryOfGeneratedCode += "#" + key + " is part of a cyclic dependency, no code generated.";
                  } else {
                    userVariablesMentioned = userVariablesMentioned.filter(function(x3) {
                      return predefinedSymbolsInGlobalScope_doNotTrackInDependencies.indexOf(x3 + "") === -1;
                    });
                    userVariablesMentioned = userVariablesMentioned.filter(function(x3) {
                      return recursedDependencies.indexOf(x3 + "") !== -1 || recursedDependencies.indexOf("'" + x3) !== -1;
                    });
                    if (userVariablesMentioned.length !== 0) {
                      parameters = "(";
                      for (u1 = 0, len7 = userVariablesMentioned.length; u1 < len7; u1++) {
                        i5 = userVariablesMentioned[u1];
                        if (i5.printname !== key) {
                          parameters += i5.printname + ", ";
                        }
                      }
                      parameters = parameters.replace(/, $/gm, "");
                      parameters += ")";
                      generatedCode += key + " = function " + parameters + " { return ( " + generatedBody + " ); }";
                      readableSummaryOfGeneratedCode += key + parameters + " = " + bodyForReadableSummaryOfGeneratedCode;
                    } else {
                      generatedCode += key + " = " + generatedBody + ";";
                      readableSummaryOfGeneratedCode += key + " = " + bodyForReadableSummaryOfGeneratedCode;
                    }
                  }
                  generatedCode += "\n";
                  readableSummaryOfGeneratedCode += "\n";
                  if (DEBUG) {
                    console.log("    " + generatedCode);
                  }
                }
              }
            }
          }
          generatedCode = generatedCode.replace(/\n$/gm, "");
          readableSummaryOfGeneratedCode = readableSummaryOfGeneratedCode.replace(/\n$/gm, "");
          symbolsDependencies = {};
          symbolsHavingReassignments = [];
          patternHasBeenFound = false;
          symbolsInExpressionsWithoutAssignments = [];
          if (DEBUG) {
            console.log("testable string: " + testableString);
          }
          if (TIMING_DEBUGS) {
            console.log("findDependenciesInScript time for: " + stringToBeRun + " : " + ((/* @__PURE__ */ new Date()).getTime() - timeStartFromAlgebra) + "ms");
          }
          return [testableString, scriptEvaluation[0], generatedCode, readableSummaryOfGeneratedCode, scriptEvaluation[1], errorMessage, dependencyInfo];
        };
        recursiveDependencies = function(variableToBeChecked, arrayWhereDependenciesWillBeAdded, variablesAlreadyFleshedOut, variablesWithCycles, chainBeingChecked, cyclesDescriptions) {
          var cyclesDescription, i5, k3, l1, len, len1, m1, ref2;
          variablesAlreadyFleshedOut.push(variableToBeChecked);
          if (symbolsDependencies[chainBeingChecked[chainBeingChecked.length - 1]] != null) {
            if (symbolsDependencies[chainBeingChecked[chainBeingChecked.length - 1]].indexOf("'" + variableToBeChecked) !== -1) {
              if (DEBUG) {
                console.log("can't keep following the chain of " + variableToBeChecked + " because it's actually a variable bound to a parameter");
              }
              if (arrayWhereDependenciesWillBeAdded.indexOf("'" + variableToBeChecked) === -1 && arrayWhereDependenciesWillBeAdded.indexOf(variableToBeChecked) === -1) {
                arrayWhereDependenciesWillBeAdded.push(variableToBeChecked);
              }
              return arrayWhereDependenciesWillBeAdded;
            }
          }
          chainBeingChecked.push(variableToBeChecked);
          if (symbolsDependencies[variableToBeChecked] == null) {
            if (arrayWhereDependenciesWillBeAdded.indexOf(variableToBeChecked) === -1) {
              arrayWhereDependenciesWillBeAdded.push(variableToBeChecked);
            }
            return arrayWhereDependenciesWillBeAdded;
          } else {
            ref2 = symbolsDependencies[variableToBeChecked];
            for (l1 = 0, len = ref2.length; l1 < len; l1++) {
              i5 = ref2[l1];
              if (chainBeingChecked.indexOf(i5) !== -1) {
                if (DEBUG) {
                  console.log("  found cycle:");
                }
                cyclesDescription = "";
                for (m1 = 0, len1 = chainBeingChecked.length; m1 < len1; m1++) {
                  k3 = chainBeingChecked[m1];
                  if (variablesWithCycles.indexOf(k3) === -1) {
                    variablesWithCycles.push(k3);
                  }
                  if (DEBUG) {
                    console.log(k3 + " --> ");
                  }
                  cyclesDescription += k3 + " --> ";
                }
                if (DEBUG) {
                  console.log(" ... then " + i5 + " again");
                }
                cyclesDescription += " ... then " + i5 + " again";
                cyclesDescriptions.push(cyclesDescription);
                if (variablesWithCycles.indexOf(i5) === -1) {
                  variablesWithCycles.push(i5);
                }
              } else {
                recursiveDependencies(i5, arrayWhereDependenciesWillBeAdded, variablesAlreadyFleshedOut, variablesWithCycles, chainBeingChecked, cyclesDescriptions);
                chainBeingChecked.pop();
              }
            }
            return arrayWhereDependenciesWillBeAdded;
          }
        };
        inited = false;
        latexErrorSign = "\\rlap{\\large\\color{red}\\bigtriangleup}{\\ \\ \\tiny\\color{red}!}";
        turnErrorMessageToLatex = function(theErrorMessage) {
          theErrorMessage = theErrorMessage.replace(/\n/g, "");
          theErrorMessage = theErrorMessage.replace(/_/g, "} \\_ \\text{");
          theErrorMessage = theErrorMessage.replace(new RegExp(String.fromCharCode(transpose_unicode), "g"), "}{}^{T}\\text{");
          theErrorMessage = theErrorMessage.replace(new RegExp(String.fromCharCode(dotprod_unicode), "g"), "}\\cdot \\text{");
          theErrorMessage = theErrorMessage.replace("Stop:", "}  \\quad \\text{Stop:");
          theErrorMessage = theErrorMessage.replace("->", "}  \\rightarrow \\text{");
          theErrorMessage = theErrorMessage.replace("?", "}\\enspace " + latexErrorSign + " \\enspace  \\text{");
          theErrorMessage = "$$\\text{" + theErrorMessage.replace(/\n/g, "") + "}$$";
          return theErrorMessage;
        };
        normaliseDots = function(stringToNormalise) {
          stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(8901), "g"), String.fromCharCode(dotprod_unicode));
          stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(8226), "g"), String.fromCharCode(dotprod_unicode));
          stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(12539), "g"), String.fromCharCode(dotprod_unicode));
          stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(55296), "g"), String.fromCharCode(dotprod_unicode));
          stringToNormalise = stringToNormalise.replace(new RegExp(String.fromCharCode(65381), "g"), String.fromCharCode(dotprod_unicode));
          return stringToNormalise;
        };
        TIMING_DEBUGS = false;
        run = function(stringToBeRun, generateLatex = false) {
          var allReturnedLatexStrings, allReturnedPlainStrings, collectedLatexResult, collectedPlainResult, error, errorWhileExecution, i5, indexOfPartRemainingToBeParsed, n9, stringToBeReturned, theErrorMessage, timeStart, timingDebugWrite;
          timeStart = (/* @__PURE__ */ new Date()).getTime();
          stringToBeRun = normaliseDots(stringToBeRun);
          if (stringToBeRun === "selftest") {
            selftest();
            return;
          }
          if (!inited) {
            inited = true;
            init();
          }
          i5 = 0;
          n9 = 0;
          indexOfPartRemainingToBeParsed = 0;
          allReturnedPlainStrings = "";
          allReturnedLatexStrings = "";
          while (1) {
            try {
              errorMessage = "";
              check_stack();
              n9 = scan(stringToBeRun.substring(indexOfPartRemainingToBeParsed));
              p1 = pop();
              check_stack();
            } catch (error1) {
              error = error1;
              if (PRINTOUTRESULT) {
                console.log(error);
              }
              allReturnedPlainStrings += error.message;
              if (generateLatex) {
                theErrorMessage = turnErrorMessageToLatex(error.message);
                allReturnedLatexStrings += theErrorMessage;
              }
              reset_after_error();
              break;
            }
            if (n9 === 0) {
              break;
            }
            indexOfPartRemainingToBeParsed += n9;
            push(p1);
            errorWhileExecution = false;
            try {
              stringsEmittedByUserPrintouts = "";
              top_level_eval();
              p2 = pop();
              check_stack();
              if (isstr(p2)) {
                if (DEBUG) {
                  console.log(p2.str);
                }
                if (DEBUG) {
                  console.log("\n");
                }
              }
              if (p2 === symbol(NIL)) {
                collectedPlainResult = stringsEmittedByUserPrintouts;
                if (generateLatex) {
                  collectedLatexResult = "$$" + stringsEmittedByUserPrintouts + "$$";
                }
              } else {
                collectedPlainResult = print_expr(p2);
                collectedPlainResult += "\n";
                if (generateLatex) {
                  collectedLatexResult = "$$" + collectLatexStringFromReturnValue(p2) + "$$";
                  if (DEBUG) {
                    console.log("collectedLatexResult: " + collectedLatexResult);
                  }
                }
              }
              allReturnedPlainStrings += collectedPlainResult;
              if (generateLatex) {
                allReturnedLatexStrings += collectedLatexResult;
              }
              if (PRINTOUTRESULT) {
                if (DEBUG) {
                  console.log("printline");
                }
                if (DEBUG) {
                  console.log(collectedPlainResult);
                }
              }
              if (PRINTOUTRESULT) {
                if (DEBUG) {
                  console.log("display:");
                }
                print2dascii(p2);
              }
              if (generateLatex) {
                allReturnedLatexStrings += "\n";
              }
            } catch (error1) {
              error = error1;
              errorWhileExecution = true;
              collectedPlainResult = error.message;
              if (generateLatex) {
                collectedLatexResult = turnErrorMessageToLatex(error.message);
              }
              if (PRINTOUTRESULT) {
                console.log(collectedPlainResult);
              }
              allReturnedPlainStrings += collectedPlainResult;
              if (collectedPlainResult !== "") {
                allReturnedPlainStrings += "\n";
              }
              if (generateLatex) {
                allReturnedLatexStrings += collectedLatexResult;
                allReturnedLatexStrings += "\n";
              }
              init();
            }
          }
          if (allReturnedPlainStrings[allReturnedPlainStrings.length - 1] === "\n") {
            allReturnedPlainStrings = allReturnedPlainStrings.substring(0, allReturnedPlainStrings.length - 1);
          }
          if (generateLatex) {
            if (allReturnedLatexStrings[allReturnedLatexStrings.length - 1] === "\n") {
              allReturnedLatexStrings = allReturnedLatexStrings.substring(0, allReturnedLatexStrings.length - 1);
            }
          }
          if (generateLatex) {
            if (DEBUG) {
              console.log("allReturnedLatexStrings: " + allReturnedLatexStrings);
            }
            stringToBeReturned = [allReturnedPlainStrings, allReturnedLatexStrings];
          } else {
            stringToBeReturned = allReturnedPlainStrings;
          }
          if (TIMING_DEBUGS) {
            timingDebugWrite = "run time on: " + stringToBeRun + " : " + ((/* @__PURE__ */ new Date()).getTime() - timeStart) + "ms";
            console.log(timingDebugWrite);
          }
          allReturnedPlainStrings = "";
          allReturnedLatexStrings = "";
          return stringToBeReturned;
        };
        check_stack = function() {
          if (tos !== 0) {
            debugger;
            stop("stack error");
          }
          if (frame !== TOS) {
            debugger;
            stop("frame error");
          }
          if (chainOfUserSymbolsNotFunctionsBeingEvaluated.length !== 0) {
            debugger;
            stop("symbols evaluation still ongoing?");
          }
          if (evaluatingAsFloats !== 0) {
            debugger;
            stop("numeric evaluation still ongoing?");
          }
          if (evaluatingPolar !== 0) {
            debugger;
            return stop("evaluation of polar still ongoing?");
          }
        };
        top_level_eval = function() {
          var evalledArgument, originalArgument, shouldAutoexpand;
          if (DEBUG) {
            console.log("#### top level eval");
          }
          trigmode = 0;
          shouldAutoexpand = symbol(AUTOEXPAND);
          if (isZeroAtomOrTensor(get_binding(shouldAutoexpand))) {
            expanding = 0;
          } else {
            expanding = 1;
          }
          originalArgument = top();
          Eval();
          evalledArgument = top();
          if (evalledArgument === symbol(NIL)) {
            return;
          }
          set_binding(symbol(LAST), evalledArgument);
          if (!isZeroAtomOrTensor(get_binding(symbol(BAKE)))) {
            bake();
            evalledArgument = top();
          }
          if ((originalArgument === symbol(SYMBOL_I) || originalArgument === symbol(SYMBOL_J)) && isimaginaryunit(evalledArgument)) {
          } else if (isimaginaryunit(get_binding(symbol(SYMBOL_J)))) {
            push(imaginaryunit);
            push_symbol(SYMBOL_J);
            return subst();
          } else if (isimaginaryunit(get_binding(symbol(SYMBOL_I)))) {
            push(imaginaryunit);
            push_symbol(SYMBOL_I);
            return subst();
          }
        };
        check_esc_flag = function() {
          if (esc_flag) {
            return stop("esc key");
          }
        };
        clearAlgebraEnvironment = function() {
          return do_clearall();
        };
        computeDependenciesFromAlgebra = function(codeFromAlgebraBlock) {
          var i5, keepState, l1, len, len1, m1, originalcodeFromAlgebraBlock, userSimplificationsInProgramForm;
          if (DEBUG) {
            console.log("computeDependenciesFromAlgebra!!!");
          }
          originalcodeFromAlgebraBlock = codeFromAlgebraBlock;
          keepState = true;
          called_from_Algebra_block = true;
          codeFromAlgebraBlock = normaliseDots(codeFromAlgebraBlock);
          if (!keepState) {
            userSimplificationsInListForm = [];
            userSimplificationsInProgramForm = "";
            for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {
              i5 = userSimplificationsInListForm[l1];
              userSimplificationsInProgramForm += "silentpattern(" + car(i5) + "," + car(cdr(i5)) + "," + car(cdr(cdr(i5))) + ")\n";
            }
            do_clearall();
            codeFromAlgebraBlock = userSimplificationsInProgramForm + codeFromAlgebraBlock;
            if (DEBUG) {
              console.log("codeFromAlgebraBlock including patterns: " + codeFromAlgebraBlock);
            }
          }
          if (DEBUG) {
            console.log("computeDependenciesFromAlgebra: patterns in the list --------------- ");
            for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {
              i5 = userSimplificationsInListForm[m1];
              console.log(car(i5) + "," + cdr(i5) + ")");
            }
            console.log("...end of list --------------- ");
          }
          called_from_Algebra_block = false;
          return findDependenciesInScript(codeFromAlgebraBlock, true)[6];
        };
        computeResultsAndJavaScriptFromAlgebra = function(codeFromAlgebraBlock) {
          var code3, dependencyInfo, i5, keepState, l1, latexResult, len, len1, m1, originalcodeFromAlgebraBlock, readableSummaryOfCode, result, stringToBeRun, testableStringIsIgnoredHere, timeStartFromAlgebra, userSimplificationsInProgramForm;
          originalcodeFromAlgebraBlock = codeFromAlgebraBlock;
          keepState = true;
          called_from_Algebra_block = true;
          timeStartFromAlgebra = (/* @__PURE__ */ new Date()).getTime();
          if (TIMING_DEBUGS) {
            console.log(" --------- computeResultsAndJavaScriptFromAlgebra input: " + codeFromAlgebraBlock + " at: " + /* @__PURE__ */ new Date());
          }
          codeFromAlgebraBlock = normaliseDots(codeFromAlgebraBlock);
          stringToBeRun = codeFromAlgebraBlock;
          if (DEBUG) {
            console.log("computeResultsAndJavaScriptFromAlgebra: patterns in the list --------------- ");
            for (l1 = 0, len = userSimplificationsInListForm.length; l1 < len; l1++) {
              i5 = userSimplificationsInListForm[l1];
              console.log(car(i5) + "," + cdr(i5) + ")");
            }
            console.log("...end of list --------------- ");
          }
          if (!keepState) {
            userSimplificationsInListForm = [];
            userSimplificationsInProgramForm = "";
            for (m1 = 0, len1 = userSimplificationsInListForm.length; m1 < len1; m1++) {
              i5 = userSimplificationsInListForm[m1];
              userSimplificationsInProgramForm += "silentpattern(" + car(i5) + "," + car(cdr(i5)) + "," + car(cdr(cdr(i5))) + ")\n";
            }
            do_clearall();
            codeFromAlgebraBlock = userSimplificationsInProgramForm + codeFromAlgebraBlock;
            if (DEBUG) {
              console.log("codeFromAlgebraBlock including patterns: " + codeFromAlgebraBlock);
            }
          }
          [testableStringIsIgnoredHere, result, code3, readableSummaryOfCode, latexResult, errorMessage, dependencyInfo] = findDependenciesInScript(codeFromAlgebraBlock);
          called_from_Algebra_block = false;
          if (readableSummaryOfCode !== "" || errorMessage !== "") {
            result += "\n" + readableSummaryOfCode;
            if (errorMessage !== "") {
              result += "\n" + errorMessage;
            }
            result = result.replace(/\n/g, "\n\n");
            latexResult += "\n$$" + readableSummaryOfCode + "$$";
            if (errorMessage !== "") {
              latexResult += turnErrorMessageToLatex(errorMessage);
            }
            latexResult = latexResult.replace(/\n/g, "\n\n");
          }
          latexResult = latexResult.replace(/\n*/, "");
          latexResult = latexResult.replace(/\$\$\$\$\n*/g, "");
          code3 = code3.replace(/Math\./g, "");
          code3 = code3.replace(/\n/g, "\n\n");
          if (TIMING_DEBUGS) {
            console.log("computeResultsAndJavaScriptFromAlgebra time (total time from notebook and back) for: " + stringToBeRun + " : " + ((/* @__PURE__ */ new Date()).getTime() - timeStartFromAlgebra) + "ms");
          }
          return {
            //code: "// no code generated yet\n//try again later"
            //code: "console.log('some passed code is run'); window.something = 1;"
            code: code3,
            // TODO temporarily pass latex in place of standard result too
            result: latexResult,
            latexResult,
            dependencyInfo
          };
        };
        (typeof exports !== "undefined" && exports !== null ? exports : this).run = run;
        (typeof exports !== "undefined" && exports !== null ? exports : this).findDependenciesInScript = findDependenciesInScript;
        (typeof exports !== "undefined" && exports !== null ? exports : this).computeDependenciesFromAlgebra = computeDependenciesFromAlgebra;
        (typeof exports !== "undefined" && exports !== null ? exports : this).computeResultsAndJavaScriptFromAlgebra = computeResultsAndJavaScriptFromAlgebra;
        (typeof exports !== "undefined" && exports !== null ? exports : this).clearAlgebraEnvironment = clearAlgebraEnvironment;
        tos = 0;
        nil_symbols = 0;
        push = function(p11) {
          if (p11 == null) {
            debugger;
          }
          if (p11.isZero != null) {
            debugger;
          }
          if (p11 === symbol(NIL)) {
            nil_symbols++;
            if (DEBUG) {
              console.log("pushing symbol(NIL) #" + nil_symbols);
            }
          }
          if (tos >= frame) {
            stop("stack overflow");
          }
          return stack[tos++] = p11;
        };
        moveTos = function(stackPos) {
          if (tos <= stackPos) {
            tos = stackPos;
            return;
          }
          while (tos > stackPos) {
            stack[tos] = null;
            tos--;
          }
        };
        top = function() {
          return stack[tos - 1];
        };
        pop = function() {
          var elementToBeReturned;
          if (tos === 0) {
            debugger;
            stop("stack underflow");
          }
          if (stack[tos - 1] == null) {
            debugger;
          }
          elementToBeReturned = stack[--tos];
          stack[tos] = null;
          return elementToBeReturned;
        };
        push_frame = function(n9) {
          var i5, l1, ref2, results;
          i5 = 0;
          frame -= n9;
          if (frame < tos) {
            debugger;
            stop("frame overflow, circular reference?");
          }
          results = [];
          for (i5 = l1 = 0, ref2 = n9; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            results.push(stack[frame + i5] = symbol(NIL));
          }
          return results;
        };
        pop_frame = function(n9) {
          frame += n9;
          if (frame > TOS) {
            return stop("frame underflow");
          }
        };
        save = function() {
          frame -= 10;
          if (frame < tos) {
            debugger;
            stop("frame overflow, circular reference?");
          }
          stack[frame + 0] = p0;
          stack[frame + 1] = p1;
          stack[frame + 2] = p2;
          stack[frame + 3] = p3;
          stack[frame + 4] = p4;
          stack[frame + 5] = p5;
          stack[frame + 6] = p6;
          stack[frame + 7] = p7;
          stack[frame + 8] = p8;
          return stack[frame + 9] = p9;
        };
        restore = function() {
          if (frame > TOS - 10) {
            stop("frame underflow");
          }
          p0 = stack[frame + 0];
          p1 = stack[frame + 1];
          p2 = stack[frame + 2];
          p3 = stack[frame + 3];
          p4 = stack[frame + 4];
          p5 = stack[frame + 5];
          p6 = stack[frame + 6];
          p7 = stack[frame + 7];
          p8 = stack[frame + 8];
          p9 = stack[frame + 9];
          return frame += 10;
        };
        swap = function() {
          var p11, q;
          p11 = pop();
          q = pop();
          push(p11);
          return push(q);
        };
        dupl = function() {
          var p11;
          p11 = pop();
          push(p11);
          return push(p11);
        };
        $.dupl = dupl;
        $.swap = swap;
        $.restore = restore;
        $.save = save;
        $.push = push;
        $.pop = pop;
        Eval_symbolsinfo = function() {
          var symbolsinfoToBePrinted;
          symbolsinfoToBePrinted = symbolsinfo();
          if (symbolsinfoToBePrinted !== "") {
            return push(new_string(symbolsinfoToBePrinted));
          } else {
            return push_symbol(NIL);
          }
        };
        symbolsinfo = function() {
          var bindingi, i5, l1, ref2, ref3, symbolsinfoToBePrinted, symtabi;
          symbolsinfoToBePrinted = "";
          for (i5 = l1 = ref2 = NIL + 1, ref3 = symtab.length; ref2 <= ref3 ? l1 < ref3 : l1 > ref3; i5 = ref2 <= ref3 ? ++l1 : --l1) {
            if (symtab[i5].printname === "") {
              if (isSymbolReclaimable[i5] === false) {
                break;
              } else {
                continue;
              }
            }
            symtabi = symtab[i5] + "";
            bindingi = (binding[i5] + "").substring(0, 4);
            symbolsinfoToBePrinted += "symbol: " + symtabi + " size: " + countsize(binding[i5]) + " value: " + bindingi + "...\n";
          }
          return symbolsinfoToBePrinted;
        };
        std_symbol = function(s8, n9, latexPrint) {
          var p11;
          p11 = symtab[n9];
          if (p11 == null) {
            debugger;
          }
          p11.printname = s8;
          if (latexPrint != null) {
            return p11.latexPrint = latexPrint;
          } else {
            return p11.latexPrint = s8;
          }
        };
        usr_symbol = function(s8) {
          var i5, l1, ref2;
          i5 = 0;
          for (i5 = l1 = 0, ref2 = NSYM; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            if (s8 === symtab[i5].printname) {
              return symtab[i5];
            }
            if (symtab[i5].printname === "") {
              break;
            }
          }
          if (i5 === NSYM) {
            stop("symbol table overflow");
          }
          symtab[i5] = new U();
          symtab[i5].k = SYM;
          symtab[i5].printname = s8;
          binding[i5] = symtab[i5];
          isSymbolReclaimable[i5] = false;
          return symtab[i5];
        };
        get_printname = function(p11) {
          if (p11.k !== SYM) {
            stop("symbol error");
          }
          return p11.printname;
        };
        set_binding = function(p11, q) {
          var indexFound;
          if (p11.k !== SYM) {
            stop("symbol error");
          }
          indexFound = symtab.indexOf(p11);
          if (symtab.indexOf(p11, indexFound + 1) !== -1) {
            console.log("ops, more than one element!");
            debugger;
          }
          if (DEBUG) {
            console.log("lookup >> set_binding lookup " + indexFound);
          }
          isSymbolReclaimable[indexFound] = false;
          return binding[indexFound] = q;
        };
        get_binding = function(p11) {
          var indexFound;
          if (p11.k !== SYM) {
            stop("symbol error");
          }
          indexFound = symtab.indexOf(p11);
          if (symtab.indexOf(p11, indexFound + 1) !== -1) {
            console.log("ops, more than one element!");
            debugger;
          }
          if (DEBUG) {
            console.log("lookup >> get_binding lookup " + indexFound);
          }
          return binding[indexFound];
        };
        is_usr_symbol = function(p11) {
          var theSymnum;
          if (p11.k !== SYM) {
            return false;
          }
          theSymnum = symnum(p11);
          if (theSymnum > PI && theSymnum !== SYMBOL_I && theSymnum !== SYMBOL_IDENTITY_MATRIX) {
            return true;
          }
          return false;
        };
        lookupsTotal = 0;
        symnum = function(p11) {
          var indexFound;
          lookupsTotal++;
          if (p11.k !== SYM) {
            stop("symbol error");
          }
          indexFound = symtab.indexOf(p11);
          if (symtab.indexOf(p11, indexFound + 1) !== -1) {
            console.log("ops, more than one element!");
            debugger;
          }
          if (DEBUG) {
            console.log("lookup >> symnum lookup " + indexFound + " lookup # " + lookupsTotal);
          }
          return indexFound;
        };
        push_symbol = function(k3) {
          return push(symtab[k3]);
        };
        clear_symbols = function() {
          var i5, l1, ref2, ref3, results;
          results = [];
          for (i5 = l1 = ref2 = NIL + 1, ref3 = NSYM; ref2 <= ref3 ? l1 < ref3 : l1 > ref3; i5 = ref2 <= ref3 ? ++l1 : --l1) {
            if (symtab[i5].printname === "") {
              if (isSymbolReclaimable[i5] === false) {
                break;
              } else {
                continue;
              }
            }
            symtab[i5] = new U();
            symtab[i5].k = SYM;
            binding[i5] = symtab[i5];
            results.push(isSymbolReclaimable[i5] = false);
          }
          return results;
        };
        collectUserSymbols = function(p11, accumulator = []) {
          var i5, l1, ref2;
          if (is_usr_symbol(p11)) {
            if (accumulator.indexOf(p11) === -1) {
              accumulator.push(p11);
              return;
            }
          }
          if (istensor(p11)) {
            for (i5 = l1 = 0, ref2 = p11.tensor.nelem; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
              collectUserSymbols(p11.tensor.elem[i5], accumulator);
            }
            return;
          }
          while (iscons(p11)) {
            collectUserSymbols(car(p11), accumulator);
            p11 = cdr(p11);
          }
        };
        $.get_binding = get_binding;
        $.set_binding = set_binding;
        $.usr_symbol = usr_symbol;
        $.symbolsinfo = symbolsinfo;
        $.collectUserSymbols = collectUserSymbols;
        if (!inited) {
          inited = true;
          init();
        }
        $.init = init;
        parse_internal = function(argu) {
          if (typeof argu === "string") {
            return scan(argu);
          } else if (typeof argu === "number") {
            if (argu % 1 === 0) {
              return push_integer(argu);
            } else {
              return push_double(argu);
            }
          } else if (argu instanceof U) {
            return push(argu);
          } else {
            console.warn("unknown argument type", argu);
            return push(symbol(NIL));
          }
        };
        parse = function(argu) {
          var data, error;
          try {
            parse_internal(argu);
            data = pop();
            check_stack();
          } catch (error1) {
            error = error1;
            reset_after_error();
            throw error;
          }
          return data;
        };
        exec = function(name, ...argus) {
          var argu, error, fn, l1, len, result;
          fn = get_binding(usr_symbol(name));
          check_stack();
          push(fn);
          for (l1 = 0, len = argus.length; l1 < len; l1++) {
            argu = argus[l1];
            parse_internal(argu);
          }
          list(1 + argus.length);
          p1 = pop();
          push(p1);
          try {
            top_level_eval();
            result = pop();
            check_stack();
          } catch (error1) {
            error = error1;
            reset_after_error();
            throw error;
          }
          return result;
        };
        $.exec = exec;
        $.parse = parse;
        (function() {
          var builtin_fns, fn, l1, len, results;
          builtin_fns = ["abs", "add", "adj", "and", "approxratio", "arccos", "arccosh", "arcsin", "arcsinh", "arctan", "arctanh", "arg", "atomize", "besselj", "bessely", "binding", "binomial", "ceiling", "check", "choose", "circexp", "clear", "clearall", "clearpatterns", "clock", "coeff", "cofactor", "condense", "conj", "contract", "cos", "cosh", "decomp", "defint", "deg", "denominator", "det", "derivative", "dim", "dirac", "divisors", "do", "dot", "draw", "dsolve", "eigen", "eigenval", "eigenvec", "erf", "erfc", "eval", "exp", "expand", "expcos", "expsin", "factor", "factorial", "factorpoly", "filter", "float", "floor", "for", "Gamma", "gcd", "hermite", "hilbert", "imag", "component", "inner", "integral", "inv", "invg", "isinteger", "isprime", "laguerre", "lcm", "leading", "legendre", "log", "mod", "multiply", "not", "nroots", "number", "numerator", "operator", "or", "outer", "pattern", "patternsinfo", "polar", "power", "prime", "print", "print2dascii", "printcomputer", "printlatex", "printlist", "printhuman", "product", "quote", "quotient", "rank", "rationalize", "real", "rect", "roots", "round", "equals", "shape", "sgn", "silentpattern", "simplify", "sin", "sinh", "sqrt", "stop", "subst", "sum", "symbolsinfo", "tan", "tanh", "taylor", "test", "testeq", "testge", "testgt", "testle", "testlt", "transpose", "unit", "zero"];
          results = [];
          for (l1 = 0, len = builtin_fns.length; l1 < len; l1++) {
            fn = builtin_fns[l1];
            results.push($[fn] = exec.bind(this, fn));
          }
          return results;
        })();
        freeze = function() {
          var frozenContents, frozenHash, frozenPatterns, frozenSymbols, i5, l1, ref2;
          frozenSymbols = [];
          frozenContents = [];
          frozenPatterns = [];
          frozenHash = "";
          for (i5 = l1 = 0, ref2 = symtab.length; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            if (isSymbolReclaimable[i5] === false) {
              frozenSymbols.push(symtab[i5]);
              frozenContents.push(binding[i5]);
            }
          }
          frozenPatterns = userSimplificationsInListForm.slice(0);
          return [frozenSymbols, frozenContents, frozenPatterns, zero, one, imaginaryunit, getStateHash()];
        };
        unfreeze = function(frozen) {
          var frozenContents, frozenPatterns, frozenSymbols, i5, l1, ref2;
          [frozenSymbols, frozenContents, frozenPatterns, zero, one, imaginaryunit] = frozen;
          for (i5 = l1 = 0, ref2 = frozenSymbols.length; 0 <= ref2 ? l1 < ref2 : l1 > ref2; i5 = 0 <= ref2 ? ++l1 : --l1) {
            symtab[i5] = frozenSymbols[i5];
            binding[i5] = frozenContents[i5];
          }
          return userSimplificationsInListForm = frozenPatterns.slice(0);
        };
        compareState = function(previousHash) {
          var frozenHash;
          frozenHash = getStateHash();
          if (frozenHash === previousHash) {
            return true;
          } else {
            return false;
          }
        };
        getStateHash = function() {
          var bindingi, frozenHash, i5, l1, len, m1, ref2, ref3, symtabi;
          frozenHash = "";
          for (i5 = l1 = ref2 = NIL + 1, ref3 = symtab.length; ref2 <= ref3 ? l1 < ref3 : l1 > ref3; i5 = ref2 <= ref3 ? ++l1 : --l1) {
            if (symtab[i5].printname === "") {
              if (isSymbolReclaimable[i5] === false) {
                break;
              } else {
                continue;
              }
            }
            symtabi = print_list(symtab[i5]);
            bindingi = print_list(binding[i5]);
            frozenHash += " //" + symtabi + " : " + bindingi;
          }
          for (m1 = 0, len = userSimplificationsInListForm.length; m1 < len; m1++) {
            i5 = userSimplificationsInListForm[m1];
            frozenHash += " pattern: " + i5;
          }
          if (DEBUG) {
            console.log("frozenHash: " + frozenHash);
          }
          return frozenHash;
        };
      }).call(exports);
    }
  });

  // ../../../../../node_modules/binary-search-bounds/search-bounds.js
  var require_search_bounds = __commonJS({
    "../../../../../node_modules/binary-search-bounds/search-bounds.js"(exports2, module2) {
      "use strict";
      function ge(a5, y3, c9, l8, h5) {
        var i5 = h5 + 1;
        while (l8 <= h5) {
          var m3 = l8 + h5 >>> 1, x3 = a5[m3];
          var p11 = c9 !== void 0 ? c9(x3, y3) : x3 - y3;
          if (p11 >= 0) {
            i5 = m3;
            h5 = m3 - 1;
          } else {
            l8 = m3 + 1;
          }
        }
        return i5;
      }
      function gt(a5, y3, c9, l8, h5) {
        var i5 = h5 + 1;
        while (l8 <= h5) {
          var m3 = l8 + h5 >>> 1, x3 = a5[m3];
          var p11 = c9 !== void 0 ? c9(x3, y3) : x3 - y3;
          if (p11 > 0) {
            i5 = m3;
            h5 = m3 - 1;
          } else {
            l8 = m3 + 1;
          }
        }
        return i5;
      }
      function lt(a5, y3, c9, l8, h5) {
        var i5 = l8 - 1;
        while (l8 <= h5) {
          var m3 = l8 + h5 >>> 1, x3 = a5[m3];
          var p11 = c9 !== void 0 ? c9(x3, y3) : x3 - y3;
          if (p11 < 0) {
            i5 = m3;
            l8 = m3 + 1;
          } else {
            h5 = m3 - 1;
          }
        }
        return i5;
      }
      function le(a5, y3, c9, l8, h5) {
        var i5 = l8 - 1;
        while (l8 <= h5) {
          var m3 = l8 + h5 >>> 1, x3 = a5[m3];
          var p11 = c9 !== void 0 ? c9(x3, y3) : x3 - y3;
          if (p11 <= 0) {
            i5 = m3;
            l8 = m3 + 1;
          } else {
            h5 = m3 - 1;
          }
        }
        return i5;
      }
      function eq(a5, y3, c9, l8, h5) {
        while (l8 <= h5) {
          var m3 = l8 + h5 >>> 1, x3 = a5[m3];
          var p11 = c9 !== void 0 ? c9(x3, y3) : x3 - y3;
          if (p11 === 0) {
            return m3;
          }
          if (p11 <= 0) {
            l8 = m3 + 1;
          } else {
            h5 = m3 - 1;
          }
        }
        return -1;
      }
      function norm(a5, y3, c9, l8, h5, f7) {
        if (typeof c9 === "function") {
          return f7(a5, y3, c9, l8 === void 0 ? 0 : l8 | 0, h5 === void 0 ? a5.length - 1 : h5 | 0);
        }
        return f7(a5, y3, void 0, c9 === void 0 ? 0 : c9 | 0, l8 === void 0 ? a5.length - 1 : l8 | 0);
      }
      module2.exports = {
        ge: function(a5, y3, c9, l8, h5) {
          return norm(a5, y3, c9, l8, h5, ge);
        },
        gt: function(a5, y3, c9, l8, h5) {
          return norm(a5, y3, c9, l8, h5, gt);
        },
        lt: function(a5, y3, c9, l8, h5) {
          return norm(a5, y3, c9, l8, h5, lt);
        },
        le: function(a5, y3, c9, l8, h5) {
          return norm(a5, y3, c9, l8, h5, le);
        },
        eq: function(a5, y3, c9, l8, h5) {
          return norm(a5, y3, c9, l8, h5, eq);
        }
      };
    }
  });

  // ../../../../../node_modules/interval-tree-1d/interval-tree.js
  var require_interval_tree = __commonJS({
    "../../../../../node_modules/interval-tree-1d/interval-tree.js"(exports2, module2) {
      "use strict";
      var bounds = require_search_bounds();
      var NOT_FOUND = 0;
      var SUCCESS = 1;
      var EMPTY = 2;
      module2.exports = createWrapper;
      function IntervalTreeNode(mid2, left2, right2, leftPoints, rightPoints) {
        this.mid = mid2;
        this.left = left2;
        this.right = right2;
        this.leftPoints = leftPoints;
        this.rightPoints = rightPoints;
        this.count = (left2 ? left2.count : 0) + (right2 ? right2.count : 0) + leftPoints.length;
      }
      var proto = IntervalTreeNode.prototype;
      function copy3(a5, b2) {
        a5.mid = b2.mid;
        a5.left = b2.left;
        a5.right = b2.right;
        a5.leftPoints = b2.leftPoints;
        a5.rightPoints = b2.rightPoints;
        a5.count = b2.count;
      }
      function rebuild(node, intervals) {
        var ntree = createIntervalTree(intervals);
        node.mid = ntree.mid;
        node.left = ntree.left;
        node.right = ntree.right;
        node.leftPoints = ntree.leftPoints;
        node.rightPoints = ntree.rightPoints;
        node.count = ntree.count;
      }
      function rebuildWithInterval(node, interval2) {
        var intervals = node.intervals([]);
        intervals.push(interval2);
        rebuild(node, intervals);
      }
      function rebuildWithoutInterval(node, interval2) {
        var intervals = node.intervals([]);
        var idx = intervals.indexOf(interval2);
        if (idx < 0) {
          return NOT_FOUND;
        }
        intervals.splice(idx, 1);
        rebuild(node, intervals);
        return SUCCESS;
      }
      proto.intervals = function(result) {
        result.push.apply(result, this.leftPoints);
        if (this.left) {
          this.left.intervals(result);
        }
        if (this.right) {
          this.right.intervals(result);
        }
        return result;
      };
      proto.insert = function(interval2) {
        var weight = this.count - this.leftPoints.length;
        this.count += 1;
        if (interval2[1] < this.mid) {
          if (this.left) {
            if (4 * (this.left.count + 1) > 3 * (weight + 1)) {
              rebuildWithInterval(this, interval2);
            } else {
              this.left.insert(interval2);
            }
          } else {
            this.left = createIntervalTree([interval2]);
          }
        } else if (interval2[0] > this.mid) {
          if (this.right) {
            if (4 * (this.right.count + 1) > 3 * (weight + 1)) {
              rebuildWithInterval(this, interval2);
            } else {
              this.right.insert(interval2);
            }
          } else {
            this.right = createIntervalTree([interval2]);
          }
        } else {
          var l8 = bounds.ge(this.leftPoints, interval2, compareBegin);
          var r6 = bounds.ge(this.rightPoints, interval2, compareEnd);
          this.leftPoints.splice(l8, 0, interval2);
          this.rightPoints.splice(r6, 0, interval2);
        }
      };
      proto.remove = function(interval2) {
        var weight = this.count - this.leftPoints;
        if (interval2[1] < this.mid) {
          if (!this.left) {
            return NOT_FOUND;
          }
          var rw = this.right ? this.right.count : 0;
          if (4 * rw > 3 * (weight - 1)) {
            return rebuildWithoutInterval(this, interval2);
          }
          var r6 = this.left.remove(interval2);
          if (r6 === EMPTY) {
            this.left = null;
            this.count -= 1;
            return SUCCESS;
          } else if (r6 === SUCCESS) {
            this.count -= 1;
          }
          return r6;
        } else if (interval2[0] > this.mid) {
          if (!this.right) {
            return NOT_FOUND;
          }
          var lw = this.left ? this.left.count : 0;
          if (4 * lw > 3 * (weight - 1)) {
            return rebuildWithoutInterval(this, interval2);
          }
          var r6 = this.right.remove(interval2);
          if (r6 === EMPTY) {
            this.right = null;
            this.count -= 1;
            return SUCCESS;
          } else if (r6 === SUCCESS) {
            this.count -= 1;
          }
          return r6;
        } else {
          if (this.count === 1) {
            if (this.leftPoints[0] === interval2) {
              return EMPTY;
            } else {
              return NOT_FOUND;
            }
          }
          if (this.leftPoints.length === 1 && this.leftPoints[0] === interval2) {
            if (this.left && this.right) {
              var p11 = this;
              var n9 = this.left;
              while (n9.right) {
                p11 = n9;
                n9 = n9.right;
              }
              if (p11 === this) {
                n9.right = this.right;
              } else {
                var l8 = this.left;
                var r6 = this.right;
                p11.count -= n9.count;
                p11.right = n9.left;
                n9.left = l8;
                n9.right = r6;
              }
              copy3(this, n9);
              this.count = (this.left ? this.left.count : 0) + (this.right ? this.right.count : 0) + this.leftPoints.length;
            } else if (this.left) {
              copy3(this, this.left);
            } else {
              copy3(this, this.right);
            }
            return SUCCESS;
          }
          for (var l8 = bounds.ge(this.leftPoints, interval2, compareBegin); l8 < this.leftPoints.length; ++l8) {
            if (this.leftPoints[l8][0] !== interval2[0]) {
              break;
            }
            if (this.leftPoints[l8] === interval2) {
              this.count -= 1;
              this.leftPoints.splice(l8, 1);
              for (var r6 = bounds.ge(this.rightPoints, interval2, compareEnd); r6 < this.rightPoints.length; ++r6) {
                if (this.rightPoints[r6][1] !== interval2[1]) {
                  break;
                } else if (this.rightPoints[r6] === interval2) {
                  this.rightPoints.splice(r6, 1);
                  return SUCCESS;
                }
              }
            }
          }
          return NOT_FOUND;
        }
      };
      function reportLeftRange(arr, hi, cb) {
        for (var i5 = 0; i5 < arr.length && arr[i5][0] <= hi; ++i5) {
          var r6 = cb(arr[i5]);
          if (r6) {
            return r6;
          }
        }
      }
      function reportRightRange(arr, lo, cb) {
        for (var i5 = arr.length - 1; i5 >= 0 && arr[i5][1] >= lo; --i5) {
          var r6 = cb(arr[i5]);
          if (r6) {
            return r6;
          }
        }
      }
      function reportRange(arr, cb) {
        for (var i5 = 0; i5 < arr.length; ++i5) {
          var r6 = cb(arr[i5]);
          if (r6) {
            return r6;
          }
        }
      }
      proto.queryPoint = function(x3, cb) {
        if (x3 < this.mid) {
          if (this.left) {
            var r6 = this.left.queryPoint(x3, cb);
            if (r6) {
              return r6;
            }
          }
          return reportLeftRange(this.leftPoints, x3, cb);
        } else if (x3 > this.mid) {
          if (this.right) {
            var r6 = this.right.queryPoint(x3, cb);
            if (r6) {
              return r6;
            }
          }
          return reportRightRange(this.rightPoints, x3, cb);
        } else {
          return reportRange(this.leftPoints, cb);
        }
      };
      proto.queryInterval = function(lo, hi, cb) {
        if (lo < this.mid && this.left) {
          var r6 = this.left.queryInterval(lo, hi, cb);
          if (r6) {
            return r6;
          }
        }
        if (hi > this.mid && this.right) {
          var r6 = this.right.queryInterval(lo, hi, cb);
          if (r6) {
            return r6;
          }
        }
        if (hi < this.mid) {
          return reportLeftRange(this.leftPoints, hi, cb);
        } else if (lo > this.mid) {
          return reportRightRange(this.rightPoints, lo, cb);
        } else {
          return reportRange(this.leftPoints, cb);
        }
      };
      function compareNumbers(a5, b2) {
        return a5 - b2;
      }
      function compareBegin(a5, b2) {
        var d3 = a5[0] - b2[0];
        if (d3) {
          return d3;
        }
        return a5[1] - b2[1];
      }
      function compareEnd(a5, b2) {
        var d3 = a5[1] - b2[1];
        if (d3) {
          return d3;
        }
        return a5[0] - b2[0];
      }
      function createIntervalTree(intervals) {
        if (intervals.length === 0) {
          return null;
        }
        var pts = [];
        for (var i5 = 0; i5 < intervals.length; ++i5) {
          pts.push(intervals[i5][0], intervals[i5][1]);
        }
        pts.sort(compareNumbers);
        var mid2 = pts[pts.length >> 1];
        var leftIntervals = [];
        var rightIntervals = [];
        var centerIntervals = [];
        for (var i5 = 0; i5 < intervals.length; ++i5) {
          var s8 = intervals[i5];
          if (s8[1] < mid2) {
            leftIntervals.push(s8);
          } else if (mid2 < s8[0]) {
            rightIntervals.push(s8);
          } else {
            centerIntervals.push(s8);
          }
        }
        var leftPoints = centerIntervals;
        var rightPoints = centerIntervals.slice();
        leftPoints.sort(compareBegin);
        rightPoints.sort(compareEnd);
        return new IntervalTreeNode(
          mid2,
          createIntervalTree(leftIntervals),
          createIntervalTree(rightIntervals),
          leftPoints,
          rightPoints
        );
      }
      function IntervalTree2(root2) {
        this.root = root2;
      }
      var tproto = IntervalTree2.prototype;
      tproto.insert = function(interval2) {
        if (this.root) {
          this.root.insert(interval2);
        } else {
          this.root = new IntervalTreeNode(interval2[0], null, null, [interval2], [interval2]);
        }
      };
      tproto.remove = function(interval2) {
        if (this.root) {
          var r6 = this.root.remove(interval2);
          if (r6 === EMPTY) {
            this.root = null;
          }
          return r6 !== NOT_FOUND;
        }
        return false;
      };
      tproto.queryPoint = function(p11, cb) {
        if (this.root) {
          return this.root.queryPoint(p11, cb);
        }
      };
      tproto.queryInterval = function(lo, hi, cb) {
        if (lo <= hi && this.root) {
          return this.root.queryInterval(lo, hi, cb);
        }
      };
      Object.defineProperty(tproto, "count", {
        get: function() {
          if (this.root) {
            return this.root.count;
          }
          return 0;
        }
      });
      Object.defineProperty(tproto, "intervals", {
        get: function() {
          if (this.root) {
            return this.root.intervals([]);
          }
          return [];
        }
      });
      function createWrapper(intervals) {
        if (!intervals || intervals.length === 0) {
          return new IntervalTree2(null);
        }
        return new IntervalTree2(createIntervalTree(intervals));
      }
    }
  });

  // ../../../../../node_modules/@lit/reactive-element/css-tag.js
  var t = window;
  var e = t.ShadowRoot && (void 0 === t.ShadyCSS || t.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
  var s = Symbol();
  var n = /* @__PURE__ */ new WeakMap();
  var o2 = class {
    constructor(t5, e11, n9) {
      if (this._$cssResult$ = true, n9 !== s) throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
      this.cssText = t5, this.t = e11;
    }
    get styleSheet() {
      let t5 = this.o;
      const s8 = this.t;
      if (e && void 0 === t5) {
        const e11 = void 0 !== s8 && 1 === s8.length;
        e11 && (t5 = n.get(s8)), void 0 === t5 && ((this.o = t5 = new CSSStyleSheet()).replaceSync(this.cssText), e11 && n.set(s8, t5));
      }
      return t5;
    }
    toString() {
      return this.cssText;
    }
  };
  var r = (t5) => new o2("string" == typeof t5 ? t5 : t5 + "", void 0, s);
  var i = (t5, ...e11) => {
    const n9 = 1 === t5.length ? t5[0] : e11.reduce((e12, s8, n10) => e12 + ((t6) => {
      if (true === t6._$cssResult$) return t6.cssText;
      if ("number" == typeof t6) return t6;
      throw Error("Value passed to 'css' function must be a 'css' function result: " + t6 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
    })(s8) + t5[n10 + 1], t5[0]);
    return new o2(n9, t5, s);
  };
  var S = (s8, n9) => {
    e ? s8.adoptedStyleSheets = n9.map((t5) => t5 instanceof CSSStyleSheet ? t5 : t5.styleSheet) : n9.forEach((e11) => {
      const n10 = document.createElement("style"), o12 = t.litNonce;
      void 0 !== o12 && n10.setAttribute("nonce", o12), n10.textContent = e11.cssText, s8.appendChild(n10);
    });
  };
  var c = e ? (t5) => t5 : (t5) => t5 instanceof CSSStyleSheet ? ((t6) => {
    let e11 = "";
    for (const s8 of t6.cssRules) e11 += s8.cssText;
    return r(e11);
  })(t5) : t5;

  // ../../../../../node_modules/@lit/reactive-element/reactive-element.js
  var s2;
  var e2 = window;
  var r2 = e2.trustedTypes;
  var h = r2 ? r2.emptyScript : "";
  var o3 = e2.reactiveElementPolyfillSupport;
  var n2 = { toAttribute(t5, i5) {
    switch (i5) {
      case Boolean:
        t5 = t5 ? h : null;
        break;
      case Object:
      case Array:
        t5 = null == t5 ? t5 : JSON.stringify(t5);
    }
    return t5;
  }, fromAttribute(t5, i5) {
    let s8 = t5;
    switch (i5) {
      case Boolean:
        s8 = null !== t5;
        break;
      case Number:
        s8 = null === t5 ? null : Number(t5);
        break;
      case Object:
      case Array:
        try {
          s8 = JSON.parse(t5);
        } catch (t6) {
          s8 = null;
        }
    }
    return s8;
  } };
  var a = (t5, i5) => i5 !== t5 && (i5 == i5 || t5 == t5);
  var l = { attribute: true, type: String, converter: n2, reflect: false, hasChanged: a };
  var d = "finalized";
  var u = class extends HTMLElement {
    constructor() {
      super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$El = null, this._$Eu();
    }
    static addInitializer(t5) {
      var i5;
      this.finalize(), (null !== (i5 = this.h) && void 0 !== i5 ? i5 : this.h = []).push(t5);
    }
    static get observedAttributes() {
      this.finalize();
      const t5 = [];
      return this.elementProperties.forEach((i5, s8) => {
        const e11 = this._$Ep(s8, i5);
        void 0 !== e11 && (this._$Ev.set(e11, s8), t5.push(e11));
      }), t5;
    }
    static createProperty(t5, i5 = l) {
      if (i5.state && (i5.attribute = false), this.finalize(), this.elementProperties.set(t5, i5), !i5.noAccessor && !this.prototype.hasOwnProperty(t5)) {
        const s8 = "symbol" == typeof t5 ? Symbol() : "__" + t5, e11 = this.getPropertyDescriptor(t5, s8, i5);
        void 0 !== e11 && Object.defineProperty(this.prototype, t5, e11);
      }
    }
    static getPropertyDescriptor(t5, i5, s8) {
      return { get() {
        return this[i5];
      }, set(e11) {
        const r6 = this[t5];
        this[i5] = e11, this.requestUpdate(t5, r6, s8);
      }, configurable: true, enumerable: true };
    }
    static getPropertyOptions(t5) {
      return this.elementProperties.get(t5) || l;
    }
    static finalize() {
      if (this.hasOwnProperty(d)) return false;
      this[d] = true;
      const t5 = Object.getPrototypeOf(this);
      if (t5.finalize(), void 0 !== t5.h && (this.h = [...t5.h]), this.elementProperties = new Map(t5.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
        const t6 = this.properties, i5 = [...Object.getOwnPropertyNames(t6), ...Object.getOwnPropertySymbols(t6)];
        for (const s8 of i5) this.createProperty(s8, t6[s8]);
      }
      return this.elementStyles = this.finalizeStyles(this.styles), true;
    }
    static finalizeStyles(i5) {
      const s8 = [];
      if (Array.isArray(i5)) {
        const e11 = new Set(i5.flat(1 / 0).reverse());
        for (const i6 of e11) s8.unshift(c(i6));
      } else void 0 !== i5 && s8.push(c(i5));
      return s8;
    }
    static _$Ep(t5, i5) {
      const s8 = i5.attribute;
      return false === s8 ? void 0 : "string" == typeof s8 ? s8 : "string" == typeof t5 ? t5.toLowerCase() : void 0;
    }
    _$Eu() {
      var t5;
      this._$E_ = new Promise((t6) => this.enableUpdating = t6), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), null === (t5 = this.constructor.h) || void 0 === t5 || t5.forEach((t6) => t6(this));
    }
    addController(t5) {
      var i5, s8;
      (null !== (i5 = this._$ES) && void 0 !== i5 ? i5 : this._$ES = []).push(t5), void 0 !== this.renderRoot && this.isConnected && (null === (s8 = t5.hostConnected) || void 0 === s8 || s8.call(t5));
    }
    removeController(t5) {
      var i5;
      null === (i5 = this._$ES) || void 0 === i5 || i5.splice(this._$ES.indexOf(t5) >>> 0, 1);
    }
    _$Eg() {
      this.constructor.elementProperties.forEach((t5, i5) => {
        this.hasOwnProperty(i5) && (this._$Ei.set(i5, this[i5]), delete this[i5]);
      });
    }
    createRenderRoot() {
      var t5;
      const s8 = null !== (t5 = this.shadowRoot) && void 0 !== t5 ? t5 : this.attachShadow(this.constructor.shadowRootOptions);
      return S(s8, this.constructor.elementStyles), s8;
    }
    connectedCallback() {
      var t5;
      void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), null === (t5 = this._$ES) || void 0 === t5 || t5.forEach((t6) => {
        var i5;
        return null === (i5 = t6.hostConnected) || void 0 === i5 ? void 0 : i5.call(t6);
      });
    }
    enableUpdating(t5) {
    }
    disconnectedCallback() {
      var t5;
      null === (t5 = this._$ES) || void 0 === t5 || t5.forEach((t6) => {
        var i5;
        return null === (i5 = t6.hostDisconnected) || void 0 === i5 ? void 0 : i5.call(t6);
      });
    }
    attributeChangedCallback(t5, i5, s8) {
      this._$AK(t5, s8);
    }
    _$EO(t5, i5, s8 = l) {
      var e11;
      const r6 = this.constructor._$Ep(t5, s8);
      if (void 0 !== r6 && true === s8.reflect) {
        const h5 = (void 0 !== (null === (e11 = s8.converter) || void 0 === e11 ? void 0 : e11.toAttribute) ? s8.converter : n2).toAttribute(i5, s8.type);
        this._$El = t5, null == h5 ? this.removeAttribute(r6) : this.setAttribute(r6, h5), this._$El = null;
      }
    }
    _$AK(t5, i5) {
      var s8;
      const e11 = this.constructor, r6 = e11._$Ev.get(t5);
      if (void 0 !== r6 && this._$El !== r6) {
        const t6 = e11.getPropertyOptions(r6), h5 = "function" == typeof t6.converter ? { fromAttribute: t6.converter } : void 0 !== (null === (s8 = t6.converter) || void 0 === s8 ? void 0 : s8.fromAttribute) ? t6.converter : n2;
        this._$El = r6, this[r6] = h5.fromAttribute(i5, t6.type), this._$El = null;
      }
    }
    requestUpdate(t5, i5, s8) {
      let e11 = true;
      void 0 !== t5 && (((s8 = s8 || this.constructor.getPropertyOptions(t5)).hasChanged || a)(this[t5], i5) ? (this._$AL.has(t5) || this._$AL.set(t5, i5), true === s8.reflect && this._$El !== t5 && (void 0 === this._$EC && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t5, s8))) : e11 = false), !this.isUpdatePending && e11 && (this._$E_ = this._$Ej());
    }
    async _$Ej() {
      this.isUpdatePending = true;
      try {
        await this._$E_;
      } catch (t6) {
        Promise.reject(t6);
      }
      const t5 = this.scheduleUpdate();
      return null != t5 && await t5, !this.isUpdatePending;
    }
    scheduleUpdate() {
      return this.performUpdate();
    }
    performUpdate() {
      var t5;
      if (!this.isUpdatePending) return;
      this.hasUpdated, this._$Ei && (this._$Ei.forEach((t6, i6) => this[i6] = t6), this._$Ei = void 0);
      let i5 = false;
      const s8 = this._$AL;
      try {
        i5 = this.shouldUpdate(s8), i5 ? (this.willUpdate(s8), null === (t5 = this._$ES) || void 0 === t5 || t5.forEach((t6) => {
          var i6;
          return null === (i6 = t6.hostUpdate) || void 0 === i6 ? void 0 : i6.call(t6);
        }), this.update(s8)) : this._$Ek();
      } catch (t6) {
        throw i5 = false, this._$Ek(), t6;
      }
      i5 && this._$AE(s8);
    }
    willUpdate(t5) {
    }
    _$AE(t5) {
      var i5;
      null === (i5 = this._$ES) || void 0 === i5 || i5.forEach((t6) => {
        var i6;
        return null === (i6 = t6.hostUpdated) || void 0 === i6 ? void 0 : i6.call(t6);
      }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t5)), this.updated(t5);
    }
    _$Ek() {
      this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
    }
    get updateComplete() {
      return this.getUpdateComplete();
    }
    getUpdateComplete() {
      return this._$E_;
    }
    shouldUpdate(t5) {
      return true;
    }
    update(t5) {
      void 0 !== this._$EC && (this._$EC.forEach((t6, i5) => this._$EO(i5, this[i5], t6)), this._$EC = void 0), this._$Ek();
    }
    updated(t5) {
    }
    firstUpdated(t5) {
    }
  };
  u[d] = true, u.elementProperties = /* @__PURE__ */ new Map(), u.elementStyles = [], u.shadowRootOptions = { mode: "open" }, null == o3 || o3({ ReactiveElement: u }), (null !== (s2 = e2.reactiveElementVersions) && void 0 !== s2 ? s2 : e2.reactiveElementVersions = []).push("1.6.3");

  // ../../../../../node_modules/lit-html/lit-html.js
  var t2;
  var i2 = window;
  var s3 = i2.trustedTypes;
  var e3 = s3 ? s3.createPolicy("lit-html", { createHTML: (t5) => t5 }) : void 0;
  var o4 = "$lit$";
  var n3 = `lit$${(Math.random() + "").slice(9)}$`;
  var l2 = "?" + n3;
  var h2 = `<${l2}>`;
  var r3 = document;
  var u2 = () => r3.createComment("");
  var d2 = (t5) => null === t5 || "object" != typeof t5 && "function" != typeof t5;
  var c2 = Array.isArray;
  var v = (t5) => c2(t5) || "function" == typeof (null == t5 ? void 0 : t5[Symbol.iterator]);
  var a2 = "[ 	\n\f\r]";
  var f = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
  var _ = /-->/g;
  var m = />/g;
  var p = RegExp(`>|${a2}(?:([^\\s"'>=/]+)(${a2}*=${a2}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
  var g = /'/g;
  var $2 = /"/g;
  var y = /^(?:script|style|textarea|title)$/i;
  var w = (t5) => (i5, ...s8) => ({ _$litType$: t5, strings: i5, values: s8 });
  var x = w(1);
  var b = w(2);
  var T = Symbol.for("lit-noChange");
  var A = Symbol.for("lit-nothing");
  var E2 = /* @__PURE__ */ new WeakMap();
  var C = r3.createTreeWalker(r3, 129, null, false);
  function P(t5, i5) {
    if (!Array.isArray(t5) || !t5.hasOwnProperty("raw")) throw Error("invalid template strings array");
    return void 0 !== e3 ? e3.createHTML(i5) : i5;
  }
  var V = (t5, i5) => {
    const s8 = t5.length - 1, e11 = [];
    let l8, r6 = 2 === i5 ? "<svg>" : "", u7 = f;
    for (let i6 = 0; i6 < s8; i6++) {
      const s9 = t5[i6];
      let d3, c9, v3 = -1, a5 = 0;
      for (; a5 < s9.length && (u7.lastIndex = a5, c9 = u7.exec(s9), null !== c9); ) a5 = u7.lastIndex, u7 === f ? "!--" === c9[1] ? u7 = _ : void 0 !== c9[1] ? u7 = m : void 0 !== c9[2] ? (y.test(c9[2]) && (l8 = RegExp("</" + c9[2], "g")), u7 = p) : void 0 !== c9[3] && (u7 = p) : u7 === p ? ">" === c9[0] ? (u7 = null != l8 ? l8 : f, v3 = -1) : void 0 === c9[1] ? v3 = -2 : (v3 = u7.lastIndex - c9[2].length, d3 = c9[1], u7 = void 0 === c9[3] ? p : '"' === c9[3] ? $2 : g) : u7 === $2 || u7 === g ? u7 = p : u7 === _ || u7 === m ? u7 = f : (u7 = p, l8 = void 0);
      const w2 = u7 === p && t5[i6 + 1].startsWith("/>") ? " " : "";
      r6 += u7 === f ? s9 + h2 : v3 >= 0 ? (e11.push(d3), s9.slice(0, v3) + o4 + s9.slice(v3) + n3 + w2) : s9 + n3 + (-2 === v3 ? (e11.push(void 0), i6) : w2);
    }
    return [P(t5, r6 + (t5[s8] || "<?>") + (2 === i5 ? "</svg>" : "")), e11];
  };
  var N2 = class _N {
    constructor({ strings: t5, _$litType$: i5 }, e11) {
      let h5;
      this.parts = [];
      let r6 = 0, d3 = 0;
      const c9 = t5.length - 1, v3 = this.parts, [a5, f7] = V(t5, i5);
      if (this.el = _N.createElement(a5, e11), C.currentNode = this.el.content, 2 === i5) {
        const t6 = this.el.content, i6 = t6.firstChild;
        i6.remove(), t6.append(...i6.childNodes);
      }
      for (; null !== (h5 = C.nextNode()) && v3.length < c9; ) {
        if (1 === h5.nodeType) {
          if (h5.hasAttributes()) {
            const t6 = [];
            for (const i6 of h5.getAttributeNames()) if (i6.endsWith(o4) || i6.startsWith(n3)) {
              const s8 = f7[d3++];
              if (t6.push(i6), void 0 !== s8) {
                const t7 = h5.getAttribute(s8.toLowerCase() + o4).split(n3), i7 = /([.?@])?(.*)/.exec(s8);
                v3.push({ type: 1, index: r6, name: i7[2], strings: t7, ctor: "." === i7[1] ? H : "?" === i7[1] ? L : "@" === i7[1] ? z : k });
              } else v3.push({ type: 6, index: r6 });
            }
            for (const i6 of t6) h5.removeAttribute(i6);
          }
          if (y.test(h5.tagName)) {
            const t6 = h5.textContent.split(n3), i6 = t6.length - 1;
            if (i6 > 0) {
              h5.textContent = s3 ? s3.emptyScript : "";
              for (let s8 = 0; s8 < i6; s8++) h5.append(t6[s8], u2()), C.nextNode(), v3.push({ type: 2, index: ++r6 });
              h5.append(t6[i6], u2());
            }
          }
        } else if (8 === h5.nodeType) if (h5.data === l2) v3.push({ type: 2, index: r6 });
        else {
          let t6 = -1;
          for (; -1 !== (t6 = h5.data.indexOf(n3, t6 + 1)); ) v3.push({ type: 7, index: r6 }), t6 += n3.length - 1;
        }
        r6++;
      }
    }
    static createElement(t5, i5) {
      const s8 = r3.createElement("template");
      return s8.innerHTML = t5, s8;
    }
  };
  function S2(t5, i5, s8 = t5, e11) {
    var o12, n9, l8, h5;
    if (i5 === T) return i5;
    let r6 = void 0 !== e11 ? null === (o12 = s8._$Co) || void 0 === o12 ? void 0 : o12[e11] : s8._$Cl;
    const u7 = d2(i5) ? void 0 : i5._$litDirective$;
    return (null == r6 ? void 0 : r6.constructor) !== u7 && (null === (n9 = null == r6 ? void 0 : r6._$AO) || void 0 === n9 || n9.call(r6, false), void 0 === u7 ? r6 = void 0 : (r6 = new u7(t5), r6._$AT(t5, s8, e11)), void 0 !== e11 ? (null !== (l8 = (h5 = s8)._$Co) && void 0 !== l8 ? l8 : h5._$Co = [])[e11] = r6 : s8._$Cl = r6), void 0 !== r6 && (i5 = S2(t5, r6._$AS(t5, i5.values), r6, e11)), i5;
  }
  var M2 = class {
    constructor(t5, i5) {
      this._$AV = [], this._$AN = void 0, this._$AD = t5, this._$AM = i5;
    }
    get parentNode() {
      return this._$AM.parentNode;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    u(t5) {
      var i5;
      const { el: { content: s8 }, parts: e11 } = this._$AD, o12 = (null !== (i5 = null == t5 ? void 0 : t5.creationScope) && void 0 !== i5 ? i5 : r3).importNode(s8, true);
      C.currentNode = o12;
      let n9 = C.nextNode(), l8 = 0, h5 = 0, u7 = e11[0];
      for (; void 0 !== u7; ) {
        if (l8 === u7.index) {
          let i6;
          2 === u7.type ? i6 = new R(n9, n9.nextSibling, this, t5) : 1 === u7.type ? i6 = new u7.ctor(n9, u7.name, u7.strings, this, t5) : 6 === u7.type && (i6 = new Z(n9, this, t5)), this._$AV.push(i6), u7 = e11[++h5];
        }
        l8 !== (null == u7 ? void 0 : u7.index) && (n9 = C.nextNode(), l8++);
      }
      return C.currentNode = r3, o12;
    }
    v(t5) {
      let i5 = 0;
      for (const s8 of this._$AV) void 0 !== s8 && (void 0 !== s8.strings ? (s8._$AI(t5, s8, i5), i5 += s8.strings.length - 2) : s8._$AI(t5[i5])), i5++;
    }
  };
  var R = class _R {
    constructor(t5, i5, s8, e11) {
      var o12;
      this.type = 2, this._$AH = A, this._$AN = void 0, this._$AA = t5, this._$AB = i5, this._$AM = s8, this.options = e11, this._$Cp = null === (o12 = null == e11 ? void 0 : e11.isConnected) || void 0 === o12 || o12;
    }
    get _$AU() {
      var t5, i5;
      return null !== (i5 = null === (t5 = this._$AM) || void 0 === t5 ? void 0 : t5._$AU) && void 0 !== i5 ? i5 : this._$Cp;
    }
    get parentNode() {
      let t5 = this._$AA.parentNode;
      const i5 = this._$AM;
      return void 0 !== i5 && 11 === (null == t5 ? void 0 : t5.nodeType) && (t5 = i5.parentNode), t5;
    }
    get startNode() {
      return this._$AA;
    }
    get endNode() {
      return this._$AB;
    }
    _$AI(t5, i5 = this) {
      t5 = S2(this, t5, i5), d2(t5) ? t5 === A || null == t5 || "" === t5 ? (this._$AH !== A && this._$AR(), this._$AH = A) : t5 !== this._$AH && t5 !== T && this._(t5) : void 0 !== t5._$litType$ ? this.g(t5) : void 0 !== t5.nodeType ? this.$(t5) : v(t5) ? this.T(t5) : this._(t5);
    }
    k(t5) {
      return this._$AA.parentNode.insertBefore(t5, this._$AB);
    }
    $(t5) {
      this._$AH !== t5 && (this._$AR(), this._$AH = this.k(t5));
    }
    _(t5) {
      this._$AH !== A && d2(this._$AH) ? this._$AA.nextSibling.data = t5 : this.$(r3.createTextNode(t5)), this._$AH = t5;
    }
    g(t5) {
      var i5;
      const { values: s8, _$litType$: e11 } = t5, o12 = "number" == typeof e11 ? this._$AC(t5) : (void 0 === e11.el && (e11.el = N2.createElement(P(e11.h, e11.h[0]), this.options)), e11);
      if ((null === (i5 = this._$AH) || void 0 === i5 ? void 0 : i5._$AD) === o12) this._$AH.v(s8);
      else {
        const t6 = new M2(o12, this), i6 = t6.u(this.options);
        t6.v(s8), this.$(i6), this._$AH = t6;
      }
    }
    _$AC(t5) {
      let i5 = E2.get(t5.strings);
      return void 0 === i5 && E2.set(t5.strings, i5 = new N2(t5)), i5;
    }
    T(t5) {
      c2(this._$AH) || (this._$AH = [], this._$AR());
      const i5 = this._$AH;
      let s8, e11 = 0;
      for (const o12 of t5) e11 === i5.length ? i5.push(s8 = new _R(this.k(u2()), this.k(u2()), this, this.options)) : s8 = i5[e11], s8._$AI(o12), e11++;
      e11 < i5.length && (this._$AR(s8 && s8._$AB.nextSibling, e11), i5.length = e11);
    }
    _$AR(t5 = this._$AA.nextSibling, i5) {
      var s8;
      for (null === (s8 = this._$AP) || void 0 === s8 || s8.call(this, false, true, i5); t5 && t5 !== this._$AB; ) {
        const i6 = t5.nextSibling;
        t5.remove(), t5 = i6;
      }
    }
    setConnected(t5) {
      var i5;
      void 0 === this._$AM && (this._$Cp = t5, null === (i5 = this._$AP) || void 0 === i5 || i5.call(this, t5));
    }
  };
  var k = class {
    constructor(t5, i5, s8, e11, o12) {
      this.type = 1, this._$AH = A, this._$AN = void 0, this.element = t5, this.name = i5, this._$AM = e11, this.options = o12, s8.length > 2 || "" !== s8[0] || "" !== s8[1] ? (this._$AH = Array(s8.length - 1).fill(new String()), this.strings = s8) : this._$AH = A;
    }
    get tagName() {
      return this.element.tagName;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t5, i5 = this, s8, e11) {
      const o12 = this.strings;
      let n9 = false;
      if (void 0 === o12) t5 = S2(this, t5, i5, 0), n9 = !d2(t5) || t5 !== this._$AH && t5 !== T, n9 && (this._$AH = t5);
      else {
        const e12 = t5;
        let l8, h5;
        for (t5 = o12[0], l8 = 0; l8 < o12.length - 1; l8++) h5 = S2(this, e12[s8 + l8], i5, l8), h5 === T && (h5 = this._$AH[l8]), n9 || (n9 = !d2(h5) || h5 !== this._$AH[l8]), h5 === A ? t5 = A : t5 !== A && (t5 += (null != h5 ? h5 : "") + o12[l8 + 1]), this._$AH[l8] = h5;
      }
      n9 && !e11 && this.j(t5);
    }
    j(t5) {
      t5 === A ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t5 ? t5 : "");
    }
  };
  var H = class extends k {
    constructor() {
      super(...arguments), this.type = 3;
    }
    j(t5) {
      this.element[this.name] = t5 === A ? void 0 : t5;
    }
  };
  var I = s3 ? s3.emptyScript : "";
  var L = class extends k {
    constructor() {
      super(...arguments), this.type = 4;
    }
    j(t5) {
      t5 && t5 !== A ? this.element.setAttribute(this.name, I) : this.element.removeAttribute(this.name);
    }
  };
  var z = class extends k {
    constructor(t5, i5, s8, e11, o12) {
      super(t5, i5, s8, e11, o12), this.type = 5;
    }
    _$AI(t5, i5 = this) {
      var s8;
      if ((t5 = null !== (s8 = S2(this, t5, i5, 0)) && void 0 !== s8 ? s8 : A) === T) return;
      const e11 = this._$AH, o12 = t5 === A && e11 !== A || t5.capture !== e11.capture || t5.once !== e11.once || t5.passive !== e11.passive, n9 = t5 !== A && (e11 === A || o12);
      o12 && this.element.removeEventListener(this.name, this, e11), n9 && this.element.addEventListener(this.name, this, t5), this._$AH = t5;
    }
    handleEvent(t5) {
      var i5, s8;
      "function" == typeof this._$AH ? this._$AH.call(null !== (s8 = null === (i5 = this.options) || void 0 === i5 ? void 0 : i5.host) && void 0 !== s8 ? s8 : this.element, t5) : this._$AH.handleEvent(t5);
    }
  };
  var Z = class {
    constructor(t5, i5, s8) {
      this.element = t5, this.type = 6, this._$AN = void 0, this._$AM = i5, this.options = s8;
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AI(t5) {
      S2(this, t5);
    }
  };
  var j = { O: o4, P: n3, A: l2, C: 1, M: V, L: M2, R: v, D: S2, I: R, V: k, H: L, N: z, U: H, F: Z };
  var B = i2.litHtmlPolyfillSupport;
  null == B || B(N2, R), (null !== (t2 = i2.litHtmlVersions) && void 0 !== t2 ? t2 : i2.litHtmlVersions = []).push("2.8.0");
  var D = (t5, i5, s8) => {
    var e11, o12;
    const n9 = null !== (e11 = null == s8 ? void 0 : s8.renderBefore) && void 0 !== e11 ? e11 : i5;
    let l8 = n9._$litPart$;
    if (void 0 === l8) {
      const t6 = null !== (o12 = null == s8 ? void 0 : s8.renderBefore) && void 0 !== o12 ? o12 : null;
      n9._$litPart$ = l8 = new R(i5.insertBefore(u2(), t6), t6, void 0, null != s8 ? s8 : {});
    }
    return l8._$AI(t5), l8;
  };

  // ../../../../../node_modules/lit-element/lit-element.js
  var l3;
  var o5;
  var s4 = class extends u {
    constructor() {
      super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
    }
    createRenderRoot() {
      var t5, e11;
      const i5 = super.createRenderRoot();
      return null !== (t5 = (e11 = this.renderOptions).renderBefore) && void 0 !== t5 || (e11.renderBefore = i5.firstChild), i5;
    }
    update(t5) {
      const i5 = this.render();
      this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t5), this._$Do = D(i5, this.renderRoot, this.renderOptions);
    }
    connectedCallback() {
      var t5;
      super.connectedCallback(), null === (t5 = this._$Do) || void 0 === t5 || t5.setConnected(true);
    }
    disconnectedCallback() {
      var t5;
      super.disconnectedCallback(), null === (t5 = this._$Do) || void 0 === t5 || t5.setConnected(false);
    }
    render() {
      return T;
    }
  };
  s4.finalized = true, s4._$litElement$ = true, null === (l3 = globalThis.litElementHydrateSupport) || void 0 === l3 || l3.call(globalThis, { LitElement: s4 });
  var n4 = globalThis.litElementPolyfillSupport;
  null == n4 || n4({ LitElement: s4 });
  (null !== (o5 = globalThis.litElementVersions) && void 0 !== o5 ? o5 : globalThis.litElementVersions = []).push("3.3.3");

  // ../../../../../node_modules/@lit/reactive-element/decorators/custom-element.js
  var e4 = (e11) => (n9) => "function" == typeof n9 ? ((e12, n10) => (customElements.define(e12, n10), n10))(e11, n9) : ((e12, n10) => {
    const { kind: t5, elements: s8 } = n10;
    return { kind: t5, elements: s8, finisher(n11) {
      customElements.define(e12, n11);
    } };
  })(e11, n9);

  // ../../../../../node_modules/@lit/reactive-element/decorators/property.js
  var i3 = (i5, e11) => "method" === e11.kind && e11.descriptor && !("value" in e11.descriptor) ? { ...e11, finisher(n9) {
    n9.createProperty(e11.key, i5);
  } } : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: e11.key, initializer() {
    "function" == typeof e11.initializer && (this[e11.key] = e11.initializer.call(this));
  }, finisher(n9) {
    n9.createProperty(e11.key, i5);
  } };
  var e5 = (i5, e11, n9) => {
    e11.constructor.createProperty(n9, i5);
  };
  function n5(n9) {
    return (t5, o12) => void 0 !== o12 ? e5(n9, t5, o12) : i3(n9, t5);
  }

  // ../../../../../node_modules/@lit/reactive-element/decorators/state.js
  function t3(t5) {
    return n5({ ...t5, state: true });
  }

  // ../../../../../node_modules/@lit/reactive-element/decorators/query-assigned-elements.js
  var n6;
  var e6 = null != (null === (n6 = window.HTMLSlotElement) || void 0 === n6 ? void 0 : n6.prototype.assignedElements) ? (o12, n9) => o12.assignedElements(n9) : (o12, n9) => o12.assignedNodes(n9).filter((o13) => o13.nodeType === Node.ELEMENT_NODE);

  // ../../../../../node_modules/lit-html/directive.js
  var t4 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
  var e7 = (t5) => (...e11) => ({ _$litDirective$: t5, values: e11 });
  var i4 = class {
    constructor(t5) {
    }
    get _$AU() {
      return this._$AM._$AU;
    }
    _$AT(t5, e11, i5) {
      this._$Ct = t5, this._$AM = e11, this._$Ci = i5;
    }
    _$AS(t5, e11) {
      return this.update(t5, e11);
    }
    update(t5, e11) {
      return this.render(...e11);
    }
  };

  // ../../../../../node_modules/lit-html/directive-helpers.js
  var { I: l5 } = j;
  var e8 = (o12) => void 0 === o12.strings;
  var r4 = () => document.createComment("");
  var c3 = (o12, i5, n9) => {
    var t5;
    const v3 = o12._$AA.parentNode, d3 = void 0 === i5 ? o12._$AB : i5._$AA;
    if (void 0 === n9) {
      const i6 = v3.insertBefore(r4(), d3), t6 = v3.insertBefore(r4(), d3);
      n9 = new l5(i6, t6, o12, o12.options);
    } else {
      const l8 = n9._$AB.nextSibling, i6 = n9._$AM, u7 = i6 !== o12;
      if (u7) {
        let l9;
        null === (t5 = n9._$AQ) || void 0 === t5 || t5.call(n9, o12), n9._$AM = o12, void 0 !== n9._$AP && (l9 = o12._$AU) !== i6._$AU && n9._$AP(l9);
      }
      if (l8 !== d3 || u7) {
        let o13 = n9._$AA;
        for (; o13 !== l8; ) {
          const l9 = o13.nextSibling;
          v3.insertBefore(o13, d3), o13 = l9;
        }
      }
    }
    return n9;
  };
  var f6 = (o12, l8, i5 = o12) => (o12._$AI(l8, i5), o12);
  var s5 = {};
  var a3 = (o12, l8 = s5) => o12._$AH = l8;
  var m2 = (o12) => o12._$AH;
  var p10 = (o12) => {
    var l8;
    null === (l8 = o12._$AP) || void 0 === l8 || l8.call(o12, false, true);
    let i5 = o12._$AA;
    const n9 = o12._$AB.nextSibling;
    for (; i5 !== n9; ) {
      const o13 = i5.nextSibling;
      i5.remove(), i5 = o13;
    }
  };

  // ../../../../../node_modules/lit-html/directives/repeat.js
  var u3 = (e11, s8, t5) => {
    const r6 = /* @__PURE__ */ new Map();
    for (let l8 = s8; l8 <= t5; l8++) r6.set(e11[l8], l8);
    return r6;
  };
  var c4 = e7(class extends i4 {
    constructor(e11) {
      if (super(e11), e11.type !== t4.CHILD) throw Error("repeat() can only be used in text expressions");
    }
    ct(e11, s8, t5) {
      let r6;
      void 0 === t5 ? t5 = s8 : void 0 !== s8 && (r6 = s8);
      const l8 = [], o12 = [];
      let i5 = 0;
      for (const s9 of e11) l8[i5] = r6 ? r6(s9, i5) : i5, o12[i5] = t5(s9, i5), i5++;
      return { values: o12, keys: l8 };
    }
    render(e11, s8, t5) {
      return this.ct(e11, s8, t5).values;
    }
    update(s8, [t5, r6, c9]) {
      var d3;
      const a5 = m2(s8), { values: p11, keys: v3 } = this.ct(t5, r6, c9);
      if (!Array.isArray(a5)) return this.ut = v3, p11;
      const h5 = null !== (d3 = this.ut) && void 0 !== d3 ? d3 : this.ut = [], m3 = [];
      let y3, x3, j2 = 0, k3 = a5.length - 1, w2 = 0, A5 = p11.length - 1;
      for (; j2 <= k3 && w2 <= A5; ) if (null === a5[j2]) j2++;
      else if (null === a5[k3]) k3--;
      else if (h5[j2] === v3[w2]) m3[w2] = f6(a5[j2], p11[w2]), j2++, w2++;
      else if (h5[k3] === v3[A5]) m3[A5] = f6(a5[k3], p11[A5]), k3--, A5--;
      else if (h5[j2] === v3[A5]) m3[A5] = f6(a5[j2], p11[A5]), c3(s8, m3[A5 + 1], a5[j2]), j2++, A5--;
      else if (h5[k3] === v3[w2]) m3[w2] = f6(a5[k3], p11[w2]), c3(s8, a5[j2], a5[k3]), k3--, w2++;
      else if (void 0 === y3 && (y3 = u3(v3, w2, A5), x3 = u3(h5, j2, k3)), y3.has(h5[j2])) if (y3.has(h5[k3])) {
        const e11 = x3.get(v3[w2]), t6 = void 0 !== e11 ? a5[e11] : null;
        if (null === t6) {
          const e12 = c3(s8, a5[j2]);
          f6(e12, p11[w2]), m3[w2] = e12;
        } else m3[w2] = f6(t6, p11[w2]), c3(s8, a5[j2], t6), a5[e11] = null;
        w2++;
      } else p10(a5[k3]), k3--;
      else p10(a5[j2]), j2++;
      for (; w2 <= A5; ) {
        const e11 = c3(s8, m3[A5 + 1]);
        f6(e11, p11[w2]), m3[w2++] = e11;
      }
      for (; j2 <= k3; ) {
        const e11 = a5[j2++];
        null !== e11 && p10(e11);
      }
      return this.ut = v3, a3(s8, m3), T;
    }
  });

  // ../../../../../node_modules/lit-html/directives/live.js
  var l6 = e7(class extends i4 {
    constructor(r6) {
      if (super(r6), r6.type !== t4.PROPERTY && r6.type !== t4.ATTRIBUTE && r6.type !== t4.BOOLEAN_ATTRIBUTE) throw Error("The `live` directive is not allowed on child or event bindings");
      if (!e8(r6)) throw Error("`live` bindings can only contain a single expression");
    }
    render(r6) {
      return r6;
    }
    update(i5, [t5]) {
      if (t5 === T || t5 === A) return t5;
      const o12 = i5.element, l8 = i5.name;
      if (i5.type === t4.PROPERTY) {
        if (t5 === o12[l8]) return T;
      } else if (i5.type === t4.BOOLEAN_ATTRIBUTE) {
        if (!!t5 === o12.hasAttribute(l8)) return T;
      } else if (i5.type === t4.ATTRIBUTE && o12.getAttribute(l8) === t5 + "") return T;
      return a3(i5), t5;
    }
  });

  // ../../../../../node_modules/lit-html/async-directive.js
  var s6 = (i5, t5) => {
    var e11, o12;
    const r6 = i5._$AN;
    if (void 0 === r6) return false;
    for (const i6 of r6) null === (o12 = (e11 = i6)._$AO) || void 0 === o12 || o12.call(e11, t5, false), s6(i6, t5);
    return true;
  };
  var o7 = (i5) => {
    let t5, e11;
    do {
      if (void 0 === (t5 = i5._$AM)) break;
      e11 = t5._$AN, e11.delete(i5), i5 = t5;
    } while (0 === (null == e11 ? void 0 : e11.size));
  };
  var r5 = (i5) => {
    for (let t5; t5 = i5._$AM; i5 = t5) {
      let e11 = t5._$AN;
      if (void 0 === e11) t5._$AN = e11 = /* @__PURE__ */ new Set();
      else if (e11.has(i5)) break;
      e11.add(i5), l7(t5);
    }
  };
  function n7(i5) {
    void 0 !== this._$AN ? (o7(this), this._$AM = i5, r5(this)) : this._$AM = i5;
  }
  function h3(i5, t5 = false, e11 = 0) {
    const r6 = this._$AH, n9 = this._$AN;
    if (void 0 !== n9 && 0 !== n9.size) if (t5) if (Array.isArray(r6)) for (let i6 = e11; i6 < r6.length; i6++) s6(r6[i6], false), o7(r6[i6]);
    else null != r6 && (s6(r6, false), o7(r6));
    else s6(this, i5);
  }
  var l7 = (i5) => {
    var t5, s8, o12, r6;
    i5.type == t4.CHILD && (null !== (t5 = (o12 = i5)._$AP) && void 0 !== t5 || (o12._$AP = h3), null !== (s8 = (r6 = i5)._$AQ) && void 0 !== s8 || (r6._$AQ = n7));
  };
  var c5 = class extends i4 {
    constructor() {
      super(...arguments), this._$AN = void 0;
    }
    _$AT(i5, t5, e11) {
      super._$AT(i5, t5, e11), r5(this), this.isConnected = i5._$AU;
    }
    _$AO(i5, t5 = true) {
      var e11, r6;
      i5 !== this.isConnected && (this.isConnected = i5, i5 ? null === (e11 = this.reconnected) || void 0 === e11 || e11.call(this) : null === (r6 = this.disconnected) || void 0 === r6 || r6.call(this)), t5 && (s6(this, i5), o7(this));
    }
    setValue(t5) {
      if (e8(this._$Ct)) this._$Ct._$AI(t5, this);
      else {
        const i5 = [...this._$Ct._$AH];
        i5[this._$Ci] = t5, this._$Ct._$AI(i5, this, 0);
      }
    }
    disconnected() {
    }
    reconnected() {
    }
  };

  // ../../../../../node_modules/lit-html/directives/ref.js
  var e9 = () => new o8();
  var o8 = class {
  };
  var h4 = /* @__PURE__ */ new WeakMap();
  var n8 = e7(class extends c5 {
    render(t5) {
      return A;
    }
    update(t5, [s8]) {
      var e11;
      const o12 = s8 !== this.G;
      return o12 && void 0 !== this.G && this.ot(void 0), (o12 || this.rt !== this.lt) && (this.G = s8, this.dt = null === (e11 = t5.options) || void 0 === e11 ? void 0 : e11.host, this.ot(this.lt = t5.element)), A;
    }
    ot(i5) {
      var t5;
      if ("function" == typeof this.G) {
        const s8 = null !== (t5 = this.dt) && void 0 !== t5 ? t5 : globalThis;
        let e11 = h4.get(s8);
        void 0 === e11 && (e11 = /* @__PURE__ */ new WeakMap(), h4.set(s8, e11)), void 0 !== e11.get(this.G) && this.G.call(this.dt, void 0), e11.set(this.G, i5), void 0 !== i5 && this.G.call(this.dt, i5);
      } else this.G.value = i5;
    }
    get rt() {
      var i5, t5, s8;
      return "function" == typeof this.G ? null === (t5 = h4.get(null !== (i5 = this.dt) && void 0 !== i5 ? i5 : globalThis)) || void 0 === t5 ? void 0 : t5.get(this.G) : null === (s8 = this.G) || void 0 === s8 ? void 0 : s8.value;
    }
    disconnected() {
      this.rt === this.lt && this.ot(void 0);
    }
    reconnected() {
      this.ot(this.lt);
    }
  });

  // ../../../../../node_modules/lit-html/directives/class-map.js
  var o9 = e7(class extends i4 {
    constructor(t5) {
      var i5;
      if (super(t5), t5.type !== t4.ATTRIBUTE || "class" !== t5.name || (null === (i5 = t5.strings) || void 0 === i5 ? void 0 : i5.length) > 2) throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
    }
    render(t5) {
      return " " + Object.keys(t5).filter((i5) => t5[i5]).join(" ") + " ";
    }
    update(i5, [s8]) {
      var r6, o12;
      if (void 0 === this.it) {
        this.it = /* @__PURE__ */ new Set(), void 0 !== i5.strings && (this.nt = new Set(i5.strings.join(" ").split(/\s/).filter((t5) => "" !== t5)));
        for (const t5 in s8) s8[t5] && !(null === (r6 = this.nt) || void 0 === r6 ? void 0 : r6.has(t5)) && this.it.add(t5);
        return this.render(s8);
      }
      const e11 = i5.element.classList;
      this.it.forEach((t5) => {
        t5 in s8 || (e11.remove(t5), this.it.delete(t5));
      });
      for (const t5 in s8) {
        const i6 = !!s8[t5];
        i6 === this.it.has(t5) || (null === (o12 = this.nt) || void 0 === o12 ? void 0 : o12.has(t5)) || (i6 ? (e11.add(t5), this.it.add(t5)) : (e11.remove(t5), this.it.delete(t5)));
      }
      return T;
    }
  });

  // ../../../../../node_modules/hotkeys-js/dist/hotkeys.esm.js
  var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
  function addEvent(object, event, method) {
    if (object.addEventListener) {
      object.addEventListener(event, method, false);
    } else if (object.attachEvent) {
      object.attachEvent("on".concat(event), function() {
        method(window.event);
      });
    }
  }
  function getMods(modifier, key) {
    var mods = key.slice(0, key.length - 1);
    for (var i5 = 0; i5 < mods.length; i5++) {
      mods[i5] = modifier[mods[i5].toLowerCase()];
    }
    return mods;
  }
  function getKeys(key) {
    if (typeof key !== "string") key = "";
    key = key.replace(/\s/g, "");
    var keys = key.split(",");
    var index2 = keys.lastIndexOf("");
    for (; index2 >= 0; ) {
      keys[index2 - 1] += ",";
      keys.splice(index2, 1);
      index2 = keys.lastIndexOf("");
    }
    return keys;
  }
  function compareArray(a1, a22) {
    var arr1 = a1.length >= a22.length ? a1 : a22;
    var arr2 = a1.length >= a22.length ? a22 : a1;
    var isIndex = true;
    for (var i5 = 0; i5 < arr1.length; i5++) {
      if (arr2.indexOf(arr1[i5]) === -1) isIndex = false;
    }
    return isIndex;
  }
  var _keyMap = {
    backspace: 8,
    tab: 9,
    clear: 12,
    enter: 13,
    return: 13,
    esc: 27,
    escape: 27,
    space: 32,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    del: 46,
    delete: 46,
    ins: 45,
    insert: 45,
    home: 36,
    end: 35,
    pageup: 33,
    pagedown: 34,
    capslock: 20,
    num_0: 96,
    num_1: 97,
    num_2: 98,
    num_3: 99,
    num_4: 100,
    num_5: 101,
    num_6: 102,
    num_7: 103,
    num_8: 104,
    num_9: 105,
    num_multiply: 106,
    num_add: 107,
    num_enter: 108,
    num_subtract: 109,
    num_decimal: 110,
    num_divide: 111,
    "\u21EA": 20,
    ",": 188,
    ".": 190,
    "/": 191,
    "`": 192,
    "-": isff ? 173 : 189,
    "=": isff ? 61 : 187,
    ";": isff ? 59 : 186,
    "'": 222,
    "[": 219,
    "]": 221,
    "\\": 220
  };
  var _modifier = {
    // shiftKey
    "\u21E7": 16,
    shift: 16,
    // altKey
    "\u2325": 18,
    alt: 18,
    option: 18,
    // ctrlKey
    "\u2303": 17,
    ctrl: 17,
    control: 17,
    // metaKey
    "\u2318": 91,
    cmd: 91,
    command: 91
  };
  var modifierMap = {
    16: "shiftKey",
    18: "altKey",
    17: "ctrlKey",
    91: "metaKey",
    shiftKey: 16,
    ctrlKey: 17,
    altKey: 18,
    metaKey: 91
  };
  var _mods = {
    16: false,
    18: false,
    17: false,
    91: false
  };
  var _handlers = {};
  for (k3 = 1; k3 < 20; k3++) {
    _keyMap["f".concat(k3)] = 111 + k3;
  }
  var k3;
  var _downKeys = [];
  var _scope = "all";
  var elementHasBindEvent = [];
  var code = function code2(x3) {
    return _keyMap[x3.toLowerCase()] || _modifier[x3.toLowerCase()] || x3.toUpperCase().charCodeAt(0);
  };
  function setScope(scope) {
    _scope = scope || "all";
  }
  function getScope() {
    return _scope || "all";
  }
  function getPressedKeyCodes() {
    return _downKeys.slice(0);
  }
  function filter2(event) {
    var target = event.target || event.srcElement;
    var tagName = target.tagName;
    var flag2 = true;
    if (target.isContentEditable || (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
      flag2 = false;
    }
    return flag2;
  }
  function isPressed(keyCode) {
    if (typeof keyCode === "string") {
      keyCode = code(keyCode);
    }
    return _downKeys.indexOf(keyCode) !== -1;
  }
  function deleteScope(scope, newScope) {
    var handlers;
    var i5;
    if (!scope) scope = getScope();
    for (var key in _handlers) {
      if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
        handlers = _handlers[key];
        for (i5 = 0; i5 < handlers.length; ) {
          if (handlers[i5].scope === scope) handlers.splice(i5, 1);
          else i5++;
        }
      }
    }
    if (getScope() === scope) setScope(newScope || "all");
  }
  function clearModifier(event) {
    var key = event.keyCode || event.which || event.charCode;
    var i5 = _downKeys.indexOf(key);
    if (i5 >= 0) {
      _downKeys.splice(i5, 1);
    }
    if (event.key && event.key.toLowerCase() === "meta") {
      _downKeys.splice(0, _downKeys.length);
    }
    if (key === 93 || key === 224) key = 91;
    if (key in _mods) {
      _mods[key] = false;
      for (var k3 in _modifier) {
        if (_modifier[k3] === key) hotkeys[k3] = false;
      }
    }
  }
  function unbind(keysInfo) {
    if (!keysInfo) {
      Object.keys(_handlers).forEach(function(key) {
        return delete _handlers[key];
      });
    } else if (Array.isArray(keysInfo)) {
      keysInfo.forEach(function(info) {
        if (info.key) eachUnbind(info);
      });
    } else if (typeof keysInfo === "object") {
      if (keysInfo.key) eachUnbind(keysInfo);
    } else if (typeof keysInfo === "string") {
      for (var _len = arguments.length, args2 = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args2[_key - 1] = arguments[_key];
      }
      var scope = args2[0], method = args2[1];
      if (typeof scope === "function") {
        method = scope;
        scope = "";
      }
      eachUnbind({
        key: keysInfo,
        scope,
        method,
        splitKey: "+"
      });
    }
  }
  var eachUnbind = function eachUnbind2(_ref) {
    var key = _ref.key, scope = _ref.scope, method = _ref.method, _ref$splitKey = _ref.splitKey, splitKey = _ref$splitKey === void 0 ? "+" : _ref$splitKey;
    var multipleKeys = getKeys(key);
    multipleKeys.forEach(function(originKey) {
      var unbindKeys = originKey.split(splitKey);
      var len = unbindKeys.length;
      var lastKey = unbindKeys[len - 1];
      var keyCode = lastKey === "*" ? "*" : code(lastKey);
      if (!_handlers[keyCode]) return;
      if (!scope) scope = getScope();
      var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
      _handlers[keyCode] = _handlers[keyCode].map(function(record) {
        var isMatchingMethod = method ? record.method === method : true;
        if (isMatchingMethod && record.scope === scope && compareArray(record.mods, mods)) {
          return {};
        }
        return record;
      });
    });
  };
  function eventHandler(event, handler, scope) {
    var modifiersMatch;
    if (handler.scope === scope || handler.scope === "all") {
      modifiersMatch = handler.mods.length > 0;
      for (var y3 in _mods) {
        if (Object.prototype.hasOwnProperty.call(_mods, y3)) {
          if (!_mods[y3] && handler.mods.indexOf(+y3) > -1 || _mods[y3] && handler.mods.indexOf(+y3) === -1) {
            modifiersMatch = false;
          }
        }
      }
      if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
        if (handler.method(event, handler) === false) {
          if (event.preventDefault) event.preventDefault();
          else event.returnValue = false;
          if (event.stopPropagation) event.stopPropagation();
          if (event.cancelBubble) event.cancelBubble = true;
        }
      }
    }
  }
  function dispatch(event) {
    var asterisk = _handlers["*"];
    var key = event.keyCode || event.which || event.charCode;
    if (!hotkeys.filter.call(this, event)) return;
    if (key === 93 || key === 224) key = 91;
    if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);
    ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(keyName) {
      var keyNum = modifierMap[keyName];
      if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
        _downKeys.push(keyNum);
      } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
        _downKeys.splice(_downKeys.indexOf(keyNum), 1);
      } else if (keyName === "metaKey" && event[keyName] && _downKeys.length === 3) {
        if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
          _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
        }
      }
    });
    if (key in _mods) {
      _mods[key] = true;
      for (var k3 in _modifier) {
        if (_modifier[k3] === key) hotkeys[k3] = true;
      }
      if (!asterisk) return;
    }
    for (var e11 in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, e11)) {
        _mods[e11] = event[modifierMap[e11]];
      }
    }
    if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
      if (_downKeys.indexOf(17) === -1) {
        _downKeys.push(17);
      }
      if (_downKeys.indexOf(18) === -1) {
        _downKeys.push(18);
      }
      _mods[17] = true;
      _mods[18] = true;
    }
    var scope = getScope();
    if (asterisk) {
      for (var i5 = 0; i5 < asterisk.length; i5++) {
        if (asterisk[i5].scope === scope && (event.type === "keydown" && asterisk[i5].keydown || event.type === "keyup" && asterisk[i5].keyup)) {
          eventHandler(event, asterisk[i5], scope);
        }
      }
    }
    if (!(key in _handlers)) return;
    for (var _i = 0; _i < _handlers[key].length; _i++) {
      if (event.type === "keydown" && _handlers[key][_i].keydown || event.type === "keyup" && _handlers[key][_i].keyup) {
        if (_handlers[key][_i].key) {
          var record = _handlers[key][_i];
          var splitKey = record.splitKey;
          var keyShortcut = record.key.split(splitKey);
          var _downKeysCurrent = [];
          for (var a5 = 0; a5 < keyShortcut.length; a5++) {
            _downKeysCurrent.push(code(keyShortcut[a5]));
          }
          if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
            eventHandler(event, record, scope);
          }
        }
      }
    }
  }
  function isElementBind(element) {
    return elementHasBindEvent.indexOf(element) > -1;
  }
  function hotkeys(key, option, method) {
    _downKeys = [];
    var keys = getKeys(key);
    var mods = [];
    var scope = "all";
    var element = document;
    var i5 = 0;
    var keyup = false;
    var keydown = true;
    var splitKey = "+";
    if (method === void 0 && typeof option === "function") {
      method = option;
    }
    if (Object.prototype.toString.call(option) === "[object Object]") {
      if (option.scope) scope = option.scope;
      if (option.element) element = option.element;
      if (option.keyup) keyup = option.keyup;
      if (option.keydown !== void 0) keydown = option.keydown;
      if (typeof option.splitKey === "string") splitKey = option.splitKey;
    }
    if (typeof option === "string") scope = option;
    for (; i5 < keys.length; i5++) {
      key = keys[i5].split(splitKey);
      mods = [];
      if (key.length > 1) mods = getMods(_modifier, key);
      key = key[key.length - 1];
      key = key === "*" ? "*" : code(key);
      if (!(key in _handlers)) _handlers[key] = [];
      _handlers[key].push({
        keyup,
        keydown,
        scope,
        mods,
        shortcut: keys[i5],
        method,
        key: keys[i5],
        splitKey
      });
    }
    if (typeof element !== "undefined" && !isElementBind(element) && window) {
      elementHasBindEvent.push(element);
      addEvent(element, "keydown", function(e11) {
        dispatch(e11);
      });
      addEvent(window, "focus", function() {
        _downKeys = [];
      });
      addEvent(element, "keyup", function(e11) {
        dispatch(e11);
        clearModifier(e11);
      });
    }
  }
  var _api = {
    setScope,
    getScope,
    deleteScope,
    getPressedKeyCodes,
    isPressed,
    filter: filter2,
    unbind
  };
  for (a5 in _api) {
    if (Object.prototype.hasOwnProperty.call(_api, a5)) {
      hotkeys[a5] = _api[a5];
    }
  }
  var a5;
  if (typeof window !== "undefined") {
    _hotkeys = window.hotkeys;
    hotkeys.noConflict = function(deep) {
      if (deep && window.hotkeys === hotkeys) {
        window.hotkeys = _hotkeys;
      }
      return hotkeys;
    };
    window.hotkeys = hotkeys;
  }
  var _hotkeys;
  var hotkeys_esm_default = hotkeys;

  // ../../../../../node_modules/ninja-keys/dist/ninja-header.js
  var __decorate = function(decorators, target, key, desc) {
    var c9 = arguments.length, r6 = c9 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
    else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d3 = decorators[i5]) r6 = (c9 < 3 ? d3(r6) : c9 > 3 ? d3(target, key, r6) : d3(target, key)) || r6;
    return c9 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
  };
  var NinjaHeader = class NinjaHeader2 extends s4 {
    constructor() {
      super(...arguments);
      this.placeholder = "";
      this.hideBreadcrumbs = false;
      this.breadcrumbHome = "Home";
      this.breadcrumbs = [];
      this._inputRef = e9();
    }
    render() {
      let breadcrumbs = "";
      if (!this.hideBreadcrumbs) {
        const itemTemplates = [];
        for (const breadcrumb of this.breadcrumbs) {
          itemTemplates.push(x`<button
            tabindex="-1"
            @click=${() => this.selectParent(breadcrumb)}
            class="breadcrumb"
          >
            ${breadcrumb}
          </button>`);
        }
        breadcrumbs = x`<div class="breadcrumb-list">
        <button
          tabindex="-1"
          @click=${() => this.selectParent()}
          class="breadcrumb"
        >
          ${this.breadcrumbHome}
        </button>
        ${itemTemplates}
      </div>`;
      }
      return x`
      ${breadcrumbs}
      <div part="ninja-input-wrapper" class="search-wrapper">
        <input
          part="ninja-input"
          type="text"
          id="search"
          spellcheck="false"
          autocomplete="off"
          @input="${this._handleInput}"
          ${n8(this._inputRef)}
          placeholder="${this.placeholder}"
          class="search"
        />
      </div>
    `;
    }
    setSearch(value) {
      if (this._inputRef.value) {
        this._inputRef.value.value = value;
      }
    }
    focusSearch() {
      requestAnimationFrame(() => this._inputRef.value.focus());
    }
    _handleInput(event) {
      const input = event.target;
      this.dispatchEvent(new CustomEvent("change", {
        detail: { search: input.value },
        bubbles: false,
        composed: false
      }));
    }
    selectParent(breadcrumb) {
      this.dispatchEvent(new CustomEvent("setParent", {
        detail: { parent: breadcrumb },
        bubbles: true,
        composed: true
      }));
    }
    firstUpdated() {
      this.focusSearch();
    }
    _close() {
      this.dispatchEvent(new CustomEvent("close", { bubbles: true, composed: true }));
    }
  };
  NinjaHeader.styles = i`
    :host {
      flex: 1;
      position: relative;
    }
    .search {
      padding: 1.25em;
      flex-grow: 1;
      flex-shrink: 0;
      margin: 0px;
      border: none;
      appearance: none;
      font-size: 1.125em;
      background: transparent;
      caret-color: var(--ninja-accent-color);
      color: var(--ninja-text-color);
      outline: none;
      font-family: var(--ninja-font-family);
    }
    .search::placeholder {
      color: var(--ninja-placeholder-color);
    }
    .breadcrumb-list {
      padding: 1em 4em 0 1em;
      display: flex;
      flex-direction: row;
      align-items: stretch;
      justify-content: flex-start;
      flex: initial;
    }

    .breadcrumb {
      background: var(--ninja-secondary-background-color);
      text-align: center;
      line-height: 1.2em;
      border-radius: var(--ninja-key-border-radius);
      border: 0;
      cursor: pointer;
      padding: 0.1em 0.5em;
      color: var(--ninja-secondary-text-color);
      margin-right: 0.5em;
      outline: none;
      font-family: var(--ninja-font-family);
    }

    .search-wrapper {
      display: flex;
      border-bottom: var(--ninja-separate-border);
    }
  `;
  __decorate([
    n5()
  ], NinjaHeader.prototype, "placeholder", void 0);
  __decorate([
    n5({ type: Boolean })
  ], NinjaHeader.prototype, "hideBreadcrumbs", void 0);
  __decorate([
    n5()
  ], NinjaHeader.prototype, "breadcrumbHome", void 0);
  __decorate([
    n5({ type: Array })
  ], NinjaHeader.prototype, "breadcrumbs", void 0);
  NinjaHeader = __decorate([
    e4("ninja-header")
  ], NinjaHeader);

  // ../../../../../node_modules/lit-html/directives/unsafe-html.js
  var e10 = class extends i4 {
    constructor(i5) {
      if (super(i5), this.et = A, i5.type !== t4.CHILD) throw Error(this.constructor.directiveName + "() can only be used in child bindings");
    }
    render(r6) {
      if (r6 === A || null == r6) return this.ft = void 0, this.et = r6;
      if (r6 === T) return r6;
      if ("string" != typeof r6) throw Error(this.constructor.directiveName + "() called with a non-string value");
      if (r6 === this.et) return this.ft;
      this.et = r6;
      const s8 = [r6];
      return s8.raw = s8, this.ft = { _$litType$: this.constructor.resultType, strings: s8, values: [] };
    }
  };
  e10.directiveName = "unsafeHTML", e10.resultType = 1;
  var o10 = e7(e10);

  // ../../../../../node_modules/lit-html/directives/join.js
  function* o11(o12, t5) {
    const f7 = "function" == typeof t5;
    if (void 0 !== o12) {
      let i5 = -1;
      for (const n9 of o12) i5 > -1 && (yield f7 ? t5(i5) : t5), i5++, yield n9;
    }
  }

  // ../../../../../node_modules/tslib/tslib.es6.mjs
  function __decorate2(decorators, target, key, desc) {
    var c9 = arguments.length, r6 = c9 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
    else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d3 = decorators[i5]) r6 = (c9 < 3 ? d3(r6) : c9 > 3 ? d3(target, key, r6) : d3(target, key)) || r6;
    return c9 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
  }

  // ../../../../../node_modules/@material/mwc-icon/mwc-icon-host.css.js
  var styles = i`:host{font-family:var(--mdc-icon-font, "Material Icons");font-weight:normal;font-style:normal;font-size:var(--mdc-icon-size, 24px);line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-smoothing:antialiased;text-rendering:optimizeLegibility;-moz-osx-font-smoothing:grayscale;font-feature-settings:"liga"}`;

  // ../../../../../node_modules/@material/mwc-icon/mwc-icon.js
  var Icon = class Icon2 extends s4 {
    /** @soyTemplate */
    render() {
      return x`<span><slot></slot></span>`;
    }
  };
  Icon.styles = [styles];
  Icon = __decorate2([
    e4("mwc-icon")
  ], Icon);

  // ../../../../../node_modules/ninja-keys/dist/ninja-action.js
  var __decorate3 = function(decorators, target, key, desc) {
    var c9 = arguments.length, r6 = c9 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
    else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d3 = decorators[i5]) r6 = (c9 < 3 ? d3(r6) : c9 > 3 ? d3(target, key, r6) : d3(target, key)) || r6;
    return c9 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
  };
  var NinjaAction = class NinjaAction2 extends s4 {
    constructor() {
      super();
      this.selected = false;
      this.hotKeysJoinedView = true;
      this.addEventListener("click", this.click);
    }
    /**
     * Scroll to show element
     */
    ensureInView() {
      requestAnimationFrame(() => this.scrollIntoView({ block: "nearest" }));
    }
    click() {
      this.dispatchEvent(new CustomEvent("actionsSelected", {
        detail: this.action,
        bubbles: true,
        composed: true
      }));
    }
    updated(changedProperties) {
      if (changedProperties.has("selected")) {
        if (this.selected) {
          this.ensureInView();
        }
      }
    }
    render() {
      let icon;
      if (this.action.mdIcon) {
        icon = x`<mwc-icon part="ninja-icon" class="ninja-icon"
        >${this.action.mdIcon}</mwc-icon
      >`;
      } else if (this.action.icon) {
        icon = o10(this.action.icon || "");
      }
      let hotkey;
      if (this.action.hotkey) {
        if (this.hotKeysJoinedView) {
          hotkey = this.action.hotkey.split(",").map((hotkeys2) => {
            const keys = hotkeys2.split("+");
            const joinedKeys = x`${o11(keys.map((key) => x`<kbd>${key}</kbd>`), "+")}`;
            return x`<div class="ninja-hotkey ninja-hotkeys">
            ${joinedKeys}
          </div>`;
          });
        } else {
          hotkey = this.action.hotkey.split(",").map((hotkeys2) => {
            const keys = hotkeys2.split("+");
            const keyElements = keys.map((key) => x`<kbd class="ninja-hotkey">${key}</kbd>`);
            return x`<kbd class="ninja-hotkeys">${keyElements}</kbd>`;
          });
        }
      }
      const classes = {
        selected: this.selected,
        "ninja-action": true
      };
      return x`
      <div
        class="ninja-action"
        part="ninja-action ${this.selected ? "ninja-selected" : ""}"
        class=${o9(classes)}
      >
        ${icon}
        <div class="ninja-title">${this.action.title}</div>
        ${hotkey}
      </div>
    `;
    }
  };
  NinjaAction.styles = i`
    :host {
      display: flex;
      width: 100%;
    }
    .ninja-action {
      padding: 0.75em 1em;
      display: flex;
      border-left: 2px solid transparent;
      align-items: center;
      justify-content: start;
      outline: none;
      transition: color 0s ease 0s;
      width: 100%;
    }
    .ninja-action.selected {
      cursor: pointer;
      color: var(--ninja-selected-text-color);
      background-color: var(--ninja-selected-background);
      border-left: 2px solid var(--ninja-accent-color);
      outline: none;
    }
    .ninja-action.selected .ninja-icon {
      color: var(--ninja-selected-text-color);
    }
    .ninja-icon {
      font-size: var(--ninja-icon-size);
      max-width: var(--ninja-icon-size);
      max-height: var(--ninja-icon-size);
      margin-right: 1em;
      color: var(--ninja-icon-color);
      margin-right: 1em;
      position: relative;
    }

    .ninja-title {
      flex-shrink: 0.01;
      margin-right: 0.5em;
      flex-grow: 1;
      font-size: 0.8125em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .ninja-hotkeys {
      flex-shrink: 0;
      width: min-content;
      display: flex;
    }

    .ninja-hotkeys kbd {
      font-family: inherit;
    }
    .ninja-hotkey {
      background: var(--ninja-secondary-background-color);
      padding: 0.06em 0.25em;
      border-radius: var(--ninja-key-border-radius);
      text-transform: capitalize;
      color: var(--ninja-secondary-text-color);
      font-size: 0.75em;
      font-family: inherit;
    }

    .ninja-hotkey + .ninja-hotkey {
      margin-left: 0.5em;
    }
    .ninja-hotkeys + .ninja-hotkeys {
      margin-left: 1em;
    }
  `;
  __decorate3([
    n5({ type: Object })
  ], NinjaAction.prototype, "action", void 0);
  __decorate3([
    n5({ type: Boolean })
  ], NinjaAction.prototype, "selected", void 0);
  __decorate3([
    n5({ type: Boolean })
  ], NinjaAction.prototype, "hotKeysJoinedView", void 0);
  NinjaAction = __decorate3([
    e4("ninja-action")
  ], NinjaAction);

  // ../../../../../node_modules/ninja-keys/dist/ninja-footer.js
  var footerHtml = x` <div class="modal-footer" slot="footer">
  <span class="help">
    <svg
      version="1.0"
      class="ninja-examplekey"
      xmlns="http://www.w3.org/2000/svg"
      viewBox="0 0 1280 1280"
    >
      <path
        d="M1013 376c0 73.4-.4 113.3-1.1 120.2a159.9 159.9 0 0 1-90.2 127.3c-20 9.6-36.7 14-59.2 15.5-7.1.5-121.9.9-255 1h-242l95.5-95.5 95.5-95.5-38.3-38.2-38.2-38.3-160 160c-88 88-160 160.4-160 161 0 .6 72 73 160 161l160 160 38.2-38.3 38.3-38.2-95.5-95.5-95.5-95.5h251.1c252.9 0 259.8-.1 281.4-3.6 72.1-11.8 136.9-54.1 178.5-116.4 8.6-12.9 22.6-40.5 28-55.4 4.4-12 10.7-36.1 13.1-50.6 1.6-9.6 1.8-21 2.1-132.8l.4-122.2H1013v110z"
      />
    </svg>

    to select
  </span>
  <span class="help">
    <svg
      xmlns="http://www.w3.org/2000/svg"
      class="ninja-examplekey"
      viewBox="0 0 24 24"
    >
      <path d="M0 0h24v24H0V0z" fill="none" />
      <path
        d="M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
      />
    </svg>
    <svg
      xmlns="http://www.w3.org/2000/svg"
      class="ninja-examplekey"
      viewBox="0 0 24 24"
    >
      <path d="M0 0h24v24H0V0z" fill="none" />
      <path d="M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z" />
    </svg>
    to navigate
  </span>
  <span class="help">
    <span class="ninja-examplekey esc">esc</span>
    to close
  </span>
  <span class="help">
    <svg
      xmlns="http://www.w3.org/2000/svg"
      class="ninja-examplekey backspace"
      viewBox="0 0 20 20"
      fill="currentColor"
    >
      <path
        fill-rule="evenodd"
        d="M6.707 4.879A3 3 0 018.828 4H15a3 3 0 013 3v6a3 3 0 01-3 3H8.828a3 3 0 01-2.12-.879l-4.415-4.414a1 1 0 010-1.414l4.414-4.414zm4 2.414a1 1 0 00-1.414 1.414L10.586 10l-1.293 1.293a1 1 0 101.414 1.414L12 11.414l1.293 1.293a1 1 0 001.414-1.414L13.414 10l1.293-1.293a1 1 0 00-1.414-1.414L12 8.586l-1.293-1.293z"
        clip-rule="evenodd"
      />
    </svg>
    move to parent
  </span>
</div>`;

  // ../../../../../node_modules/ninja-keys/dist/base-styles.js
  var baseStyles = i`
  :host {
    --ninja-width: 640px;
    --ninja-backdrop-filter: none;
    --ninja-overflow-background: rgba(255, 255, 255, 0.5);
    --ninja-text-color: rgb(60, 65, 73);
    --ninja-font-size: 16px;
    --ninja-top: 20%;

    --ninja-key-border-radius: 0.25em;
    --ninja-accent-color: rgb(110, 94, 210);
    --ninja-secondary-background-color: rgb(239, 241, 244);
    --ninja-secondary-text-color: rgb(107, 111, 118);

    --ninja-selected-background: rgb(248, 249, 251);

    --ninja-icon-color: var(--ninja-secondary-text-color);
    --ninja-icon-size: 1.2em;
    --ninja-separate-border: 1px solid var(--ninja-secondary-background-color);

    --ninja-modal-background: #fff;
    --ninja-modal-shadow: rgb(0 0 0 / 50%) 0px 16px 70px;

    --ninja-actions-height: 300px;
    --ninja-group-text-color: rgb(144, 149, 157);

    --ninja-footer-background: rgba(242, 242, 242, 0.4);

    --ninja-placeholder-color: #8e8e8e;

    font-size: var(--ninja-font-size);

    --ninja-z-index: 1;
  }

  :host(.dark) {
    --ninja-backdrop-filter: none;
    --ninja-overflow-background: rgba(0, 0, 0, 0.7);
    --ninja-text-color: #7d7d7d;

    --ninja-modal-background: rgba(17, 17, 17, 0.85);
    --ninja-accent-color: rgb(110, 94, 210);
    --ninja-secondary-background-color: rgba(51, 51, 51, 0.44);
    --ninja-secondary-text-color: #888;

    --ninja-selected-text-color: #eaeaea;
    --ninja-selected-background: rgba(51, 51, 51, 0.44);

    --ninja-icon-color: var(--ninja-secondary-text-color);
    --ninja-separate-border: 1px solid var(--ninja-secondary-background-color);

    --ninja-modal-shadow: 0 16px 70px rgba(0, 0, 0, 0.2);

    --ninja-group-text-color: rgb(144, 149, 157);

    --ninja-footer-background: rgba(30, 30, 30, 85%);
  }

  .modal {
    display: none;
    position: fixed;
    z-index: var(--ninja-z-index);
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background: var(--ninja-overflow-background);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-backdrop-filter: var(--ninja-backdrop-filter);
    backdrop-filter: var(--ninja-backdrop-filter);
    text-align: left;
    color: var(--ninja-text-color);
    font-family: var(--ninja-font-family);
  }
  .modal.visible {
    display: block;
  }

  .modal-content {
    position: relative;
    top: var(--ninja-top);
    margin: auto;
    padding: 0;
    display: flex;
    flex-direction: column;
    flex-shrink: 1;
    -webkit-box-flex: 1;
    flex-grow: 1;
    min-width: 0px;
    will-change: transform;
    background: var(--ninja-modal-background);
    border-radius: 0.5em;
    box-shadow: var(--ninja-modal-shadow);
    max-width: var(--ninja-width);
    overflow: hidden;
  }

  .bump {
    animation: zoom-in-zoom-out 0.2s ease;
  }

  @keyframes zoom-in-zoom-out {
    0% {
      transform: scale(0.99);
    }
    50% {
      transform: scale(1.01, 1.01);
    }
    100% {
      transform: scale(1, 1);
    }
  }

  .ninja-github {
    color: var(--ninja-keys-text-color);
    font-weight: normal;
    text-decoration: none;
  }

  .actions-list {
    max-height: var(--ninja-actions-height);
    overflow: auto;
    scroll-behavior: smooth;
    position: relative;
    margin: 0;
    padding: 0.5em 0;
    list-style: none;
    scroll-behavior: smooth;
  }

  .group-header {
    height: 1.375em;
    line-height: 1.375em;
    padding-left: 1.25em;
    padding-top: 0.5em;
    text-overflow: ellipsis;
    white-space: nowrap;
    overflow: hidden;
    font-size: 0.75em;
    line-height: 1em;
    color: var(--ninja-group-text-color);
    margin: 1px 0;
  }

  .modal-footer {
    background: var(--ninja-footer-background);
    padding: 0.5em 1em;
    display: flex;
    /* font-size: 0.75em; */
    border-top: var(--ninja-separate-border);
    color: var(--ninja-secondary-text-color);
  }

  .modal-footer .help {
    display: flex;
    margin-right: 1em;
    align-items: center;
    font-size: 0.75em;
  }

  .ninja-examplekey {
    background: var(--ninja-secondary-background-color);
    padding: 0.06em 0.25em;
    border-radius: var(--ninja-key-border-radius);
    color: var(--ninja-secondary-text-color);
    width: 1em;
    height: 1em;
    margin-right: 0.5em;
    font-size: 1.25em;
    fill: currentColor;
  }
  .ninja-examplekey.esc {
    width: auto;
    height: auto;
    font-size: 1.1em;
  }
  .ninja-examplekey.backspace {
    opacity: 0.7;
  }
`;

  // ../../../../../node_modules/ninja-keys/dist/ninja-keys.js
  var __decorate4 = function(decorators, target, key, desc) {
    var c9 = arguments.length, r6 = c9 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r6 = Reflect.decorate(decorators, target, key, desc);
    else for (var i5 = decorators.length - 1; i5 >= 0; i5--) if (d3 = decorators[i5]) r6 = (c9 < 3 ? d3(r6) : c9 > 3 ? d3(target, key, r6) : d3(target, key)) || r6;
    return c9 > 3 && r6 && Object.defineProperty(target, key, r6), r6;
  };
  var NinjaKeys = class NinjaKeys2 extends s4 {
    constructor() {
      super(...arguments);
      this.placeholder = "Type a command or search...";
      this.disableHotkeys = false;
      this.hideBreadcrumbs = false;
      this.openHotkey = "cmd+k,ctrl+k";
      this.navigationUpHotkey = "up,shift+tab";
      this.navigationDownHotkey = "down,tab";
      this.closeHotkey = "esc";
      this.goBackHotkey = "backspace";
      this.selectHotkey = "enter";
      this.hotKeysJoinedView = false;
      this.noAutoLoadMdIcons = false;
      this.data = [];
      this.visible = false;
      this._bump = true;
      this._actionMatches = [];
      this._search = "";
      this._flatData = [];
      this._headerRef = e9();
    }
    /**
     * Public methods
     */
    /**
     * Show a modal
     */
    open(options = {}) {
      this._bump = true;
      this.visible = true;
      this._headerRef.value.focusSearch();
      if (this._actionMatches.length > 0) {
        this._selected = this._actionMatches[0];
      }
      this.setParent(options.parent);
    }
    /**
     * Close modal
     */
    close() {
      this._bump = false;
      this.visible = false;
    }
    /**
     * Navigate to group of actions
     * @param parent id of parent group/action
     */
    setParent(parent) {
      if (!parent) {
        this._currentRoot = void 0;
      } else {
        this._currentRoot = parent;
      }
      this._selected = void 0;
      this._search = "";
      this._headerRef.value.setSearch("");
    }
    get breadcrumbs() {
      var _a;
      const path2 = [];
      let parentAction = (_a = this._selected) === null || _a === void 0 ? void 0 : _a.parent;
      if (parentAction) {
        path2.push(parentAction);
        while (parentAction) {
          const action = this._flatData.find((a5) => a5.id === parentAction);
          if (action === null || action === void 0 ? void 0 : action.parent) {
            path2.push(action.parent);
          }
          parentAction = action ? action.parent : void 0;
        }
      }
      return path2.reverse();
    }
    connectedCallback() {
      super.connectedCallback();
      if (!this.noAutoLoadMdIcons) {
        document.fonts.load("24px Material Icons", "apps").then(() => {
        });
      }
      this._registerInternalHotkeys();
    }
    disconnectedCallback() {
      super.disconnectedCallback();
      this._unregisterInternalHotkeys();
    }
    _flattern(members, parent) {
      let children2 = [];
      if (!members) {
        members = [];
      }
      return members.map((mem) => {
        const alreadyFlatternByUser = mem.children && mem.children.some((value) => {
          return typeof value == "string";
        });
        const m3 = { ...mem, parent: mem.parent || parent };
        if (alreadyFlatternByUser) {
          return m3;
        } else {
          if (m3.children && m3.children.length) {
            parent = mem.id;
            children2 = [...children2, ...m3.children];
          }
          m3.children = m3.children ? m3.children.map((c9) => c9.id) : [];
          return m3;
        }
      }).concat(children2.length ? this._flattern(children2, parent) : children2);
    }
    update(changedProperties) {
      if (changedProperties.has("data") && !this.disableHotkeys) {
        this._flatData = this._flattern(this.data);
        this._flatData.filter((action) => !!action.hotkey).forEach((action) => {
          hotkeys_esm_default(action.hotkey, (event) => {
            event.preventDefault();
            if (action.handler) {
              action.handler(action);
            }
          });
        });
      }
      super.update(changedProperties);
    }
    _registerInternalHotkeys() {
      if (this.openHotkey) {
        hotkeys_esm_default(this.openHotkey, (event) => {
          event.preventDefault();
          this.visible ? this.close() : this.open();
        });
      }
      if (this.selectHotkey) {
        hotkeys_esm_default(this.selectHotkey, (event) => {
          if (!this.visible) {
            return;
          }
          event.preventDefault();
          this._actionSelected(this._actionMatches[this._selectedIndex]);
        });
      }
      if (this.goBackHotkey) {
        hotkeys_esm_default(this.goBackHotkey, (event) => {
          if (!this.visible) {
            return;
          }
          if (!this._search) {
            event.preventDefault();
            this._goBack();
          }
        });
      }
      if (this.navigationDownHotkey) {
        hotkeys_esm_default(this.navigationDownHotkey, (event) => {
          if (!this.visible) {
            return;
          }
          event.preventDefault();
          if (this._selectedIndex >= this._actionMatches.length - 1) {
            this._selected = this._actionMatches[0];
          } else {
            this._selected = this._actionMatches[this._selectedIndex + 1];
          }
        });
      }
      if (this.navigationUpHotkey) {
        hotkeys_esm_default(this.navigationUpHotkey, (event) => {
          if (!this.visible) {
            return;
          }
          event.preventDefault();
          if (this._selectedIndex === 0) {
            this._selected = this._actionMatches[this._actionMatches.length - 1];
          } else {
            this._selected = this._actionMatches[this._selectedIndex - 1];
          }
        });
      }
      if (this.closeHotkey) {
        hotkeys_esm_default(this.closeHotkey, () => {
          if (!this.visible) {
            return;
          }
          this.close();
        });
      }
    }
    _unregisterInternalHotkeys() {
      if (this.openHotkey) {
        hotkeys_esm_default.unbind(this.openHotkey);
      }
      if (this.selectHotkey) {
        hotkeys_esm_default.unbind(this.selectHotkey);
      }
      if (this.goBackHotkey) {
        hotkeys_esm_default.unbind(this.goBackHotkey);
      }
      if (this.navigationDownHotkey) {
        hotkeys_esm_default.unbind(this.navigationDownHotkey);
      }
      if (this.navigationUpHotkey) {
        hotkeys_esm_default.unbind(this.navigationUpHotkey);
      }
      if (this.closeHotkey) {
        hotkeys_esm_default.unbind(this.closeHotkey);
      }
    }
    _actionFocused(index2, $event) {
      this._selected = index2;
      $event.target.ensureInView();
    }
    _onTransitionEnd() {
      this._bump = false;
    }
    _goBack() {
      const parent = this.breadcrumbs.length > 1 ? this.breadcrumbs[this.breadcrumbs.length - 2] : void 0;
      this.setParent(parent);
    }
    render() {
      const classes = {
        bump: this._bump,
        "modal-content": true
      };
      const menuClasses = {
        visible: this.visible,
        modal: true
      };
      const actionMatches = this._flatData.filter((action) => {
        var _a;
        const regex = new RegExp(this._search, "gi");
        const matcher = action.title.match(regex) || ((_a = action.keywords) === null || _a === void 0 ? void 0 : _a.match(regex));
        if (!this._currentRoot && this._search) {
          return matcher;
        }
        return action.parent === this._currentRoot && matcher;
      });
      const sections = actionMatches.reduce((entryMap, e11) => entryMap.set(e11.section, [...entryMap.get(e11.section) || [], e11]), /* @__PURE__ */ new Map());
      this._actionMatches = [...sections.values()].flat();
      if (this._actionMatches.length > 0 && this._selectedIndex === -1) {
        this._selected = this._actionMatches[0];
      }
      if (this._actionMatches.length === 0) {
        this._selected = void 0;
      }
      const actionsList = (actions) => x` ${c4(actions, (action) => action.id, (action) => {
        var _a;
        return x`<ninja-action
            exportparts="ninja-action,ninja-selected,ninja-icon"
            .selected=${l6(action.id === ((_a = this._selected) === null || _a === void 0 ? void 0 : _a.id))}
            .hotKeysJoinedView=${this.hotKeysJoinedView}
            @mouseover=${(event) => this._actionFocused(action, event)}
            @actionsSelected=${(event) => this._actionSelected(event.detail)}
            .action=${action}
          ></ninja-action>`;
      })}`;
      const itemTemplates = [];
      sections.forEach((actions, section) => {
        const header = section ? x`<div class="group-header">${section}</div>` : void 0;
        itemTemplates.push(x`${header}${actionsList(actions)}`);
      });
      return x`
      <div @click=${this._overlayClick} class=${o9(menuClasses)}>
        <div class=${o9(classes)} @animationend=${this._onTransitionEnd}>
          <ninja-header
            exportparts="ninja-input,ninja-input-wrapper"
            ${n8(this._headerRef)}
            .placeholder=${this.placeholder}
            .hideBreadcrumbs=${this.hideBreadcrumbs}
            .breadcrumbs=${this.breadcrumbs}
            @change=${this._handleInput}
            @setParent=${(event) => this.setParent(event.detail.parent)}
            @close=${this.close}
          >
          </ninja-header>
          <div class="modal-body">
            <div class="actions-list" part="actions-list">${itemTemplates}</div>
          </div>
          <slot name="footer"> ${footerHtml} </slot>
        </div>
      </div>
    `;
    }
    get _selectedIndex() {
      if (!this._selected) {
        return -1;
      }
      return this._actionMatches.indexOf(this._selected);
    }
    _actionSelected(action) {
      var _a;
      this.dispatchEvent(new CustomEvent("selected", {
        detail: { search: this._search, action },
        bubbles: true,
        composed: true
      }));
      if (!action) {
        return;
      }
      if (action.children && ((_a = action.children) === null || _a === void 0 ? void 0 : _a.length) > 0) {
        this._currentRoot = action.id;
        this._search = "";
      }
      this._headerRef.value.setSearch("");
      this._headerRef.value.focusSearch();
      if (action.handler) {
        const result = action.handler(action);
        if (!(result === null || result === void 0 ? void 0 : result.keepOpen)) {
          this.close();
        }
      }
      this._bump = true;
    }
    async _handleInput(event) {
      this._search = event.detail.search;
      await this.updateComplete;
      this.dispatchEvent(new CustomEvent("change", {
        detail: { search: this._search, actions: this._actionMatches },
        bubbles: true,
        composed: true
      }));
    }
    _overlayClick(event) {
      var _a;
      if ((_a = event.target) === null || _a === void 0 ? void 0 : _a.classList.contains("modal")) {
        this.close();
      }
    }
  };
  NinjaKeys.styles = [baseStyles];
  __decorate4([
    n5({ type: String })
  ], NinjaKeys.prototype, "placeholder", void 0);
  __decorate4([
    n5({ type: Boolean })
  ], NinjaKeys.prototype, "disableHotkeys", void 0);
  __decorate4([
    n5({ type: Boolean })
  ], NinjaKeys.prototype, "hideBreadcrumbs", void 0);
  __decorate4([
    n5()
  ], NinjaKeys.prototype, "openHotkey", void 0);
  __decorate4([
    n5()
  ], NinjaKeys.prototype, "navigationUpHotkey", void 0);
  __decorate4([
    n5()
  ], NinjaKeys.prototype, "navigationDownHotkey", void 0);
  __decorate4([
    n5()
  ], NinjaKeys.prototype, "closeHotkey", void 0);
  __decorate4([
    n5()
  ], NinjaKeys.prototype, "goBackHotkey", void 0);
  __decorate4([
    n5()
  ], NinjaKeys.prototype, "selectHotkey", void 0);
  __decorate4([
    n5({ type: Boolean })
  ], NinjaKeys.prototype, "hotKeysJoinedView", void 0);
  __decorate4([
    n5({ type: Boolean })
  ], NinjaKeys.prototype, "noAutoLoadMdIcons", void 0);
  __decorate4([
    n5({
      type: Array,
      hasChanged() {
        return true;
      }
    })
  ], NinjaKeys.prototype, "data", void 0);
  __decorate4([
    t3()
  ], NinjaKeys.prototype, "visible", void 0);
  __decorate4([
    t3()
  ], NinjaKeys.prototype, "_bump", void 0);
  __decorate4([
    t3()
  ], NinjaKeys.prototype, "_actionMatches", void 0);
  __decorate4([
    t3()
  ], NinjaKeys.prototype, "_search", void 0);
  __decorate4([
    t3()
  ], NinjaKeys.prototype, "_currentRoot", void 0);
  __decorate4([
    t3()
  ], NinjaKeys.prototype, "_flatData", void 0);
  __decorate4([
    t3()
  ], NinjaKeys.prototype, "breadcrumbs", null);
  __decorate4([
    t3()
  ], NinjaKeys.prototype, "_selected", void 0);
  NinjaKeys = __decorate4([
    e4("ninja-keys")
  ], NinjaKeys);

  // prebundle.js
  var import_algebrite = __toESM(require_algebrite());

  // ../../../../../node_modules/@observablehq/plot/src/index.js
  var src_exports = {};
  __export(src_exports, {
    Area: () => Area,
    Arrow: () => Arrow,
    BarX: () => BarX,
    BarY: () => BarY,
    Cell: () => Cell,
    Contour: () => Contour,
    Density: () => Density,
    Dot: () => Dot,
    Frame: () => Frame,
    Geo: () => Geo,
    Hexgrid: () => Hexgrid,
    Image: () => Image,
    Line: () => Line,
    Link: () => Link,
    Mark: () => Mark,
    Raster: () => Raster,
    Rect: () => Rect,
    RuleX: () => RuleX,
    RuleY: () => RuleY,
    Text: () => Text,
    TickX: () => TickX,
    TickY: () => TickY,
    Tip: () => Tip,
    Vector: () => Vector,
    WaffleX: () => WaffleX,
    WaffleY: () => WaffleY,
    area: () => area,
    areaX: () => areaX,
    areaY: () => areaY,
    arrow: () => arrow,
    auto: () => auto,
    autoSpec: () => autoSpec,
    axisFx: () => axisFx,
    axisFy: () => axisFy,
    axisX: () => axisX,
    axisY: () => axisY,
    barX: () => barX,
    barY: () => barY,
    bin: () => bin,
    binX: () => binX,
    binY: () => binY,
    bollinger: () => bollinger,
    bollingerX: () => bollingerX,
    bollingerY: () => bollingerY,
    boxX: () => boxX,
    boxY: () => boxY,
    cell: () => cell,
    cellX: () => cellX,
    cellY: () => cellY,
    centroid: () => centroid,
    circle: () => circle,
    cluster: () => cluster,
    column: () => column,
    contour: () => contour,
    crosshair: () => crosshair,
    crosshairX: () => crosshairX,
    crosshairY: () => crosshairY,
    delaunayLink: () => delaunayLink,
    delaunayMesh: () => delaunayMesh,
    density: () => density,
    differenceX: () => differenceX,
    differenceY: () => differenceY,
    dodgeX: () => dodgeX,
    dodgeY: () => dodgeY,
    dot: () => dot,
    dotX: () => dotX,
    dotY: () => dotY,
    filter: () => filter4,
    find: () => find2,
    formatIsoDate: () => formatIsoDate,
    formatMonth: () => formatMonth,
    formatNumber: () => formatNumber,
    formatWeekday: () => formatWeekday,
    frame: () => frame3,
    geo: () => geo,
    geoCentroid: () => geoCentroid,
    graticule: () => graticule2,
    gridFx: () => gridFx,
    gridFy: () => gridFy,
    gridX: () => gridX,
    gridY: () => gridY,
    group: () => group2,
    groupX: () => groupX,
    groupY: () => groupY,
    groupZ: () => groupZ,
    hexagon: () => hexagon,
    hexbin: () => hexbin,
    hexgrid: () => hexgrid,
    hull: () => hull,
    identity: () => identity6,
    image: () => image,
    indexOf: () => indexOf,
    initializer: () => initializer,
    interpolateNearest: () => interpolateNearest,
    interpolateNone: () => interpolateNone,
    interpolatorBarycentric: () => interpolatorBarycentric,
    interpolatorRandomWalk: () => interpolatorRandomWalk,
    legend: () => legend,
    line: () => line,
    lineX: () => lineX,
    lineY: () => lineY,
    linearRegressionX: () => linearRegressionX,
    linearRegressionY: () => linearRegressionY,
    link: () => link2,
    map: () => map3,
    mapX: () => mapX,
    mapY: () => mapY,
    marks: () => marks,
    normalize: () => normalize3,
    normalizeX: () => normalizeX,
    normalizeY: () => normalizeY,
    numberInterval: () => numberInterval,
    plot: () => plot,
    pointer: () => pointer,
    pointerX: () => pointerX,
    pointerY: () => pointerY,
    raster: () => raster,
    rect: () => rect2,
    rectX: () => rectX,
    rectY: () => rectY,
    reverse: () => reverse2,
    ruleX: () => ruleX,
    ruleY: () => ruleY,
    scale: () => scale2,
    select: () => select,
    selectFirst: () => selectFirst,
    selectLast: () => selectLast,
    selectMaxX: () => selectMaxX,
    selectMaxY: () => selectMaxY,
    selectMinX: () => selectMinX,
    selectMinY: () => selectMinY,
    shiftX: () => shiftX,
    shiftY: () => shiftY,
    shuffle: () => shuffle,
    sort: () => sort2,
    sphere: () => sphere2,
    spike: () => spike,
    stackX: () => stackX,
    stackX1: () => stackX1,
    stackX2: () => stackX2,
    stackY: () => stackY,
    stackY1: () => stackY1,
    stackY2: () => stackY2,
    text: () => text,
    textX: () => textX,
    textY: () => textY,
    tickX: () => tickX,
    tickY: () => tickY,
    timeInterval: () => timeInterval2,
    tip: () => tip,
    transform: () => basic,
    tree: () => tree,
    treeLink: () => treeLink,
    treeNode: () => treeNode,
    utcInterval: () => utcInterval,
    valueof: () => valueof,
    vector: () => vector,
    vectorX: () => vectorX,
    vectorY: () => vectorY,
    voronoi: () => voronoi,
    voronoiMesh: () => voronoiMesh,
    waffleX: () => waffleX,
    waffleY: () => waffleY,
    window: () => window2,
    windowX: () => windowX,
    windowY: () => windowY
  });

  // ../../../../../node_modules/d3-array/src/ascending.js
  function ascending(a5, b2) {
    return a5 == null || b2 == null ? NaN : a5 < b2 ? -1 : a5 > b2 ? 1 : a5 >= b2 ? 0 : NaN;
  }

  // ../../../../../node_modules/d3-array/src/descending.js
  function descending(a5, b2) {
    return a5 == null || b2 == null ? NaN : b2 < a5 ? -1 : b2 > a5 ? 1 : b2 >= a5 ? 0 : NaN;
  }

  // ../../../../../node_modules/d3-array/src/bisector.js
  function bisector(f7) {
    let compare1, compare2, delta;
    if (f7.length !== 2) {
      compare1 = ascending;
      compare2 = (d3, x3) => ascending(f7(d3), x3);
      delta = (d3, x3) => f7(d3) - x3;
    } else {
      compare1 = f7 === ascending || f7 === descending ? f7 : zero2;
      compare2 = f7;
      delta = f7;
    }
    function left2(a5, x3, lo = 0, hi = a5.length) {
      if (lo < hi) {
        if (compare1(x3, x3) !== 0) return hi;
        do {
          const mid2 = lo + hi >>> 1;
          if (compare2(a5[mid2], x3) < 0) lo = mid2 + 1;
          else hi = mid2;
        } while (lo < hi);
      }
      return lo;
    }
    function right2(a5, x3, lo = 0, hi = a5.length) {
      if (lo < hi) {
        if (compare1(x3, x3) !== 0) return hi;
        do {
          const mid2 = lo + hi >>> 1;
          if (compare2(a5[mid2], x3) <= 0) lo = mid2 + 1;
          else hi = mid2;
        } while (lo < hi);
      }
      return lo;
    }
    function center2(a5, x3, lo = 0, hi = a5.length) {
      const i5 = left2(a5, x3, lo, hi - 1);
      return i5 > lo && delta(a5[i5 - 1], x3) > -delta(a5[i5], x3) ? i5 - 1 : i5;
    }
    return { left: left2, center: center2, right: right2 };
  }
  function zero2() {
    return 0;
  }

  // ../../../../../node_modules/d3-array/src/number.js
  function number(x3) {
    return x3 === null ? NaN : +x3;
  }
  function* numbers(values2, valueof2) {
    if (valueof2 === void 0) {
      for (let value of values2) {
        if (value != null && (value = +value) >= value) {
          yield value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values2) {
        if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
          yield value;
        }
      }
    }
  }

  // ../../../../../node_modules/d3-array/src/bisect.js
  var ascendingBisect = bisector(ascending);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;
  var bisectCenter = bisector(number).center;
  var bisect_default = bisectRight;

  // ../../../../../node_modules/d3-array/src/blur.js
  var blur2 = Blur2(blurf);
  var blurImage = Blur2(blurfImage);
  function Blur2(blur3) {
    return function(data, rx, ry = rx) {
      if (!((rx = +rx) >= 0)) throw new RangeError("invalid rx");
      if (!((ry = +ry) >= 0)) throw new RangeError("invalid ry");
      let { data: values2, width, height } = data;
      if (!((width = Math.floor(width)) >= 0)) throw new RangeError("invalid width");
      if (!((height = Math.floor(height !== void 0 ? height : values2.length / width)) >= 0)) throw new RangeError("invalid height");
      if (!width || !height || !rx && !ry) return data;
      const blurx = rx && blur3(rx);
      const blury = ry && blur3(ry);
      const temp = values2.slice();
      if (blurx && blury) {
        blurh(blurx, temp, values2, width, height);
        blurh(blurx, values2, temp, width, height);
        blurh(blurx, temp, values2, width, height);
        blurv(blury, values2, temp, width, height);
        blurv(blury, temp, values2, width, height);
        blurv(blury, values2, temp, width, height);
      } else if (blurx) {
        blurh(blurx, values2, temp, width, height);
        blurh(blurx, temp, values2, width, height);
        blurh(blurx, values2, temp, width, height);
      } else if (blury) {
        blurv(blury, values2, temp, width, height);
        blurv(blury, temp, values2, width, height);
        blurv(blury, values2, temp, width, height);
      }
      return data;
    };
  }
  function blurh(blur3, T2, S3, w2, h5) {
    for (let y3 = 0, n9 = w2 * h5; y3 < n9; ) {
      blur3(T2, S3, y3, y3 += w2, 1);
    }
  }
  function blurv(blur3, T2, S3, w2, h5) {
    for (let x3 = 0, n9 = w2 * h5; x3 < w2; ++x3) {
      blur3(T2, S3, x3, x3 + n9, w2);
    }
  }
  function blurfImage(radius2) {
    const blur3 = blurf(radius2);
    return (T2, S3, start2, stop2, step3) => {
      start2 <<= 2, stop2 <<= 2, step3 <<= 2;
      blur3(T2, S3, start2 + 0, stop2 + 0, step3);
      blur3(T2, S3, start2 + 1, stop2 + 1, step3);
      blur3(T2, S3, start2 + 2, stop2 + 2, step3);
      blur3(T2, S3, start2 + 3, stop2 + 3, step3);
    };
  }
  function blurf(radius2) {
    const radius0 = Math.floor(radius2);
    if (radius0 === radius2) return bluri(radius2);
    const t5 = radius2 - radius0;
    const w2 = 2 * radius2 + 1;
    return (T2, S3, start2, stop2, step3) => {
      if (!((stop2 -= step3) >= start2)) return;
      let sum3 = radius0 * S3[start2];
      const s0 = step3 * radius0;
      const s1 = s0 + step3;
      for (let i5 = start2, j2 = start2 + s0; i5 < j2; i5 += step3) {
        sum3 += S3[Math.min(stop2, i5)];
      }
      for (let i5 = start2, j2 = stop2; i5 <= j2; i5 += step3) {
        sum3 += S3[Math.min(stop2, i5 + s0)];
        T2[i5] = (sum3 + t5 * (S3[Math.max(start2, i5 - s1)] + S3[Math.min(stop2, i5 + s1)])) / w2;
        sum3 -= S3[Math.max(start2, i5 - s0)];
      }
    };
  }
  function bluri(radius2) {
    const w2 = 2 * radius2 + 1;
    return (T2, S3, start2, stop2, step3) => {
      if (!((stop2 -= step3) >= start2)) return;
      let sum3 = radius2 * S3[start2];
      const s8 = step3 * radius2;
      for (let i5 = start2, j2 = start2 + s8; i5 < j2; i5 += step3) {
        sum3 += S3[Math.min(stop2, i5)];
      }
      for (let i5 = start2, j2 = stop2; i5 <= j2; i5 += step3) {
        sum3 += S3[Math.min(stop2, i5 + s8)];
        T2[i5] = sum3 / w2;
        sum3 -= S3[Math.max(start2, i5 - s8)];
      }
    };
  }

  // ../../../../../node_modules/d3-array/src/count.js
  function count2(values2, valueof2) {
    let count4 = 0;
    if (valueof2 === void 0) {
      for (let value of values2) {
        if (value != null && (value = +value) >= value) {
          ++count4;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values2) {
        if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
          ++count4;
        }
      }
    }
    return count4;
  }

  // ../../../../../node_modules/d3-array/src/cross.js
  function length2(array3) {
    return array3.length | 0;
  }
  function empty(length4) {
    return !(length4 > 0);
  }
  function arrayify(values2) {
    return typeof values2 !== "object" || "length" in values2 ? values2 : Array.from(values2);
  }
  function reducer(reduce) {
    return (values2) => reduce(...values2);
  }
  function cross(...values2) {
    const reduce = typeof values2[values2.length - 1] === "function" && reducer(values2.pop());
    values2 = values2.map(arrayify);
    const lengths = values2.map(length2);
    const j2 = values2.length - 1;
    const index2 = new Array(j2 + 1).fill(0);
    const product = [];
    if (j2 < 0 || lengths.some(empty)) return product;
    while (true) {
      product.push(index2.map((j3, i6) => values2[i6][j3]));
      let i5 = j2;
      while (++index2[i5] === lengths[i5]) {
        if (i5 === 0) return reduce ? product.map(reduce) : product;
        index2[i5--] = 0;
      }
    }
  }

  // ../../../../../node_modules/d3-array/src/cumsum.js
  function cumsum(values2, valueof2) {
    var sum3 = 0, index2 = 0;
    return Float64Array.from(values2, valueof2 === void 0 ? (v3) => sum3 += +v3 || 0 : (v3) => sum3 += +valueof2(v3, index2++, values2) || 0);
  }

  // ../../../../../node_modules/d3-array/src/variance.js
  function variance(values2, valueof2) {
    let count4 = 0;
    let delta;
    let mean2 = 0;
    let sum3 = 0;
    if (valueof2 === void 0) {
      for (let value of values2) {
        if (value != null && (value = +value) >= value) {
          delta = value - mean2;
          mean2 += delta / ++count4;
          sum3 += delta * (value - mean2);
        }
      }
    } else {
      let index2 = -1;
      for (let value of values2) {
        if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
          delta = value - mean2;
          mean2 += delta / ++count4;
          sum3 += delta * (value - mean2);
        }
      }
    }
    if (count4 > 1) return sum3 / (count4 - 1);
  }

  // ../../../../../node_modules/d3-array/src/deviation.js
  function deviation(values2, valueof2) {
    const v3 = variance(values2, valueof2);
    return v3 ? Math.sqrt(v3) : v3;
  }

  // ../../../../../node_modules/d3-array/src/extent.js
  function extent(values2, valueof2) {
    let min4;
    let max3;
    if (valueof2 === void 0) {
      for (const value of values2) {
        if (value != null) {
          if (min4 === void 0) {
            if (value >= value) min4 = max3 = value;
          } else {
            if (min4 > value) min4 = value;
            if (max3 < value) max3 = value;
          }
        }
      }
    } else {
      let index2 = -1;
      for (let value of values2) {
        if ((value = valueof2(value, ++index2, values2)) != null) {
          if (min4 === void 0) {
            if (value >= value) min4 = max3 = value;
          } else {
            if (min4 > value) min4 = value;
            if (max3 < value) max3 = value;
          }
        }
      }
    }
    return [min4, max3];
  }

  // ../../../../../node_modules/d3-array/src/fsum.js
  var Adder = class {
    constructor() {
      this._partials = new Float64Array(32);
      this._n = 0;
    }
    add(x3) {
      const p11 = this._partials;
      let i5 = 0;
      for (let j2 = 0; j2 < this._n && j2 < 32; j2++) {
        const y3 = p11[j2], hi = x3 + y3, lo = Math.abs(x3) < Math.abs(y3) ? x3 - (hi - y3) : y3 - (hi - x3);
        if (lo) p11[i5++] = lo;
        x3 = hi;
      }
      p11[i5] = x3;
      this._n = i5 + 1;
      return this;
    }
    valueOf() {
      const p11 = this._partials;
      let n9 = this._n, x3, y3, lo, hi = 0;
      if (n9 > 0) {
        hi = p11[--n9];
        while (n9 > 0) {
          x3 = hi;
          y3 = p11[--n9];
          hi = x3 + y3;
          lo = y3 - (hi - x3);
          if (lo) break;
        }
        if (n9 > 0 && (lo < 0 && p11[n9 - 1] < 0 || lo > 0 && p11[n9 - 1] > 0)) {
          y3 = lo * 2;
          x3 = hi + y3;
          if (y3 == x3 - hi) hi = x3;
        }
      }
      return hi;
    }
  };

  // ../../../../../node_modules/internmap/src/index.js
  var InternMap = class extends Map {
    constructor(entries, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (entries != null) for (const [key2, value] of entries) this.set(key2, value);
    }
    get(key) {
      return super.get(intern_get(this, key));
    }
    has(key) {
      return super.has(intern_get(this, key));
    }
    set(key, value) {
      return super.set(intern_set(this, key), value);
    }
    delete(key) {
      return super.delete(intern_delete(this, key));
    }
  };
  var InternSet = class extends Set {
    constructor(values2, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (values2 != null) for (const value of values2) this.add(value);
    }
    has(value) {
      return super.has(intern_get(this, value));
    }
    add(value) {
      return super.add(intern_set(this, value));
    }
    delete(value) {
      return super.delete(intern_delete(this, value));
    }
  };
  function intern_get({ _intern, _key }, value) {
    const key = _key(value);
    return _intern.has(key) ? _intern.get(key) : value;
  }
  function intern_set({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) return _intern.get(key);
    _intern.set(key, value);
    return value;
  }
  function intern_delete({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) {
      value = _intern.get(key);
      _intern.delete(key);
    }
    return value;
  }
  function keyof(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }

  // ../../../../../node_modules/d3-array/src/identity.js
  function identity(x3) {
    return x3;
  }

  // ../../../../../node_modules/d3-array/src/group.js
  function group(values2, ...keys) {
    return nest(values2, identity, identity, keys);
  }
  function rollup(values2, reduce, ...keys) {
    return nest(values2, identity, reduce, keys);
  }
  function rollups(values2, reduce, ...keys) {
    return nest(values2, Array.from, reduce, keys);
  }
  function nest(values2, map4, reduce, keys) {
    return function regroup(values3, i5) {
      if (i5 >= keys.length) return reduce(values3);
      const groups2 = new InternMap();
      const keyof3 = keys[i5++];
      let index2 = -1;
      for (const value of values3) {
        const key = keyof3(value, ++index2, values3);
        const group3 = groups2.get(key);
        if (group3) group3.push(value);
        else groups2.set(key, [value]);
      }
      for (const [key, values4] of groups2) {
        groups2.set(key, regroup(values4, i5));
      }
      return map4(groups2);
    }(values2, 0);
  }

  // ../../../../../node_modules/d3-array/src/permute.js
  function permute(source, keys) {
    return Array.from(keys, (key) => source[key]);
  }

  // ../../../../../node_modules/d3-array/src/sort.js
  function sort(values2, ...F) {
    if (typeof values2[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    values2 = Array.from(values2);
    let [f7] = F;
    if (f7 && f7.length !== 2 || F.length > 1) {
      const index2 = Uint32Array.from(values2, (d3, i5) => i5);
      if (F.length > 1) {
        F = F.map((f8) => values2.map(f8));
        index2.sort((i5, j2) => {
          for (const f8 of F) {
            const c9 = ascendingDefined(f8[i5], f8[j2]);
            if (c9) return c9;
          }
        });
      } else {
        f7 = values2.map(f7);
        index2.sort((i5, j2) => ascendingDefined(f7[i5], f7[j2]));
      }
      return permute(values2, index2);
    }
    return values2.sort(compareDefined(f7));
  }
  function compareDefined(compare = ascending) {
    if (compare === ascending) return ascendingDefined;
    if (typeof compare !== "function") throw new TypeError("compare is not a function");
    return (a5, b2) => {
      const x3 = compare(a5, b2);
      if (x3 || x3 === 0) return x3;
      return (compare(b2, b2) === 0) - (compare(a5, a5) === 0);
    };
  }
  function ascendingDefined(a5, b2) {
    return (a5 == null || !(a5 >= a5)) - (b2 == null || !(b2 >= b2)) || (a5 < b2 ? -1 : a5 > b2 ? 1 : 0);
  }

  // ../../../../../node_modules/d3-array/src/groupSort.js
  function groupSort(values2, reduce, key) {
    return (reduce.length !== 2 ? sort(rollup(values2, reduce, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort(group(values2, key), ([ak, av], [bk, bv]) => reduce(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
  }

  // ../../../../../node_modules/d3-array/src/ticks.js
  var e102 = Math.sqrt(50);
  var e52 = Math.sqrt(10);
  var e22 = Math.sqrt(2);
  function tickSpec(start2, stop2, count4) {
    const step3 = (stop2 - start2) / Math.max(0, count4), power2 = Math.floor(Math.log10(step3)), error = step3 / Math.pow(10, power2), factor2 = error >= e102 ? 10 : error >= e52 ? 5 : error >= e22 ? 2 : 1;
    let i12, i22, inc2;
    if (power2 < 0) {
      inc2 = Math.pow(10, -power2) / factor2;
      i12 = Math.round(start2 * inc2);
      i22 = Math.round(stop2 * inc2);
      if (i12 / inc2 < start2) ++i12;
      if (i22 / inc2 > stop2) --i22;
      inc2 = -inc2;
    } else {
      inc2 = Math.pow(10, power2) * factor2;
      i12 = Math.round(start2 / inc2);
      i22 = Math.round(stop2 / inc2);
      if (i12 * inc2 < start2) ++i12;
      if (i22 * inc2 > stop2) --i22;
    }
    if (i22 < i12 && 0.5 <= count4 && count4 < 2) return tickSpec(start2, stop2, count4 * 2);
    return [i12, i22, inc2];
  }
  function ticks(start2, stop2, count4) {
    stop2 = +stop2, start2 = +start2, count4 = +count4;
    if (!(count4 > 0)) return [];
    if (start2 === stop2) return [start2];
    const reverse3 = stop2 < start2, [i12, i22, inc2] = reverse3 ? tickSpec(stop2, start2, count4) : tickSpec(start2, stop2, count4);
    if (!(i22 >= i12)) return [];
    const n9 = i22 - i12 + 1, ticks2 = new Array(n9);
    if (reverse3) {
      if (inc2 < 0) for (let i5 = 0; i5 < n9; ++i5) ticks2[i5] = (i22 - i5) / -inc2;
      else for (let i5 = 0; i5 < n9; ++i5) ticks2[i5] = (i22 - i5) * inc2;
    } else {
      if (inc2 < 0) for (let i5 = 0; i5 < n9; ++i5) ticks2[i5] = (i12 + i5) / -inc2;
      else for (let i5 = 0; i5 < n9; ++i5) ticks2[i5] = (i12 + i5) * inc2;
    }
    return ticks2;
  }
  function tickIncrement(start2, stop2, count4) {
    stop2 = +stop2, start2 = +start2, count4 = +count4;
    return tickSpec(start2, stop2, count4)[2];
  }
  function tickStep(start2, stop2, count4) {
    stop2 = +stop2, start2 = +start2, count4 = +count4;
    const reverse3 = stop2 < start2, inc2 = reverse3 ? tickIncrement(stop2, start2, count4) : tickIncrement(start2, stop2, count4);
    return (reverse3 ? -1 : 1) * (inc2 < 0 ? 1 / -inc2 : inc2);
  }

  // ../../../../../node_modules/d3-array/src/nice.js
  function nice(start2, stop2, count4) {
    let prestep;
    while (true) {
      const step3 = tickIncrement(start2, stop2, count4);
      if (step3 === prestep || step3 === 0 || !isFinite(step3)) {
        return [start2, stop2];
      } else if (step3 > 0) {
        start2 = Math.floor(start2 / step3) * step3;
        stop2 = Math.ceil(stop2 / step3) * step3;
      } else if (step3 < 0) {
        start2 = Math.ceil(start2 * step3) / step3;
        stop2 = Math.floor(stop2 * step3) / step3;
      }
      prestep = step3;
    }
  }

  // ../../../../../node_modules/d3-array/src/threshold/sturges.js
  function thresholdSturges(values2) {
    return Math.max(1, Math.ceil(Math.log(count2(values2)) / Math.LN2) + 1);
  }

  // ../../../../../node_modules/d3-array/src/max.js
  function max(values2, valueof2) {
    let max3;
    if (valueof2 === void 0) {
      for (const value of values2) {
        if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
          max3 = value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values2) {
        if ((value = valueof2(value, ++index2, values2)) != null && (max3 < value || max3 === void 0 && value >= value)) {
          max3 = value;
        }
      }
    }
    return max3;
  }

  // ../../../../../node_modules/d3-array/src/maxIndex.js
  function maxIndex(values2, valueof2) {
    let max3;
    let maxIndex2 = -1;
    let index2 = -1;
    if (valueof2 === void 0) {
      for (const value of values2) {
        ++index2;
        if (value != null && (max3 < value || max3 === void 0 && value >= value)) {
          max3 = value, maxIndex2 = index2;
        }
      }
    } else {
      for (let value of values2) {
        if ((value = valueof2(value, ++index2, values2)) != null && (max3 < value || max3 === void 0 && value >= value)) {
          max3 = value, maxIndex2 = index2;
        }
      }
    }
    return maxIndex2;
  }

  // ../../../../../node_modules/d3-array/src/min.js
  function min(values2, valueof2) {
    let min4;
    if (valueof2 === void 0) {
      for (const value of values2) {
        if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
          min4 = value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values2) {
        if ((value = valueof2(value, ++index2, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {
          min4 = value;
        }
      }
    }
    return min4;
  }

  // ../../../../../node_modules/d3-array/src/minIndex.js
  function minIndex(values2, valueof2) {
    let min4;
    let minIndex2 = -1;
    let index2 = -1;
    if (valueof2 === void 0) {
      for (const value of values2) {
        ++index2;
        if (value != null && (min4 > value || min4 === void 0 && value >= value)) {
          min4 = value, minIndex2 = index2;
        }
      }
    } else {
      for (let value of values2) {
        if ((value = valueof2(value, ++index2, values2)) != null && (min4 > value || min4 === void 0 && value >= value)) {
          min4 = value, minIndex2 = index2;
        }
      }
    }
    return minIndex2;
  }

  // ../../../../../node_modules/d3-array/src/quickselect.js
  function quickselect(array3, k3, left2 = 0, right2 = Infinity, compare) {
    k3 = Math.floor(k3);
    left2 = Math.floor(Math.max(0, left2));
    right2 = Math.floor(Math.min(array3.length - 1, right2));
    if (!(left2 <= k3 && k3 <= right2)) return array3;
    compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
    while (right2 > left2) {
      if (right2 - left2 > 600) {
        const n9 = right2 - left2 + 1;
        const m3 = k3 - left2 + 1;
        const z2 = Math.log(n9);
        const s8 = 0.5 * Math.exp(2 * z2 / 3);
        const sd = 0.5 * Math.sqrt(z2 * s8 * (n9 - s8) / n9) * (m3 - n9 / 2 < 0 ? -1 : 1);
        const newLeft = Math.max(left2, Math.floor(k3 - m3 * s8 / n9 + sd));
        const newRight = Math.min(right2, Math.floor(k3 + (n9 - m3) * s8 / n9 + sd));
        quickselect(array3, k3, newLeft, newRight, compare);
      }
      const t5 = array3[k3];
      let i5 = left2;
      let j2 = right2;
      swap2(array3, left2, k3);
      if (compare(array3[right2], t5) > 0) swap2(array3, left2, right2);
      while (i5 < j2) {
        swap2(array3, i5, j2), ++i5, --j2;
        while (compare(array3[i5], t5) < 0) ++i5;
        while (compare(array3[j2], t5) > 0) --j2;
      }
      if (compare(array3[left2], t5) === 0) swap2(array3, left2, j2);
      else ++j2, swap2(array3, j2, right2);
      if (j2 <= k3) left2 = j2 + 1;
      if (k3 <= j2) right2 = j2 - 1;
    }
    return array3;
  }
  function swap2(array3, i5, j2) {
    const t5 = array3[i5];
    array3[i5] = array3[j2];
    array3[j2] = t5;
  }

  // ../../../../../node_modules/d3-array/src/greatest.js
  function greatest(values2, compare = ascending) {
    let max3;
    let defined2 = false;
    if (compare.length === 1) {
      let maxValue;
      for (const element of values2) {
        const value = compare(element);
        if (defined2 ? ascending(value, maxValue) > 0 : ascending(value, value) === 0) {
          max3 = element;
          maxValue = value;
          defined2 = true;
        }
      }
    } else {
      for (const value of values2) {
        if (defined2 ? compare(value, max3) > 0 : compare(value, value) === 0) {
          max3 = value;
          defined2 = true;
        }
      }
    }
    return max3;
  }

  // ../../../../../node_modules/d3-array/src/quantile.js
  function quantile(values2, p11, valueof2) {
    values2 = Float64Array.from(numbers(values2, valueof2));
    if (!(n9 = values2.length) || isNaN(p11 = +p11)) return;
    if (p11 <= 0 || n9 < 2) return min(values2);
    if (p11 >= 1) return max(values2);
    var n9, i5 = (n9 - 1) * p11, i0 = Math.floor(i5), value0 = max(quickselect(values2, i0).subarray(0, i0 + 1)), value1 = min(values2.subarray(i0 + 1));
    return value0 + (value1 - value0) * (i5 - i0);
  }
  function quantileSorted(values2, p11, valueof2 = number) {
    if (!(n9 = values2.length) || isNaN(p11 = +p11)) return;
    if (p11 <= 0 || n9 < 2) return +valueof2(values2[0], 0, values2);
    if (p11 >= 1) return +valueof2(values2[n9 - 1], n9 - 1, values2);
    var n9, i5 = (n9 - 1) * p11, i0 = Math.floor(i5), value0 = +valueof2(values2[i0], i0, values2), value1 = +valueof2(values2[i0 + 1], i0 + 1, values2);
    return value0 + (value1 - value0) * (i5 - i0);
  }

  // ../../../../../node_modules/d3-array/src/threshold/freedmanDiaconis.js
  function thresholdFreedmanDiaconis(values2, min4, max3) {
    const c9 = count2(values2), d3 = quantile(values2, 0.75) - quantile(values2, 0.25);
    return c9 && d3 ? Math.ceil((max3 - min4) / (2 * d3 * Math.pow(c9, -1 / 3))) : 1;
  }

  // ../../../../../node_modules/d3-array/src/threshold/scott.js
  function thresholdScott(values2, min4, max3) {
    const c9 = count2(values2), d3 = deviation(values2);
    return c9 && d3 ? Math.ceil((max3 - min4) * Math.cbrt(c9) / (3.49 * d3)) : 1;
  }

  // ../../../../../node_modules/d3-array/src/mean.js
  function mean(values2, valueof2) {
    let count4 = 0;
    let sum3 = 0;
    if (valueof2 === void 0) {
      for (let value of values2) {
        if (value != null && (value = +value) >= value) {
          ++count4, sum3 += value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values2) {
        if ((value = valueof2(value, ++index2, values2)) != null && (value = +value) >= value) {
          ++count4, sum3 += value;
        }
      }
    }
    if (count4) return sum3 / count4;
  }

  // ../../../../../node_modules/d3-array/src/median.js
  function median(values2, valueof2) {
    return quantile(values2, 0.5, valueof2);
  }

  // ../../../../../node_modules/d3-array/src/merge.js
  function* flatten(arrays) {
    for (const array3 of arrays) {
      yield* array3;
    }
  }
  function merge(arrays) {
    return Array.from(flatten(arrays));
  }

  // ../../../../../node_modules/d3-array/src/mode.js
  function mode(values2, valueof2) {
    const counts = new InternMap();
    if (valueof2 === void 0) {
      for (let value of values2) {
        if (value != null && value >= value) {
          counts.set(value, (counts.get(value) || 0) + 1);
        }
      }
    } else {
      let index2 = -1;
      for (let value of values2) {
        if ((value = valueof2(value, ++index2, values2)) != null && value >= value) {
          counts.set(value, (counts.get(value) || 0) + 1);
        }
      }
    }
    let modeValue;
    let modeCount = 0;
    for (const [value, count4] of counts) {
      if (count4 > modeCount) {
        modeCount = count4;
        modeValue = value;
      }
    }
    return modeValue;
  }

  // ../../../../../node_modules/d3-array/src/pairs.js
  function pairs(values2, pairof = pair) {
    const pairs2 = [];
    let previous;
    let first2 = false;
    for (const value of values2) {
      if (first2) pairs2.push(pairof(previous, value));
      previous = value;
      first2 = true;
    }
    return pairs2;
  }
  function pair(a5, b2) {
    return [a5, b2];
  }

  // ../../../../../node_modules/d3-array/src/range.js
  function range(start2, stop2, step3) {
    start2 = +start2, stop2 = +stop2, step3 = (n9 = arguments.length) < 2 ? (stop2 = start2, start2 = 0, 1) : n9 < 3 ? 1 : +step3;
    var i5 = -1, n9 = Math.max(0, Math.ceil((stop2 - start2) / step3)) | 0, range3 = new Array(n9);
    while (++i5 < n9) {
      range3[i5] = start2 + i5 * step3;
    }
    return range3;
  }

  // ../../../../../node_modules/d3-array/src/rank.js
  function rank(values2, valueof2 = ascending) {
    if (typeof values2[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    let V2 = Array.from(values2);
    const R2 = new Float64Array(V2.length);
    if (valueof2.length !== 2) V2 = V2.map(valueof2), valueof2 = ascending;
    const compareIndex = (i5, j2) => valueof2(V2[i5], V2[j2]);
    let k3, r6;
    values2 = Uint32Array.from(V2, (_2, i5) => i5);
    values2.sort(valueof2 === ascending ? (i5, j2) => ascendingDefined(V2[i5], V2[j2]) : compareDefined(compareIndex));
    values2.forEach((j2, i5) => {
      const c9 = compareIndex(j2, k3 === void 0 ? j2 : k3);
      if (c9 >= 0) {
        if (k3 === void 0 || c9 > 0) k3 = j2, r6 = i5;
        R2[j2] = r6;
      } else {
        R2[j2] = NaN;
      }
    });
    return R2;
  }

  // ../../../../../node_modules/d3-array/src/least.js
  function least(values2, compare = ascending) {
    let min4;
    let defined2 = false;
    if (compare.length === 1) {
      let minValue;
      for (const element of values2) {
        const value = compare(element);
        if (defined2 ? ascending(value, minValue) < 0 : ascending(value, value) === 0) {
          min4 = element;
          minValue = value;
          defined2 = true;
        }
      }
    } else {
      for (const value of values2) {
        if (defined2 ? compare(value, min4) < 0 : compare(value, value) === 0) {
          min4 = value;
          defined2 = true;
        }
      }
    }
    return min4;
  }

  // ../../../../../node_modules/d3-array/src/sum.js
  function sum(values2, valueof2) {
    let sum3 = 0;
    if (valueof2 === void 0) {
      for (let value of values2) {
        if (value = +value) {
          sum3 += value;
        }
      }
    } else {
      let index2 = -1;
      for (let value of values2) {
        if (value = +valueof2(value, ++index2, values2)) {
          sum3 += value;
        }
      }
    }
    return sum3;
  }

  // ../../../../../node_modules/d3-array/src/reverse.js
  function reverse(values2) {
    if (typeof values2[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    return Array.from(values2).reverse();
  }

  // ../../../../../node_modules/d3-axis/src/identity.js
  function identity_default(x3) {
    return x3;
  }

  // ../../../../../node_modules/d3-axis/src/axis.js
  var top2 = 1;
  var right = 2;
  var bottom = 3;
  var left = 4;
  var epsilon = 1e-6;
  function translateX(x3) {
    return "translate(" + x3 + ",0)";
  }
  function translateY(y3) {
    return "translate(0," + y3 + ")";
  }
  function number2(scale3) {
    return (d3) => +scale3(d3);
  }
  function center(scale3, offset2) {
    offset2 = Math.max(0, scale3.bandwidth() - offset2 * 2) / 2;
    if (scale3.round()) offset2 = Math.round(offset2);
    return (d3) => +scale3(d3) + offset2;
  }
  function entering() {
    return !this.__axis;
  }
  function axis(orient, scale3) {
    var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset2 = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k3 = orient === top2 || orient === left ? -1 : 1, x3 = orient === left || orient === right ? "x" : "y", transform3 = orient === top2 || orient === bottom ? translateX : translateY;
    function axis2(context) {
      var values2 = tickValues == null ? scale3.ticks ? scale3.ticks.apply(scale3, tickArguments) : scale3.domain() : tickValues, format3 = tickFormat2 == null ? scale3.tickFormat ? scale3.tickFormat.apply(scale3, tickArguments) : identity_default : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range3 = scale3.range(), range0 = +range3[0] + offset2, range1 = +range3[range3.length - 1] + offset2, position3 = (scale3.bandwidth ? center : number2)(scale3.copy(), offset2), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values2, scale3).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line2 = tick.select("line"), text2 = tick.select("text");
      path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
      tick = tick.merge(tickEnter);
      line2 = line2.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x3 + "2", k3 * tickSizeInner));
      text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x3, k3 * spacing).attr("dy", orient === top2 ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
      if (context !== selection2) {
        path2 = path2.transition(context);
        tick = tick.transition(context);
        line2 = line2.transition(context);
        text2 = text2.transition(context);
        tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function(d3) {
          return isFinite(d3 = position3(d3)) ? transform3(d3 + offset2) : this.getAttribute("transform");
        });
        tickEnter.attr("opacity", epsilon).attr("transform", function(d3) {
          var p11 = this.parentNode.__axis;
          return transform3((p11 && isFinite(p11 = p11(d3)) ? p11 : position3(d3)) + offset2);
        });
      }
      tickExit.remove();
      path2.attr("d", orient === left || orient === right ? tickSizeOuter ? "M" + k3 * tickSizeOuter + "," + range0 + "H" + offset2 + "V" + range1 + "H" + k3 * tickSizeOuter : "M" + offset2 + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k3 * tickSizeOuter + "V" + offset2 + "H" + range1 + "V" + k3 * tickSizeOuter : "M" + range0 + "," + offset2 + "H" + range1);
      tick.attr("opacity", 1).attr("transform", function(d3) {
        return transform3(position3(d3) + offset2);
      });
      line2.attr(x3 + "2", k3 * tickSizeInner);
      text2.attr(x3, k3 * spacing).text(format3);
      selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
      selection2.each(function() {
        this.__axis = position3;
      });
    }
    axis2.scale = function(_2) {
      return arguments.length ? (scale3 = _2, axis2) : scale3;
    };
    axis2.ticks = function() {
      return tickArguments = Array.from(arguments), axis2;
    };
    axis2.tickArguments = function(_2) {
      return arguments.length ? (tickArguments = _2 == null ? [] : Array.from(_2), axis2) : tickArguments.slice();
    };
    axis2.tickValues = function(_2) {
      return arguments.length ? (tickValues = _2 == null ? null : Array.from(_2), axis2) : tickValues && tickValues.slice();
    };
    axis2.tickFormat = function(_2) {
      return arguments.length ? (tickFormat2 = _2, axis2) : tickFormat2;
    };
    axis2.tickSize = function(_2) {
      return arguments.length ? (tickSizeInner = tickSizeOuter = +_2, axis2) : tickSizeInner;
    };
    axis2.tickSizeInner = function(_2) {
      return arguments.length ? (tickSizeInner = +_2, axis2) : tickSizeInner;
    };
    axis2.tickSizeOuter = function(_2) {
      return arguments.length ? (tickSizeOuter = +_2, axis2) : tickSizeOuter;
    };
    axis2.tickPadding = function(_2) {
      return arguments.length ? (tickPadding = +_2, axis2) : tickPadding;
    };
    axis2.offset = function(_2) {
      return arguments.length ? (offset2 = +_2, axis2) : offset2;
    };
    return axis2;
  }
  function axisBottom(scale3) {
    return axis(bottom, scale3);
  }

  // ../../../../../node_modules/d3-dispatch/src/dispatch.js
  var noop = { value: () => {
  } };
  function dispatch2() {
    for (var i5 = 0, n9 = arguments.length, _2 = {}, t5; i5 < n9; ++i5) {
      if (!(t5 = arguments[i5] + "") || t5 in _2 || /[\s.]/.test(t5)) throw new Error("illegal type: " + t5);
      _2[t5] = [];
    }
    return new Dispatch(_2);
  }
  function Dispatch(_2) {
    this._ = _2;
  }
  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t5) {
      var name = "", i5 = t5.indexOf(".");
      if (i5 >= 0) name = t5.slice(i5 + 1), t5 = t5.slice(0, i5);
      if (t5 && !types.hasOwnProperty(t5)) throw new Error("unknown type: " + t5);
      return { type: t5, name };
    });
  }
  Dispatch.prototype = dispatch2.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _2 = this._, T2 = parseTypenames(typename + "", _2), t5, i5 = -1, n9 = T2.length;
      if (arguments.length < 2) {
        while (++i5 < n9) if ((t5 = (typename = T2[i5]).type) && (t5 = get(_2[t5], typename.name))) return t5;
        return;
      }
      if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
      while (++i5 < n9) {
        if (t5 = (typename = T2[i5]).type) _2[t5] = set(_2[t5], typename.name, callback);
        else if (callback == null) for (t5 in _2) _2[t5] = set(_2[t5], typename.name, null);
      }
      return this;
    },
    copy: function() {
      var copy3 = {}, _2 = this._;
      for (var t5 in _2) copy3[t5] = _2[t5].slice();
      return new Dispatch(copy3);
    },
    call: function(type2, that) {
      if ((n9 = arguments.length - 2) > 0) for (var args2 = new Array(n9), i5 = 0, n9, t5; i5 < n9; ++i5) args2[i5] = arguments[i5 + 2];
      if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
      for (t5 = this._[type2], i5 = 0, n9 = t5.length; i5 < n9; ++i5) t5[i5].value.apply(that, args2);
    },
    apply: function(type2, that, args2) {
      if (!this._.hasOwnProperty(type2)) throw new Error("unknown type: " + type2);
      for (var t5 = this._[type2], i5 = 0, n9 = t5.length; i5 < n9; ++i5) t5[i5].value.apply(that, args2);
    }
  };
  function get(type2, name) {
    for (var i5 = 0, n9 = type2.length, c9; i5 < n9; ++i5) {
      if ((c9 = type2[i5]).name === name) {
        return c9.value;
      }
    }
  }
  function set(type2, name, callback) {
    for (var i5 = 0, n9 = type2.length; i5 < n9; ++i5) {
      if (type2[i5].name === name) {
        type2[i5] = noop, type2 = type2.slice(0, i5).concat(type2.slice(i5 + 1));
        break;
      }
    }
    if (callback != null) type2.push({ name, value: callback });
    return type2;
  }
  var dispatch_default = dispatch2;

  // ../../../../../node_modules/d3-selection/src/namespaces.js
  var xhtml = "http://www.w3.org/1999/xhtml";
  var namespaces_default = {
    svg: "http://www.w3.org/2000/svg",
    xhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };

  // ../../../../../node_modules/d3-selection/src/namespace.js
  function namespace_default(name) {
    var prefix = name += "", i5 = prefix.indexOf(":");
    if (i5 >= 0 && (prefix = name.slice(0, i5)) !== "xmlns") name = name.slice(i5 + 1);
    return namespaces_default.hasOwnProperty(prefix) ? { space: namespaces_default[prefix], local: name } : name;
  }

  // ../../../../../node_modules/d3-selection/src/creator.js
  function creatorInherit(name) {
    return function() {
      var document2 = this.ownerDocument, uri = this.namespaceURI;
      return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
    };
  }
  function creatorFixed(fullname) {
    return function() {
      return this.ownerDocument.createElementNS(fullname.space, fullname.local);
    };
  }
  function creator_default(name) {
    var fullname = namespace_default(name);
    return (fullname.local ? creatorFixed : creatorInherit)(fullname);
  }

  // ../../../../../node_modules/d3-selection/src/selector.js
  function none() {
  }
  function selector_default(selector) {
    return selector == null ? none : function() {
      return this.querySelector(selector);
    };
  }

  // ../../../../../node_modules/d3-selection/src/selection/select.js
  function select_default(select2) {
    if (typeof select2 !== "function") select2 = selector_default(select2);
    for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j2 = 0; j2 < m3; ++j2) {
      for (var group3 = groups2[j2], n9 = group3.length, subgroup = subgroups[j2] = new Array(n9), node, subnode, i5 = 0; i5 < n9; ++i5) {
        if ((node = group3[i5]) && (subnode = select2.call(node, node.__data__, i5, group3))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i5] = subnode;
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // ../../../../../node_modules/d3-selection/src/array.js
  function array(x3) {
    return x3 == null ? [] : Array.isArray(x3) ? x3 : Array.from(x3);
  }

  // ../../../../../node_modules/d3-selection/src/selectorAll.js
  function empty2() {
    return [];
  }
  function selectorAll_default(selector) {
    return selector == null ? empty2 : function() {
      return this.querySelectorAll(selector);
    };
  }

  // ../../../../../node_modules/d3-selection/src/selection/selectAll.js
  function arrayAll(select2) {
    return function() {
      return array(select2.apply(this, arguments));
    };
  }
  function selectAll_default(select2) {
    if (typeof select2 === "function") select2 = arrayAll(select2);
    else select2 = selectorAll_default(select2);
    for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j2 = 0; j2 < m3; ++j2) {
      for (var group3 = groups2[j2], n9 = group3.length, node, i5 = 0; i5 < n9; ++i5) {
        if (node = group3[i5]) {
          subgroups.push(select2.call(node, node.__data__, i5, group3));
          parents.push(node);
        }
      }
    }
    return new Selection(subgroups, parents);
  }

  // ../../../../../node_modules/d3-selection/src/matcher.js
  function matcher_default(selector) {
    return function() {
      return this.matches(selector);
    };
  }
  function childMatcher(selector) {
    return function(node) {
      return node.matches(selector);
    };
  }

  // ../../../../../node_modules/d3-selection/src/selection/selectChild.js
  var find = Array.prototype.find;
  function childFind(match) {
    return function() {
      return find.call(this.children, match);
    };
  }
  function childFirst() {
    return this.firstElementChild;
  }
  function selectChild_default(match) {
    return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
  }

  // ../../../../../node_modules/d3-selection/src/selection/selectChildren.js
  var filter3 = Array.prototype.filter;
  function children() {
    return Array.from(this.children);
  }
  function childrenFilter(match) {
    return function() {
      return filter3.call(this.children, match);
    };
  }
  function selectChildren_default(match) {
    return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
  }

  // ../../../../../node_modules/d3-selection/src/selection/filter.js
  function filter_default(match) {
    if (typeof match !== "function") match = matcher_default(match);
    for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j2 = 0; j2 < m3; ++j2) {
      for (var group3 = groups2[j2], n9 = group3.length, subgroup = subgroups[j2] = [], node, i5 = 0; i5 < n9; ++i5) {
        if ((node = group3[i5]) && match.call(node, node.__data__, i5, group3)) {
          subgroup.push(node);
        }
      }
    }
    return new Selection(subgroups, this._parents);
  }

  // ../../../../../node_modules/d3-selection/src/selection/sparse.js
  function sparse_default(update) {
    return new Array(update.length);
  }

  // ../../../../../node_modules/d3-selection/src/selection/enter.js
  function enter_default() {
    return new Selection(this._enter || this._groups.map(sparse_default), this._parents);
  }
  function EnterNode(parent, datum2) {
    this.ownerDocument = parent.ownerDocument;
    this.namespaceURI = parent.namespaceURI;
    this._next = null;
    this._parent = parent;
    this.__data__ = datum2;
  }
  EnterNode.prototype = {
    constructor: EnterNode,
    appendChild: function(child) {
      return this._parent.insertBefore(child, this._next);
    },
    insertBefore: function(child, next) {
      return this._parent.insertBefore(child, next);
    },
    querySelector: function(selector) {
      return this._parent.querySelector(selector);
    },
    querySelectorAll: function(selector) {
      return this._parent.querySelectorAll(selector);
    }
  };

  // ../../../../../node_modules/d3-selection/src/constant.js
  function constant_default(x3) {
    return function() {
      return x3;
    };
  }

  // ../../../../../node_modules/d3-selection/src/selection/data.js
  function bindIndex(parent, group3, enter, update, exit, data) {
    var i5 = 0, node, groupLength = group3.length, dataLength = data.length;
    for (; i5 < dataLength; ++i5) {
      if (node = group3[i5]) {
        node.__data__ = data[i5];
        update[i5] = node;
      } else {
        enter[i5] = new EnterNode(parent, data[i5]);
      }
    }
    for (; i5 < groupLength; ++i5) {
      if (node = group3[i5]) {
        exit[i5] = node;
      }
    }
  }
  function bindKey(parent, group3, enter, update, exit, data, key) {
    var i5, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group3.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
    for (i5 = 0; i5 < groupLength; ++i5) {
      if (node = group3[i5]) {
        keyValues[i5] = keyValue = key.call(node, node.__data__, i5, group3) + "";
        if (nodeByKeyValue.has(keyValue)) {
          exit[i5] = node;
        } else {
          nodeByKeyValue.set(keyValue, node);
        }
      }
    }
    for (i5 = 0; i5 < dataLength; ++i5) {
      keyValue = key.call(parent, data[i5], i5, data) + "";
      if (node = nodeByKeyValue.get(keyValue)) {
        update[i5] = node;
        node.__data__ = data[i5];
        nodeByKeyValue.delete(keyValue);
      } else {
        enter[i5] = new EnterNode(parent, data[i5]);
      }
    }
    for (i5 = 0; i5 < groupLength; ++i5) {
      if ((node = group3[i5]) && nodeByKeyValue.get(keyValues[i5]) === node) {
        exit[i5] = node;
      }
    }
  }
  function datum(node) {
    return node.__data__;
  }
  function data_default(value, key) {
    if (!arguments.length) return Array.from(this, datum);
    var bind = key ? bindKey : bindIndex, parents = this._parents, groups2 = this._groups;
    if (typeof value !== "function") value = constant_default(value);
    for (var m3 = groups2.length, update = new Array(m3), enter = new Array(m3), exit = new Array(m3), j2 = 0; j2 < m3; ++j2) {
      var parent = parents[j2], group3 = groups2[j2], groupLength = group3.length, data = arraylike(value.call(parent, parent && parent.__data__, j2, parents)), dataLength = data.length, enterGroup = enter[j2] = new Array(dataLength), updateGroup = update[j2] = new Array(dataLength), exitGroup = exit[j2] = new Array(groupLength);
      bind(parent, group3, enterGroup, updateGroup, exitGroup, data, key);
      for (var i0 = 0, i12 = 0, previous, next; i0 < dataLength; ++i0) {
        if (previous = enterGroup[i0]) {
          if (i0 >= i12) i12 = i0 + 1;
          while (!(next = updateGroup[i12]) && ++i12 < dataLength) ;
          previous._next = next || null;
        }
      }
    }
    update = new Selection(update, parents);
    update._enter = enter;
    update._exit = exit;
    return update;
  }
  function arraylike(data) {
    return typeof data === "object" && "length" in data ? data : Array.from(data);
  }

  // ../../../../../node_modules/d3-selection/src/selection/exit.js
  function exit_default() {
    return new Selection(this._exit || this._groups.map(sparse_default), this._parents);
  }

  // ../../../../../node_modules/d3-selection/src/selection/join.js
  function join_default(onenter, onupdate, onexit) {
    var enter = this.enter(), update = this, exit = this.exit();
    if (typeof onenter === "function") {
      enter = onenter(enter);
      if (enter) enter = enter.selection();
    } else {
      enter = enter.append(onenter + "");
    }
    if (onupdate != null) {
      update = onupdate(update);
      if (update) update = update.selection();
    }
    if (onexit == null) exit.remove();
    else onexit(exit);
    return enter && update ? enter.merge(update).order() : update;
  }

  // ../../../../../node_modules/d3-selection/src/selection/merge.js
  function merge_default(context) {
    var selection2 = context.selection ? context.selection() : context;
    for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m3; ++j2) {
      for (var group0 = groups0[j2], group1 = groups1[j2], n9 = group0.length, merge2 = merges[j2] = new Array(n9), node, i5 = 0; i5 < n9; ++i5) {
        if (node = group0[i5] || group1[i5]) {
          merge2[i5] = node;
        }
      }
    }
    for (; j2 < m0; ++j2) {
      merges[j2] = groups0[j2];
    }
    return new Selection(merges, this._parents);
  }

  // ../../../../../node_modules/d3-selection/src/selection/order.js
  function order_default() {
    for (var groups2 = this._groups, j2 = -1, m3 = groups2.length; ++j2 < m3; ) {
      for (var group3 = groups2[j2], i5 = group3.length - 1, next = group3[i5], node; --i5 >= 0; ) {
        if (node = group3[i5]) {
          if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  }

  // ../../../../../node_modules/d3-selection/src/selection/sort.js
  function sort_default(compare) {
    if (!compare) compare = ascending2;
    function compareNode(a5, b2) {
      return a5 && b2 ? compare(a5.__data__, b2.__data__) : !a5 - !b2;
    }
    for (var groups2 = this._groups, m3 = groups2.length, sortgroups = new Array(m3), j2 = 0; j2 < m3; ++j2) {
      for (var group3 = groups2[j2], n9 = group3.length, sortgroup = sortgroups[j2] = new Array(n9), node, i5 = 0; i5 < n9; ++i5) {
        if (node = group3[i5]) {
          sortgroup[i5] = node;
        }
      }
      sortgroup.sort(compareNode);
    }
    return new Selection(sortgroups, this._parents).order();
  }
  function ascending2(a5, b2) {
    return a5 < b2 ? -1 : a5 > b2 ? 1 : a5 >= b2 ? 0 : NaN;
  }

  // ../../../../../node_modules/d3-selection/src/selection/call.js
  function call_default() {
    var callback = arguments[0];
    arguments[0] = this;
    callback.apply(null, arguments);
    return this;
  }

  // ../../../../../node_modules/d3-selection/src/selection/nodes.js
  function nodes_default() {
    return Array.from(this);
  }

  // ../../../../../node_modules/d3-selection/src/selection/node.js
  function node_default() {
    for (var groups2 = this._groups, j2 = 0, m3 = groups2.length; j2 < m3; ++j2) {
      for (var group3 = groups2[j2], i5 = 0, n9 = group3.length; i5 < n9; ++i5) {
        var node = group3[i5];
        if (node) return node;
      }
    }
    return null;
  }

  // ../../../../../node_modules/d3-selection/src/selection/size.js
  function size_default() {
    let size = 0;
    for (const node of this) ++size;
    return size;
  }

  // ../../../../../node_modules/d3-selection/src/selection/empty.js
  function empty_default() {
    return !this.node();
  }

  // ../../../../../node_modules/d3-selection/src/selection/each.js
  function each_default(callback) {
    for (var groups2 = this._groups, j2 = 0, m3 = groups2.length; j2 < m3; ++j2) {
      for (var group3 = groups2[j2], i5 = 0, n9 = group3.length, node; i5 < n9; ++i5) {
        if (node = group3[i5]) callback.call(node, node.__data__, i5, group3);
      }
    }
    return this;
  }

  // ../../../../../node_modules/d3-selection/src/selection/attr.js
  function attrRemove(name) {
    return function() {
      this.removeAttribute(name);
    };
  }
  function attrRemoveNS(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant(name, value) {
    return function() {
      this.setAttribute(name, value);
    };
  }
  function attrConstantNS(fullname, value) {
    return function() {
      this.setAttributeNS(fullname.space, fullname.local, value);
    };
  }
  function attrFunction(name, value) {
    return function() {
      var v3 = value.apply(this, arguments);
      if (v3 == null) this.removeAttribute(name);
      else this.setAttribute(name, v3);
    };
  }
  function attrFunctionNS(fullname, value) {
    return function() {
      var v3 = value.apply(this, arguments);
      if (v3 == null) this.removeAttributeNS(fullname.space, fullname.local);
      else this.setAttributeNS(fullname.space, fullname.local, v3);
    };
  }
  function attr_default(name, value) {
    var fullname = namespace_default(name);
    if (arguments.length < 2) {
      var node = this.node();
      return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
    }
    return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
  }

  // ../../../../../node_modules/d3-selection/src/window.js
  function window_default(node) {
    return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
  }

  // ../../../../../node_modules/d3-selection/src/selection/style.js
  function styleRemove(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }
  function styleConstant(name, value, priority) {
    return function() {
      this.style.setProperty(name, value, priority);
    };
  }
  function styleFunction(name, value, priority) {
    return function() {
      var v3 = value.apply(this, arguments);
      if (v3 == null) this.style.removeProperty(name);
      else this.style.setProperty(name, v3, priority);
    };
  }
  function style_default(name, value, priority) {
    return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
  }
  function styleValue(node, name) {
    return node.style.getPropertyValue(name) || window_default(node).getComputedStyle(node, null).getPropertyValue(name);
  }

  // ../../../../../node_modules/d3-selection/src/selection/property.js
  function propertyRemove(name) {
    return function() {
      delete this[name];
    };
  }
  function propertyConstant(name, value) {
    return function() {
      this[name] = value;
    };
  }
  function propertyFunction(name, value) {
    return function() {
      var v3 = value.apply(this, arguments);
      if (v3 == null) delete this[name];
      else this[name] = v3;
    };
  }
  function property_default(name, value) {
    return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
  }

  // ../../../../../node_modules/d3-selection/src/selection/classed.js
  function classArray(string2) {
    return string2.trim().split(/^|\s+/);
  }
  function classList(node) {
    return node.classList || new ClassList(node);
  }
  function ClassList(node) {
    this._node = node;
    this._names = classArray(node.getAttribute("class") || "");
  }
  ClassList.prototype = {
    add: function(name) {
      var i5 = this._names.indexOf(name);
      if (i5 < 0) {
        this._names.push(name);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    remove: function(name) {
      var i5 = this._names.indexOf(name);
      if (i5 >= 0) {
        this._names.splice(i5, 1);
        this._node.setAttribute("class", this._names.join(" "));
      }
    },
    contains: function(name) {
      return this._names.indexOf(name) >= 0;
    }
  };
  function classedAdd(node, names) {
    var list2 = classList(node), i5 = -1, n9 = names.length;
    while (++i5 < n9) list2.add(names[i5]);
  }
  function classedRemove(node, names) {
    var list2 = classList(node), i5 = -1, n9 = names.length;
    while (++i5 < n9) list2.remove(names[i5]);
  }
  function classedTrue(names) {
    return function() {
      classedAdd(this, names);
    };
  }
  function classedFalse(names) {
    return function() {
      classedRemove(this, names);
    };
  }
  function classedFunction(names, value) {
    return function() {
      (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
    };
  }
  function classed_default(name, value) {
    var names = classArray(name + "");
    if (arguments.length < 2) {
      var list2 = classList(this.node()), i5 = -1, n9 = names.length;
      while (++i5 < n9) if (!list2.contains(names[i5])) return false;
      return true;
    }
    return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
  }

  // ../../../../../node_modules/d3-selection/src/selection/text.js
  function textRemove() {
    this.textContent = "";
  }
  function textConstant(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction(value) {
    return function() {
      var v3 = value.apply(this, arguments);
      this.textContent = v3 == null ? "" : v3;
    };
  }
  function text_default(value) {
    return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
  }

  // ../../../../../node_modules/d3-selection/src/selection/html.js
  function htmlRemove() {
    this.innerHTML = "";
  }
  function htmlConstant(value) {
    return function() {
      this.innerHTML = value;
    };
  }
  function htmlFunction(value) {
    return function() {
      var v3 = value.apply(this, arguments);
      this.innerHTML = v3 == null ? "" : v3;
    };
  }
  function html_default(value) {
    return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
  }

  // ../../../../../node_modules/d3-selection/src/selection/raise.js
  function raise() {
    if (this.nextSibling) this.parentNode.appendChild(this);
  }
  function raise_default() {
    return this.each(raise);
  }

  // ../../../../../node_modules/d3-selection/src/selection/lower.js
  function lower() {
    if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function lower_default() {
    return this.each(lower);
  }

  // ../../../../../node_modules/d3-selection/src/selection/append.js
  function append_default(name) {
    var create3 = typeof name === "function" ? name : creator_default(name);
    return this.select(function() {
      return this.appendChild(create3.apply(this, arguments));
    });
  }

  // ../../../../../node_modules/d3-selection/src/selection/insert.js
  function constantNull() {
    return null;
  }
  function insert_default(name, before) {
    var create3 = typeof name === "function" ? name : creator_default(name), select2 = before == null ? constantNull : typeof before === "function" ? before : selector_default(before);
    return this.select(function() {
      return this.insertBefore(create3.apply(this, arguments), select2.apply(this, arguments) || null);
    });
  }

  // ../../../../../node_modules/d3-selection/src/selection/remove.js
  function remove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  function remove_default() {
    return this.each(remove);
  }

  // ../../../../../node_modules/d3-selection/src/selection/clone.js
  function selection_cloneShallow() {
    var clone = this.cloneNode(false), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function selection_cloneDeep() {
    var clone = this.cloneNode(true), parent = this.parentNode;
    return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
  }
  function clone_default(deep) {
    return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
  }

  // ../../../../../node_modules/d3-selection/src/selection/datum.js
  function datum_default(value) {
    return arguments.length ? this.property("__data__", value) : this.node().__data__;
  }

  // ../../../../../node_modules/d3-selection/src/selection/on.js
  function contextListener(listener) {
    return function(event) {
      listener.call(this, event, this.__data__);
    };
  }
  function parseTypenames2(typenames) {
    return typenames.trim().split(/^|\s+/).map(function(t5) {
      var name = "", i5 = t5.indexOf(".");
      if (i5 >= 0) name = t5.slice(i5 + 1), t5 = t5.slice(0, i5);
      return { type: t5, name };
    });
  }
  function onRemove(typename) {
    return function() {
      var on = this.__on;
      if (!on) return;
      for (var j2 = 0, i5 = -1, m3 = on.length, o12; j2 < m3; ++j2) {
        if (o12 = on[j2], (!typename.type || o12.type === typename.type) && o12.name === typename.name) {
          this.removeEventListener(o12.type, o12.listener, o12.options);
        } else {
          on[++i5] = o12;
        }
      }
      if (++i5) on.length = i5;
      else delete this.__on;
    };
  }
  function onAdd(typename, value, options) {
    return function() {
      var on = this.__on, o12, listener = contextListener(value);
      if (on) for (var j2 = 0, m3 = on.length; j2 < m3; ++j2) {
        if ((o12 = on[j2]).type === typename.type && o12.name === typename.name) {
          this.removeEventListener(o12.type, o12.listener, o12.options);
          this.addEventListener(o12.type, o12.listener = listener, o12.options = options);
          o12.value = value;
          return;
        }
      }
      this.addEventListener(typename.type, listener, options);
      o12 = { type: typename.type, name: typename.name, value, listener, options };
      if (!on) this.__on = [o12];
      else on.push(o12);
    };
  }
  function on_default(typename, value, options) {
    var typenames = parseTypenames2(typename + ""), i5, n9 = typenames.length, t5;
    if (arguments.length < 2) {
      var on = this.node().__on;
      if (on) for (var j2 = 0, m3 = on.length, o12; j2 < m3; ++j2) {
        for (i5 = 0, o12 = on[j2]; i5 < n9; ++i5) {
          if ((t5 = typenames[i5]).type === o12.type && t5.name === o12.name) {
            return o12.value;
          }
        }
      }
      return;
    }
    on = value ? onAdd : onRemove;
    for (i5 = 0; i5 < n9; ++i5) this.each(on(typenames[i5], value, options));
    return this;
  }

  // ../../../../../node_modules/d3-selection/src/selection/dispatch.js
  function dispatchEvent(node, type2, params) {
    var window3 = window_default(node), event = window3.CustomEvent;
    if (typeof event === "function") {
      event = new event(type2, params);
    } else {
      event = window3.document.createEvent("Event");
      if (params) event.initEvent(type2, params.bubbles, params.cancelable), event.detail = params.detail;
      else event.initEvent(type2, false, false);
    }
    node.dispatchEvent(event);
  }
  function dispatchConstant(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params);
    };
  }
  function dispatchFunction(type2, params) {
    return function() {
      return dispatchEvent(this, type2, params.apply(this, arguments));
    };
  }
  function dispatch_default2(type2, params) {
    return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
  }

  // ../../../../../node_modules/d3-selection/src/selection/iterator.js
  function* iterator_default() {
    for (var groups2 = this._groups, j2 = 0, m3 = groups2.length; j2 < m3; ++j2) {
      for (var group3 = groups2[j2], i5 = 0, n9 = group3.length, node; i5 < n9; ++i5) {
        if (node = group3[i5]) yield node;
      }
    }
  }

  // ../../../../../node_modules/d3-selection/src/selection/index.js
  var root = [null];
  function Selection(groups2, parents) {
    this._groups = groups2;
    this._parents = parents;
  }
  function selection() {
    return new Selection([[document.documentElement]], root);
  }
  function selection_selection() {
    return this;
  }
  Selection.prototype = selection.prototype = {
    constructor: Selection,
    select: select_default,
    selectAll: selectAll_default,
    selectChild: selectChild_default,
    selectChildren: selectChildren_default,
    filter: filter_default,
    data: data_default,
    enter: enter_default,
    exit: exit_default,
    join: join_default,
    merge: merge_default,
    selection: selection_selection,
    order: order_default,
    sort: sort_default,
    call: call_default,
    nodes: nodes_default,
    node: node_default,
    size: size_default,
    empty: empty_default,
    each: each_default,
    attr: attr_default,
    style: style_default,
    property: property_default,
    classed: classed_default,
    text: text_default,
    html: html_default,
    raise: raise_default,
    lower: lower_default,
    append: append_default,
    insert: insert_default,
    remove: remove_default,
    clone: clone_default,
    datum: datum_default,
    on: on_default,
    dispatch: dispatch_default2,
    [Symbol.iterator]: iterator_default
  };
  var selection_default = selection;

  // ../../../../../node_modules/d3-selection/src/select.js
  function select_default2(selector) {
    return typeof selector === "string" ? new Selection([[document.querySelector(selector)]], [document.documentElement]) : new Selection([[selector]], root);
  }

  // ../../../../../node_modules/d3-selection/src/sourceEvent.js
  function sourceEvent_default(event) {
    let sourceEvent;
    while (sourceEvent = event.sourceEvent) event = sourceEvent;
    return event;
  }

  // ../../../../../node_modules/d3-selection/src/pointer.js
  function pointer_default(event, node) {
    event = sourceEvent_default(event);
    if (node === void 0) node = event.currentTarget;
    if (node) {
      var svg = node.ownerSVGElement || node;
      if (svg.createSVGPoint) {
        var point6 = svg.createSVGPoint();
        point6.x = event.clientX, point6.y = event.clientY;
        point6 = point6.matrixTransform(node.getScreenCTM().inverse());
        return [point6.x, point6.y];
      }
      if (node.getBoundingClientRect) {
        var rect3 = node.getBoundingClientRect();
        return [event.clientX - rect3.left - node.clientLeft, event.clientY - rect3.top - node.clientTop];
      }
    }
    return [event.pageX, event.pageY];
  }

  // ../../../../../node_modules/d3-color/src/define.js
  function define_default(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  // ../../../../../node_modules/d3-color/src/color.js
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
  var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
  var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
  var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
  var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
  var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color, color, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format3) {
    var m3, l8;
    format3 = (format3 + "").trim().toLowerCase();
    return (m3 = reHex.exec(format3)) ? (l8 = m3[1].length, m3 = parseInt(m3[1], 16), l8 === 6 ? rgbn(m3) : l8 === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l8 === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l8 === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format3)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format3)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format3)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format3)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n9) {
    return new Rgb(n9 >> 16 & 255, n9 >> 8 & 255, n9 & 255, 1);
  }
  function rgba(r6, g2, b2, a5) {
    if (a5 <= 0) r6 = g2 = b2 = NaN;
    return new Rgb(r6, g2, b2, a5);
  }
  function rgbConvert(o12) {
    if (!(o12 instanceof Color)) o12 = color(o12);
    if (!o12) return new Rgb();
    o12 = o12.rgb();
    return new Rgb(o12.r, o12.g, o12.b, o12.opacity);
  }
  function rgb(r6, g2, b2, opacity2) {
    return arguments.length === 1 ? rgbConvert(r6) : new Rgb(r6, g2, b2, opacity2 == null ? 1 : opacity2);
  }
  function Rgb(r6, g2, b2, opacity2) {
    this.r = +r6;
    this.g = +g2;
    this.b = +b2;
    this.opacity = +opacity2;
  }
  define_default(Rgb, rgb, extend(Color, {
    brighter(k3) {
      k3 = k3 == null ? brighter : Math.pow(brighter, k3);
      return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
    },
    darker(k3) {
      k3 = k3 == null ? darker : Math.pow(darker, k3);
      return new Rgb(this.r * k3, this.g * k3, this.b * k3, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a5 = clampa(this.opacity);
    return `${a5 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a5 === 1 ? ")" : `, ${a5})`}`;
  }
  function clampa(opacity2) {
    return isNaN(opacity2) ? 1 : Math.max(0, Math.min(1, opacity2));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h5, s8, l8, a5) {
    if (a5 <= 0) h5 = s8 = l8 = NaN;
    else if (l8 <= 0 || l8 >= 1) h5 = s8 = NaN;
    else if (s8 <= 0) h5 = NaN;
    return new Hsl(h5, s8, l8, a5);
  }
  function hslConvert(o12) {
    if (o12 instanceof Hsl) return new Hsl(o12.h, o12.s, o12.l, o12.opacity);
    if (!(o12 instanceof Color)) o12 = color(o12);
    if (!o12) return new Hsl();
    if (o12 instanceof Hsl) return o12;
    o12 = o12.rgb();
    var r6 = o12.r / 255, g2 = o12.g / 255, b2 = o12.b / 255, min4 = Math.min(r6, g2, b2), max3 = Math.max(r6, g2, b2), h5 = NaN, s8 = max3 - min4, l8 = (max3 + min4) / 2;
    if (s8) {
      if (r6 === max3) h5 = (g2 - b2) / s8 + (g2 < b2) * 6;
      else if (g2 === max3) h5 = (b2 - r6) / s8 + 2;
      else h5 = (r6 - g2) / s8 + 4;
      s8 /= l8 < 0.5 ? max3 + min4 : 2 - max3 - min4;
      h5 *= 60;
    } else {
      s8 = l8 > 0 && l8 < 1 ? 0 : h5;
    }
    return new Hsl(h5, s8, l8, o12.opacity);
  }
  function hsl(h5, s8, l8, opacity2) {
    return arguments.length === 1 ? hslConvert(h5) : new Hsl(h5, s8, l8, opacity2 == null ? 1 : opacity2);
  }
  function Hsl(h5, s8, l8, opacity2) {
    this.h = +h5;
    this.s = +s8;
    this.l = +l8;
    this.opacity = +opacity2;
  }
  define_default(Hsl, hsl, extend(Color, {
    brighter(k3) {
      k3 = k3 == null ? brighter : Math.pow(brighter, k3);
      return new Hsl(this.h, this.s, this.l * k3, this.opacity);
    },
    darker(k3) {
      k3 = k3 == null ? darker : Math.pow(darker, k3);
      return new Hsl(this.h, this.s, this.l * k3, this.opacity);
    },
    rgb() {
      var h5 = this.h % 360 + (this.h < 0) * 360, s8 = isNaN(h5) || isNaN(this.s) ? 0 : this.s, l8 = this.l, m22 = l8 + (l8 < 0.5 ? l8 : 1 - l8) * s8, m1 = 2 * l8 - m22;
      return new Rgb(
        hsl2rgb(h5 >= 240 ? h5 - 240 : h5 + 120, m1, m22),
        hsl2rgb(h5, m1, m22),
        hsl2rgb(h5 < 120 ? h5 + 240 : h5 - 120, m1, m22),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a5 = clampa(this.opacity);
      return `${a5 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a5 === 1 ? ")" : `, ${a5})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h5, m1, m22) {
    return (h5 < 60 ? m1 + (m22 - m1) * h5 / 60 : h5 < 180 ? m22 : h5 < 240 ? m1 + (m22 - m1) * (240 - h5) / 60 : m1) * 255;
  }

  // ../../../../../node_modules/d3-color/src/math.js
  var radians = Math.PI / 180;
  var degrees = 180 / Math.PI;

  // ../../../../../node_modules/d3-color/src/lab.js
  var K = 18;
  var Xn = 0.96422;
  var Yn = 1;
  var Zn = 0.82521;
  var t0 = 4 / 29;
  var t1 = 6 / 29;
  var t22 = 3 * t1 * t1;
  var t32 = t1 * t1 * t1;
  function labConvert(o12) {
    if (o12 instanceof Lab) return new Lab(o12.l, o12.a, o12.b, o12.opacity);
    if (o12 instanceof Hcl) return hcl2lab(o12);
    if (!(o12 instanceof Rgb)) o12 = rgbConvert(o12);
    var r6 = rgb2lrgb(o12.r), g2 = rgb2lrgb(o12.g), b2 = rgb2lrgb(o12.b), y3 = xyz2lab((0.2225045 * r6 + 0.7168786 * g2 + 0.0606169 * b2) / Yn), x3, z2;
    if (r6 === g2 && g2 === b2) x3 = z2 = y3;
    else {
      x3 = xyz2lab((0.4360747 * r6 + 0.3850649 * g2 + 0.1430804 * b2) / Xn);
      z2 = xyz2lab((0.0139322 * r6 + 0.0971045 * g2 + 0.7141733 * b2) / Zn);
    }
    return new Lab(116 * y3 - 16, 500 * (x3 - y3), 200 * (y3 - z2), o12.opacity);
  }
  function lab(l8, a5, b2, opacity2) {
    return arguments.length === 1 ? labConvert(l8) : new Lab(l8, a5, b2, opacity2 == null ? 1 : opacity2);
  }
  function Lab(l8, a5, b2, opacity2) {
    this.l = +l8;
    this.a = +a5;
    this.b = +b2;
    this.opacity = +opacity2;
  }
  define_default(Lab, lab, extend(Color, {
    brighter(k3) {
      return new Lab(this.l + K * (k3 == null ? 1 : k3), this.a, this.b, this.opacity);
    },
    darker(k3) {
      return new Lab(this.l - K * (k3 == null ? 1 : k3), this.a, this.b, this.opacity);
    },
    rgb() {
      var y3 = (this.l + 16) / 116, x3 = isNaN(this.a) ? y3 : y3 + this.a / 500, z2 = isNaN(this.b) ? y3 : y3 - this.b / 200;
      x3 = Xn * lab2xyz(x3);
      y3 = Yn * lab2xyz(y3);
      z2 = Zn * lab2xyz(z2);
      return new Rgb(
        lrgb2rgb(3.1338561 * x3 - 1.6168667 * y3 - 0.4906146 * z2),
        lrgb2rgb(-0.9787684 * x3 + 1.9161415 * y3 + 0.033454 * z2),
        lrgb2rgb(0.0719453 * x3 - 0.2289914 * y3 + 1.4052427 * z2),
        this.opacity
      );
    }
  }));
  function xyz2lab(t5) {
    return t5 > t32 ? Math.pow(t5, 1 / 3) : t5 / t22 + t0;
  }
  function lab2xyz(t5) {
    return t5 > t1 ? t5 * t5 * t5 : t22 * (t5 - t0);
  }
  function lrgb2rgb(x3) {
    return 255 * (x3 <= 31308e-7 ? 12.92 * x3 : 1.055 * Math.pow(x3, 1 / 2.4) - 0.055);
  }
  function rgb2lrgb(x3) {
    return (x3 /= 255) <= 0.04045 ? x3 / 12.92 : Math.pow((x3 + 0.055) / 1.055, 2.4);
  }
  function hclConvert(o12) {
    if (o12 instanceof Hcl) return new Hcl(o12.h, o12.c, o12.l, o12.opacity);
    if (!(o12 instanceof Lab)) o12 = labConvert(o12);
    if (o12.a === 0 && o12.b === 0) return new Hcl(NaN, 0 < o12.l && o12.l < 100 ? 0 : NaN, o12.l, o12.opacity);
    var h5 = Math.atan2(o12.b, o12.a) * degrees;
    return new Hcl(h5 < 0 ? h5 + 360 : h5, Math.sqrt(o12.a * o12.a + o12.b * o12.b), o12.l, o12.opacity);
  }
  function hcl(h5, c9, l8, opacity2) {
    return arguments.length === 1 ? hclConvert(h5) : new Hcl(h5, c9, l8, opacity2 == null ? 1 : opacity2);
  }
  function Hcl(h5, c9, l8, opacity2) {
    this.h = +h5;
    this.c = +c9;
    this.l = +l8;
    this.opacity = +opacity2;
  }
  function hcl2lab(o12) {
    if (isNaN(o12.h)) return new Lab(o12.l, 0, 0, o12.opacity);
    var h5 = o12.h * radians;
    return new Lab(o12.l, Math.cos(h5) * o12.c, Math.sin(h5) * o12.c, o12.opacity);
  }
  define_default(Hcl, hcl, extend(Color, {
    brighter(k3) {
      return new Hcl(this.h, this.c, this.l + K * (k3 == null ? 1 : k3), this.opacity);
    },
    darker(k3) {
      return new Hcl(this.h, this.c, this.l - K * (k3 == null ? 1 : k3), this.opacity);
    },
    rgb() {
      return hcl2lab(this).rgb();
    }
  }));

  // ../../../../../node_modules/d3-color/src/cubehelix.js
  var A2 = -0.14861;
  var B2 = 1.78277;
  var C7 = -0.29227;
  var D2 = -0.90649;
  var E3 = 1.97294;
  var ED = E3 * D2;
  var EB = E3 * B2;
  var BC_DA = B2 * C7 - D2 * A2;
  function cubehelixConvert(o12) {
    if (o12 instanceof Cubehelix) return new Cubehelix(o12.h, o12.s, o12.l, o12.opacity);
    if (!(o12 instanceof Rgb)) o12 = rgbConvert(o12);
    var r6 = o12.r / 255, g2 = o12.g / 255, b2 = o12.b / 255, l8 = (BC_DA * b2 + ED * r6 - EB * g2) / (BC_DA + ED - EB), bl = b2 - l8, k3 = (E3 * (g2 - l8) - C7 * bl) / D2, s8 = Math.sqrt(k3 * k3 + bl * bl) / (E3 * l8 * (1 - l8)), h5 = s8 ? Math.atan2(k3, bl) * degrees - 120 : NaN;
    return new Cubehelix(h5 < 0 ? h5 + 360 : h5, s8, l8, o12.opacity);
  }
  function cubehelix(h5, s8, l8, opacity2) {
    return arguments.length === 1 ? cubehelixConvert(h5) : new Cubehelix(h5, s8, l8, opacity2 == null ? 1 : opacity2);
  }
  function Cubehelix(h5, s8, l8, opacity2) {
    this.h = +h5;
    this.s = +s8;
    this.l = +l8;
    this.opacity = +opacity2;
  }
  define_default(Cubehelix, cubehelix, extend(Color, {
    brighter(k3) {
      k3 = k3 == null ? brighter : Math.pow(brighter, k3);
      return new Cubehelix(this.h, this.s, this.l * k3, this.opacity);
    },
    darker(k3) {
      k3 = k3 == null ? darker : Math.pow(darker, k3);
      return new Cubehelix(this.h, this.s, this.l * k3, this.opacity);
    },
    rgb() {
      var h5 = isNaN(this.h) ? 0 : (this.h + 120) * radians, l8 = +this.l, a5 = isNaN(this.s) ? 0 : this.s * l8 * (1 - l8), cosh = Math.cos(h5), sinh = Math.sin(h5);
      return new Rgb(
        255 * (l8 + a5 * (A2 * cosh + B2 * sinh)),
        255 * (l8 + a5 * (C7 * cosh + D2 * sinh)),
        255 * (l8 + a5 * (E3 * cosh)),
        this.opacity
      );
    }
  }));

  // ../../../../../node_modules/d3-interpolate/src/basis.js
  function basis(t13, v0, v1, v22, v3) {
    var t23 = t13 * t13, t33 = t23 * t13;
    return ((1 - 3 * t13 + 3 * t23 - t33) * v0 + (4 - 6 * t23 + 3 * t33) * v1 + (1 + 3 * t13 + 3 * t23 - 3 * t33) * v22 + t33 * v3) / 6;
  }
  function basis_default(values2) {
    var n9 = values2.length - 1;
    return function(t5) {
      var i5 = t5 <= 0 ? t5 = 0 : t5 >= 1 ? (t5 = 1, n9 - 1) : Math.floor(t5 * n9), v1 = values2[i5], v22 = values2[i5 + 1], v0 = i5 > 0 ? values2[i5 - 1] : 2 * v1 - v22, v3 = i5 < n9 - 1 ? values2[i5 + 2] : 2 * v22 - v1;
      return basis((t5 - i5 / n9) * n9, v0, v1, v22, v3);
    };
  }

  // ../../../../../node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values2) {
    var n9 = values2.length;
    return function(t5) {
      var i5 = Math.floor(((t5 %= 1) < 0 ? ++t5 : t5) * n9), v0 = values2[(i5 + n9 - 1) % n9], v1 = values2[i5 % n9], v22 = values2[(i5 + 1) % n9], v3 = values2[(i5 + 2) % n9];
      return basis((t5 - i5 / n9) * n9, v0, v1, v22, v3);
    };
  }

  // ../../../../../node_modules/d3-interpolate/src/constant.js
  var constant_default2 = (x3) => () => x3;

  // ../../../../../node_modules/d3-interpolate/src/color.js
  function linear(a5, d3) {
    return function(t5) {
      return a5 + t5 * d3;
    };
  }
  function exponential2(a5, b2, y3) {
    return a5 = Math.pow(a5, y3), b2 = Math.pow(b2, y3) - a5, y3 = 1 / y3, function(t5) {
      return Math.pow(a5 + t5 * b2, y3);
    };
  }
  function hue(a5, b2) {
    var d3 = b2 - a5;
    return d3 ? linear(a5, d3 > 180 || d3 < -180 ? d3 - 360 * Math.round(d3 / 360) : d3) : constant_default2(isNaN(a5) ? b2 : a5);
  }
  function gamma2(y3) {
    return (y3 = +y3) === 1 ? nogamma : function(a5, b2) {
      return b2 - a5 ? exponential2(a5, b2, y3) : constant_default2(isNaN(a5) ? b2 : a5);
    };
  }
  function nogamma(a5, b2) {
    var d3 = b2 - a5;
    return d3 ? linear(a5, d3) : constant_default2(isNaN(a5) ? b2 : a5);
  }

  // ../../../../../node_modules/d3-interpolate/src/rgb.js
  var rgb_default = function rgbGamma(y3) {
    var color3 = gamma2(y3);
    function rgb2(start2, end) {
      var r6 = color3((start2 = rgb(start2)).r, (end = rgb(end)).r), g2 = color3(start2.g, end.g), b2 = color3(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);
      return function(t5) {
        start2.r = r6(t5);
        start2.g = g2(t5);
        start2.b = b2(t5);
        start2.opacity = opacity2(t5);
        return start2 + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  }(1);
  function rgbSpline(spline) {
    return function(colors) {
      var n9 = colors.length, r6 = new Array(n9), g2 = new Array(n9), b2 = new Array(n9), i5, color3;
      for (i5 = 0; i5 < n9; ++i5) {
        color3 = rgb(colors[i5]);
        r6[i5] = color3.r || 0;
        g2[i5] = color3.g || 0;
        b2[i5] = color3.b || 0;
      }
      r6 = spline(r6);
      g2 = spline(g2);
      b2 = spline(b2);
      color3.opacity = 1;
      return function(t5) {
        color3.r = r6(t5);
        color3.g = g2(t5);
        color3.b = b2(t5);
        return color3 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // ../../../../../node_modules/d3-interpolate/src/numberArray.js
  function numberArray_default(a5, b2) {
    if (!b2) b2 = [];
    var n9 = a5 ? Math.min(b2.length, a5.length) : 0, c9 = b2.slice(), i5;
    return function(t5) {
      for (i5 = 0; i5 < n9; ++i5) c9[i5] = a5[i5] * (1 - t5) + b2[i5] * t5;
      return c9;
    };
  }
  function isNumberArray(x3) {
    return ArrayBuffer.isView(x3) && !(x3 instanceof DataView);
  }

  // ../../../../../node_modules/d3-interpolate/src/array.js
  function genericArray(a5, b2) {
    var nb = b2 ? b2.length : 0, na = a5 ? Math.min(nb, a5.length) : 0, x3 = new Array(na), c9 = new Array(nb), i5;
    for (i5 = 0; i5 < na; ++i5) x3[i5] = value_default(a5[i5], b2[i5]);
    for (; i5 < nb; ++i5) c9[i5] = b2[i5];
    return function(t5) {
      for (i5 = 0; i5 < na; ++i5) c9[i5] = x3[i5](t5);
      return c9;
    };
  }

  // ../../../../../node_modules/d3-interpolate/src/date.js
  function date_default(a5, b2) {
    var d3 = /* @__PURE__ */ new Date();
    return a5 = +a5, b2 = +b2, function(t5) {
      return d3.setTime(a5 * (1 - t5) + b2 * t5), d3;
    };
  }

  // ../../../../../node_modules/d3-interpolate/src/number.js
  function number_default(a5, b2) {
    return a5 = +a5, b2 = +b2, function(t5) {
      return a5 * (1 - t5) + b2 * t5;
    };
  }

  // ../../../../../node_modules/d3-interpolate/src/object.js
  function object_default(a5, b2) {
    var i5 = {}, c9 = {}, k3;
    if (a5 === null || typeof a5 !== "object") a5 = {};
    if (b2 === null || typeof b2 !== "object") b2 = {};
    for (k3 in b2) {
      if (k3 in a5) {
        i5[k3] = value_default(a5[k3], b2[k3]);
      } else {
        c9[k3] = b2[k3];
      }
    }
    return function(t5) {
      for (k3 in i5) c9[k3] = i5[k3](t5);
      return c9;
    };
  }

  // ../../../../../node_modules/d3-interpolate/src/string.js
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");
  function zero3(b2) {
    return function() {
      return b2;
    };
  }
  function one2(b2) {
    return function(t5) {
      return b2(t5) + "";
    };
  }
  function string_default(a5, b2) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i5 = -1, s8 = [], q = [];
    a5 = a5 + "", b2 = b2 + "";
    while ((am = reA.exec(a5)) && (bm = reB.exec(b2))) {
      if ((bs = bm.index) > bi) {
        bs = b2.slice(bi, bs);
        if (s8[i5]) s8[i5] += bs;
        else s8[++i5] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s8[i5]) s8[i5] += bm;
        else s8[++i5] = bm;
      } else {
        s8[++i5] = null;
        q.push({ i: i5, x: number_default(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b2.length) {
      bs = b2.slice(bi);
      if (s8[i5]) s8[i5] += bs;
      else s8[++i5] = bs;
    }
    return s8.length < 2 ? q[0] ? one2(q[0].x) : zero3(b2) : (b2 = q.length, function(t5) {
      for (var i6 = 0, o12; i6 < b2; ++i6) s8[(o12 = q[i6]).i] = o12.x(t5);
      return s8.join("");
    });
  }

  // ../../../../../node_modules/d3-interpolate/src/value.js
  function value_default(a5, b2) {
    var t5 = typeof b2, c9;
    return b2 == null || t5 === "boolean" ? constant_default2(b2) : (t5 === "number" ? number_default : t5 === "string" ? (c9 = color(b2)) ? (b2 = c9, rgb_default) : string_default : b2 instanceof color ? rgb_default : b2 instanceof Date ? date_default : isNumberArray(b2) ? numberArray_default : Array.isArray(b2) ? genericArray : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object_default : number_default)(a5, b2);
  }

  // ../../../../../node_modules/d3-interpolate/src/round.js
  function round_default(a5, b2) {
    return a5 = +a5, b2 = +b2, function(t5) {
      return Math.round(a5 * (1 - t5) + b2 * t5);
    };
  }

  // ../../../../../node_modules/d3-interpolate/src/transform/decompose.js
  var degrees2 = 180 / Math.PI;
  var identity2 = {
    translateX: 0,
    translateY: 0,
    rotate: 0,
    skewX: 0,
    scaleX: 1,
    scaleY: 1
  };
  function decompose_default(a5, b2, c9, d3, e11, f7) {
    var scaleX, scaleY, skewX;
    if (scaleX = Math.sqrt(a5 * a5 + b2 * b2)) a5 /= scaleX, b2 /= scaleX;
    if (skewX = a5 * c9 + b2 * d3) c9 -= a5 * skewX, d3 -= b2 * skewX;
    if (scaleY = Math.sqrt(c9 * c9 + d3 * d3)) c9 /= scaleY, d3 /= scaleY, skewX /= scaleY;
    if (a5 * d3 < b2 * c9) a5 = -a5, b2 = -b2, skewX = -skewX, scaleX = -scaleX;
    return {
      translateX: e11,
      translateY: f7,
      rotate: Math.atan2(b2, a5) * degrees2,
      skewX: Math.atan(skewX) * degrees2,
      scaleX,
      scaleY
    };
  }

  // ../../../../../node_modules/d3-interpolate/src/transform/parse.js
  var svgNode;
  function parseCss(value) {
    const m3 = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
    return m3.isIdentity ? identity2 : decompose_default(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
  }
  function parseSvg(value) {
    if (value == null) return identity2;
    if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
    svgNode.setAttribute("transform", value);
    if (!(value = svgNode.transform.baseVal.consolidate())) return identity2;
    value = value.matrix;
    return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
  }

  // ../../../../../node_modules/d3-interpolate/src/transform/index.js
  function interpolateTransform(parse3, pxComma, pxParen, degParen) {
    function pop2(s8) {
      return s8.length ? s8.pop() + " " : "";
    }
    function translate(xa, ya, xb, yb, s8, q) {
      if (xa !== xb || ya !== yb) {
        var i5 = s8.push("translate(", null, pxComma, null, pxParen);
        q.push({ i: i5 - 4, x: number_default(xa, xb) }, { i: i5 - 2, x: number_default(ya, yb) });
      } else if (xb || yb) {
        s8.push("translate(" + xb + pxComma + yb + pxParen);
      }
    }
    function rotate(a5, b2, s8, q) {
      if (a5 !== b2) {
        if (a5 - b2 > 180) b2 += 360;
        else if (b2 - a5 > 180) a5 += 360;
        q.push({ i: s8.push(pop2(s8) + "rotate(", null, degParen) - 2, x: number_default(a5, b2) });
      } else if (b2) {
        s8.push(pop2(s8) + "rotate(" + b2 + degParen);
      }
    }
    function skewX(a5, b2, s8, q) {
      if (a5 !== b2) {
        q.push({ i: s8.push(pop2(s8) + "skewX(", null, degParen) - 2, x: number_default(a5, b2) });
      } else if (b2) {
        s8.push(pop2(s8) + "skewX(" + b2 + degParen);
      }
    }
    function scale3(xa, ya, xb, yb, s8, q) {
      if (xa !== xb || ya !== yb) {
        var i5 = s8.push(pop2(s8) + "scale(", null, ",", null, ")");
        q.push({ i: i5 - 4, x: number_default(xa, xb) }, { i: i5 - 2, x: number_default(ya, yb) });
      } else if (xb !== 1 || yb !== 1) {
        s8.push(pop2(s8) + "scale(" + xb + "," + yb + ")");
      }
    }
    return function(a5, b2) {
      var s8 = [], q = [];
      a5 = parse3(a5), b2 = parse3(b2);
      translate(a5.translateX, a5.translateY, b2.translateX, b2.translateY, s8, q);
      rotate(a5.rotate, b2.rotate, s8, q);
      skewX(a5.skewX, b2.skewX, s8, q);
      scale3(a5.scaleX, a5.scaleY, b2.scaleX, b2.scaleY, s8, q);
      a5 = b2 = null;
      return function(t5) {
        var i5 = -1, n9 = q.length, o12;
        while (++i5 < n9) s8[(o12 = q[i5]).i] = o12.x(t5);
        return s8.join("");
      };
    };
  }
  var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
  var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

  // ../../../../../node_modules/d3-interpolate/src/hsl.js
  function hsl2(hue2) {
    return function(start2, end) {
      var h5 = hue2((start2 = hsl(start2)).h, (end = hsl(end)).h), s8 = nogamma(start2.s, end.s), l8 = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
      return function(t5) {
        start2.h = h5(t5);
        start2.s = s8(t5);
        start2.l = l8(t5);
        start2.opacity = opacity2(t5);
        return start2 + "";
      };
    };
  }
  var hsl_default = hsl2(hue);
  var hslLong = hsl2(nogamma);

  // ../../../../../node_modules/d3-interpolate/src/lab.js
  function lab2(start2, end) {
    var l8 = nogamma((start2 = lab(start2)).l, (end = lab(end)).l), a5 = nogamma(start2.a, end.a), b2 = nogamma(start2.b, end.b), opacity2 = nogamma(start2.opacity, end.opacity);
    return function(t5) {
      start2.l = l8(t5);
      start2.a = a5(t5);
      start2.b = b2(t5);
      start2.opacity = opacity2(t5);
      return start2 + "";
    };
  }

  // ../../../../../node_modules/d3-interpolate/src/hcl.js
  function hcl2(hue2) {
    return function(start2, end) {
      var h5 = hue2((start2 = hcl(start2)).h, (end = hcl(end)).h), c9 = nogamma(start2.c, end.c), l8 = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
      return function(t5) {
        start2.h = h5(t5);
        start2.c = c9(t5);
        start2.l = l8(t5);
        start2.opacity = opacity2(t5);
        return start2 + "";
      };
    };
  }
  var hcl_default = hcl2(hue);
  var hclLong = hcl2(nogamma);

  // ../../../../../node_modules/d3-interpolate/src/cubehelix.js
  function cubehelix2(hue2) {
    return function cubehelixGamma(y3) {
      y3 = +y3;
      function cubehelix3(start2, end) {
        var h5 = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s8 = nogamma(start2.s, end.s), l8 = nogamma(start2.l, end.l), opacity2 = nogamma(start2.opacity, end.opacity);
        return function(t5) {
          start2.h = h5(t5);
          start2.s = s8(t5);
          start2.l = l8(Math.pow(t5, y3));
          start2.opacity = opacity2(t5);
          return start2 + "";
        };
      }
      cubehelix3.gamma = cubehelixGamma;
      return cubehelix3;
    }(1);
  }
  var cubehelix_default = cubehelix2(hue);
  var cubehelixLong = cubehelix2(nogamma);

  // ../../../../../node_modules/d3-interpolate/src/piecewise.js
  function piecewise(interpolate, values2) {
    if (values2 === void 0) values2 = interpolate, interpolate = value_default;
    var i5 = 0, n9 = values2.length - 1, v3 = values2[0], I2 = new Array(n9 < 0 ? 0 : n9);
    while (i5 < n9) I2[i5] = interpolate(v3, v3 = values2[++i5]);
    return function(t5) {
      var i6 = Math.max(0, Math.min(n9 - 1, Math.floor(t5 *= n9)));
      return I2[i6](t5 - i6);
    };
  }

  // ../../../../../node_modules/d3-interpolate/src/quantize.js
  function quantize_default(interpolator, n9) {
    var samples = new Array(n9);
    for (var i5 = 0; i5 < n9; ++i5) samples[i5] = interpolator(i5 / (n9 - 1));
    return samples;
  }

  // ../../../../../node_modules/d3-timer/src/timer.js
  var frame2 = 0;
  var timeout = 0;
  var interval = 0;
  var pokeDelay = 1e3;
  var taskHead;
  var taskTail;
  var clockLast = 0;
  var clockNow = 0;
  var clockSkew = 0;
  var clock = typeof performance === "object" && performance.now ? performance : Date;
  var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f7) {
    setTimeout(f7, 17);
  };
  function now() {
    return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time2) {
      if (typeof callback !== "function") throw new TypeError("callback is not a function");
      time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail) taskTail._next = this;
        else taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time2;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time2) {
    var t5 = new Timer();
    t5.restart(callback, delay, time2);
    return t5;
  }
  function timerFlush() {
    now();
    ++frame2;
    var t5 = taskHead, e11;
    while (t5) {
      if ((e11 = clockNow - t5._time) >= 0) t5._call.call(void 0, e11);
      t5 = t5._next;
    }
    --frame2;
  }
  function wake() {
    clockNow = (clockLast = clock.now()) + clockSkew;
    frame2 = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame2 = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now2 = clock.now(), delay = now2 - clockLast;
    if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
  }
  function nap() {
    var t03, t13 = taskHead, t23, time2 = Infinity;
    while (t13) {
      if (t13._call) {
        if (time2 > t13._time) time2 = t13._time;
        t03 = t13, t13 = t13._next;
      } else {
        t23 = t13._next, t13._next = null;
        t13 = t03 ? t03._next = t23 : taskHead = t23;
      }
    }
    taskTail = t03;
    sleep(time2);
  }
  function sleep(time2) {
    if (frame2) return;
    if (timeout) timeout = clearTimeout(timeout);
    var delay = time2 - clockNow;
    if (delay > 24) {
      if (time2 < Infinity) timeout = setTimeout(wake, time2 - clock.now() - clockSkew);
      if (interval) interval = clearInterval(interval);
    } else {
      if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
      frame2 = 1, setFrame(wake);
    }
  }

  // ../../../../../node_modules/d3-timer/src/timeout.js
  function timeout_default(callback, delay, time2) {
    var t5 = new Timer();
    delay = delay == null ? 0 : +delay;
    t5.restart((elapsed) => {
      t5.stop();
      callback(elapsed + delay);
    }, delay, time2);
    return t5;
  }

  // ../../../../../node_modules/d3-transition/src/transition/schedule.js
  var emptyOn = dispatch_default("start", "end", "cancel", "interrupt");
  var emptyTween = [];
  var CREATED = 0;
  var SCHEDULED = 1;
  var STARTING = 2;
  var STARTED = 3;
  var RUNNING = 4;
  var ENDING = 5;
  var ENDED = 6;
  function schedule_default(node, name, id2, index2, group3, timing) {
    var schedules = node.__transition;
    if (!schedules) node.__transition = {};
    else if (id2 in schedules) return;
    create(node, id2, {
      name,
      index: index2,
      // For context during callback.
      group: group3,
      // For context during callback.
      on: emptyOn,
      tween: emptyTween,
      time: timing.time,
      delay: timing.delay,
      duration: timing.duration,
      ease: timing.ease,
      timer: null,
      state: CREATED
    });
  }
  function init2(node, id2) {
    var schedule = get2(node, id2);
    if (schedule.state > CREATED) throw new Error("too late; already scheduled");
    return schedule;
  }
  function set2(node, id2) {
    var schedule = get2(node, id2);
    if (schedule.state > STARTED) throw new Error("too late; already running");
    return schedule;
  }
  function get2(node, id2) {
    var schedule = node.__transition;
    if (!schedule || !(schedule = schedule[id2])) throw new Error("transition not found");
    return schedule;
  }
  function create(node, id2, self) {
    var schedules = node.__transition, tween;
    schedules[id2] = self;
    self.timer = timer(schedule, 0, self.time);
    function schedule(elapsed) {
      self.state = SCHEDULED;
      self.timer.restart(start2, self.delay, self.time);
      if (self.delay <= elapsed) start2(elapsed - self.delay);
    }
    function start2(elapsed) {
      var i5, j2, n9, o12;
      if (self.state !== SCHEDULED) return stop2();
      for (i5 in schedules) {
        o12 = schedules[i5];
        if (o12.name !== self.name) continue;
        if (o12.state === STARTED) return timeout_default(start2);
        if (o12.state === RUNNING) {
          o12.state = ENDED;
          o12.timer.stop();
          o12.on.call("interrupt", node, node.__data__, o12.index, o12.group);
          delete schedules[i5];
        } else if (+i5 < id2) {
          o12.state = ENDED;
          o12.timer.stop();
          o12.on.call("cancel", node, node.__data__, o12.index, o12.group);
          delete schedules[i5];
        }
      }
      timeout_default(function() {
        if (self.state === STARTED) {
          self.state = RUNNING;
          self.timer.restart(tick, self.delay, self.time);
          tick(elapsed);
        }
      });
      self.state = STARTING;
      self.on.call("start", node, node.__data__, self.index, self.group);
      if (self.state !== STARTING) return;
      self.state = STARTED;
      tween = new Array(n9 = self.tween.length);
      for (i5 = 0, j2 = -1; i5 < n9; ++i5) {
        if (o12 = self.tween[i5].value.call(node, node.__data__, self.index, self.group)) {
          tween[++j2] = o12;
        }
      }
      tween.length = j2 + 1;
    }
    function tick(elapsed) {
      var t5 = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop2), self.state = ENDING, 1), i5 = -1, n9 = tween.length;
      while (++i5 < n9) {
        tween[i5].call(node, t5);
      }
      if (self.state === ENDING) {
        self.on.call("end", node, node.__data__, self.index, self.group);
        stop2();
      }
    }
    function stop2() {
      self.state = ENDED;
      self.timer.stop();
      delete schedules[id2];
      for (var i5 in schedules) return;
      delete node.__transition;
    }
  }

  // ../../../../../node_modules/d3-transition/src/interrupt.js
  function interrupt_default(node, name) {
    var schedules = node.__transition, schedule, active, empty3 = true, i5;
    if (!schedules) return;
    name = name == null ? null : name + "";
    for (i5 in schedules) {
      if ((schedule = schedules[i5]).name !== name) {
        empty3 = false;
        continue;
      }
      active = schedule.state > STARTING && schedule.state < ENDING;
      schedule.state = ENDED;
      schedule.timer.stop();
      schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
      delete schedules[i5];
    }
    if (empty3) delete node.__transition;
  }

  // ../../../../../node_modules/d3-transition/src/selection/interrupt.js
  function interrupt_default2(name) {
    return this.each(function() {
      interrupt_default(this, name);
    });
  }

  // ../../../../../node_modules/d3-transition/src/transition/tween.js
  function tweenRemove(id2, name) {
    var tween0, tween1;
    return function() {
      var schedule = set2(this, id2), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = tween0 = tween;
        for (var i5 = 0, n9 = tween1.length; i5 < n9; ++i5) {
          if (tween1[i5].name === name) {
            tween1 = tween1.slice();
            tween1.splice(i5, 1);
            break;
          }
        }
      }
      schedule.tween = tween1;
    };
  }
  function tweenFunction(id2, name, value) {
    var tween0, tween1;
    if (typeof value !== "function") throw new Error();
    return function() {
      var schedule = set2(this, id2), tween = schedule.tween;
      if (tween !== tween0) {
        tween1 = (tween0 = tween).slice();
        for (var t5 = { name, value }, i5 = 0, n9 = tween1.length; i5 < n9; ++i5) {
          if (tween1[i5].name === name) {
            tween1[i5] = t5;
            break;
          }
        }
        if (i5 === n9) tween1.push(t5);
      }
      schedule.tween = tween1;
    };
  }
  function tween_default(name, value) {
    var id2 = this._id;
    name += "";
    if (arguments.length < 2) {
      var tween = get2(this.node(), id2).tween;
      for (var i5 = 0, n9 = tween.length, t5; i5 < n9; ++i5) {
        if ((t5 = tween[i5]).name === name) {
          return t5.value;
        }
      }
      return null;
    }
    return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
  }
  function tweenValue(transition2, name, value) {
    var id2 = transition2._id;
    transition2.each(function() {
      var schedule = set2(this, id2);
      (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
    });
    return function(node) {
      return get2(node, id2).value[name];
    };
  }

  // ../../../../../node_modules/d3-transition/src/transition/interpolate.js
  function interpolate_default(a5, b2) {
    var c9;
    return (typeof b2 === "number" ? number_default : b2 instanceof color ? rgb_default : (c9 = color(b2)) ? (b2 = c9, rgb_default) : string_default)(a5, b2);
  }

  // ../../../../../node_modules/d3-transition/src/transition/attr.js
  function attrRemove2(name) {
    return function() {
      this.removeAttribute(name);
    };
  }
  function attrRemoveNS2(fullname) {
    return function() {
      this.removeAttributeNS(fullname.space, fullname.local);
    };
  }
  function attrConstant2(name, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttribute(name);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrConstantNS2(fullname, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = this.getAttributeNS(fullname.space, fullname.local);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function attrFunction2(name, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null) return void this.removeAttribute(name);
      string0 = this.getAttribute(name);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attrFunctionNS2(fullname, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0, value1 = value(this), string1;
      if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
      string0 = this.getAttributeNS(fullname.space, fullname.local);
      string1 = value1 + "";
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function attr_default2(name, value) {
    var fullname = namespace_default(name), i5 = fullname === "transform" ? interpolateTransformSvg : interpolate_default;
    return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS2 : attrFunction2)(fullname, i5, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS2 : attrRemove2)(fullname) : (fullname.local ? attrConstantNS2 : attrConstant2)(fullname, i5, value));
  }

  // ../../../../../node_modules/d3-transition/src/transition/attrTween.js
  function attrInterpolate(name, i5) {
    return function(t5) {
      this.setAttribute(name, i5.call(this, t5));
    };
  }
  function attrInterpolateNS(fullname, i5) {
    return function(t5) {
      this.setAttributeNS(fullname.space, fullname.local, i5.call(this, t5));
    };
  }
  function attrTweenNS(fullname, value) {
    var t03, i0;
    function tween() {
      var i5 = value.apply(this, arguments);
      if (i5 !== i0) t03 = (i0 = i5) && attrInterpolateNS(fullname, i5);
      return t03;
    }
    tween._value = value;
    return tween;
  }
  function attrTween(name, value) {
    var t03, i0;
    function tween() {
      var i5 = value.apply(this, arguments);
      if (i5 !== i0) t03 = (i0 = i5) && attrInterpolate(name, i5);
      return t03;
    }
    tween._value = value;
    return tween;
  }
  function attrTween_default(name, value) {
    var key = "attr." + name;
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    var fullname = namespace_default(name);
    return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
  }

  // ../../../../../node_modules/d3-transition/src/transition/delay.js
  function delayFunction(id2, value) {
    return function() {
      init2(this, id2).delay = +value.apply(this, arguments);
    };
  }
  function delayConstant(id2, value) {
    return value = +value, function() {
      init2(this, id2).delay = value;
    };
  }
  function delay_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get2(this.node(), id2).delay;
  }

  // ../../../../../node_modules/d3-transition/src/transition/duration.js
  function durationFunction(id2, value) {
    return function() {
      set2(this, id2).duration = +value.apply(this, arguments);
    };
  }
  function durationConstant(id2, value) {
    return value = +value, function() {
      set2(this, id2).duration = value;
    };
  }
  function duration_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get2(this.node(), id2).duration;
  }

  // ../../../../../node_modules/d3-transition/src/transition/ease.js
  function easeConstant(id2, value) {
    if (typeof value !== "function") throw new Error();
    return function() {
      set2(this, id2).ease = value;
    };
  }
  function ease_default(value) {
    var id2 = this._id;
    return arguments.length ? this.each(easeConstant(id2, value)) : get2(this.node(), id2).ease;
  }

  // ../../../../../node_modules/d3-transition/src/transition/easeVarying.js
  function easeVarying(id2, value) {
    return function() {
      var v3 = value.apply(this, arguments);
      if (typeof v3 !== "function") throw new Error();
      set2(this, id2).ease = v3;
    };
  }
  function easeVarying_default(value) {
    if (typeof value !== "function") throw new Error();
    return this.each(easeVarying(this._id, value));
  }

  // ../../../../../node_modules/d3-transition/src/transition/filter.js
  function filter_default2(match) {
    if (typeof match !== "function") match = matcher_default(match);
    for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j2 = 0; j2 < m3; ++j2) {
      for (var group3 = groups2[j2], n9 = group3.length, subgroup = subgroups[j2] = [], node, i5 = 0; i5 < n9; ++i5) {
        if ((node = group3[i5]) && match.call(node, node.__data__, i5, group3)) {
          subgroup.push(node);
        }
      }
    }
    return new Transition(subgroups, this._parents, this._name, this._id);
  }

  // ../../../../../node_modules/d3-transition/src/transition/merge.js
  function merge_default2(transition2) {
    if (transition2._id !== this._id) throw new Error();
    for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m3 = Math.min(m0, m1), merges = new Array(m0), j2 = 0; j2 < m3; ++j2) {
      for (var group0 = groups0[j2], group1 = groups1[j2], n9 = group0.length, merge2 = merges[j2] = new Array(n9), node, i5 = 0; i5 < n9; ++i5) {
        if (node = group0[i5] || group1[i5]) {
          merge2[i5] = node;
        }
      }
    }
    for (; j2 < m0; ++j2) {
      merges[j2] = groups0[j2];
    }
    return new Transition(merges, this._parents, this._name, this._id);
  }

  // ../../../../../node_modules/d3-transition/src/transition/on.js
  function start(name) {
    return (name + "").trim().split(/^|\s+/).every(function(t5) {
      var i5 = t5.indexOf(".");
      if (i5 >= 0) t5 = t5.slice(0, i5);
      return !t5 || t5 === "start";
    });
  }
  function onFunction(id2, name, listener) {
    var on0, on1, sit = start(name) ? init2 : set2;
    return function() {
      var schedule = sit(this, id2), on = schedule.on;
      if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
      schedule.on = on1;
    };
  }
  function on_default2(name, listener) {
    var id2 = this._id;
    return arguments.length < 2 ? get2(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
  }

  // ../../../../../node_modules/d3-transition/src/transition/remove.js
  function removeFunction(id2) {
    return function() {
      var parent = this.parentNode;
      for (var i5 in this.__transition) if (+i5 !== id2) return;
      if (parent) parent.removeChild(this);
    };
  }
  function remove_default2() {
    return this.on("end.remove", removeFunction(this._id));
  }

  // ../../../../../node_modules/d3-transition/src/transition/select.js
  function select_default3(select2) {
    var name = this._name, id2 = this._id;
    if (typeof select2 !== "function") select2 = selector_default(select2);
    for (var groups2 = this._groups, m3 = groups2.length, subgroups = new Array(m3), j2 = 0; j2 < m3; ++j2) {
      for (var group3 = groups2[j2], n9 = group3.length, subgroup = subgroups[j2] = new Array(n9), node, subnode, i5 = 0; i5 < n9; ++i5) {
        if ((node = group3[i5]) && (subnode = select2.call(node, node.__data__, i5, group3))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          subgroup[i5] = subnode;
          schedule_default(subgroup[i5], name, id2, i5, subgroup, get2(node, id2));
        }
      }
    }
    return new Transition(subgroups, this._parents, name, id2);
  }

  // ../../../../../node_modules/d3-transition/src/transition/selectAll.js
  function selectAll_default2(select2) {
    var name = this._name, id2 = this._id;
    if (typeof select2 !== "function") select2 = selectorAll_default(select2);
    for (var groups2 = this._groups, m3 = groups2.length, subgroups = [], parents = [], j2 = 0; j2 < m3; ++j2) {
      for (var group3 = groups2[j2], n9 = group3.length, node, i5 = 0; i5 < n9; ++i5) {
        if (node = group3[i5]) {
          for (var children2 = select2.call(node, node.__data__, i5, group3), child, inherit3 = get2(node, id2), k3 = 0, l8 = children2.length; k3 < l8; ++k3) {
            if (child = children2[k3]) {
              schedule_default(child, name, id2, k3, children2, inherit3);
            }
          }
          subgroups.push(children2);
          parents.push(node);
        }
      }
    }
    return new Transition(subgroups, parents, name, id2);
  }

  // ../../../../../node_modules/d3-transition/src/transition/selection.js
  var Selection2 = selection_default.prototype.constructor;
  function selection_default2() {
    return new Selection2(this._groups, this._parents);
  }

  // ../../../../../node_modules/d3-transition/src/transition/style.js
  function styleNull(name, interpolate) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate(string00 = string0, string10 = string1);
    };
  }
  function styleRemove2(name) {
    return function() {
      this.style.removeProperty(name);
    };
  }
  function styleConstant2(name, interpolate, value1) {
    var string00, string1 = value1 + "", interpolate0;
    return function() {
      var string0 = styleValue(this, name);
      return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate(string00 = string0, value1);
    };
  }
  function styleFunction2(name, interpolate, value) {
    var string00, string10, interpolate0;
    return function() {
      var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
      if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
      return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
    };
  }
  function styleMaybeRemove(id2, name) {
    var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
    return function() {
      var schedule = set2(this, id2), on = schedule.on, listener = schedule.value[key] == null ? remove2 || (remove2 = styleRemove2(name)) : void 0;
      if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
      schedule.on = on1;
    };
  }
  function style_default2(name, value, priority) {
    var i5 = (name += "") === "transform" ? interpolateTransformCss : interpolate_default;
    return value == null ? this.styleTween(name, styleNull(name, i5)).on("end.style." + name, styleRemove2(name)) : typeof value === "function" ? this.styleTween(name, styleFunction2(name, i5, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant2(name, i5, value), priority).on("end.style." + name, null);
  }

  // ../../../../../node_modules/d3-transition/src/transition/styleTween.js
  function styleInterpolate(name, i5, priority) {
    return function(t5) {
      this.style.setProperty(name, i5.call(this, t5), priority);
    };
  }
  function styleTween(name, value, priority) {
    var t5, i0;
    function tween() {
      var i5 = value.apply(this, arguments);
      if (i5 !== i0) t5 = (i0 = i5) && styleInterpolate(name, i5, priority);
      return t5;
    }
    tween._value = value;
    return tween;
  }
  function styleTween_default(name, value, priority) {
    var key = "style." + (name += "");
    if (arguments.length < 2) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
  }

  // ../../../../../node_modules/d3-transition/src/transition/text.js
  function textConstant2(value) {
    return function() {
      this.textContent = value;
    };
  }
  function textFunction2(value) {
    return function() {
      var value1 = value(this);
      this.textContent = value1 == null ? "" : value1;
    };
  }
  function text_default2(value) {
    return this.tween("text", typeof value === "function" ? textFunction2(tweenValue(this, "text", value)) : textConstant2(value == null ? "" : value + ""));
  }

  // ../../../../../node_modules/d3-transition/src/transition/textTween.js
  function textInterpolate(i5) {
    return function(t5) {
      this.textContent = i5.call(this, t5);
    };
  }
  function textTween(value) {
    var t03, i0;
    function tween() {
      var i5 = value.apply(this, arguments);
      if (i5 !== i0) t03 = (i0 = i5) && textInterpolate(i5);
      return t03;
    }
    tween._value = value;
    return tween;
  }
  function textTween_default(value) {
    var key = "text";
    if (arguments.length < 1) return (key = this.tween(key)) && key._value;
    if (value == null) return this.tween(key, null);
    if (typeof value !== "function") throw new Error();
    return this.tween(key, textTween(value));
  }

  // ../../../../../node_modules/d3-transition/src/transition/transition.js
  function transition_default() {
    var name = this._name, id0 = this._id, id1 = newId();
    for (var groups2 = this._groups, m3 = groups2.length, j2 = 0; j2 < m3; ++j2) {
      for (var group3 = groups2[j2], n9 = group3.length, node, i5 = 0; i5 < n9; ++i5) {
        if (node = group3[i5]) {
          var inherit3 = get2(node, id0);
          schedule_default(node, name, id1, i5, group3, {
            time: inherit3.time + inherit3.delay + inherit3.duration,
            delay: 0,
            duration: inherit3.duration,
            ease: inherit3.ease
          });
        }
      }
    }
    return new Transition(groups2, this._parents, name, id1);
  }

  // ../../../../../node_modules/d3-transition/src/transition/end.js
  function end_default() {
    var on0, on1, that = this, id2 = that._id, size = that.size();
    return new Promise(function(resolve, reject) {
      var cancel = { value: reject }, end = { value: function() {
        if (--size === 0) resolve();
      } };
      that.each(function() {
        var schedule = set2(this, id2), on = schedule.on;
        if (on !== on0) {
          on1 = (on0 = on).copy();
          on1._.cancel.push(cancel);
          on1._.interrupt.push(cancel);
          on1._.end.push(end);
        }
        schedule.on = on1;
      });
      if (size === 0) resolve();
    });
  }

  // ../../../../../node_modules/d3-transition/src/transition/index.js
  var id = 0;
  function Transition(groups2, parents, name, id2) {
    this._groups = groups2;
    this._parents = parents;
    this._name = name;
    this._id = id2;
  }
  function transition(name) {
    return selection_default().transition(name);
  }
  function newId() {
    return ++id;
  }
  var selection_prototype = selection_default.prototype;
  Transition.prototype = transition.prototype = {
    constructor: Transition,
    select: select_default3,
    selectAll: selectAll_default2,
    selectChild: selection_prototype.selectChild,
    selectChildren: selection_prototype.selectChildren,
    filter: filter_default2,
    merge: merge_default2,
    selection: selection_default2,
    transition: transition_default,
    call: selection_prototype.call,
    nodes: selection_prototype.nodes,
    node: selection_prototype.node,
    size: selection_prototype.size,
    empty: selection_prototype.empty,
    each: selection_prototype.each,
    on: on_default2,
    attr: attr_default2,
    attrTween: attrTween_default,
    style: style_default2,
    styleTween: styleTween_default,
    text: text_default2,
    textTween: textTween_default,
    remove: remove_default2,
    tween: tween_default,
    delay: delay_default,
    duration: duration_default,
    ease: ease_default,
    easeVarying: easeVarying_default,
    end: end_default,
    [Symbol.iterator]: selection_prototype[Symbol.iterator]
  };

  // ../../../../../node_modules/d3-ease/src/cubic.js
  function cubicInOut(t5) {
    return ((t5 *= 2) <= 1 ? t5 * t5 * t5 : (t5 -= 2) * t5 * t5 + 2) / 2;
  }

  // ../../../../../node_modules/d3-transition/src/selection/transition.js
  var defaultTiming = {
    time: null,
    // Set on use.
    delay: 0,
    duration: 250,
    ease: cubicInOut
  };
  function inherit(node, id2) {
    var timing;
    while (!(timing = node.__transition) || !(timing = timing[id2])) {
      if (!(node = node.parentNode)) {
        throw new Error(`transition ${id2} not found`);
      }
    }
    return timing;
  }
  function transition_default2(name) {
    var id2, timing;
    if (name instanceof Transition) {
      id2 = name._id, name = name._name;
    } else {
      id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
    }
    for (var groups2 = this._groups, m3 = groups2.length, j2 = 0; j2 < m3; ++j2) {
      for (var group3 = groups2[j2], n9 = group3.length, node, i5 = 0; i5 < n9; ++i5) {
        if (node = group3[i5]) {
          schedule_default(node, name, id2, i5, group3, timing || inherit(node, id2));
        }
      }
    }
    return new Transition(groups2, this._parents, name, id2);
  }

  // ../../../../../node_modules/d3-transition/src/selection/index.js
  selection_default.prototype.interrupt = interrupt_default2;
  selection_default.prototype.transition = transition_default2;

  // ../../../../../node_modules/d3-brush/src/brush.js
  var { abs: abs2, max: max2, min: min2 } = Math;
  function number1(e11) {
    return [+e11[0], +e11[1]];
  }
  function number22(e11) {
    return [number1(e11[0]), number1(e11[1])];
  }
  var X = {
    name: "x",
    handles: ["w", "e"].map(type),
    input: function(x3, e11) {
      return x3 == null ? null : [[+x3[0], e11[0][1]], [+x3[1], e11[1][1]]];
    },
    output: function(xy) {
      return xy && [xy[0][0], xy[1][0]];
    }
  };
  var Y = {
    name: "y",
    handles: ["n", "s"].map(type),
    input: function(y3, e11) {
      return y3 == null ? null : [[e11[0][0], +y3[0]], [e11[1][0], +y3[1]]];
    },
    output: function(xy) {
      return xy && [xy[0][1], xy[1][1]];
    }
  };
  var XY = {
    name: "xy",
    handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
    input: function(xy) {
      return xy == null ? null : number22(xy);
    },
    output: function(xy) {
      return xy;
    }
  };
  function type(t5) {
    return { type: t5 };
  }

  // ../../../../../node_modules/d3-path/src/path.js
  var pi = Math.PI;
  var tau = 2 * pi;
  var epsilon2 = 1e-6;
  var tauEpsilon = tau - epsilon2;
  function append2(strings) {
    this._ += strings[0];
    for (let i5 = 1, n9 = strings.length; i5 < n9; ++i5) {
      this._ += arguments[i5] + strings[i5];
    }
  }
  function appendRound(digits) {
    let d3 = Math.floor(digits);
    if (!(d3 >= 0)) throw new Error(`invalid digits: ${digits}`);
    if (d3 > 15) return append2;
    const k3 = 10 ** d3;
    return function(strings) {
      this._ += strings[0];
      for (let i5 = 1, n9 = strings.length; i5 < n9; ++i5) {
        this._ += Math.round(arguments[i5] * k3) / k3 + strings[i5];
      }
    };
  }
  var Path = class {
    constructor(digits) {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null;
      this._ = "";
      this._append = digits == null ? append2 : appendRound(digits);
    }
    moveTo(x3, y3) {
      this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}`;
    }
    closePath() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._append`Z`;
      }
    }
    lineTo(x3, y3) {
      this._append`L${this._x1 = +x3},${this._y1 = +y3}`;
    }
    quadraticCurveTo(x12, y12, x3, y3) {
      this._append`Q${+x12},${+y12},${this._x1 = +x3},${this._y1 = +y3}`;
    }
    bezierCurveTo(x12, y12, x22, y22, x3, y3) {
      this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x3},${this._y1 = +y3}`;
    }
    arcTo(x12, y12, x22, y22, r6) {
      x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r6 = +r6;
      if (r6 < 0) throw new Error(`negative radius: ${r6}`);
      let x06 = this._x1, y06 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x06 - x12, y01 = y06 - y12, l01_2 = x01 * x01 + y01 * y01;
      if (this._x1 === null) {
        this._append`M${this._x1 = x12},${this._y1 = y12}`;
      } else if (!(l01_2 > epsilon2)) ;
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r6) {
        this._append`L${this._x1 = x12},${this._y1 = y12}`;
      } else {
        let x20 = x22 - x06, y20 = y22 - y06, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l8 = r6 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l8 / l01, t21 = l8 / l21;
        if (Math.abs(t01 - 1) > epsilon2) {
          this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
        }
        this._append`A${r6},${r6},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
      }
    }
    arc(x3, y3, r6, a0, a1, ccw) {
      x3 = +x3, y3 = +y3, r6 = +r6, ccw = !!ccw;
      if (r6 < 0) throw new Error(`negative radius: ${r6}`);
      let dx = r6 * Math.cos(a0), dy = r6 * Math.sin(a0), x06 = x3 + dx, y06 = y3 + dy, cw = 1 ^ ccw, da2 = ccw ? a0 - a1 : a1 - a0;
      if (this._x1 === null) {
        this._append`M${x06},${y06}`;
      } else if (Math.abs(this._x1 - x06) > epsilon2 || Math.abs(this._y1 - y06) > epsilon2) {
        this._append`L${x06},${y06}`;
      }
      if (!r6) return;
      if (da2 < 0) da2 = da2 % tau + tau;
      if (da2 > tauEpsilon) {
        this._append`A${r6},${r6},0,1,${cw},${x3 - dx},${y3 - dy}A${r6},${r6},0,1,${cw},${this._x1 = x06},${this._y1 = y06}`;
      } else if (da2 > epsilon2) {
        this._append`A${r6},${r6},0,${+(da2 >= pi)},${cw},${this._x1 = x3 + r6 * Math.cos(a1)},${this._y1 = y3 + r6 * Math.sin(a1)}`;
      }
    }
    rect(x3, y3, w2, h5) {
      this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}h${w2 = +w2}v${+h5}h${-w2}Z`;
    }
    toString() {
      return this._;
    }
  };
  function path() {
    return new Path();
  }
  path.prototype = Path.prototype;
  function pathRound(digits = 3) {
    return new Path(+digits);
  }

  // ../../../../../node_modules/d3-contour/src/array.js
  var array2 = Array.prototype;
  var slice = array2.slice;

  // ../../../../../node_modules/d3-contour/src/ascending.js
  function ascending_default(a5, b2) {
    return a5 - b2;
  }

  // ../../../../../node_modules/d3-contour/src/area.js
  function area_default(ring) {
    var i5 = 0, n9 = ring.length, area2 = ring[n9 - 1][1] * ring[0][0] - ring[n9 - 1][0] * ring[0][1];
    while (++i5 < n9) area2 += ring[i5 - 1][1] * ring[i5][0] - ring[i5 - 1][0] * ring[i5][1];
    return area2;
  }

  // ../../../../../node_modules/d3-contour/src/constant.js
  var constant_default4 = (x3) => () => x3;

  // ../../../../../node_modules/d3-contour/src/contains.js
  function contains_default(ring, hole) {
    var i5 = -1, n9 = hole.length, c9;
    while (++i5 < n9) if (c9 = ringContains(ring, hole[i5])) return c9;
    return 0;
  }
  function ringContains(ring, point6) {
    var x3 = point6[0], y3 = point6[1], contains = -1;
    for (var i5 = 0, n9 = ring.length, j2 = n9 - 1; i5 < n9; j2 = i5++) {
      var pi5 = ring[i5], xi = pi5[0], yi = pi5[1], pj = ring[j2], xj = pj[0], yj = pj[1];
      if (segmentContains(pi5, pj, point6)) return 0;
      if (yi > y3 !== yj > y3 && x3 < (xj - xi) * (y3 - yi) / (yj - yi) + xi) contains = -contains;
    }
    return contains;
  }
  function segmentContains(a5, b2, c9) {
    var i5;
    return collinear(a5, b2, c9) && within(a5[i5 = +(a5[0] === b2[0])], c9[i5], b2[i5]);
  }
  function collinear(a5, b2, c9) {
    return (b2[0] - a5[0]) * (c9[1] - a5[1]) === (c9[0] - a5[0]) * (b2[1] - a5[1]);
  }
  function within(p11, q, r6) {
    return p11 <= q && q <= r6 || r6 <= q && q <= p11;
  }

  // ../../../../../node_modules/d3-contour/src/noop.js
  function noop_default() {
  }

  // ../../../../../node_modules/d3-contour/src/contours.js
  var cases = [
    [],
    [[[1, 1.5], [0.5, 1]]],
    [[[1.5, 1], [1, 1.5]]],
    [[[1.5, 1], [0.5, 1]]],
    [[[1, 0.5], [1.5, 1]]],
    [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],
    [[[1, 0.5], [1, 1.5]]],
    [[[1, 0.5], [0.5, 1]]],
    [[[0.5, 1], [1, 0.5]]],
    [[[1, 1.5], [1, 0.5]]],
    [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],
    [[[1.5, 1], [1, 0.5]]],
    [[[0.5, 1], [1.5, 1]]],
    [[[1, 1.5], [1.5, 1]]],
    [[[0.5, 1], [1, 1.5]]],
    []
  ];
  function contours_default() {
    var dx = 1, dy = 1, threshold2 = thresholdSturges, smooth = smoothLinear;
    function contours(values2) {
      var tz = threshold2(values2);
      if (!Array.isArray(tz)) {
        const e11 = extent(values2, finite);
        tz = ticks(...nice(e11[0], e11[1], tz), tz);
        while (tz[tz.length - 1] >= e11[1]) tz.pop();
        while (tz[1] < e11[0]) tz.shift();
      } else {
        tz = tz.slice().sort(ascending_default);
      }
      return tz.map((value) => contour2(values2, value));
    }
    function contour2(values2, value) {
      const v3 = value == null ? NaN : +value;
      if (isNaN(v3)) throw new Error(`invalid value: ${value}`);
      var polygons = [], holes = [];
      isorings(values2, v3, function(ring) {
        smooth(ring, values2, v3);
        if (area_default(ring) > 0) polygons.push([ring]);
        else holes.push(ring);
      });
      holes.forEach(function(hole) {
        for (var i5 = 0, n9 = polygons.length, polygon; i5 < n9; ++i5) {
          if (contains_default((polygon = polygons[i5])[0], hole) !== -1) {
            polygon.push(hole);
            return;
          }
        }
      });
      return {
        type: "MultiPolygon",
        value,
        coordinates: polygons
      };
    }
    function isorings(values2, value, callback) {
      var fragmentByStart = new Array(), fragmentByEnd = new Array(), x3, y3, t03, t13, t23, t33;
      x3 = y3 = -1;
      t13 = above(values2[0], value);
      cases[t13 << 1].forEach(stitch);
      while (++x3 < dx - 1) {
        t03 = t13, t13 = above(values2[x3 + 1], value);
        cases[t03 | t13 << 1].forEach(stitch);
      }
      cases[t13 << 0].forEach(stitch);
      while (++y3 < dy - 1) {
        x3 = -1;
        t13 = above(values2[y3 * dx + dx], value);
        t23 = above(values2[y3 * dx], value);
        cases[t13 << 1 | t23 << 2].forEach(stitch);
        while (++x3 < dx - 1) {
          t03 = t13, t13 = above(values2[y3 * dx + dx + x3 + 1], value);
          t33 = t23, t23 = above(values2[y3 * dx + x3 + 1], value);
          cases[t03 | t13 << 1 | t23 << 2 | t33 << 3].forEach(stitch);
        }
        cases[t13 | t23 << 3].forEach(stitch);
      }
      x3 = -1;
      t23 = values2[y3 * dx] >= value;
      cases[t23 << 2].forEach(stitch);
      while (++x3 < dx - 1) {
        t33 = t23, t23 = above(values2[y3 * dx + x3 + 1], value);
        cases[t23 << 2 | t33 << 3].forEach(stitch);
      }
      cases[t23 << 3].forEach(stitch);
      function stitch(line2) {
        var start2 = [line2[0][0] + x3, line2[0][1] + y3], end = [line2[1][0] + x3, line2[1][1] + y3], startIndex = index2(start2), endIndex = index2(end), f7, g2;
        if (f7 = fragmentByEnd[startIndex]) {
          if (g2 = fragmentByStart[endIndex]) {
            delete fragmentByEnd[f7.end];
            delete fragmentByStart[g2.start];
            if (f7 === g2) {
              f7.ring.push(end);
              callback(f7.ring);
            } else {
              fragmentByStart[f7.start] = fragmentByEnd[g2.end] = { start: f7.start, end: g2.end, ring: f7.ring.concat(g2.ring) };
            }
          } else {
            delete fragmentByEnd[f7.end];
            f7.ring.push(end);
            fragmentByEnd[f7.end = endIndex] = f7;
          }
        } else if (f7 = fragmentByStart[endIndex]) {
          if (g2 = fragmentByEnd[startIndex]) {
            delete fragmentByStart[f7.start];
            delete fragmentByEnd[g2.end];
            if (f7 === g2) {
              f7.ring.push(end);
              callback(f7.ring);
            } else {
              fragmentByStart[g2.start] = fragmentByEnd[f7.end] = { start: g2.start, end: f7.end, ring: g2.ring.concat(f7.ring) };
            }
          } else {
            delete fragmentByStart[f7.start];
            f7.ring.unshift(start2);
            fragmentByStart[f7.start = startIndex] = f7;
          }
        } else {
          fragmentByStart[startIndex] = fragmentByEnd[endIndex] = { start: startIndex, end: endIndex, ring: [start2, end] };
        }
      }
    }
    function index2(point6) {
      return point6[0] * 2 + point6[1] * (dx + 1) * 4;
    }
    function smoothLinear(ring, values2, value) {
      ring.forEach(function(point6) {
        var x3 = point6[0], y3 = point6[1], xt = x3 | 0, yt = y3 | 0, v1 = valid(values2[yt * dx + xt]);
        if (x3 > 0 && x3 < dx && xt === x3) {
          point6[0] = smooth1(x3, valid(values2[yt * dx + xt - 1]), v1, value);
        }
        if (y3 > 0 && y3 < dy && yt === y3) {
          point6[1] = smooth1(y3, valid(values2[(yt - 1) * dx + xt]), v1, value);
        }
      });
    }
    contours.contour = contour2;
    contours.size = function(_2) {
      if (!arguments.length) return [dx, dy];
      var _0 = Math.floor(_2[0]), _1 = Math.floor(_2[1]);
      if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
      return dx = _0, dy = _1, contours;
    };
    contours.thresholds = function(_2) {
      return arguments.length ? (threshold2 = typeof _2 === "function" ? _2 : Array.isArray(_2) ? constant_default4(slice.call(_2)) : constant_default4(_2), contours) : threshold2;
    };
    contours.smooth = function(_2) {
      return arguments.length ? (smooth = _2 ? smoothLinear : noop_default, contours) : smooth === smoothLinear;
    };
    return contours;
  }
  function finite(x3) {
    return isFinite(x3) ? x3 : NaN;
  }
  function above(x3, value) {
    return x3 == null ? false : +x3 >= value;
  }
  function valid(v3) {
    return v3 == null || isNaN(v3 = +v3) ? -Infinity : v3;
  }
  function smooth1(x3, v0, v1, value) {
    const a5 = value - v0;
    const b2 = v1 - v0;
    const d3 = isFinite(a5) || isFinite(b2) ? a5 / b2 : Math.sign(a5) / Math.sign(b2);
    return isNaN(d3) ? x3 : x3 + d3 - 0.5;
  }

  // ../../../../../node_modules/d3-contour/src/density.js
  function defaultX(d3) {
    return d3[0];
  }
  function defaultY(d3) {
    return d3[1];
  }
  function defaultWeight() {
    return 1;
  }
  function density_default() {
    var x3 = defaultX, y3 = defaultY, weight = defaultWeight, dx = 960, dy = 500, r6 = 20, k3 = 2, o12 = r6 * 3, n9 = dx + o12 * 2 >> k3, m3 = dy + o12 * 2 >> k3, threshold2 = constant_default4(20);
    function grid(data) {
      var values2 = new Float32Array(n9 * m3), pow2k = Math.pow(2, -k3), i5 = -1;
      for (const d3 of data) {
        var xi = (x3(d3, ++i5, data) + o12) * pow2k, yi = (y3(d3, i5, data) + o12) * pow2k, wi = +weight(d3, i5, data);
        if (wi && xi >= 0 && xi < n9 && yi >= 0 && yi < m3) {
          var x06 = Math.floor(xi), y06 = Math.floor(yi), xt = xi - x06 - 0.5, yt = yi - y06 - 0.5;
          values2[x06 + y06 * n9] += (1 - xt) * (1 - yt) * wi;
          values2[x06 + 1 + y06 * n9] += xt * (1 - yt) * wi;
          values2[x06 + 1 + (y06 + 1) * n9] += xt * yt * wi;
          values2[x06 + (y06 + 1) * n9] += (1 - xt) * yt * wi;
        }
      }
      blur2({ data: values2, width: n9, height: m3 }, r6 * pow2k);
      return values2;
    }
    function density2(data) {
      var values2 = grid(data), tz = threshold2(values2), pow4k = Math.pow(2, 2 * k3);
      if (!Array.isArray(tz)) {
        tz = ticks(Number.MIN_VALUE, max(values2) / pow4k, tz);
      }
      return contours_default().size([n9, m3]).thresholds(tz.map((d3) => d3 * pow4k))(values2).map((c9, i5) => (c9.value = +tz[i5], transform3(c9)));
    }
    density2.contours = function(data) {
      var values2 = grid(data), contours = contours_default().size([n9, m3]), pow4k = Math.pow(2, 2 * k3), contour2 = (value) => {
        value = +value;
        var c9 = transform3(contours.contour(values2, value * pow4k));
        c9.value = value;
        return c9;
      };
      Object.defineProperty(contour2, "max", { get: () => max(values2) / pow4k });
      return contour2;
    };
    function transform3(geometry) {
      geometry.coordinates.forEach(transformPolygon);
      return geometry;
    }
    function transformPolygon(coordinates) {
      coordinates.forEach(transformRing);
    }
    function transformRing(coordinates) {
      coordinates.forEach(transformPoint);
    }
    function transformPoint(coordinates) {
      coordinates[0] = coordinates[0] * Math.pow(2, k3) - o12;
      coordinates[1] = coordinates[1] * Math.pow(2, k3) - o12;
    }
    function resize() {
      o12 = r6 * 3;
      n9 = dx + o12 * 2 >> k3;
      m3 = dy + o12 * 2 >> k3;
      return density2;
    }
    density2.x = function(_2) {
      return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default4(+_2), density2) : x3;
    };
    density2.y = function(_2) {
      return arguments.length ? (y3 = typeof _2 === "function" ? _2 : constant_default4(+_2), density2) : y3;
    };
    density2.weight = function(_2) {
      return arguments.length ? (weight = typeof _2 === "function" ? _2 : constant_default4(+_2), density2) : weight;
    };
    density2.size = function(_2) {
      if (!arguments.length) return [dx, dy];
      var _0 = +_2[0], _1 = +_2[1];
      if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
      return dx = _0, dy = _1, resize();
    };
    density2.cellSize = function(_2) {
      if (!arguments.length) return 1 << k3;
      if (!((_2 = +_2) >= 1)) throw new Error("invalid cell size");
      return k3 = Math.floor(Math.log(_2) / Math.LN2), resize();
    };
    density2.thresholds = function(_2) {
      return arguments.length ? (threshold2 = typeof _2 === "function" ? _2 : Array.isArray(_2) ? constant_default4(slice.call(_2)) : constant_default4(_2), density2) : threshold2;
    };
    density2.bandwidth = function(_2) {
      if (!arguments.length) return Math.sqrt(r6 * (r6 + 1));
      if (!((_2 = +_2) >= 0)) throw new Error("invalid bandwidth");
      return r6 = (Math.sqrt(4 * _2 * _2 + 1) - 1) / 2, resize();
    };
    return density2;
  }

  // ../../../../../node_modules/robust-predicates/esm/util.js
  var epsilon3 = 11102230246251565e-32;
  var splitter = 134217729;
  var resulterrbound = (3 + 8 * epsilon3) * epsilon3;
  function sum2(elen, e11, flen, f7, h5) {
    let Q, Qnew, hh, bvirt;
    let enow = e11[0];
    let fnow = f7[0];
    let eindex = 0;
    let findex = 0;
    if (fnow > enow === fnow > -enow) {
      Q = enow;
      enow = e11[++eindex];
    } else {
      Q = fnow;
      fnow = f7[++findex];
    }
    let hindex = 0;
    if (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = enow + Q;
        hh = Q - (Qnew - enow);
        enow = e11[++eindex];
      } else {
        Qnew = fnow + Q;
        hh = Q - (Qnew - fnow);
        fnow = f7[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h5[hindex++] = hh;
      }
      while (eindex < elen && findex < flen) {
        if (fnow > enow === fnow > -enow) {
          Qnew = Q + enow;
          bvirt = Qnew - Q;
          hh = Q - (Qnew - bvirt) + (enow - bvirt);
          enow = e11[++eindex];
        } else {
          Qnew = Q + fnow;
          bvirt = Qnew - Q;
          hh = Q - (Qnew - bvirt) + (fnow - bvirt);
          fnow = f7[++findex];
        }
        Q = Qnew;
        if (hh !== 0) {
          h5[hindex++] = hh;
        }
      }
    }
    while (eindex < elen) {
      Qnew = Q + enow;
      bvirt = Qnew - Q;
      hh = Q - (Qnew - bvirt) + (enow - bvirt);
      enow = e11[++eindex];
      Q = Qnew;
      if (hh !== 0) {
        h5[hindex++] = hh;
      }
    }
    while (findex < flen) {
      Qnew = Q + fnow;
      bvirt = Qnew - Q;
      hh = Q - (Qnew - bvirt) + (fnow - bvirt);
      fnow = f7[++findex];
      Q = Qnew;
      if (hh !== 0) {
        h5[hindex++] = hh;
      }
    }
    if (Q !== 0 || hindex === 0) {
      h5[hindex++] = Q;
    }
    return hindex;
  }
  function estimate(elen, e11) {
    let Q = e11[0];
    for (let i5 = 1; i5 < elen; i5++) Q += e11[i5];
    return Q;
  }
  function vec(n9) {
    return new Float64Array(n9);
  }

  // ../../../../../node_modules/robust-predicates/esm/orient2d.js
  var ccwerrboundA = (3 + 16 * epsilon3) * epsilon3;
  var ccwerrboundB = (2 + 12 * epsilon3) * epsilon3;
  var ccwerrboundC = (9 + 64 * epsilon3) * epsilon3 * epsilon3;
  var B3 = vec(4);
  var C12 = vec(8);
  var C22 = vec(12);
  var D3 = vec(16);
  var u4 = vec(4);
  function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
    let acxtail, acytail, bcxtail, bcytail;
    let bvirt, c9, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t13, t03, u32;
    const acx = ax - cx;
    const bcx = bx - cx;
    const acy = ay - cy;
    const bcy = by - cy;
    s1 = acx * bcy;
    c9 = splitter * acx;
    ahi = c9 - (c9 - acx);
    alo = acx - ahi;
    c9 = splitter * bcy;
    bhi = c9 - (c9 - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t13 = acy * bcx;
    c9 = splitter * acy;
    ahi = c9 - (c9 - acy);
    alo = acy - ahi;
    c9 = splitter * bcx;
    bhi = c9 - (c9 - bcx);
    blo = bcx - bhi;
    t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t03;
    bvirt = s0 - _i;
    B3[0] = s0 - (_i + bvirt) + (bvirt - t03);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t13;
    bvirt = _0 - _i;
    B3[1] = _0 - (_i + bvirt) + (bvirt - t13);
    u32 = _j + _i;
    bvirt = u32 - _j;
    B3[2] = _j - (u32 - bvirt) + (_i - bvirt);
    B3[3] = u32;
    let det2 = estimate(4, B3);
    let errbound = ccwerrboundB * detsum;
    if (det2 >= errbound || -det2 >= errbound) {
      return det2;
    }
    bvirt = ax - acx;
    acxtail = ax - (acx + bvirt) + (bvirt - cx);
    bvirt = bx - bcx;
    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
    bvirt = ay - acy;
    acytail = ay - (acy + bvirt) + (bvirt - cy);
    bvirt = by - bcy;
    bcytail = by - (bcy + bvirt) + (bvirt - cy);
    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
      return det2;
    }
    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det2);
    det2 += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
    if (det2 >= errbound || -det2 >= errbound) return det2;
    s1 = acxtail * bcy;
    c9 = splitter * acxtail;
    ahi = c9 - (c9 - acxtail);
    alo = acxtail - ahi;
    c9 = splitter * bcy;
    bhi = c9 - (c9 - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t13 = acytail * bcx;
    c9 = splitter * acytail;
    ahi = c9 - (c9 - acytail);
    alo = acytail - ahi;
    c9 = splitter * bcx;
    bhi = c9 - (c9 - bcx);
    blo = bcx - bhi;
    t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t03;
    bvirt = s0 - _i;
    u4[0] = s0 - (_i + bvirt) + (bvirt - t03);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t13;
    bvirt = _0 - _i;
    u4[1] = _0 - (_i + bvirt) + (bvirt - t13);
    u32 = _j + _i;
    bvirt = u32 - _j;
    u4[2] = _j - (u32 - bvirt) + (_i - bvirt);
    u4[3] = u32;
    const C1len = sum2(4, B3, 4, u4, C12);
    s1 = acx * bcytail;
    c9 = splitter * acx;
    ahi = c9 - (c9 - acx);
    alo = acx - ahi;
    c9 = splitter * bcytail;
    bhi = c9 - (c9 - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t13 = acy * bcxtail;
    c9 = splitter * acy;
    ahi = c9 - (c9 - acy);
    alo = acy - ahi;
    c9 = splitter * bcxtail;
    bhi = c9 - (c9 - bcxtail);
    blo = bcxtail - bhi;
    t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t03;
    bvirt = s0 - _i;
    u4[0] = s0 - (_i + bvirt) + (bvirt - t03);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t13;
    bvirt = _0 - _i;
    u4[1] = _0 - (_i + bvirt) + (bvirt - t13);
    u32 = _j + _i;
    bvirt = u32 - _j;
    u4[2] = _j - (u32 - bvirt) + (_i - bvirt);
    u4[3] = u32;
    const C2len = sum2(C1len, C12, 4, u4, C22);
    s1 = acxtail * bcytail;
    c9 = splitter * acxtail;
    ahi = c9 - (c9 - acxtail);
    alo = acxtail - ahi;
    c9 = splitter * bcytail;
    bhi = c9 - (c9 - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t13 = acytail * bcxtail;
    c9 = splitter * acytail;
    ahi = c9 - (c9 - acytail);
    alo = acytail - ahi;
    c9 = splitter * bcxtail;
    bhi = c9 - (c9 - bcxtail);
    blo = bcxtail - bhi;
    t03 = alo * blo - (t13 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t03;
    bvirt = s0 - _i;
    u4[0] = s0 - (_i + bvirt) + (bvirt - t03);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t13;
    bvirt = _0 - _i;
    u4[1] = _0 - (_i + bvirt) + (bvirt - t13);
    u32 = _j + _i;
    bvirt = u32 - _j;
    u4[2] = _j - (u32 - bvirt) + (_i - bvirt);
    u4[3] = u32;
    const Dlen = sum2(C2len, C22, 4, u4, D3);
    return D3[Dlen - 1];
  }
  function orient2d(ax, ay, bx, by, cx, cy) {
    const detleft = (ay - cy) * (bx - cx);
    const detright = (ax - cx) * (by - cy);
    const det2 = detleft - detright;
    const detsum = Math.abs(detleft + detright);
    if (Math.abs(det2) >= ccwerrboundA * detsum) return det2;
    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
  }

  // ../../../../../node_modules/robust-predicates/esm/orient3d.js
  var o3derrboundA = (7 + 56 * epsilon3) * epsilon3;
  var o3derrboundB = (3 + 28 * epsilon3) * epsilon3;
  var o3derrboundC = (26 + 288 * epsilon3) * epsilon3 * epsilon3;
  var bc = vec(4);
  var ca = vec(4);
  var ab = vec(4);
  var at_b = vec(4);
  var at_c = vec(4);
  var bt_c = vec(4);
  var bt_a = vec(4);
  var ct_a = vec(4);
  var ct_b = vec(4);
  var bct = vec(8);
  var cat = vec(8);
  var abt = vec(8);
  var u5 = vec(4);
  var _8 = vec(8);
  var _8b = vec(8);
  var _16 = vec(8);
  var _12 = vec(12);
  var fin = vec(192);
  var fin2 = vec(192);

  // ../../../../../node_modules/robust-predicates/esm/incircle.js
  var iccerrboundA = (10 + 96 * epsilon3) * epsilon3;
  var iccerrboundB = (4 + 48 * epsilon3) * epsilon3;
  var iccerrboundC = (44 + 576 * epsilon3) * epsilon3 * epsilon3;
  var bc2 = vec(4);
  var ca2 = vec(4);
  var ab2 = vec(4);
  var aa = vec(4);
  var bb = vec(4);
  var cc = vec(4);
  var u6 = vec(4);
  var v2 = vec(4);
  var axtbc = vec(8);
  var aytbc = vec(8);
  var bxtca = vec(8);
  var bytca = vec(8);
  var cxtab = vec(8);
  var cytab = vec(8);
  var abt2 = vec(8);
  var bct2 = vec(8);
  var cat2 = vec(8);
  var abtt = vec(4);
  var bctt = vec(4);
  var catt = vec(4);
  var _82 = vec(8);
  var _162 = vec(16);
  var _16b = vec(16);
  var _16c = vec(16);
  var _32 = vec(32);
  var _32b = vec(32);
  var _48 = vec(48);
  var _64 = vec(64);
  var fin3 = vec(1152);
  var fin22 = vec(1152);

  // ../../../../../node_modules/robust-predicates/esm/insphere.js
  var isperrboundA = (16 + 224 * epsilon3) * epsilon3;
  var isperrboundB = (5 + 72 * epsilon3) * epsilon3;
  var isperrboundC = (71 + 1408 * epsilon3) * epsilon3 * epsilon3;
  var ab3 = vec(4);
  var bc3 = vec(4);
  var cd = vec(4);
  var de = vec(4);
  var ea = vec(4);
  var ac = vec(4);
  var bd = vec(4);
  var ce = vec(4);
  var da = vec(4);
  var eb = vec(4);
  var abc = vec(24);
  var bcd = vec(24);
  var cde = vec(24);
  var dea = vec(24);
  var eab = vec(24);
  var abd = vec(24);
  var bce = vec(24);
  var cda = vec(24);
  var deb = vec(24);
  var eac = vec(24);
  var adet = vec(1152);
  var bdet = vec(1152);
  var cdet = vec(1152);
  var ddet = vec(1152);
  var edet = vec(1152);
  var abdet = vec(2304);
  var cddet = vec(2304);
  var cdedet = vec(3456);
  var deter = vec(5760);
  var _83 = vec(8);
  var _8b2 = vec(8);
  var _8c = vec(8);
  var _163 = vec(16);
  var _24 = vec(24);
  var _482 = vec(48);
  var _48b = vec(48);
  var _96 = vec(96);
  var _192 = vec(192);
  var _384x = vec(384);
  var _384y = vec(384);
  var _384z = vec(384);
  var _768 = vec(768);
  var xdet = vec(96);
  var ydet = vec(96);
  var zdet = vec(96);
  var fin4 = vec(1152);

  // ../../../../../node_modules/delaunator/index.js
  var EPSILON = Math.pow(2, -52);
  var EDGE_STACK = new Uint32Array(512);
  var Delaunator = class _Delaunator {
    static from(points, getX = defaultGetX, getY = defaultGetY) {
      const n9 = points.length;
      const coords = new Float64Array(n9 * 2);
      for (let i5 = 0; i5 < n9; i5++) {
        const p11 = points[i5];
        coords[2 * i5] = getX(p11);
        coords[2 * i5 + 1] = getY(p11);
      }
      return new _Delaunator(coords);
    }
    constructor(coords) {
      const n9 = coords.length >> 1;
      if (n9 > 0 && typeof coords[0] !== "number") throw new Error("Expected coords to contain numbers.");
      this.coords = coords;
      const maxTriangles = Math.max(2 * n9 - 5, 0);
      this._triangles = new Uint32Array(maxTriangles * 3);
      this._halfedges = new Int32Array(maxTriangles * 3);
      this._hashSize = Math.ceil(Math.sqrt(n9));
      this._hullPrev = new Uint32Array(n9);
      this._hullNext = new Uint32Array(n9);
      this._hullTri = new Uint32Array(n9);
      this._hullHash = new Int32Array(this._hashSize);
      this._ids = new Uint32Array(n9);
      this._dists = new Float64Array(n9);
      this.update();
    }
    update() {
      const { coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash } = this;
      const n9 = coords.length >> 1;
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY2 = -Infinity;
      for (let i5 = 0; i5 < n9; i5++) {
        const x3 = coords[2 * i5];
        const y3 = coords[2 * i5 + 1];
        if (x3 < minX) minX = x3;
        if (y3 < minY) minY = y3;
        if (x3 > maxX) maxX = x3;
        if (y3 > maxY2) maxY2 = y3;
        this._ids[i5] = i5;
      }
      const cx = (minX + maxX) / 2;
      const cy = (minY + maxY2) / 2;
      let i0, i12, i22;
      for (let i5 = 0, minDist = Infinity; i5 < n9; i5++) {
        const d3 = dist(cx, cy, coords[2 * i5], coords[2 * i5 + 1]);
        if (d3 < minDist) {
          i0 = i5;
          minDist = d3;
        }
      }
      const i0x = coords[2 * i0];
      const i0y = coords[2 * i0 + 1];
      for (let i5 = 0, minDist = Infinity; i5 < n9; i5++) {
        if (i5 === i0) continue;
        const d3 = dist(i0x, i0y, coords[2 * i5], coords[2 * i5 + 1]);
        if (d3 < minDist && d3 > 0) {
          i12 = i5;
          minDist = d3;
        }
      }
      let i1x = coords[2 * i12];
      let i1y = coords[2 * i12 + 1];
      let minRadius = Infinity;
      for (let i5 = 0; i5 < n9; i5++) {
        if (i5 === i0 || i5 === i12) continue;
        const r6 = circumradius(i0x, i0y, i1x, i1y, coords[2 * i5], coords[2 * i5 + 1]);
        if (r6 < minRadius) {
          i22 = i5;
          minRadius = r6;
        }
      }
      let i2x = coords[2 * i22];
      let i2y = coords[2 * i22 + 1];
      if (minRadius === Infinity) {
        for (let i5 = 0; i5 < n9; i5++) {
          this._dists[i5] = coords[2 * i5] - coords[0] || coords[2 * i5 + 1] - coords[1];
        }
        quicksort(this._ids, this._dists, 0, n9 - 1);
        const hull2 = new Uint32Array(n9);
        let j2 = 0;
        for (let i5 = 0, d0 = -Infinity; i5 < n9; i5++) {
          const id2 = this._ids[i5];
          const d3 = this._dists[id2];
          if (d3 > d0) {
            hull2[j2++] = id2;
            d0 = d3;
          }
        }
        this.hull = hull2.subarray(0, j2);
        this.triangles = new Uint32Array(0);
        this.halfedges = new Uint32Array(0);
        return;
      }
      if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
        const i5 = i12;
        const x3 = i1x;
        const y3 = i1y;
        i12 = i22;
        i1x = i2x;
        i1y = i2y;
        i22 = i5;
        i2x = x3;
        i2y = y3;
      }
      const center2 = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
      this._cx = center2.x;
      this._cy = center2.y;
      for (let i5 = 0; i5 < n9; i5++) {
        this._dists[i5] = dist(coords[2 * i5], coords[2 * i5 + 1], center2.x, center2.y);
      }
      quicksort(this._ids, this._dists, 0, n9 - 1);
      this._hullStart = i0;
      let hullSize = 3;
      hullNext[i0] = hullPrev[i22] = i12;
      hullNext[i12] = hullPrev[i0] = i22;
      hullNext[i22] = hullPrev[i12] = i0;
      hullTri[i0] = 0;
      hullTri[i12] = 1;
      hullTri[i22] = 2;
      hullHash.fill(-1);
      hullHash[this._hashKey(i0x, i0y)] = i0;
      hullHash[this._hashKey(i1x, i1y)] = i12;
      hullHash[this._hashKey(i2x, i2y)] = i22;
      this.trianglesLen = 0;
      this._addTriangle(i0, i12, i22, -1, -1, -1);
      for (let k3 = 0, xp, yp; k3 < this._ids.length; k3++) {
        const i5 = this._ids[k3];
        const x3 = coords[2 * i5];
        const y3 = coords[2 * i5 + 1];
        if (k3 > 0 && Math.abs(x3 - xp) <= EPSILON && Math.abs(y3 - yp) <= EPSILON) continue;
        xp = x3;
        yp = y3;
        if (i5 === i0 || i5 === i12 || i5 === i22) continue;
        let start2 = 0;
        for (let j2 = 0, key = this._hashKey(x3, y3); j2 < this._hashSize; j2++) {
          start2 = hullHash[(key + j2) % this._hashSize];
          if (start2 !== -1 && start2 !== hullNext[start2]) break;
        }
        start2 = hullPrev[start2];
        let e11 = start2, q;
        while (q = hullNext[e11], orient2d(x3, y3, coords[2 * e11], coords[2 * e11 + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
          e11 = q;
          if (e11 === start2) {
            e11 = -1;
            break;
          }
        }
        if (e11 === -1) continue;
        let t5 = this._addTriangle(e11, i5, hullNext[e11], -1, -1, hullTri[e11]);
        hullTri[i5] = this._legalize(t5 + 2);
        hullTri[e11] = t5;
        hullSize++;
        let n10 = hullNext[e11];
        while (q = hullNext[n10], orient2d(x3, y3, coords[2 * n10], coords[2 * n10 + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
          t5 = this._addTriangle(n10, i5, q, hullTri[i5], -1, hullTri[n10]);
          hullTri[i5] = this._legalize(t5 + 2);
          hullNext[n10] = n10;
          hullSize--;
          n10 = q;
        }
        if (e11 === start2) {
          while (q = hullPrev[e11], orient2d(x3, y3, coords[2 * q], coords[2 * q + 1], coords[2 * e11], coords[2 * e11 + 1]) < 0) {
            t5 = this._addTriangle(q, i5, e11, -1, hullTri[e11], hullTri[q]);
            this._legalize(t5 + 2);
            hullTri[q] = t5;
            hullNext[e11] = e11;
            hullSize--;
            e11 = q;
          }
        }
        this._hullStart = hullPrev[i5] = e11;
        hullNext[e11] = hullPrev[n10] = i5;
        hullNext[i5] = n10;
        hullHash[this._hashKey(x3, y3)] = i5;
        hullHash[this._hashKey(coords[2 * e11], coords[2 * e11 + 1])] = e11;
      }
      this.hull = new Uint32Array(hullSize);
      for (let i5 = 0, e11 = this._hullStart; i5 < hullSize; i5++) {
        this.hull[i5] = e11;
        e11 = hullNext[e11];
      }
      this.triangles = this._triangles.subarray(0, this.trianglesLen);
      this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
    }
    _hashKey(x3, y3) {
      return Math.floor(pseudoAngle(x3 - this._cx, y3 - this._cy) * this._hashSize) % this._hashSize;
    }
    _legalize(a5) {
      const { _triangles: triangles, _halfedges: halfedges, coords } = this;
      let i5 = 0;
      let ar = 0;
      while (true) {
        const b2 = halfedges[a5];
        const a0 = a5 - a5 % 3;
        ar = a0 + (a5 + 2) % 3;
        if (b2 === -1) {
          if (i5 === 0) break;
          a5 = EDGE_STACK[--i5];
          continue;
        }
        const b0 = b2 - b2 % 3;
        const al = a0 + (a5 + 1) % 3;
        const bl = b0 + (b2 + 2) % 3;
        const p02 = triangles[ar];
        const pr = triangles[a5];
        const pl = triangles[al];
        const p12 = triangles[bl];
        const illegal = inCircle(
          coords[2 * p02],
          coords[2 * p02 + 1],
          coords[2 * pr],
          coords[2 * pr + 1],
          coords[2 * pl],
          coords[2 * pl + 1],
          coords[2 * p12],
          coords[2 * p12 + 1]
        );
        if (illegal) {
          triangles[a5] = p12;
          triangles[b2] = p02;
          const hbl = halfedges[bl];
          if (hbl === -1) {
            let e11 = this._hullStart;
            do {
              if (this._hullTri[e11] === bl) {
                this._hullTri[e11] = a5;
                break;
              }
              e11 = this._hullPrev[e11];
            } while (e11 !== this._hullStart);
          }
          this._link(a5, hbl);
          this._link(b2, halfedges[ar]);
          this._link(ar, bl);
          const br = b0 + (b2 + 1) % 3;
          if (i5 < EDGE_STACK.length) {
            EDGE_STACK[i5++] = br;
          }
        } else {
          if (i5 === 0) break;
          a5 = EDGE_STACK[--i5];
        }
      }
      return ar;
    }
    _link(a5, b2) {
      this._halfedges[a5] = b2;
      if (b2 !== -1) this._halfedges[b2] = a5;
    }
    // add a new triangle given vertex indices and adjacent half-edge ids
    _addTriangle(i0, i12, i22, a5, b2, c9) {
      const t5 = this.trianglesLen;
      this._triangles[t5] = i0;
      this._triangles[t5 + 1] = i12;
      this._triangles[t5 + 2] = i22;
      this._link(t5, a5);
      this._link(t5 + 1, b2);
      this._link(t5 + 2, c9);
      this.trianglesLen += 3;
      return t5;
    }
  };
  function pseudoAngle(dx, dy) {
    const p11 = dx / (Math.abs(dx) + Math.abs(dy));
    return (dy > 0 ? 3 - p11 : 1 + p11) / 4;
  }
  function dist(ax, ay, bx, by) {
    const dx = ax - bx;
    const dy = ay - by;
    return dx * dx + dy * dy;
  }
  function inCircle(ax, ay, bx, by, cx, cy, px, py) {
    const dx = ax - px;
    const dy = ay - py;
    const ex = bx - px;
    const ey = by - py;
    const fx = cx - px;
    const fy = cy - py;
    const ap = dx * dx + dy * dy;
    const bp = ex * ex + ey * ey;
    const cp = fx * fx + fy * fy;
    return dx * (ey * cp - bp * fy) - dy * (ex * cp - bp * fx) + ap * (ex * fy - ey * fx) < 0;
  }
  function circumradius(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;
    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d3 = 0.5 / (dx * ey - dy * ex);
    const x3 = (ey * bl - dy * cl) * d3;
    const y3 = (dx * cl - ex * bl) * d3;
    return x3 * x3 + y3 * y3;
  }
  function circumcenter(ax, ay, bx, by, cx, cy) {
    const dx = bx - ax;
    const dy = by - ay;
    const ex = cx - ax;
    const ey = cy - ay;
    const bl = dx * dx + dy * dy;
    const cl = ex * ex + ey * ey;
    const d3 = 0.5 / (dx * ey - dy * ex);
    const x3 = ax + (ey * bl - dy * cl) * d3;
    const y3 = ay + (dx * cl - ex * bl) * d3;
    return { x: x3, y: y3 };
  }
  function quicksort(ids, dists, left2, right2) {
    if (right2 - left2 <= 20) {
      for (let i5 = left2 + 1; i5 <= right2; i5++) {
        const temp = ids[i5];
        const tempDist = dists[temp];
        let j2 = i5 - 1;
        while (j2 >= left2 && dists[ids[j2]] > tempDist) ids[j2 + 1] = ids[j2--];
        ids[j2 + 1] = temp;
      }
    } else {
      const median2 = left2 + right2 >> 1;
      let i5 = left2 + 1;
      let j2 = right2;
      swap3(ids, median2, i5);
      if (dists[ids[left2]] > dists[ids[right2]]) swap3(ids, left2, right2);
      if (dists[ids[i5]] > dists[ids[right2]]) swap3(ids, i5, right2);
      if (dists[ids[left2]] > dists[ids[i5]]) swap3(ids, left2, i5);
      const temp = ids[i5];
      const tempDist = dists[temp];
      while (true) {
        do
          i5++;
        while (dists[ids[i5]] < tempDist);
        do
          j2--;
        while (dists[ids[j2]] > tempDist);
        if (j2 < i5) break;
        swap3(ids, i5, j2);
      }
      ids[left2 + 1] = ids[j2];
      ids[j2] = temp;
      if (right2 - i5 + 1 >= j2 - left2) {
        quicksort(ids, dists, i5, right2);
        quicksort(ids, dists, left2, j2 - 1);
      } else {
        quicksort(ids, dists, left2, j2 - 1);
        quicksort(ids, dists, i5, right2);
      }
    }
  }
  function swap3(arr, i5, j2) {
    const tmp = arr[i5];
    arr[i5] = arr[j2];
    arr[j2] = tmp;
  }
  function defaultGetX(p11) {
    return p11[0];
  }
  function defaultGetY(p11) {
    return p11[1];
  }

  // ../../../../../node_modules/d3-delaunay/src/path.js
  var epsilon4 = 1e-6;
  var Path2 = class {
    constructor() {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null;
      this._ = "";
    }
    moveTo(x3, y3) {
      this._ += `M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}`;
    }
    closePath() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._ += "Z";
      }
    }
    lineTo(x3, y3) {
      this._ += `L${this._x1 = +x3},${this._y1 = +y3}`;
    }
    arc(x3, y3, r6) {
      x3 = +x3, y3 = +y3, r6 = +r6;
      const x06 = x3 + r6;
      const y06 = y3;
      if (r6 < 0) throw new Error("negative radius");
      if (this._x1 === null) this._ += `M${x06},${y06}`;
      else if (Math.abs(this._x1 - x06) > epsilon4 || Math.abs(this._y1 - y06) > epsilon4) this._ += "L" + x06 + "," + y06;
      if (!r6) return;
      this._ += `A${r6},${r6},0,1,1,${x3 - r6},${y3}A${r6},${r6},0,1,1,${this._x1 = x06},${this._y1 = y06}`;
    }
    rect(x3, y3, w2, h5) {
      this._ += `M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}h${+w2}v${+h5}h${-w2}Z`;
    }
    value() {
      return this._ || null;
    }
  };

  // ../../../../../node_modules/d3-delaunay/src/polygon.js
  var Polygon = class {
    constructor() {
      this._ = [];
    }
    moveTo(x3, y3) {
      this._.push([x3, y3]);
    }
    closePath() {
      this._.push(this._[0].slice());
    }
    lineTo(x3, y3) {
      this._.push([x3, y3]);
    }
    value() {
      return this._.length ? this._ : null;
    }
  };

  // ../../../../../node_modules/d3-delaunay/src/voronoi.js
  var Voronoi = class {
    constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
      if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
      this.delaunay = delaunay;
      this._circumcenters = new Float64Array(delaunay.points.length * 2);
      this.vectors = new Float64Array(delaunay.points.length * 2);
      this.xmax = xmax, this.xmin = xmin;
      this.ymax = ymax, this.ymin = ymin;
      this._init();
    }
    update() {
      this.delaunay.update();
      this._init();
      return this;
    }
    _init() {
      const { delaunay: { points, hull: hull2, triangles }, vectors } = this;
      let bx, by;
      const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
      for (let i5 = 0, j2 = 0, n9 = triangles.length, x3, y3; i5 < n9; i5 += 3, j2 += 2) {
        const t13 = triangles[i5] * 2;
        const t23 = triangles[i5 + 1] * 2;
        const t33 = triangles[i5 + 2] * 2;
        const x13 = points[t13];
        const y13 = points[t13 + 1];
        const x22 = points[t23];
        const y22 = points[t23 + 1];
        const x32 = points[t33];
        const y32 = points[t33 + 1];
        const dx = x22 - x13;
        const dy = y22 - y13;
        const ex = x32 - x13;
        const ey = y32 - y13;
        const ab4 = (dx * ey - dy * ex) * 2;
        if (Math.abs(ab4) < 1e-9) {
          if (bx === void 0) {
            bx = by = 0;
            for (const i6 of hull2) bx += points[i6 * 2], by += points[i6 * 2 + 1];
            bx /= hull2.length, by /= hull2.length;
          }
          const a5 = 1e9 * Math.sign((bx - x13) * ey - (by - y13) * ex);
          x3 = (x13 + x32) / 2 - a5 * ey;
          y3 = (y13 + y32) / 2 + a5 * ex;
        } else {
          const d3 = 1 / ab4;
          const bl = dx * dx + dy * dy;
          const cl = ex * ex + ey * ey;
          x3 = x13 + (ey * bl - dy * cl) * d3;
          y3 = y13 + (dx * cl - ex * bl) * d3;
        }
        circumcenters[j2] = x3;
        circumcenters[j2 + 1] = y3;
      }
      let h5 = hull2[hull2.length - 1];
      let p02, p12 = h5 * 4;
      let x06, x12 = points[2 * h5];
      let y06, y12 = points[2 * h5 + 1];
      vectors.fill(0);
      for (let i5 = 0; i5 < hull2.length; ++i5) {
        h5 = hull2[i5];
        p02 = p12, x06 = x12, y06 = y12;
        p12 = h5 * 4, x12 = points[2 * h5], y12 = points[2 * h5 + 1];
        vectors[p02 + 2] = vectors[p12] = y06 - y12;
        vectors[p02 + 3] = vectors[p12 + 1] = x12 - x06;
      }
    }
    render(context) {
      const buffer2 = context == null ? context = new Path2() : void 0;
      const { delaunay: { halfedges, inedges, hull: hull2 }, circumcenters, vectors } = this;
      if (hull2.length <= 1) return null;
      for (let i5 = 0, n9 = halfedges.length; i5 < n9; ++i5) {
        const j2 = halfedges[i5];
        if (j2 < i5) continue;
        const ti = Math.floor(i5 / 3) * 2;
        const tj = Math.floor(j2 / 3) * 2;
        const xi = circumcenters[ti];
        const yi = circumcenters[ti + 1];
        const xj = circumcenters[tj];
        const yj = circumcenters[tj + 1];
        this._renderSegment(xi, yi, xj, yj, context);
      }
      let h0, h1 = hull2[hull2.length - 1];
      for (let i5 = 0; i5 < hull2.length; ++i5) {
        h0 = h1, h1 = hull2[i5];
        const t5 = Math.floor(inedges[h1] / 3) * 2;
        const x3 = circumcenters[t5];
        const y3 = circumcenters[t5 + 1];
        const v3 = h0 * 4;
        const p11 = this._project(x3, y3, vectors[v3 + 2], vectors[v3 + 3]);
        if (p11) this._renderSegment(x3, y3, p11[0], p11[1], context);
      }
      return buffer2 && buffer2.value();
    }
    renderBounds(context) {
      const buffer2 = context == null ? context = new Path2() : void 0;
      context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
      return buffer2 && buffer2.value();
    }
    renderCell(i5, context) {
      const buffer2 = context == null ? context = new Path2() : void 0;
      const points = this._clip(i5);
      if (points === null || !points.length) return;
      context.moveTo(points[0], points[1]);
      let n9 = points.length;
      while (points[0] === points[n9 - 2] && points[1] === points[n9 - 1] && n9 > 1) n9 -= 2;
      for (let i6 = 2; i6 < n9; i6 += 2) {
        if (points[i6] !== points[i6 - 2] || points[i6 + 1] !== points[i6 - 1])
          context.lineTo(points[i6], points[i6 + 1]);
      }
      context.closePath();
      return buffer2 && buffer2.value();
    }
    *cellPolygons() {
      const { delaunay: { points } } = this;
      for (let i5 = 0, n9 = points.length / 2; i5 < n9; ++i5) {
        const cell2 = this.cellPolygon(i5);
        if (cell2) cell2.index = i5, yield cell2;
      }
    }
    cellPolygon(i5) {
      const polygon = new Polygon();
      this.renderCell(i5, polygon);
      return polygon.value();
    }
    _renderSegment(x06, y06, x12, y12, context) {
      let S3;
      const c0 = this._regioncode(x06, y06);
      const c1 = this._regioncode(x12, y12);
      if (c0 === 0 && c1 === 0) {
        context.moveTo(x06, y06);
        context.lineTo(x12, y12);
      } else if (S3 = this._clipSegment(x06, y06, x12, y12, c0, c1)) {
        context.moveTo(S3[0], S3[1]);
        context.lineTo(S3[2], S3[3]);
      }
    }
    contains(i5, x3, y3) {
      if ((x3 = +x3, x3 !== x3) || (y3 = +y3, y3 !== y3)) return false;
      return this.delaunay._step(i5, x3, y3) === i5;
    }
    *neighbors(i5) {
      const ci = this._clip(i5);
      if (ci) for (const j2 of this.delaunay.neighbors(i5)) {
        const cj = this._clip(j2);
        if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
          for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
            if (ci[ai] === cj[aj] && ci[ai + 1] === cj[aj + 1] && ci[(ai + 2) % li] === cj[(aj + lj - 2) % lj] && ci[(ai + 3) % li] === cj[(aj + lj - 1) % lj]) {
              yield j2;
              break loop;
            }
          }
        }
      }
    }
    _cell(i5) {
      const { circumcenters, delaunay: { inedges, halfedges, triangles } } = this;
      const e0 = inedges[i5];
      if (e0 === -1) return null;
      const points = [];
      let e11 = e0;
      do {
        const t5 = Math.floor(e11 / 3);
        points.push(circumcenters[t5 * 2], circumcenters[t5 * 2 + 1]);
        e11 = e11 % 3 === 2 ? e11 - 2 : e11 + 1;
        if (triangles[e11] !== i5) break;
        e11 = halfedges[e11];
      } while (e11 !== e0 && e11 !== -1);
      return points;
    }
    _clip(i5) {
      if (i5 === 0 && this.delaunay.hull.length === 1) {
        return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
      }
      const points = this._cell(i5);
      if (points === null) return null;
      const { vectors: V2 } = this;
      const v3 = i5 * 4;
      return this._simplify(V2[v3] || V2[v3 + 1] ? this._clipInfinite(i5, points, V2[v3], V2[v3 + 1], V2[v3 + 2], V2[v3 + 3]) : this._clipFinite(i5, points));
    }
    _clipFinite(i5, points) {
      const n9 = points.length;
      let P2 = null;
      let x06, y06, x12 = points[n9 - 2], y12 = points[n9 - 1];
      let c0, c1 = this._regioncode(x12, y12);
      let e0, e1 = 0;
      for (let j2 = 0; j2 < n9; j2 += 2) {
        x06 = x12, y06 = y12, x12 = points[j2], y12 = points[j2 + 1];
        c0 = c1, c1 = this._regioncode(x12, y12);
        if (c0 === 0 && c1 === 0) {
          e0 = e1, e1 = 0;
          if (P2) P2.push(x12, y12);
          else P2 = [x12, y12];
        } else {
          let S3, sx0, sy0, sx1, sy1;
          if (c0 === 0) {
            if ((S3 = this._clipSegment(x06, y06, x12, y12, c0, c1)) === null) continue;
            [sx0, sy0, sx1, sy1] = S3;
          } else {
            if ((S3 = this._clipSegment(x12, y12, x06, y06, c1, c0)) === null) continue;
            [sx1, sy1, sx0, sy0] = S3;
            e0 = e1, e1 = this._edgecode(sx0, sy0);
            if (e0 && e1) this._edge(i5, e0, e1, P2, P2.length);
            if (P2) P2.push(sx0, sy0);
            else P2 = [sx0, sy0];
          }
          e0 = e1, e1 = this._edgecode(sx1, sy1);
          if (e0 && e1) this._edge(i5, e0, e1, P2, P2.length);
          if (P2) P2.push(sx1, sy1);
          else P2 = [sx1, sy1];
        }
      }
      if (P2) {
        e0 = e1, e1 = this._edgecode(P2[0], P2[1]);
        if (e0 && e1) this._edge(i5, e0, e1, P2, P2.length);
      } else if (this.contains(i5, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
        return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
      }
      return P2;
    }
    _clipSegment(x06, y06, x12, y12, c0, c1) {
      const flip2 = c0 < c1;
      if (flip2) [x06, y06, x12, y12, c0, c1] = [x12, y12, x06, y06, c1, c0];
      while (true) {
        if (c0 === 0 && c1 === 0) return flip2 ? [x12, y12, x06, y06] : [x06, y06, x12, y12];
        if (c0 & c1) return null;
        let x3, y3, c9 = c0 || c1;
        if (c9 & 8) x3 = x06 + (x12 - x06) * (this.ymax - y06) / (y12 - y06), y3 = this.ymax;
        else if (c9 & 4) x3 = x06 + (x12 - x06) * (this.ymin - y06) / (y12 - y06), y3 = this.ymin;
        else if (c9 & 2) y3 = y06 + (y12 - y06) * (this.xmax - x06) / (x12 - x06), x3 = this.xmax;
        else y3 = y06 + (y12 - y06) * (this.xmin - x06) / (x12 - x06), x3 = this.xmin;
        if (c0) x06 = x3, y06 = y3, c0 = this._regioncode(x06, y06);
        else x12 = x3, y12 = y3, c1 = this._regioncode(x12, y12);
      }
    }
    _clipInfinite(i5, points, vx0, vy0, vxn, vyn) {
      let P2 = Array.from(points), p11;
      if (p11 = this._project(P2[0], P2[1], vx0, vy0)) P2.unshift(p11[0], p11[1]);
      if (p11 = this._project(P2[P2.length - 2], P2[P2.length - 1], vxn, vyn)) P2.push(p11[0], p11[1]);
      if (P2 = this._clipFinite(i5, P2)) {
        for (let j2 = 0, n9 = P2.length, c0, c1 = this._edgecode(P2[n9 - 2], P2[n9 - 1]); j2 < n9; j2 += 2) {
          c0 = c1, c1 = this._edgecode(P2[j2], P2[j2 + 1]);
          if (c0 && c1) j2 = this._edge(i5, c0, c1, P2, j2), n9 = P2.length;
        }
      } else if (this.contains(i5, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
        P2 = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
      }
      return P2;
    }
    _edge(i5, e0, e1, P2, j2) {
      while (e0 !== e1) {
        let x3, y3;
        switch (e0) {
          case 5:
            e0 = 4;
            continue;
          // top-left
          case 4:
            e0 = 6, x3 = this.xmax, y3 = this.ymin;
            break;
          // top
          case 6:
            e0 = 2;
            continue;
          // top-right
          case 2:
            e0 = 10, x3 = this.xmax, y3 = this.ymax;
            break;
          // right
          case 10:
            e0 = 8;
            continue;
          // bottom-right
          case 8:
            e0 = 9, x3 = this.xmin, y3 = this.ymax;
            break;
          // bottom
          case 9:
            e0 = 1;
            continue;
          // bottom-left
          case 1:
            e0 = 5, x3 = this.xmin, y3 = this.ymin;
            break;
        }
        if ((P2[j2] !== x3 || P2[j2 + 1] !== y3) && this.contains(i5, x3, y3)) {
          P2.splice(j2, 0, x3, y3), j2 += 2;
        }
      }
      return j2;
    }
    _project(x06, y06, vx, vy) {
      let t5 = Infinity, c9, x3, y3;
      if (vy < 0) {
        if (y06 <= this.ymin) return null;
        if ((c9 = (this.ymin - y06) / vy) < t5) y3 = this.ymin, x3 = x06 + (t5 = c9) * vx;
      } else if (vy > 0) {
        if (y06 >= this.ymax) return null;
        if ((c9 = (this.ymax - y06) / vy) < t5) y3 = this.ymax, x3 = x06 + (t5 = c9) * vx;
      }
      if (vx > 0) {
        if (x06 >= this.xmax) return null;
        if ((c9 = (this.xmax - x06) / vx) < t5) x3 = this.xmax, y3 = y06 + (t5 = c9) * vy;
      } else if (vx < 0) {
        if (x06 <= this.xmin) return null;
        if ((c9 = (this.xmin - x06) / vx) < t5) x3 = this.xmin, y3 = y06 + (t5 = c9) * vy;
      }
      return [x3, y3];
    }
    _edgecode(x3, y3) {
      return (x3 === this.xmin ? 1 : x3 === this.xmax ? 2 : 0) | (y3 === this.ymin ? 4 : y3 === this.ymax ? 8 : 0);
    }
    _regioncode(x3, y3) {
      return (x3 < this.xmin ? 1 : x3 > this.xmax ? 2 : 0) | (y3 < this.ymin ? 4 : y3 > this.ymax ? 8 : 0);
    }
    _simplify(P2) {
      if (P2 && P2.length > 4) {
        for (let i5 = 0; i5 < P2.length; i5 += 2) {
          const j2 = (i5 + 2) % P2.length, k3 = (i5 + 4) % P2.length;
          if (P2[i5] === P2[j2] && P2[j2] === P2[k3] || P2[i5 + 1] === P2[j2 + 1] && P2[j2 + 1] === P2[k3 + 1]) {
            P2.splice(j2, 2), i5 -= 2;
          }
        }
        if (!P2.length) P2 = null;
      }
      return P2;
    }
  };

  // ../../../../../node_modules/d3-delaunay/src/delaunay.js
  var tau2 = 2 * Math.PI;
  var pow = Math.pow;
  function pointX(p11) {
    return p11[0];
  }
  function pointY(p11) {
    return p11[1];
  }
  function collinear2(d3) {
    const { triangles, coords } = d3;
    for (let i5 = 0; i5 < triangles.length; i5 += 3) {
      const a5 = 2 * triangles[i5], b2 = 2 * triangles[i5 + 1], c9 = 2 * triangles[i5 + 2], cross3 = (coords[c9] - coords[a5]) * (coords[b2 + 1] - coords[a5 + 1]) - (coords[b2] - coords[a5]) * (coords[c9 + 1] - coords[a5 + 1]);
      if (cross3 > 1e-10) return false;
    }
    return true;
  }
  function jitter(x3, y3, r6) {
    return [x3 + Math.sin(x3 + y3) * r6, y3 + Math.cos(x3 - y3) * r6];
  }
  var Delaunay = class _Delaunay {
    static from(points, fx = pointX, fy = pointY, that) {
      return new _Delaunay("length" in points ? flatArray(points, fx, fy, that) : Float64Array.from(flatIterable(points, fx, fy, that)));
    }
    constructor(points) {
      this._delaunator = new Delaunator(points);
      this.inedges = new Int32Array(points.length / 2);
      this._hullIndex = new Int32Array(points.length / 2);
      this.points = this._delaunator.coords;
      this._init();
    }
    update() {
      this._delaunator.update();
      this._init();
      return this;
    }
    _init() {
      const d3 = this._delaunator, points = this.points;
      if (d3.hull && d3.hull.length > 2 && collinear2(d3)) {
        this.collinear = Int32Array.from({ length: points.length / 2 }, (_2, i5) => i5).sort((i5, j2) => points[2 * i5] - points[2 * j2] || points[2 * i5 + 1] - points[2 * j2 + 1]);
        const e11 = this.collinear[0], f7 = this.collinear[this.collinear.length - 1], bounds = [points[2 * e11], points[2 * e11 + 1], points[2 * f7], points[2 * f7 + 1]], r6 = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
        for (let i5 = 0, n9 = points.length / 2; i5 < n9; ++i5) {
          const p11 = jitter(points[2 * i5], points[2 * i5 + 1], r6);
          points[2 * i5] = p11[0];
          points[2 * i5 + 1] = p11[1];
        }
        this._delaunator = new Delaunator(points);
      } else {
        delete this.collinear;
      }
      const halfedges = this.halfedges = this._delaunator.halfedges;
      const hull2 = this.hull = this._delaunator.hull;
      const triangles = this.triangles = this._delaunator.triangles;
      const inedges = this.inedges.fill(-1);
      const hullIndex = this._hullIndex.fill(-1);
      for (let e11 = 0, n9 = halfedges.length; e11 < n9; ++e11) {
        const p11 = triangles[e11 % 3 === 2 ? e11 - 2 : e11 + 1];
        if (halfedges[e11] === -1 || inedges[p11] === -1) inedges[p11] = e11;
      }
      for (let i5 = 0, n9 = hull2.length; i5 < n9; ++i5) {
        hullIndex[hull2[i5]] = i5;
      }
      if (hull2.length <= 2 && hull2.length > 0) {
        this.triangles = new Int32Array(3).fill(-1);
        this.halfedges = new Int32Array(3).fill(-1);
        this.triangles[0] = hull2[0];
        inedges[hull2[0]] = 1;
        if (hull2.length === 2) {
          inedges[hull2[1]] = 0;
          this.triangles[1] = hull2[1];
          this.triangles[2] = hull2[1];
        }
      }
    }
    voronoi(bounds) {
      return new Voronoi(this, bounds);
    }
    *neighbors(i5) {
      const { inedges, hull: hull2, _hullIndex, halfedges, triangles, collinear: collinear3 } = this;
      if (collinear3) {
        const l8 = collinear3.indexOf(i5);
        if (l8 > 0) yield collinear3[l8 - 1];
        if (l8 < collinear3.length - 1) yield collinear3[l8 + 1];
        return;
      }
      const e0 = inedges[i5];
      if (e0 === -1) return;
      let e11 = e0, p02 = -1;
      do {
        yield p02 = triangles[e11];
        e11 = e11 % 3 === 2 ? e11 - 2 : e11 + 1;
        if (triangles[e11] !== i5) return;
        e11 = halfedges[e11];
        if (e11 === -1) {
          const p11 = hull2[(_hullIndex[i5] + 1) % hull2.length];
          if (p11 !== p02) yield p11;
          return;
        }
      } while (e11 !== e0);
    }
    find(x3, y3, i5 = 0) {
      if ((x3 = +x3, x3 !== x3) || (y3 = +y3, y3 !== y3)) return -1;
      const i0 = i5;
      let c9;
      while ((c9 = this._step(i5, x3, y3)) >= 0 && c9 !== i5 && c9 !== i0) i5 = c9;
      return c9;
    }
    _step(i5, x3, y3) {
      const { inedges, hull: hull2, _hullIndex, halfedges, triangles, points } = this;
      if (inedges[i5] === -1 || !points.length) return (i5 + 1) % (points.length >> 1);
      let c9 = i5;
      let dc = pow(x3 - points[i5 * 2], 2) + pow(y3 - points[i5 * 2 + 1], 2);
      const e0 = inedges[i5];
      let e11 = e0;
      do {
        let t5 = triangles[e11];
        const dt = pow(x3 - points[t5 * 2], 2) + pow(y3 - points[t5 * 2 + 1], 2);
        if (dt < dc) dc = dt, c9 = t5;
        e11 = e11 % 3 === 2 ? e11 - 2 : e11 + 1;
        if (triangles[e11] !== i5) break;
        e11 = halfedges[e11];
        if (e11 === -1) {
          e11 = hull2[(_hullIndex[i5] + 1) % hull2.length];
          if (e11 !== t5) {
            if (pow(x3 - points[e11 * 2], 2) + pow(y3 - points[e11 * 2 + 1], 2) < dc) return e11;
          }
          break;
        }
      } while (e11 !== e0);
      return c9;
    }
    render(context) {
      const buffer2 = context == null ? context = new Path2() : void 0;
      const { points, halfedges, triangles } = this;
      for (let i5 = 0, n9 = halfedges.length; i5 < n9; ++i5) {
        const j2 = halfedges[i5];
        if (j2 < i5) continue;
        const ti = triangles[i5] * 2;
        const tj = triangles[j2] * 2;
        context.moveTo(points[ti], points[ti + 1]);
        context.lineTo(points[tj], points[tj + 1]);
      }
      this.renderHull(context);
      return buffer2 && buffer2.value();
    }
    renderPoints(context, r6) {
      if (r6 === void 0 && (!context || typeof context.moveTo !== "function")) r6 = context, context = null;
      r6 = r6 == void 0 ? 2 : +r6;
      const buffer2 = context == null ? context = new Path2() : void 0;
      const { points } = this;
      for (let i5 = 0, n9 = points.length; i5 < n9; i5 += 2) {
        const x3 = points[i5], y3 = points[i5 + 1];
        context.moveTo(x3 + r6, y3);
        context.arc(x3, y3, r6, 0, tau2);
      }
      return buffer2 && buffer2.value();
    }
    renderHull(context) {
      const buffer2 = context == null ? context = new Path2() : void 0;
      const { hull: hull2, points } = this;
      const h5 = hull2[0] * 2, n9 = hull2.length;
      context.moveTo(points[h5], points[h5 + 1]);
      for (let i5 = 1; i5 < n9; ++i5) {
        const h6 = 2 * hull2[i5];
        context.lineTo(points[h6], points[h6 + 1]);
      }
      context.closePath();
      return buffer2 && buffer2.value();
    }
    hullPolygon() {
      const polygon = new Polygon();
      this.renderHull(polygon);
      return polygon.value();
    }
    renderTriangle(i5, context) {
      const buffer2 = context == null ? context = new Path2() : void 0;
      const { points, triangles } = this;
      const t03 = triangles[i5 *= 3] * 2;
      const t13 = triangles[i5 + 1] * 2;
      const t23 = triangles[i5 + 2] * 2;
      context.moveTo(points[t03], points[t03 + 1]);
      context.lineTo(points[t13], points[t13 + 1]);
      context.lineTo(points[t23], points[t23 + 1]);
      context.closePath();
      return buffer2 && buffer2.value();
    }
    *trianglePolygons() {
      const { triangles } = this;
      for (let i5 = 0, n9 = triangles.length / 3; i5 < n9; ++i5) {
        yield this.trianglePolygon(i5);
      }
    }
    trianglePolygon(i5) {
      const polygon = new Polygon();
      this.renderTriangle(i5, polygon);
      return polygon.value();
    }
  };
  function flatArray(points, fx, fy, that) {
    const n9 = points.length;
    const array3 = new Float64Array(n9 * 2);
    for (let i5 = 0; i5 < n9; ++i5) {
      const p11 = points[i5];
      array3[i5 * 2] = fx.call(that, p11, i5, points);
      array3[i5 * 2 + 1] = fy.call(that, p11, i5, points);
    }
    return array3;
  }
  function* flatIterable(points, fx, fy, that) {
    let i5 = 0;
    for (const p11 of points) {
      yield fx.call(that, p11, i5, points);
      yield fy.call(that, p11, i5, points);
      ++i5;
    }
  }

  // ../../../../../node_modules/d3-format/src/formatDecimal.js
  function formatDecimal_default(x3) {
    return Math.abs(x3 = Math.round(x3)) >= 1e21 ? x3.toLocaleString("en").replace(/,/g, "") : x3.toString(10);
  }
  function formatDecimalParts(x3, p11) {
    if ((i5 = (x3 = p11 ? x3.toExponential(p11 - 1) : x3.toExponential()).indexOf("e")) < 0) return null;
    var i5, coefficient = x3.slice(0, i5);
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x3.slice(i5 + 1)
    ];
  }

  // ../../../../../node_modules/d3-format/src/exponent.js
  function exponent_default(x3) {
    return x3 = formatDecimalParts(Math.abs(x3)), x3 ? x3[1] : NaN;
  }

  // ../../../../../node_modules/d3-format/src/formatGroup.js
  function formatGroup_default(grouping, thousands) {
    return function(value, width) {
      var i5 = value.length, t5 = [], j2 = 0, g2 = grouping[0], length4 = 0;
      while (i5 > 0 && g2 > 0) {
        if (length4 + g2 + 1 > width) g2 = Math.max(1, width - length4);
        t5.push(value.substring(i5 -= g2, i5 + g2));
        if ((length4 += g2 + 1) > width) break;
        g2 = grouping[j2 = (j2 + 1) % grouping.length];
      }
      return t5.reverse().join(thousands);
    };
  }

  // ../../../../../node_modules/d3-format/src/formatNumerals.js
  function formatNumerals_default(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i5) {
        return numerals[+i5];
      });
    };
  }

  // ../../../../../node_modules/d3-format/src/formatSpecifier.js
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function formatSpecifier(specifier) {
    if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier({
      fill: match[1],
      align: match[2],
      sign: match[3],
      symbol: match[4],
      zero: match[5],
      width: match[6],
      comma: match[7],
      precision: match[8] && match[8].slice(1),
      trim: match[9],
      type: match[10]
    });
  }
  formatSpecifier.prototype = FormatSpecifier.prototype;
  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
    this.align = specifier.align === void 0 ? ">" : specifier.align + "";
    this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === void 0 ? void 0 : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === void 0 ? "" : specifier.type + "";
  }
  FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };

  // ../../../../../node_modules/d3-format/src/formatTrim.js
  function formatTrim_default(s8) {
    out: for (var n9 = s8.length, i5 = 1, i0 = -1, i12; i5 < n9; ++i5) {
      switch (s8[i5]) {
        case ".":
          i0 = i12 = i5;
          break;
        case "0":
          if (i0 === 0) i0 = i5;
          i12 = i5;
          break;
        default:
          if (!+s8[i5]) break out;
          if (i0 > 0) i0 = 0;
          break;
      }
    }
    return i0 > 0 ? s8.slice(0, i0) + s8.slice(i12 + 1) : s8;
  }

  // ../../../../../node_modules/d3-format/src/formatPrefixAuto.js
  var prefixExponent;
  function formatPrefixAuto_default(x3, p11) {
    var d3 = formatDecimalParts(x3, p11);
    if (!d3) return x3 + "";
    var coefficient = d3[0], exponent = d3[1], i5 = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n9 = coefficient.length;
    return i5 === n9 ? coefficient : i5 > n9 ? coefficient + new Array(i5 - n9 + 1).join("0") : i5 > 0 ? coefficient.slice(0, i5) + "." + coefficient.slice(i5) : "0." + new Array(1 - i5).join("0") + formatDecimalParts(x3, Math.max(0, p11 + i5 - 1))[0];
  }

  // ../../../../../node_modules/d3-format/src/formatRounded.js
  function formatRounded_default(x3, p11) {
    var d3 = formatDecimalParts(x3, p11);
    if (!d3) return x3 + "";
    var coefficient = d3[0], exponent = d3[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  // ../../../../../node_modules/d3-format/src/formatTypes.js
  var formatTypes_default = {
    "%": (x3, p11) => (x3 * 100).toFixed(p11),
    "b": (x3) => Math.round(x3).toString(2),
    "c": (x3) => x3 + "",
    "d": formatDecimal_default,
    "e": (x3, p11) => x3.toExponential(p11),
    "f": (x3, p11) => x3.toFixed(p11),
    "g": (x3, p11) => x3.toPrecision(p11),
    "o": (x3) => Math.round(x3).toString(8),
    "p": (x3, p11) => formatRounded_default(x3 * 100, p11),
    "r": formatRounded_default,
    "s": formatPrefixAuto_default,
    "X": (x3) => Math.round(x3).toString(16).toUpperCase(),
    "x": (x3) => Math.round(x3).toString(16)
  };

  // ../../../../../node_modules/d3-format/src/identity.js
  function identity_default2(x3) {
    return x3;
  }

  // ../../../../../node_modules/d3-format/src/locale.js
  var map = Array.prototype.map;
  var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function locale_default(locale3) {
    var group3 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default2 : formatGroup_default(map.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default2 : formatNumerals_default(map.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "\u2212" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);
      var fill = specifier.fill, align = specifier.align, sign4 = specifier.sign, symbol3 = specifier.symbol, zero4 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type2 = specifier.type;
      if (type2 === "n") comma = true, type2 = "g";
      else if (!formatTypes_default[type2]) precision === void 0 && (precision = 12), trim = true, type2 = "g";
      if (zero4 || fill === "0" && align === "=") zero4 = true, fill = "0", align = "=";
      var prefix = symbol3 === "$" ? currencyPrefix : symbol3 === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol3 === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
      var formatType = formatTypes_default[type2], maybeSuffix = /[defgprs%]/.test(type2);
      precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
      function format3(value) {
        var valuePrefix = prefix, valueSuffix = suffix, i5, n9, c9;
        if (type2 === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;
          var valueNegative = value < 0 || 1 / value < 0;
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
          if (trim) value = formatTrim_default(value);
          if (valueNegative && +value === 0 && sign4 !== "+") valueNegative = false;
          valuePrefix = (valueNegative ? sign4 === "(" ? sign4 : minus : sign4 === "-" || sign4 === "(" ? "" : sign4) + valuePrefix;
          valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign4 === "(" ? ")" : "");
          if (maybeSuffix) {
            i5 = -1, n9 = value.length;
            while (++i5 < n9) {
              if (c9 = value.charCodeAt(i5), 48 > c9 || c9 > 57) {
                valueSuffix = (c9 === 46 ? decimal + value.slice(i5 + 1) : value.slice(i5)) + valueSuffix;
                value = value.slice(0, i5);
                break;
              }
            }
          }
        }
        if (comma && !zero4) value = group3(value, Infinity);
        var length4 = valuePrefix.length + value.length + valueSuffix.length, padding = length4 < width ? new Array(width - length4 + 1).join(fill) : "";
        if (comma && zero4) value = group3(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
        switch (align) {
          case "<":
            value = valuePrefix + value + valueSuffix + padding;
            break;
          case "=":
            value = valuePrefix + padding + value + valueSuffix;
            break;
          case "^":
            value = padding.slice(0, length4 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length4);
            break;
          default:
            value = padding + valuePrefix + value + valueSuffix;
            break;
        }
        return numerals(value);
      }
      format3.toString = function() {
        return specifier + "";
      };
      return format3;
    }
    function formatPrefix2(specifier, value) {
      var f7 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e11 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k3 = Math.pow(10, -e11), prefix = prefixes[8 + e11 / 3];
      return function(value2) {
        return f7(k3 * value2) + prefix;
      };
    }
    return {
      format: newFormat,
      formatPrefix: formatPrefix2
    };
  }

  // ../../../../../node_modules/d3-format/src/defaultLocale.js
  var locale;
  var format;
  var formatPrefix;
  defaultLocale({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function defaultLocale(definition) {
    locale = locale_default(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  // ../../../../../node_modules/d3-format/src/precisionFixed.js
  function precisionFixed_default(step3) {
    return Math.max(0, -exponent_default(Math.abs(step3)));
  }

  // ../../../../../node_modules/d3-format/src/precisionPrefix.js
  function precisionPrefix_default(step3, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step3)));
  }

  // ../../../../../node_modules/d3-format/src/precisionRound.js
  function precisionRound_default(step3, max3) {
    step3 = Math.abs(step3), max3 = Math.abs(max3) - step3;
    return Math.max(0, exponent_default(max3) - exponent_default(step3)) + 1;
  }

  // ../../../../../node_modules/d3-geo/src/math.js
  var epsilon5 = 1e-6;
  var epsilon22 = 1e-12;
  var pi2 = Math.PI;
  var halfPi = pi2 / 2;
  var quarterPi = pi2 / 4;
  var tau3 = pi2 * 2;
  var degrees3 = 180 / pi2;
  var radians2 = pi2 / 180;
  var abs3 = Math.abs;
  var atan = Math.atan;
  var atan2 = Math.atan2;
  var cos = Math.cos;
  var ceil = Math.ceil;
  var exp = Math.exp;
  var hypot = Math.hypot;
  var log = Math.log;
  var pow2 = Math.pow;
  var sin = Math.sin;
  var sign2 = Math.sign || function(x3) {
    return x3 > 0 ? 1 : x3 < 0 ? -1 : 0;
  };
  var sqrt = Math.sqrt;
  var tan = Math.tan;
  function acos(x3) {
    return x3 > 1 ? 0 : x3 < -1 ? pi2 : Math.acos(x3);
  }
  function asin(x3) {
    return x3 > 1 ? halfPi : x3 < -1 ? -halfPi : Math.asin(x3);
  }

  // ../../../../../node_modules/d3-geo/src/noop.js
  function noop2() {
  }

  // ../../../../../node_modules/d3-geo/src/stream.js
  function streamGeometry(geometry, stream) {
    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
      streamGeometryType[geometry.type](geometry, stream);
    }
  }
  var streamObjectType = {
    Feature: function(object, stream) {
      streamGeometry(object.geometry, stream);
    },
    FeatureCollection: function(object, stream) {
      var features = object.features, i5 = -1, n9 = features.length;
      while (++i5 < n9) streamGeometry(features[i5].geometry, stream);
    }
  };
  var streamGeometryType = {
    Sphere: function(object, stream) {
      stream.sphere();
    },
    Point: function(object, stream) {
      object = object.coordinates;
      stream.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, stream) {
      var coordinates = object.coordinates, i5 = -1, n9 = coordinates.length;
      while (++i5 < n9) object = coordinates[i5], stream.point(object[0], object[1], object[2]);
    },
    LineString: function(object, stream) {
      streamLine(object.coordinates, stream, 0);
    },
    MultiLineString: function(object, stream) {
      var coordinates = object.coordinates, i5 = -1, n9 = coordinates.length;
      while (++i5 < n9) streamLine(coordinates[i5], stream, 0);
    },
    Polygon: function(object, stream) {
      streamPolygon(object.coordinates, stream);
    },
    MultiPolygon: function(object, stream) {
      var coordinates = object.coordinates, i5 = -1, n9 = coordinates.length;
      while (++i5 < n9) streamPolygon(coordinates[i5], stream);
    },
    GeometryCollection: function(object, stream) {
      var geometries = object.geometries, i5 = -1, n9 = geometries.length;
      while (++i5 < n9) streamGeometry(geometries[i5], stream);
    }
  };
  function streamLine(coordinates, stream, closed) {
    var i5 = -1, n9 = coordinates.length - closed, coordinate;
    stream.lineStart();
    while (++i5 < n9) coordinate = coordinates[i5], stream.point(coordinate[0], coordinate[1], coordinate[2]);
    stream.lineEnd();
  }
  function streamPolygon(coordinates, stream) {
    var i5 = -1, n9 = coordinates.length;
    stream.polygonStart();
    while (++i5 < n9) streamLine(coordinates[i5], stream, 1);
    stream.polygonEnd();
  }
  function stream_default(object, stream) {
    if (object && streamObjectType.hasOwnProperty(object.type)) {
      streamObjectType[object.type](object, stream);
    } else {
      streamGeometry(object, stream);
    }
  }

  // ../../../../../node_modules/d3-geo/src/cartesian.js
  function spherical(cartesian2) {
    return [atan2(cartesian2[1], cartesian2[0]), asin(cartesian2[2])];
  }
  function cartesian(spherical2) {
    var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos(phi);
    return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];
  }
  function cartesianDot(a5, b2) {
    return a5[0] * b2[0] + a5[1] * b2[1] + a5[2] * b2[2];
  }
  function cartesianCross(a5, b2) {
    return [a5[1] * b2[2] - a5[2] * b2[1], a5[2] * b2[0] - a5[0] * b2[2], a5[0] * b2[1] - a5[1] * b2[0]];
  }
  function cartesianAddInPlace(a5, b2) {
    a5[0] += b2[0], a5[1] += b2[1], a5[2] += b2[2];
  }
  function cartesianScale(vector2, k3) {
    return [vector2[0] * k3, vector2[1] * k3, vector2[2] * k3];
  }
  function cartesianNormalizeInPlace(d3) {
    var l8 = sqrt(d3[0] * d3[0] + d3[1] * d3[1] + d3[2] * d3[2]);
    d3[0] /= l8, d3[1] /= l8, d3[2] /= l8;
  }

  // ../../../../../node_modules/d3-geo/src/centroid.js
  var W0;
  var W1;
  var X0;
  var Y0;
  var Z0;
  var X1;
  var Y1;
  var Z1;
  var X2;
  var Y2;
  var Z2;
  var lambda00;
  var phi00;
  var x0;
  var y0;
  var z0;
  var centroidStream = {
    sphere: noop2,
    point: centroidPoint,
    lineStart: centroidLineStart,
    lineEnd: centroidLineEnd,
    polygonStart: function() {
      centroidStream.lineStart = centroidRingStart;
      centroidStream.lineEnd = centroidRingEnd;
    },
    polygonEnd: function() {
      centroidStream.lineStart = centroidLineStart;
      centroidStream.lineEnd = centroidLineEnd;
    }
  };
  function centroidPoint(lambda, phi) {
    lambda *= radians2, phi *= radians2;
    var cosPhi = cos(phi);
    centroidPointCartesian(cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi));
  }
  function centroidPointCartesian(x3, y3, z2) {
    ++W0;
    X0 += (x3 - X0) / W0;
    Y0 += (y3 - Y0) / W0;
    Z0 += (z2 - Z0) / W0;
  }
  function centroidLineStart() {
    centroidStream.point = centroidLinePointFirst;
  }
  function centroidLinePointFirst(lambda, phi) {
    lambda *= radians2, phi *= radians2;
    var cosPhi = cos(phi);
    x0 = cosPhi * cos(lambda);
    y0 = cosPhi * sin(lambda);
    z0 = sin(phi);
    centroidStream.point = centroidLinePoint;
    centroidPointCartesian(x0, y0, z0);
  }
  function centroidLinePoint(lambda, phi) {
    lambda *= radians2, phi *= radians2;
    var cosPhi = cos(phi), x3 = cosPhi * cos(lambda), y3 = cosPhi * sin(lambda), z2 = sin(phi), w2 = atan2(sqrt((w2 = y0 * z2 - z0 * y3) * w2 + (w2 = z0 * x3 - x0 * z2) * w2 + (w2 = x0 * y3 - y0 * x3) * w2), x0 * x3 + y0 * y3 + z0 * z2);
    W1 += w2;
    X1 += w2 * (x0 + (x0 = x3));
    Y1 += w2 * (y0 + (y0 = y3));
    Z1 += w2 * (z0 + (z0 = z2));
    centroidPointCartesian(x0, y0, z0);
  }
  function centroidLineEnd() {
    centroidStream.point = centroidPoint;
  }
  function centroidRingStart() {
    centroidStream.point = centroidRingPointFirst;
  }
  function centroidRingEnd() {
    centroidRingPoint(lambda00, phi00);
    centroidStream.point = centroidPoint;
  }
  function centroidRingPointFirst(lambda, phi) {
    lambda00 = lambda, phi00 = phi;
    lambda *= radians2, phi *= radians2;
    centroidStream.point = centroidRingPoint;
    var cosPhi = cos(phi);
    x0 = cosPhi * cos(lambda);
    y0 = cosPhi * sin(lambda);
    z0 = sin(phi);
    centroidPointCartesian(x0, y0, z0);
  }
  function centroidRingPoint(lambda, phi) {
    lambda *= radians2, phi *= radians2;
    var cosPhi = cos(phi), x3 = cosPhi * cos(lambda), y3 = cosPhi * sin(lambda), z2 = sin(phi), cx = y0 * z2 - z0 * y3, cy = z0 * x3 - x0 * z2, cz = x0 * y3 - y0 * x3, m3 = hypot(cx, cy, cz), w2 = asin(m3), v3 = m3 && -w2 / m3;
    X2.add(v3 * cx);
    Y2.add(v3 * cy);
    Z2.add(v3 * cz);
    W1 += w2;
    X1 += w2 * (x0 + (x0 = x3));
    Y1 += w2 * (y0 + (y0 = y3));
    Z1 += w2 * (z0 + (z0 = z2));
    centroidPointCartesian(x0, y0, z0);
  }
  function centroid_default(object) {
    W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = 0;
    X2 = new Adder();
    Y2 = new Adder();
    Z2 = new Adder();
    stream_default(object, centroidStream);
    var x3 = +X2, y3 = +Y2, z2 = +Z2, m3 = hypot(x3, y3, z2);
    if (m3 < epsilon22) {
      x3 = X1, y3 = Y1, z2 = Z1;
      if (W1 < epsilon5) x3 = X0, y3 = Y0, z2 = Z0;
      m3 = hypot(x3, y3, z2);
      if (m3 < epsilon22) return [NaN, NaN];
    }
    return [atan2(y3, x3) * degrees3, asin(z2 / m3) * degrees3];
  }

  // ../../../../../node_modules/d3-geo/src/compose.js
  function compose_default(a5, b2) {
    function compose(x3, y3) {
      return x3 = a5(x3, y3), b2(x3[0], x3[1]);
    }
    if (a5.invert && b2.invert) compose.invert = function(x3, y3) {
      return x3 = b2.invert(x3, y3), x3 && a5.invert(x3[0], x3[1]);
    };
    return compose;
  }

  // ../../../../../node_modules/d3-geo/src/rotation.js
  function rotationIdentity(lambda, phi) {
    if (abs3(lambda) > pi2) lambda -= Math.round(lambda / tau3) * tau3;
    return [lambda, phi];
  }
  rotationIdentity.invert = rotationIdentity;
  function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
    return (deltaLambda %= tau3) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
  }
  function forwardRotationLambda(deltaLambda) {
    return function(lambda, phi) {
      lambda += deltaLambda;
      if (abs3(lambda) > pi2) lambda -= Math.round(lambda / tau3) * tau3;
      return [lambda, phi];
    };
  }
  function rotationLambda(deltaLambda) {
    var rotation = forwardRotationLambda(deltaLambda);
    rotation.invert = forwardRotationLambda(-deltaLambda);
    return rotation;
  }
  function rotationPhiGamma(deltaPhi, deltaGamma) {
    var cosDeltaPhi = cos(deltaPhi), sinDeltaPhi = sin(deltaPhi), cosDeltaGamma = cos(deltaGamma), sinDeltaGamma = sin(deltaGamma);
    function rotation(lambda, phi) {
      var cosPhi = cos(phi), x3 = cos(lambda) * cosPhi, y3 = sin(lambda) * cosPhi, z2 = sin(phi), k3 = z2 * cosDeltaPhi + x3 * sinDeltaPhi;
      return [
        atan2(y3 * cosDeltaGamma - k3 * sinDeltaGamma, x3 * cosDeltaPhi - z2 * sinDeltaPhi),
        asin(k3 * cosDeltaGamma + y3 * sinDeltaGamma)
      ];
    }
    rotation.invert = function(lambda, phi) {
      var cosPhi = cos(phi), x3 = cos(lambda) * cosPhi, y3 = sin(lambda) * cosPhi, z2 = sin(phi), k3 = z2 * cosDeltaGamma - y3 * sinDeltaGamma;
      return [
        atan2(y3 * cosDeltaGamma + z2 * sinDeltaGamma, x3 * cosDeltaPhi + k3 * sinDeltaPhi),
        asin(k3 * cosDeltaPhi - x3 * sinDeltaPhi)
      ];
    };
    return rotation;
  }
  function rotation_default(rotate) {
    rotate = rotateRadians(rotate[0] * radians2, rotate[1] * radians2, rotate.length > 2 ? rotate[2] * radians2 : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * radians2, coordinates[1] * radians2);
      return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * radians2, coordinates[1] * radians2);
      return coordinates[0] *= degrees3, coordinates[1] *= degrees3, coordinates;
    };
    return forward;
  }

  // ../../../../../node_modules/d3-geo/src/circle.js
  function circleStream(stream, radius2, delta, direction, t03, t13) {
    if (!delta) return;
    var cosRadius = cos(radius2), sinRadius = sin(radius2), step3 = direction * delta;
    if (t03 == null) {
      t03 = radius2 + direction * tau3;
      t13 = radius2 - step3 / 2;
    } else {
      t03 = circleRadius(cosRadius, t03);
      t13 = circleRadius(cosRadius, t13);
      if (direction > 0 ? t03 < t13 : t03 > t13) t03 += direction * tau3;
    }
    for (var point6, t5 = t03; direction > 0 ? t5 > t13 : t5 < t13; t5 -= step3) {
      point6 = spherical([cosRadius, -sinRadius * cos(t5), -sinRadius * sin(t5)]);
      stream.point(point6[0], point6[1]);
    }
  }
  function circleRadius(cosRadius, point6) {
    point6 = cartesian(point6), point6[0] -= cosRadius;
    cartesianNormalizeInPlace(point6);
    var radius2 = acos(-point6[1]);
    return ((-point6[2] < 0 ? -radius2 : radius2) + tau3 - epsilon5) % tau3;
  }

  // ../../../../../node_modules/d3-geo/src/clip/buffer.js
  function buffer_default() {
    var lines = [], line2;
    return {
      point: function(x3, y3, m3) {
        line2.push([x3, y3, m3]);
      },
      lineStart: function() {
        lines.push(line2 = []);
      },
      lineEnd: noop2,
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      },
      result: function() {
        var result = lines;
        lines = [];
        line2 = null;
        return result;
      }
    };
  }

  // ../../../../../node_modules/d3-geo/src/pointEqual.js
  function pointEqual_default(a5, b2) {
    return abs3(a5[0] - b2[0]) < epsilon5 && abs3(a5[1] - b2[1]) < epsilon5;
  }

  // ../../../../../node_modules/d3-geo/src/clip/rejoin.js
  function Intersection(point6, points, other, entry) {
    this.x = point6;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function rejoin_default(segments, compareIntersection2, startInside, interpolate, stream) {
    var subject = [], clip = [], i5, n9;
    segments.forEach(function(segment) {
      if ((n10 = segment.length - 1) <= 0) return;
      var n10, p02 = segment[0], p12 = segment[n10], x3;
      if (pointEqual_default(p02, p12)) {
        if (!p02[2] && !p12[2]) {
          stream.lineStart();
          for (i5 = 0; i5 < n10; ++i5) stream.point((p02 = segment[i5])[0], p02[1]);
          stream.lineEnd();
          return;
        }
        p12[0] += 2 * epsilon5;
      }
      subject.push(x3 = new Intersection(p02, segment, null, true));
      clip.push(x3.o = new Intersection(p02, null, x3, false));
      subject.push(x3 = new Intersection(p12, segment, null, false));
      clip.push(x3.o = new Intersection(p12, null, x3, true));
    });
    if (!subject.length) return;
    clip.sort(compareIntersection2);
    link(subject);
    link(clip);
    for (i5 = 0, n9 = clip.length; i5 < n9; ++i5) {
      clip[i5].e = startInside = !startInside;
    }
    var start2 = subject[0], points, point6;
    while (1) {
      var current = start2, isSubject = true;
      while (current.v) if ((current = current.n) === start2) return;
      points = current.z;
      stream.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (i5 = 0, n9 = points.length; i5 < n9; ++i5) stream.point((point6 = points[i5])[0], point6[1]);
          } else {
            interpolate(current.x, current.n.x, 1, stream);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (i5 = points.length - 1; i5 >= 0; --i5) stream.point((point6 = points[i5])[0], point6[1]);
          } else {
            interpolate(current.x, current.p.x, -1, stream);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      stream.lineEnd();
    }
  }
  function link(array3) {
    if (!(n9 = array3.length)) return;
    var n9, i5 = 0, a5 = array3[0], b2;
    while (++i5 < n9) {
      a5.n = b2 = array3[i5];
      b2.p = a5;
      a5 = b2;
    }
    a5.n = b2 = array3[0];
    b2.p = a5;
  }

  // ../../../../../node_modules/d3-geo/src/polygonContains.js
  function longitude(point6) {
    return abs3(point6[0]) <= pi2 ? point6[0] : sign2(point6[0]) * ((abs3(point6[0]) + pi2) % tau3 - pi2);
  }
  function polygonContains_default(polygon, point6) {
    var lambda = longitude(point6), phi = point6[1], sinPhi = sin(phi), normal = [sin(lambda), -cos(lambda), 0], angle = 0, winding = 0;
    var sum3 = new Adder();
    if (sinPhi === 1) phi = halfPi + epsilon5;
    else if (sinPhi === -1) phi = -halfPi - epsilon5;
    for (var i5 = 0, n9 = polygon.length; i5 < n9; ++i5) {
      if (!(m3 = (ring = polygon[i5]).length)) continue;
      var ring, m3, point0 = ring[m3 - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin(phi0), cosPhi0 = cos(phi0);
      for (var j2 = 0; j2 < m3; ++j2, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
        var point1 = ring[j2], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin(phi1), cosPhi1 = cos(phi1), delta = lambda1 - lambda0, sign4 = delta >= 0 ? 1 : -1, absDelta = sign4 * delta, antimeridian = absDelta > pi2, k3 = sinPhi0 * sinPhi1;
        sum3.add(atan2(k3 * sign4 * sin(absDelta), cosPhi0 * cosPhi1 + k3 * cos(absDelta)));
        angle += antimeridian ? delta + sign4 * tau3 : delta;
        if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
          var arc = cartesianCross(cartesian(point0), cartesian(point1));
          cartesianNormalizeInPlace(arc);
          var intersection = cartesianCross(normal, arc);
          cartesianNormalizeInPlace(intersection);
          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
          if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
            winding += antimeridian ^ delta >= 0 ? 1 : -1;
          }
        }
      }
    }
    return (angle < -epsilon5 || angle < epsilon5 && sum3 < -epsilon22) ^ winding & 1;
  }

  // ../../../../../node_modules/d3-geo/src/clip/index.js
  function clip_default(pointVisible, clipLine, interpolate, start2) {
    return function(sink) {
      var line2 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
      var clip = {
        point: point6,
        lineStart,
        lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point6;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = merge(segments);
          var startInside = polygonContains_default(polygon, start2);
          if (segments.length) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            rejoin_default(segments, compareIntersection, startInside, interpolate, sink);
          } else if (startInside) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
          }
          if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          sink.polygonStart();
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
          sink.polygonEnd();
        }
      };
      function point6(lambda, phi) {
        if (pointVisible(lambda, phi)) sink.point(lambda, phi);
      }
      function pointLine(lambda, phi) {
        line2.point(lambda, phi);
      }
      function lineStart() {
        clip.point = pointLine;
        line2.lineStart();
      }
      function lineEnd() {
        clip.point = point6;
        line2.lineEnd();
      }
      function pointRing(lambda, phi) {
        ring.push([lambda, phi]);
        ringSink.point(lambda, phi);
      }
      function ringStart() {
        ringSink.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringSink.lineEnd();
        var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i5, n9 = ringSegments.length, m3, segment, point7;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n9) return;
        if (clean & 1) {
          segment = ringSegments[0];
          if ((m3 = segment.length - 1) > 0) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            for (i5 = 0; i5 < m3; ++i5) sink.point((point7 = segment[i5])[0], point7[1]);
            sink.lineEnd();
          }
          return;
        }
        if (n9 > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(validSegment));
      }
      return clip;
    };
  }
  function validSegment(segment) {
    return segment.length > 1;
  }
  function compareIntersection(a5, b2) {
    return ((a5 = a5.x)[0] < 0 ? a5[1] - halfPi - epsilon5 : halfPi - a5[1]) - ((b2 = b2.x)[0] < 0 ? b2[1] - halfPi - epsilon5 : halfPi - b2[1]);
  }

  // ../../../../../node_modules/d3-geo/src/clip/antimeridian.js
  var antimeridian_default = clip_default(
    function() {
      return true;
    },
    clipAntimeridianLine,
    clipAntimeridianInterpolate,
    [-pi2, -halfPi]
  );
  function clipAntimeridianLine(stream) {
    var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
    return {
      lineStart: function() {
        stream.lineStart();
        clean = 1;
      },
      point: function(lambda1, phi1) {
        var sign1 = lambda1 > 0 ? pi2 : -pi2, delta = abs3(lambda1 - lambda0);
        if (abs3(delta - pi2) < epsilon5) {
          stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi : -halfPi);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          stream.point(lambda1, phi0);
          clean = 0;
        } else if (sign0 !== sign1 && delta >= pi2) {
          if (abs3(lambda0 - sign0) < epsilon5) lambda0 -= sign0 * epsilon5;
          if (abs3(lambda1 - sign1) < epsilon5) lambda1 -= sign1 * epsilon5;
          phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          clean = 0;
        }
        stream.point(lambda0 = lambda1, phi0 = phi1);
        sign0 = sign1;
      },
      lineEnd: function() {
        stream.lineEnd();
        lambda0 = phi0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
    var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin(lambda0 - lambda1);
    return abs3(sinLambda0Lambda1) > epsilon5 ? atan((sin(phi0) * (cosPhi1 = cos(phi1)) * sin(lambda1) - sin(phi1) * (cosPhi0 = cos(phi0)) * sin(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
  }
  function clipAntimeridianInterpolate(from, to, direction, stream) {
    var phi;
    if (from == null) {
      phi = direction * halfPi;
      stream.point(-pi2, phi);
      stream.point(0, phi);
      stream.point(pi2, phi);
      stream.point(pi2, 0);
      stream.point(pi2, -phi);
      stream.point(0, -phi);
      stream.point(-pi2, -phi);
      stream.point(-pi2, 0);
      stream.point(-pi2, phi);
    } else if (abs3(from[0] - to[0]) > epsilon5) {
      var lambda = from[0] < to[0] ? pi2 : -pi2;
      phi = direction * lambda / 2;
      stream.point(-lambda, phi);
      stream.point(0, phi);
      stream.point(lambda, phi);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  // ../../../../../node_modules/d3-geo/src/clip/circle.js
  function circle_default(radius2) {
    var cr = cos(radius2), delta = 2 * radians2, smallRadius = cr > 0, notHemisphere = abs3(cr) > epsilon5;
    function interpolate(from, to, direction, stream) {
      circleStream(stream, radius2, delta, direction, from, to);
    }
    function visible(lambda, phi) {
      return cos(lambda) * cos(phi) > cr;
    }
    function clipLine(stream) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(lambda, phi) {
          var point1 = [lambda, phi], point22, v3 = visible(lambda, phi), c9 = smallRadius ? v3 ? 0 : code3(lambda, phi) : v3 ? code3(lambda + (lambda < 0 ? pi2 : -pi2), phi) : 0;
          if (!point0 && (v00 = v0 = v3)) stream.lineStart();
          if (v3 !== v0) {
            point22 = intersect(point0, point1);
            if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
              point1[2] = 1;
          }
          if (v3 !== v0) {
            clean = 0;
            if (v3) {
              stream.lineStart();
              point22 = intersect(point1, point0);
              stream.point(point22[0], point22[1]);
            } else {
              point22 = intersect(point0, point1);
              stream.point(point22[0], point22[1], 2);
              stream.lineEnd();
            }
            point0 = point22;
          } else if (notHemisphere && point0 && smallRadius ^ v3) {
            var t5;
            if (!(c9 & c0) && (t5 = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                stream.lineStart();
                stream.point(t5[0][0], t5[0][1]);
                stream.point(t5[1][0], t5[1][1]);
                stream.lineEnd();
              } else {
                stream.point(t5[1][0], t5[1][1]);
                stream.lineEnd();
                stream.lineStart();
                stream.point(t5[0][0], t5[0][1], 3);
              }
            }
          }
          if (v3 && (!point0 || !pointEqual_default(point0, point1))) {
            stream.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v3, c0 = c9;
        },
        lineEnd: function() {
          if (v0) stream.lineEnd();
          point0 = null;
        },
        // Rejoin first and last segments if there were intersections and the first
        // and last points were visible.
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a5, b2, two) {
      var pa = cartesian(a5), pb = cartesian(b2);
      var n1 = [1, 0, 0], n22 = cartesianCross(pa, pb), n2n2 = cartesianDot(n22, n22), n1n2 = n22[0], determinant2 = n2n2 - n1n2 * n1n2;
      if (!determinant2) return !two && a5;
      var c1 = cr * n2n2 / determinant2, c22 = -cr * n1n2 / determinant2, n1xn2 = cartesianCross(n1, n22), A5 = cartesianScale(n1, c1), B4 = cartesianScale(n22, c22);
      cartesianAddInPlace(A5, B4);
      var u7 = n1xn2, w2 = cartesianDot(A5, u7), uu = cartesianDot(u7, u7), t23 = w2 * w2 - uu * (cartesianDot(A5, A5) - 1);
      if (t23 < 0) return;
      var t5 = sqrt(t23), q = cartesianScale(u7, (-w2 - t5) / uu);
      cartesianAddInPlace(q, A5);
      q = spherical(q);
      if (!two) return q;
      var lambda0 = a5[0], lambda1 = b2[0], phi0 = a5[1], phi1 = b2[1], z2;
      if (lambda1 < lambda0) z2 = lambda0, lambda0 = lambda1, lambda1 = z2;
      var delta2 = lambda1 - lambda0, polar2 = abs3(delta2 - pi2) < epsilon5, meridian = polar2 || delta2 < epsilon5;
      if (!polar2 && phi1 < phi0) z2 = phi0, phi0 = phi1, phi1 = z2;
      if (meridian ? polar2 ? phi0 + phi1 > 0 ^ q[1] < (abs3(q[0] - lambda0) < epsilon5 ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta2 > pi2 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
        var q1 = cartesianScale(u7, (-w2 + t5) / uu);
        cartesianAddInPlace(q1, A5);
        return [q, spherical(q1)];
      }
    }
    function code3(lambda, phi) {
      var r6 = smallRadius ? radius2 : pi2 - radius2, code4 = 0;
      if (lambda < -r6) code4 |= 1;
      else if (lambda > r6) code4 |= 2;
      if (phi < -r6) code4 |= 4;
      else if (phi > r6) code4 |= 8;
      return code4;
    }
    return clip_default(visible, clipLine, interpolate, smallRadius ? [0, -radius2] : [-pi2, radius2 - pi2]);
  }

  // ../../../../../node_modules/d3-geo/src/clip/line.js
  function line_default(a5, b2, x06, y06, x12, y12) {
    var ax = a5[0], ay = a5[1], bx = b2[0], by = b2[1], t03 = 0, t13 = 1, dx = bx - ax, dy = by - ay, r6;
    r6 = x06 - ax;
    if (!dx && r6 > 0) return;
    r6 /= dx;
    if (dx < 0) {
      if (r6 < t03) return;
      if (r6 < t13) t13 = r6;
    } else if (dx > 0) {
      if (r6 > t13) return;
      if (r6 > t03) t03 = r6;
    }
    r6 = x12 - ax;
    if (!dx && r6 < 0) return;
    r6 /= dx;
    if (dx < 0) {
      if (r6 > t13) return;
      if (r6 > t03) t03 = r6;
    } else if (dx > 0) {
      if (r6 < t03) return;
      if (r6 < t13) t13 = r6;
    }
    r6 = y06 - ay;
    if (!dy && r6 > 0) return;
    r6 /= dy;
    if (dy < 0) {
      if (r6 < t03) return;
      if (r6 < t13) t13 = r6;
    } else if (dy > 0) {
      if (r6 > t13) return;
      if (r6 > t03) t03 = r6;
    }
    r6 = y12 - ay;
    if (!dy && r6 < 0) return;
    r6 /= dy;
    if (dy < 0) {
      if (r6 > t13) return;
      if (r6 > t03) t03 = r6;
    } else if (dy > 0) {
      if (r6 < t03) return;
      if (r6 < t13) t13 = r6;
    }
    if (t03 > 0) a5[0] = ax + t03 * dx, a5[1] = ay + t03 * dy;
    if (t13 < 1) b2[0] = ax + t13 * dx, b2[1] = ay + t13 * dy;
    return true;
  }

  // ../../../../../node_modules/d3-geo/src/clip/rectangle.js
  var clipMax = 1e9;
  var clipMin = -clipMax;
  function clipRectangle(x06, y06, x12, y12) {
    function visible(x3, y3) {
      return x06 <= x3 && x3 <= x12 && y06 <= y3 && y3 <= y12;
    }
    function interpolate(from, to, direction, stream) {
      var a5 = 0, a1 = 0;
      if (from == null || (a5 = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
        do
          stream.point(a5 === 0 || a5 === 3 ? x06 : x12, a5 > 1 ? y12 : y06);
        while ((a5 = (a5 + direction + 4) % 4) !== a1);
      } else {
        stream.point(to[0], to[1]);
      }
    }
    function corner(p11, direction) {
      return abs3(p11[0] - x06) < epsilon5 ? direction > 0 ? 0 : 3 : abs3(p11[0] - x12) < epsilon5 ? direction > 0 ? 2 : 1 : abs3(p11[1] - y06) < epsilon5 ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compareIntersection2(a5, b2) {
      return comparePoint(a5.x, b2.x);
    }
    function comparePoint(a5, b2) {
      var ca3 = corner(a5, 1), cb = corner(b2, 1);
      return ca3 !== cb ? ca3 - cb : ca3 === 0 ? b2[1] - a5[1] : ca3 === 1 ? a5[0] - b2[0] : ca3 === 2 ? a5[1] - b2[1] : b2[0] - a5[0];
    }
    return function(stream) {
      var activeStream = stream, bufferStream = buffer_default(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first2, clean;
      var clipStream = {
        point: point6,
        lineStart,
        lineEnd,
        polygonStart,
        polygonEnd
      };
      function point6(x3, y3) {
        if (visible(x3, y3)) activeStream.point(x3, y3);
      }
      function polygonInside() {
        var winding = 0;
        for (var i5 = 0, n9 = polygon.length; i5 < n9; ++i5) {
          for (var ring2 = polygon[i5], j2 = 1, m3 = ring2.length, point7 = ring2[0], a0, a1, b0 = point7[0], b1 = point7[1]; j2 < m3; ++j2) {
            a0 = b0, a1 = b1, point7 = ring2[j2], b0 = point7[0], b1 = point7[1];
            if (a1 <= y12) {
              if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x06 - a0)) ++winding;
            } else {
              if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x06 - a0)) --winding;
            }
          }
        }
        return winding;
      }
      function polygonStart() {
        activeStream = bufferStream, segments = [], polygon = [], clean = true;
      }
      function polygonEnd() {
        var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
        if (cleanInside || visible2) {
          stream.polygonStart();
          if (cleanInside) {
            stream.lineStart();
            interpolate(null, null, 1, stream);
            stream.lineEnd();
          }
          if (visible2) {
            rejoin_default(segments, compareIntersection2, startInside, interpolate, stream);
          }
          stream.polygonEnd();
        }
        activeStream = stream, segments = polygon = ring = null;
      }
      function lineStart() {
        clipStream.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first2 = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferStream.rejoin();
          segments.push(bufferStream.result());
        }
        clipStream.point = point6;
        if (v_) activeStream.lineEnd();
      }
      function linePoint(x3, y3) {
        var v3 = visible(x3, y3);
        if (polygon) ring.push([x3, y3]);
        if (first2) {
          x__ = x3, y__ = y3, v__ = v3;
          first2 = false;
          if (v3) {
            activeStream.lineStart();
            activeStream.point(x3, y3);
          }
        } else {
          if (v3 && v_) activeStream.point(x3, y3);
          else {
            var a5 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b2 = [x3 = Math.max(clipMin, Math.min(clipMax, x3)), y3 = Math.max(clipMin, Math.min(clipMax, y3))];
            if (line_default(a5, b2, x06, y06, x12, y12)) {
              if (!v_) {
                activeStream.lineStart();
                activeStream.point(a5[0], a5[1]);
              }
              activeStream.point(b2[0], b2[1]);
              if (!v3) activeStream.lineEnd();
              clean = false;
            } else if (v3) {
              activeStream.lineStart();
              activeStream.point(x3, y3);
              clean = false;
            }
          }
        }
        x_ = x3, y_ = y3, v_ = v3;
      }
      return clipStream;
    };
  }

  // ../../../../../node_modules/d3-geo/src/graticule.js
  function graticuleX(y06, y12, dy) {
    var y3 = range(y06, y12 - epsilon5, dy).concat(y12);
    return function(x3) {
      return y3.map(function(y4) {
        return [x3, y4];
      });
    };
  }
  function graticuleY(x06, x12, dx) {
    var x3 = range(x06, x12 - epsilon5, dx).concat(x12);
    return function(y3) {
      return x3.map(function(x4) {
        return [x4, y3];
      });
    };
  }
  function graticule() {
    var x12, x06, X13, X03, y12, y06, Y13, Y03, dx = 10, dy = dx, DX = 90, DY = 360, x3, y3, X3, Y3, precision = 2.5;
    function graticule3() {
      return { type: "MultiLineString", coordinates: lines() };
    }
    function lines() {
      return range(ceil(X03 / DX) * DX, X13, DX).map(X3).concat(range(ceil(Y03 / DY) * DY, Y13, DY).map(Y3)).concat(range(ceil(x06 / dx) * dx, x12, dx).filter(function(x4) {
        return abs3(x4 % DX) > epsilon5;
      }).map(x3)).concat(range(ceil(y06 / dy) * dy, y12, dy).filter(function(y4) {
        return abs3(y4 % DY) > epsilon5;
      }).map(y3));
    }
    graticule3.lines = function() {
      return lines().map(function(coordinates) {
        return { type: "LineString", coordinates };
      });
    };
    graticule3.outline = function() {
      return {
        type: "Polygon",
        coordinates: [
          X3(X03).concat(
            Y3(Y13).slice(1),
            X3(X13).reverse().slice(1),
            Y3(Y03).reverse().slice(1)
          )
        ]
      };
    };
    graticule3.extent = function(_2) {
      if (!arguments.length) return graticule3.extentMinor();
      return graticule3.extentMajor(_2).extentMinor(_2);
    };
    graticule3.extentMajor = function(_2) {
      if (!arguments.length) return [[X03, Y03], [X13, Y13]];
      X03 = +_2[0][0], X13 = +_2[1][0];
      Y03 = +_2[0][1], Y13 = +_2[1][1];
      if (X03 > X13) _2 = X03, X03 = X13, X13 = _2;
      if (Y03 > Y13) _2 = Y03, Y03 = Y13, Y13 = _2;
      return graticule3.precision(precision);
    };
    graticule3.extentMinor = function(_2) {
      if (!arguments.length) return [[x06, y06], [x12, y12]];
      x06 = +_2[0][0], x12 = +_2[1][0];
      y06 = +_2[0][1], y12 = +_2[1][1];
      if (x06 > x12) _2 = x06, x06 = x12, x12 = _2;
      if (y06 > y12) _2 = y06, y06 = y12, y12 = _2;
      return graticule3.precision(precision);
    };
    graticule3.step = function(_2) {
      if (!arguments.length) return graticule3.stepMinor();
      return graticule3.stepMajor(_2).stepMinor(_2);
    };
    graticule3.stepMajor = function(_2) {
      if (!arguments.length) return [DX, DY];
      DX = +_2[0], DY = +_2[1];
      return graticule3;
    };
    graticule3.stepMinor = function(_2) {
      if (!arguments.length) return [dx, dy];
      dx = +_2[0], dy = +_2[1];
      return graticule3;
    };
    graticule3.precision = function(_2) {
      if (!arguments.length) return precision;
      precision = +_2;
      x3 = graticuleX(y06, y12, 90);
      y3 = graticuleY(x06, x12, precision);
      X3 = graticuleX(Y03, Y13, 90);
      Y3 = graticuleY(X03, X13, precision);
      return graticule3;
    };
    return graticule3.extentMajor([[-180, -90 + epsilon5], [180, 90 - epsilon5]]).extentMinor([[-180, -80 - epsilon5], [180, 80 + epsilon5]]);
  }
  function graticule10() {
    return graticule()();
  }

  // ../../../../../node_modules/d3-geo/src/identity.js
  var identity_default3 = (x3) => x3;

  // ../../../../../node_modules/d3-geo/src/path/area.js
  var areaSum = new Adder();
  var areaRingSum = new Adder();
  var x00;
  var y00;
  var x02;
  var y02;
  var areaStream = {
    point: noop2,
    lineStart: noop2,
    lineEnd: noop2,
    polygonStart: function() {
      areaStream.lineStart = areaRingStart;
      areaStream.lineEnd = areaRingEnd;
    },
    polygonEnd: function() {
      areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop2;
      areaSum.add(abs3(areaRingSum));
      areaRingSum = new Adder();
    },
    result: function() {
      var area2 = areaSum / 2;
      areaSum = new Adder();
      return area2;
    }
  };
  function areaRingStart() {
    areaStream.point = areaPointFirst;
  }
  function areaPointFirst(x3, y3) {
    areaStream.point = areaPoint;
    x00 = x02 = x3, y00 = y02 = y3;
  }
  function areaPoint(x3, y3) {
    areaRingSum.add(y02 * x3 - x02 * y3);
    x02 = x3, y02 = y3;
  }
  function areaRingEnd() {
    areaPoint(x00, y00);
  }
  var area_default2 = areaStream;

  // ../../../../../node_modules/d3-geo/src/path/bounds.js
  var x03 = Infinity;
  var y03 = x03;
  var x1 = -x03;
  var y1 = x1;
  var boundsStream = {
    point: boundsPoint,
    lineStart: noop2,
    lineEnd: noop2,
    polygonStart: noop2,
    polygonEnd: noop2,
    result: function() {
      var bounds = [[x03, y03], [x1, y1]];
      x1 = y1 = -(y03 = x03 = Infinity);
      return bounds;
    }
  };
  function boundsPoint(x3, y3) {
    if (x3 < x03) x03 = x3;
    if (x3 > x1) x1 = x3;
    if (y3 < y03) y03 = y3;
    if (y3 > y1) y1 = y3;
  }
  var bounds_default = boundsStream;

  // ../../../../../node_modules/d3-geo/src/path/centroid.js
  var X02 = 0;
  var Y02 = 0;
  var Z02 = 0;
  var X12 = 0;
  var Y12 = 0;
  var Z12 = 0;
  var X22 = 0;
  var Y22 = 0;
  var Z22 = 0;
  var x002;
  var y002;
  var x04;
  var y04;
  var centroidStream2 = {
    point: centroidPoint2,
    lineStart: centroidLineStart2,
    lineEnd: centroidLineEnd2,
    polygonStart: function() {
      centroidStream2.lineStart = centroidRingStart2;
      centroidStream2.lineEnd = centroidRingEnd2;
    },
    polygonEnd: function() {
      centroidStream2.point = centroidPoint2;
      centroidStream2.lineStart = centroidLineStart2;
      centroidStream2.lineEnd = centroidLineEnd2;
    },
    result: function() {
      var centroid2 = Z22 ? [X22 / Z22, Y22 / Z22] : Z12 ? [X12 / Z12, Y12 / Z12] : Z02 ? [X02 / Z02, Y02 / Z02] : [NaN, NaN];
      X02 = Y02 = Z02 = X12 = Y12 = Z12 = X22 = Y22 = Z22 = 0;
      return centroid2;
    }
  };
  function centroidPoint2(x3, y3) {
    X02 += x3;
    Y02 += y3;
    ++Z02;
  }
  function centroidLineStart2() {
    centroidStream2.point = centroidPointFirstLine;
  }
  function centroidPointFirstLine(x3, y3) {
    centroidStream2.point = centroidPointLine;
    centroidPoint2(x04 = x3, y04 = y3);
  }
  function centroidPointLine(x3, y3) {
    var dx = x3 - x04, dy = y3 - y04, z2 = sqrt(dx * dx + dy * dy);
    X12 += z2 * (x04 + x3) / 2;
    Y12 += z2 * (y04 + y3) / 2;
    Z12 += z2;
    centroidPoint2(x04 = x3, y04 = y3);
  }
  function centroidLineEnd2() {
    centroidStream2.point = centroidPoint2;
  }
  function centroidRingStart2() {
    centroidStream2.point = centroidPointFirstRing;
  }
  function centroidRingEnd2() {
    centroidPointRing(x002, y002);
  }
  function centroidPointFirstRing(x3, y3) {
    centroidStream2.point = centroidPointRing;
    centroidPoint2(x002 = x04 = x3, y002 = y04 = y3);
  }
  function centroidPointRing(x3, y3) {
    var dx = x3 - x04, dy = y3 - y04, z2 = sqrt(dx * dx + dy * dy);
    X12 += z2 * (x04 + x3) / 2;
    Y12 += z2 * (y04 + y3) / 2;
    Z12 += z2;
    z2 = y04 * x3 - x04 * y3;
    X22 += z2 * (x04 + x3);
    Y22 += z2 * (y04 + y3);
    Z22 += z2 * 3;
    centroidPoint2(x04 = x3, y04 = y3);
  }
  var centroid_default2 = centroidStream2;

  // ../../../../../node_modules/d3-geo/src/path/context.js
  function PathContext(context) {
    this._context = context;
  }
  PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function(_2) {
      return this._radius = _2, this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0) this._context.closePath();
      this._point = NaN;
    },
    point: function(x3, y3) {
      switch (this._point) {
        case 0: {
          this._context.moveTo(x3, y3);
          this._point = 1;
          break;
        }
        case 1: {
          this._context.lineTo(x3, y3);
          break;
        }
        default: {
          this._context.moveTo(x3 + this._radius, y3);
          this._context.arc(x3, y3, this._radius, 0, tau3);
          break;
        }
      }
    },
    result: noop2
  };

  // ../../../../../node_modules/d3-geo/src/path/measure.js
  var lengthSum = new Adder();
  var lengthRing;
  var x003;
  var y003;
  var x05;
  var y05;
  var lengthStream = {
    point: noop2,
    lineStart: function() {
      lengthStream.point = lengthPointFirst;
    },
    lineEnd: function() {
      if (lengthRing) lengthPoint(x003, y003);
      lengthStream.point = noop2;
    },
    polygonStart: function() {
      lengthRing = true;
    },
    polygonEnd: function() {
      lengthRing = null;
    },
    result: function() {
      var length4 = +lengthSum;
      lengthSum = new Adder();
      return length4;
    }
  };
  function lengthPointFirst(x3, y3) {
    lengthStream.point = lengthPoint;
    x003 = x05 = x3, y003 = y05 = y3;
  }
  function lengthPoint(x3, y3) {
    x05 -= x3, y05 -= y3;
    lengthSum.add(sqrt(x05 * x05 + y05 * y05));
    x05 = x3, y05 = y3;
  }
  var measure_default = lengthStream;

  // ../../../../../node_modules/d3-geo/src/path/string.js
  var cacheDigits;
  var cacheAppend;
  var cacheRadius;
  var cacheCircle;
  var PathString = class {
    constructor(digits) {
      this._append = digits == null ? append3 : appendRound2(digits);
      this._radius = 4.5;
      this._ = "";
    }
    pointRadius(_2) {
      this._radius = +_2;
      return this;
    }
    polygonStart() {
      this._line = 0;
    }
    polygonEnd() {
      this._line = NaN;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {
      if (this._line === 0) this._ += "Z";
      this._point = NaN;
    }
    point(x3, y3) {
      switch (this._point) {
        case 0: {
          this._append`M${x3},${y3}`;
          this._point = 1;
          break;
        }
        case 1: {
          this._append`L${x3},${y3}`;
          break;
        }
        default: {
          this._append`M${x3},${y3}`;
          if (this._radius !== cacheRadius || this._append !== cacheAppend) {
            const r6 = this._radius;
            const s8 = this._;
            this._ = "";
            this._append`m0,${r6}a${r6},${r6} 0 1,1 0,${-2 * r6}a${r6},${r6} 0 1,1 0,${2 * r6}z`;
            cacheRadius = r6;
            cacheAppend = this._append;
            cacheCircle = this._;
            this._ = s8;
          }
          this._ += cacheCircle;
          break;
        }
      }
    }
    result() {
      const result = this._;
      this._ = "";
      return result.length ? result : null;
    }
  };
  function append3(strings) {
    let i5 = 1;
    this._ += strings[0];
    for (const j2 = strings.length; i5 < j2; ++i5) {
      this._ += arguments[i5] + strings[i5];
    }
  }
  function appendRound2(digits) {
    const d3 = Math.floor(digits);
    if (!(d3 >= 0)) throw new RangeError(`invalid digits: ${digits}`);
    if (d3 > 15) return append3;
    if (d3 !== cacheDigits) {
      const k3 = 10 ** d3;
      cacheDigits = d3;
      cacheAppend = function append4(strings) {
        let i5 = 1;
        this._ += strings[0];
        for (const j2 = strings.length; i5 < j2; ++i5) {
          this._ += Math.round(arguments[i5] * k3) / k3 + strings[i5];
        }
      };
    }
    return cacheAppend;
  }

  // ../../../../../node_modules/d3-geo/src/path/index.js
  function path_default(projection3, context) {
    let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
    function path2(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        stream_default(object, projectionStream(contextStream));
      }
      return contextStream.result();
    }
    path2.area = function(object) {
      stream_default(object, projectionStream(area_default2));
      return area_default2.result();
    };
    path2.measure = function(object) {
      stream_default(object, projectionStream(measure_default));
      return measure_default.result();
    };
    path2.bounds = function(object) {
      stream_default(object, projectionStream(bounds_default));
      return bounds_default.result();
    };
    path2.centroid = function(object) {
      stream_default(object, projectionStream(centroid_default2));
      return centroid_default2.result();
    };
    path2.projection = function(_2) {
      if (!arguments.length) return projection3;
      projectionStream = _2 == null ? (projection3 = null, identity_default3) : (projection3 = _2).stream;
      return path2;
    };
    path2.context = function(_2) {
      if (!arguments.length) return context;
      contextStream = _2 == null ? (context = null, new PathString(digits)) : new PathContext(context = _2);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return path2;
    };
    path2.pointRadius = function(_2) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
      return path2;
    };
    path2.digits = function(_2) {
      if (!arguments.length) return digits;
      if (_2 == null) digits = null;
      else {
        const d3 = Math.floor(_2);
        if (!(d3 >= 0)) throw new RangeError(`invalid digits: ${_2}`);
        digits = d3;
      }
      if (context === null) contextStream = new PathString(digits);
      return path2;
    };
    return path2.projection(projection3).digits(digits).context(context);
  }

  // ../../../../../node_modules/d3-geo/src/transform.js
  function transform_default(methods) {
    return {
      stream: transformer(methods)
    };
  }
  function transformer(methods) {
    return function(stream) {
      var s8 = new TransformStream();
      for (var key in methods) s8[key] = methods[key];
      s8.stream = stream;
      return s8;
    };
  }
  function TransformStream() {
  }
  TransformStream.prototype = {
    constructor: TransformStream,
    point: function(x3, y3) {
      this.stream.point(x3, y3);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };

  // ../../../../../node_modules/d3-geo/src/projection/fit.js
  function fit(projection3, fitBounds, object) {
    var clip = projection3.clipExtent && projection3.clipExtent();
    projection3.scale(150).translate([0, 0]);
    if (clip != null) projection3.clipExtent(null);
    stream_default(object, projection3.stream(bounds_default));
    fitBounds(bounds_default.result());
    if (clip != null) projection3.clipExtent(clip);
    return projection3;
  }
  function fitExtent(projection3, extent3, object) {
    return fit(projection3, function(b2) {
      var w2 = extent3[1][0] - extent3[0][0], h5 = extent3[1][1] - extent3[0][1], k3 = Math.min(w2 / (b2[1][0] - b2[0][0]), h5 / (b2[1][1] - b2[0][1])), x3 = +extent3[0][0] + (w2 - k3 * (b2[1][0] + b2[0][0])) / 2, y3 = +extent3[0][1] + (h5 - k3 * (b2[1][1] + b2[0][1])) / 2;
      projection3.scale(150 * k3).translate([x3, y3]);
    }, object);
  }
  function fitSize(projection3, size, object) {
    return fitExtent(projection3, [[0, 0], size], object);
  }
  function fitWidth(projection3, width, object) {
    return fit(projection3, function(b2) {
      var w2 = +width, k3 = w2 / (b2[1][0] - b2[0][0]), x3 = (w2 - k3 * (b2[1][0] + b2[0][0])) / 2, y3 = -k3 * b2[0][1];
      projection3.scale(150 * k3).translate([x3, y3]);
    }, object);
  }
  function fitHeight(projection3, height, object) {
    return fit(projection3, function(b2) {
      var h5 = +height, k3 = h5 / (b2[1][1] - b2[0][1]), x3 = -k3 * b2[0][0], y3 = (h5 - k3 * (b2[1][1] + b2[0][1])) / 2;
      projection3.scale(150 * k3).translate([x3, y3]);
    }, object);
  }

  // ../../../../../node_modules/d3-geo/src/projection/resample.js
  var maxDepth = 16;
  var cosMinDistance = cos(30 * radians2);
  function resample_default(project2, delta2) {
    return +delta2 ? resample(project2, delta2) : resampleNone(project2);
  }
  function resampleNone(project2) {
    return transformer({
      point: function(x3, y3) {
        x3 = project2(x3, y3);
        this.stream.point(x3[0], x3[1]);
      }
    });
  }
  function resample(project2, delta2) {
    function resampleLineTo(x06, y06, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
      var dx = x12 - x06, dy = y12 - y06, d22 = dx * dx + dy * dy;
      if (d22 > 4 * delta2 && depth--) {
        var a5 = a0 + a1, b2 = b0 + b1, c9 = c0 + c1, m3 = sqrt(a5 * a5 + b2 * b2 + c9 * c9), phi2 = asin(c9 /= m3), lambda2 = abs3(abs3(c9) - 1) < epsilon5 || abs3(lambda0 - lambda1) < epsilon5 ? (lambda0 + lambda1) / 2 : atan2(b2, a5), p11 = project2(lambda2, phi2), x22 = p11[0], y22 = p11[1], dx2 = x22 - x06, dy2 = y22 - y06, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d22 > delta2 || abs3((dx * dx2 + dy * dy2) / d22 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x06, y06, lambda0, a0, b0, c0, x22, y22, lambda2, a5 /= m3, b2 /= m3, c9, depth, stream);
          stream.point(x22, y22);
          resampleLineTo(x22, y22, lambda2, a5, b2, c9, x12, y12, lambda1, a1, b1, c1, depth, stream);
        }
      }
    }
    return function(stream) {
      var lambda002, x004, y004, a00, b00, c00, lambda0, x06, y06, a0, b0, c0;
      var resampleStream = {
        point: point6,
        lineStart,
        lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resampleStream.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resampleStream.lineStart = lineStart;
        }
      };
      function point6(x3, y3) {
        x3 = project2(x3, y3);
        stream.point(x3[0], x3[1]);
      }
      function lineStart() {
        x06 = NaN;
        resampleStream.point = linePoint;
        stream.lineStart();
      }
      function linePoint(lambda, phi) {
        var c9 = cartesian([lambda, phi]), p11 = project2(lambda, phi);
        resampleLineTo(x06, y06, lambda0, a0, b0, c0, x06 = p11[0], y06 = p11[1], lambda0 = lambda, a0 = c9[0], b0 = c9[1], c0 = c9[2], maxDepth, stream);
        stream.point(x06, y06);
      }
      function lineEnd() {
        resampleStream.point = point6;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resampleStream.point = ringPoint;
        resampleStream.lineEnd = ringEnd;
      }
      function ringPoint(lambda, phi) {
        linePoint(lambda002 = lambda, phi), x004 = x06, y004 = y06, a00 = a0, b00 = b0, c00 = c0;
        resampleStream.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x06, y06, lambda0, a0, b0, c0, x004, y004, lambda002, a00, b00, c00, maxDepth, stream);
        resampleStream.lineEnd = lineEnd;
        lineEnd();
      }
      return resampleStream;
    };
  }

  // ../../../../../node_modules/d3-geo/src/projection/index.js
  var transformRadians = transformer({
    point: function(x3, y3) {
      this.stream.point(x3 * radians2, y3 * radians2);
    }
  });
  function transformRotate(rotate) {
    return transformer({
      point: function(x3, y3) {
        var r6 = rotate(x3, y3);
        return this.stream.point(r6[0], r6[1]);
      }
    });
  }
  function scaleTranslate(k3, dx, dy, sx, sy) {
    function transform3(x3, y3) {
      x3 *= sx;
      y3 *= sy;
      return [dx + k3 * x3, dy - k3 * y3];
    }
    transform3.invert = function(x3, y3) {
      return [(x3 - dx) / k3 * sx, (dy - y3) / k3 * sy];
    };
    return transform3;
  }
  function scaleTranslateRotate(k3, dx, dy, sx, sy, alpha) {
    if (!alpha) return scaleTranslate(k3, dx, dy, sx, sy);
    var cosAlpha = cos(alpha), sinAlpha = sin(alpha), a5 = cosAlpha * k3, b2 = sinAlpha * k3, ai = cosAlpha / k3, bi = sinAlpha / k3, ci = (sinAlpha * dy - cosAlpha * dx) / k3, fi = (sinAlpha * dx + cosAlpha * dy) / k3;
    function transform3(x3, y3) {
      x3 *= sx;
      y3 *= sy;
      return [a5 * x3 - b2 * y3 + dx, dy - b2 * x3 - a5 * y3];
    }
    transform3.invert = function(x3, y3) {
      return [sx * (ai * x3 - bi * y3 + ci), sy * (fi - bi * x3 - ai * y3)];
    };
    return transform3;
  }
  function projection(project2) {
    return projectionMutator(function() {
      return project2;
    })();
  }
  function projectionMutator(projectAt) {
    var project2, k3 = 150, x3 = 480, y3 = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x06 = null, y06, x12, y12, postclip = identity_default3, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
    function projection3(point6) {
      return projectRotateTransform(point6[0] * radians2, point6[1] * radians2);
    }
    function invert(point6) {
      point6 = projectRotateTransform.invert(point6[0], point6[1]);
      return point6 && [point6[0] * degrees3, point6[1] * degrees3];
    }
    projection3.stream = function(stream) {
      return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
    };
    projection3.preclip = function(_2) {
      return arguments.length ? (preclip = _2, theta = void 0, reset()) : preclip;
    };
    projection3.postclip = function(_2) {
      return arguments.length ? (postclip = _2, x06 = y06 = x12 = y12 = null, reset()) : postclip;
    };
    projection3.clipAngle = function(_2) {
      return arguments.length ? (preclip = +_2 ? circle_default(theta = _2 * radians2) : (theta = null, antimeridian_default), reset()) : theta * degrees3;
    };
    projection3.clipExtent = function(_2) {
      return arguments.length ? (postclip = _2 == null ? (x06 = y06 = x12 = y12 = null, identity_default3) : clipRectangle(x06 = +_2[0][0], y06 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x06 == null ? null : [[x06, y06], [x12, y12]];
    };
    projection3.scale = function(_2) {
      return arguments.length ? (k3 = +_2, recenter()) : k3;
    };
    projection3.translate = function(_2) {
      return arguments.length ? (x3 = +_2[0], y3 = +_2[1], recenter()) : [x3, y3];
    };
    projection3.center = function(_2) {
      return arguments.length ? (lambda = _2[0] % 360 * radians2, phi = _2[1] % 360 * radians2, recenter()) : [lambda * degrees3, phi * degrees3];
    };
    projection3.rotate = function(_2) {
      return arguments.length ? (deltaLambda = _2[0] % 360 * radians2, deltaPhi = _2[1] % 360 * radians2, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees3, deltaPhi * degrees3, deltaGamma * degrees3];
    };
    projection3.angle = function(_2) {
      return arguments.length ? (alpha = _2 % 360 * radians2, recenter()) : alpha * degrees3;
    };
    projection3.reflectX = function(_2) {
      return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
    };
    projection3.reflectY = function(_2) {
      return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
    };
    projection3.precision = function(_2) {
      return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _2 * _2), reset()) : sqrt(delta2);
    };
    projection3.fitExtent = function(extent3, object) {
      return fitExtent(projection3, extent3, object);
    };
    projection3.fitSize = function(size, object) {
      return fitSize(projection3, size, object);
    };
    projection3.fitWidth = function(width, object) {
      return fitWidth(projection3, width, object);
    };
    projection3.fitHeight = function(height, object) {
      return fitHeight(projection3, height, object);
    };
    function recenter() {
      var center2 = scaleTranslateRotate(k3, 0, 0, sx, sy, alpha).apply(null, project2(lambda, phi)), transform3 = scaleTranslateRotate(k3, x3 - center2[0], y3 - center2[1], sx, sy, alpha);
      rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
      projectTransform = compose_default(project2, transform3);
      projectRotateTransform = compose_default(rotate, projectTransform);
      projectResample = resample_default(projectTransform, delta2);
      return reset();
    }
    function reset() {
      cache = cacheStream = null;
      return projection3;
    }
    return function() {
      project2 = projectAt.apply(this, arguments);
      projection3.invert = project2.invert && invert;
      return recenter();
    };
  }

  // ../../../../../node_modules/d3-geo/src/projection/conic.js
  function conicProjection(projectAt) {
    var phi0 = 0, phi1 = pi2 / 3, m3 = projectionMutator(projectAt), p11 = m3(phi0, phi1);
    p11.parallels = function(_2) {
      return arguments.length ? m3(phi0 = _2[0] * radians2, phi1 = _2[1] * radians2) : [phi0 * degrees3, phi1 * degrees3];
    };
    return p11;
  }

  // ../../../../../node_modules/d3-geo/src/projection/cylindricalEqualArea.js
  function cylindricalEqualAreaRaw(phi0) {
    var cosPhi0 = cos(phi0);
    function forward(lambda, phi) {
      return [lambda * cosPhi0, sin(phi) / cosPhi0];
    }
    forward.invert = function(x3, y3) {
      return [x3 / cosPhi0, asin(y3 * cosPhi0)];
    };
    return forward;
  }

  // ../../../../../node_modules/d3-geo/src/projection/conicEqualArea.js
  function conicEqualAreaRaw(y06, y12) {
    var sy0 = sin(y06), n9 = (sy0 + sin(y12)) / 2;
    if (abs3(n9) < epsilon5) return cylindricalEqualAreaRaw(y06);
    var c9 = 1 + sy0 * (2 * n9 - sy0), r0 = sqrt(c9) / n9;
    function project2(x3, y3) {
      var r6 = sqrt(c9 - 2 * n9 * sin(y3)) / n9;
      return [r6 * sin(x3 *= n9), r0 - r6 * cos(x3)];
    }
    project2.invert = function(x3, y3) {
      var r0y = r0 - y3, l8 = atan2(x3, abs3(r0y)) * sign2(r0y);
      if (r0y * n9 < 0)
        l8 -= pi2 * sign2(x3) * sign2(r0y);
      return [l8 / n9, asin((c9 - (x3 * x3 + r0y * r0y) * n9 * n9) / (2 * n9))];
    };
    return project2;
  }
  function conicEqualArea_default() {
    return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
  }

  // ../../../../../node_modules/d3-geo/src/projection/albers.js
  function albers_default() {
    return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
  }

  // ../../../../../node_modules/d3-geo/src/projection/albersUsa.js
  function multiplex(streams) {
    var n9 = streams.length;
    return {
      point: function(x3, y3) {
        var i5 = -1;
        while (++i5 < n9) streams[i5].point(x3, y3);
      },
      sphere: function() {
        var i5 = -1;
        while (++i5 < n9) streams[i5].sphere();
      },
      lineStart: function() {
        var i5 = -1;
        while (++i5 < n9) streams[i5].lineStart();
      },
      lineEnd: function() {
        var i5 = -1;
        while (++i5 < n9) streams[i5].lineEnd();
      },
      polygonStart: function() {
        var i5 = -1;
        while (++i5 < n9) streams[i5].polygonStart();
      },
      polygonEnd: function() {
        var i5 = -1;
        while (++i5 < n9) streams[i5].polygonEnd();
      }
    };
  }
  function albersUsa_default() {
    var cache, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point6, pointStream = { point: function(x3, y3) {
      point6 = [x3, y3];
    } };
    function albersUsa(coordinates) {
      var x3 = coordinates[0], y3 = coordinates[1];
      return point6 = null, (lower48Point.point(x3, y3), point6) || (alaskaPoint.point(x3, y3), point6) || (hawaiiPoint.point(x3, y3), point6);
    }
    albersUsa.invert = function(coordinates) {
      var k3 = lower48.scale(), t5 = lower48.translate(), x3 = (coordinates[0] - t5[0]) / k3, y3 = (coordinates[1] - t5[1]) / k3;
      return (y3 >= 0.12 && y3 < 0.234 && x3 >= -0.425 && x3 < -0.214 ? alaska : y3 >= 0.166 && y3 < 0.234 && x3 >= -0.214 && x3 < -0.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
    };
    albersUsa.precision = function(_2) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_2), alaska.precision(_2), hawaii.precision(_2);
      return reset();
    };
    albersUsa.scale = function(_2) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_2), alaska.scale(_2 * 0.35), hawaii.scale(_2);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_2) {
      if (!arguments.length) return lower48.translate();
      var k3 = lower48.scale(), x3 = +_2[0], y3 = +_2[1];
      lower48Point = lower48.translate(_2).clipExtent([[x3 - 0.455 * k3, y3 - 0.238 * k3], [x3 + 0.455 * k3, y3 + 0.238 * k3]]).stream(pointStream);
      alaskaPoint = alaska.translate([x3 - 0.307 * k3, y3 + 0.201 * k3]).clipExtent([[x3 - 0.425 * k3 + epsilon5, y3 + 0.12 * k3 + epsilon5], [x3 - 0.214 * k3 - epsilon5, y3 + 0.234 * k3 - epsilon5]]).stream(pointStream);
      hawaiiPoint = hawaii.translate([x3 - 0.205 * k3, y3 + 0.212 * k3]).clipExtent([[x3 - 0.214 * k3 + epsilon5, y3 + 0.166 * k3 + epsilon5], [x3 - 0.115 * k3 - epsilon5, y3 + 0.234 * k3 - epsilon5]]).stream(pointStream);
      return reset();
    };
    albersUsa.fitExtent = function(extent3, object) {
      return fitExtent(albersUsa, extent3, object);
    };
    albersUsa.fitSize = function(size, object) {
      return fitSize(albersUsa, size, object);
    };
    albersUsa.fitWidth = function(width, object) {
      return fitWidth(albersUsa, width, object);
    };
    albersUsa.fitHeight = function(height, object) {
      return fitHeight(albersUsa, height, object);
    };
    function reset() {
      cache = cacheStream = null;
      return albersUsa;
    }
    return albersUsa.scale(1070);
  }

  // ../../../../../node_modules/d3-geo/src/projection/azimuthal.js
  function azimuthalRaw(scale3) {
    return function(x3, y3) {
      var cx = cos(x3), cy = cos(y3), k3 = scale3(cx * cy);
      if (k3 === Infinity) return [2, 0];
      return [
        k3 * cy * sin(x3),
        k3 * sin(y3)
      ];
    };
  }
  function azimuthalInvert(angle) {
    return function(x3, y3) {
      var z2 = sqrt(x3 * x3 + y3 * y3), c9 = angle(z2), sc = sin(c9), cc2 = cos(c9);
      return [
        atan2(x3 * sc, z2 * cc2),
        asin(z2 && y3 * sc / z2)
      ];
    };
  }

  // ../../../../../node_modules/d3-geo/src/projection/azimuthalEqualArea.js
  var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
    return sqrt(2 / (1 + cxcy));
  });
  azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z2) {
    return 2 * asin(z2 / 2);
  });
  function azimuthalEqualArea_default() {
    return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
  }

  // ../../../../../node_modules/d3-geo/src/projection/azimuthalEquidistant.js
  var azimuthalEquidistantRaw = azimuthalRaw(function(c9) {
    return (c9 = acos(c9)) && c9 / sin(c9);
  });
  azimuthalEquidistantRaw.invert = azimuthalInvert(function(z2) {
    return z2;
  });
  function azimuthalEquidistant_default() {
    return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
  }

  // ../../../../../node_modules/d3-geo/src/projection/mercator.js
  function mercatorRaw(lambda, phi) {
    return [lambda, log(tan((halfPi + phi) / 2))];
  }
  mercatorRaw.invert = function(x3, y3) {
    return [x3, 2 * atan(exp(y3)) - halfPi];
  };
  function mercator_default() {
    return mercatorProjection(mercatorRaw).scale(961 / tau3);
  }
  function mercatorProjection(project2) {
    var m3 = projection(project2), center2 = m3.center, scale3 = m3.scale, translate = m3.translate, clipExtent = m3.clipExtent, x06 = null, y06, x12, y12;
    m3.scale = function(_2) {
      return arguments.length ? (scale3(_2), reclip()) : scale3();
    };
    m3.translate = function(_2) {
      return arguments.length ? (translate(_2), reclip()) : translate();
    };
    m3.center = function(_2) {
      return arguments.length ? (center2(_2), reclip()) : center2();
    };
    m3.clipExtent = function(_2) {
      return arguments.length ? (_2 == null ? x06 = y06 = x12 = y12 = null : (x06 = +_2[0][0], y06 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reclip()) : x06 == null ? null : [[x06, y06], [x12, y12]];
    };
    function reclip() {
      var k3 = pi2 * scale3(), t5 = m3(rotation_default(m3.rotate()).invert([0, 0]));
      return clipExtent(x06 == null ? [[t5[0] - k3, t5[1] - k3], [t5[0] + k3, t5[1] + k3]] : project2 === mercatorRaw ? [[Math.max(t5[0] - k3, x06), y06], [Math.min(t5[0] + k3, x12), y12]] : [[x06, Math.max(t5[1] - k3, y06)], [x12, Math.min(t5[1] + k3, y12)]]);
    }
    return reclip();
  }

  // ../../../../../node_modules/d3-geo/src/projection/conicConformal.js
  function tany(y3) {
    return tan((halfPi + y3) / 2);
  }
  function conicConformalRaw(y06, y12) {
    var cy0 = cos(y06), n9 = y06 === y12 ? sin(y06) : log(cy0 / cos(y12)) / log(tany(y12) / tany(y06)), f7 = cy0 * pow2(tany(y06), n9) / n9;
    if (!n9) return mercatorRaw;
    function project2(x3, y3) {
      if (f7 > 0) {
        if (y3 < -halfPi + epsilon5) y3 = -halfPi + epsilon5;
      } else {
        if (y3 > halfPi - epsilon5) y3 = halfPi - epsilon5;
      }
      var r6 = f7 / pow2(tany(y3), n9);
      return [r6 * sin(n9 * x3), f7 - r6 * cos(n9 * x3)];
    }
    project2.invert = function(x3, y3) {
      var fy = f7 - y3, r6 = sign2(n9) * sqrt(x3 * x3 + fy * fy), l8 = atan2(x3, abs3(fy)) * sign2(fy);
      if (fy * n9 < 0)
        l8 -= pi2 * sign2(x3) * sign2(fy);
      return [l8 / n9, 2 * atan(pow2(f7 / r6, 1 / n9)) - halfPi];
    };
    return project2;
  }
  function conicConformal_default() {
    return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
  }

  // ../../../../../node_modules/d3-geo/src/projection/equirectangular.js
  function equirectangularRaw(lambda, phi) {
    return [lambda, phi];
  }
  equirectangularRaw.invert = equirectangularRaw;
  function equirectangular_default() {
    return projection(equirectangularRaw).scale(152.63);
  }

  // ../../../../../node_modules/d3-geo/src/projection/conicEquidistant.js
  function conicEquidistantRaw(y06, y12) {
    var cy0 = cos(y06), n9 = y06 === y12 ? sin(y06) : (cy0 - cos(y12)) / (y12 - y06), g2 = cy0 / n9 + y06;
    if (abs3(n9) < epsilon5) return equirectangularRaw;
    function project2(x3, y3) {
      var gy = g2 - y3, nx = n9 * x3;
      return [gy * sin(nx), g2 - gy * cos(nx)];
    }
    project2.invert = function(x3, y3) {
      var gy = g2 - y3, l8 = atan2(x3, abs3(gy)) * sign2(gy);
      if (gy * n9 < 0)
        l8 -= pi2 * sign2(x3) * sign2(gy);
      return [l8 / n9, g2 - sign2(n9) * sqrt(x3 * x3 + gy * gy)];
    };
    return project2;
  }
  function conicEquidistant_default() {
    return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
  }

  // ../../../../../node_modules/d3-geo/src/projection/equalEarth.js
  var A1 = 1.340264;
  var A22 = -0.081106;
  var A3 = 893e-6;
  var A4 = 3796e-6;
  var M3 = sqrt(3) / 2;
  var iterations = 12;
  function equalEarthRaw(lambda, phi) {
    var l8 = asin(M3 * sin(phi)), l22 = l8 * l8, l62 = l22 * l22 * l22;
    return [
      lambda * cos(l8) / (M3 * (A1 + 3 * A22 * l22 + l62 * (7 * A3 + 9 * A4 * l22))),
      l8 * (A1 + A22 * l22 + l62 * (A3 + A4 * l22))
    ];
  }
  equalEarthRaw.invert = function(x3, y3) {
    var l8 = y3, l22 = l8 * l8, l62 = l22 * l22 * l22;
    for (var i5 = 0, delta, fy, fpy; i5 < iterations; ++i5) {
      fy = l8 * (A1 + A22 * l22 + l62 * (A3 + A4 * l22)) - y3;
      fpy = A1 + 3 * A22 * l22 + l62 * (7 * A3 + 9 * A4 * l22);
      l8 -= delta = fy / fpy, l22 = l8 * l8, l62 = l22 * l22 * l22;
      if (abs3(delta) < epsilon22) break;
    }
    return [
      M3 * x3 * (A1 + 3 * A22 * l22 + l62 * (7 * A3 + 9 * A4 * l22)) / cos(l8),
      asin(sin(l8) / M3)
    ];
  };
  function equalEarth_default() {
    return projection(equalEarthRaw).scale(177.158);
  }

  // ../../../../../node_modules/d3-geo/src/projection/gnomonic.js
  function gnomonicRaw(x3, y3) {
    var cy = cos(y3), k3 = cos(x3) * cy;
    return [cy * sin(x3) / k3, sin(y3) / k3];
  }
  gnomonicRaw.invert = azimuthalInvert(atan);
  function gnomonic_default() {
    return projection(gnomonicRaw).scale(144.049).clipAngle(60);
  }

  // ../../../../../node_modules/d3-geo/src/projection/orthographic.js
  function orthographicRaw(x3, y3) {
    return [cos(y3) * sin(x3), sin(y3)];
  }
  orthographicRaw.invert = azimuthalInvert(asin);
  function orthographic_default() {
    return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon5);
  }

  // ../../../../../node_modules/d3-geo/src/projection/stereographic.js
  function stereographicRaw(x3, y3) {
    var cy = cos(y3), k3 = 1 + cos(x3) * cy;
    return [cy * sin(x3) / k3, sin(y3) / k3];
  }
  stereographicRaw.invert = azimuthalInvert(function(z2) {
    return 2 * atan(z2);
  });
  function stereographic_default() {
    return projection(stereographicRaw).scale(250).clipAngle(142);
  }

  // ../../../../../node_modules/d3-geo/src/projection/transverseMercator.js
  function transverseMercatorRaw(lambda, phi) {
    return [log(tan((halfPi + phi) / 2)), -lambda];
  }
  transverseMercatorRaw.invert = function(x3, y3) {
    return [-y3, 2 * atan(exp(x3)) - halfPi];
  };
  function transverseMercator_default() {
    var m3 = mercatorProjection(transverseMercatorRaw), center2 = m3.center, rotate = m3.rotate;
    m3.center = function(_2) {
      return arguments.length ? center2([-_2[1], _2[0]]) : (_2 = center2(), [_2[1], -_2[0]]);
    };
    m3.rotate = function(_2) {
      return arguments.length ? rotate([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate(), [_2[0], _2[1], _2[2] - 90]);
    };
    return rotate([0, 0, 90]).scale(159.155);
  }

  // ../../../../../node_modules/d3-hierarchy/src/cluster.js
  function defaultSeparation(a5, b2) {
    return a5.parent === b2.parent ? 1 : 2;
  }
  function meanX(children2) {
    return children2.reduce(meanXReduce, 0) / children2.length;
  }
  function meanXReduce(x3, c9) {
    return x3 + c9.x;
  }
  function maxY(children2) {
    return 1 + children2.reduce(maxYReduce, 0);
  }
  function maxYReduce(y3, c9) {
    return Math.max(y3, c9.y);
  }
  function leafLeft(node) {
    var children2;
    while (children2 = node.children) node = children2[0];
    return node;
  }
  function leafRight(node) {
    var children2;
    while (children2 = node.children) node = children2[children2.length - 1];
    return node;
  }
  function cluster_default() {
    var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
    function cluster2(root2) {
      var previousNode, x3 = 0;
      root2.eachAfter(function(node) {
        var children2 = node.children;
        if (children2) {
          node.x = meanX(children2);
          node.y = maxY(children2);
        } else {
          node.x = previousNode ? x3 += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left2 = leafLeft(root2), right2 = leafRight(root2), x06 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;
      return root2.eachAfter(nodeSize ? function(node) {
        node.x = (node.x - root2.x) * dx;
        node.y = (root2.y - node.y) * dy;
      } : function(node) {
        node.x = (node.x - x06) / (x12 - x06) * dx;
        node.y = (1 - (root2.y ? node.y / root2.y : 1)) * dy;
      });
    }
    cluster2.separation = function(x3) {
      return arguments.length ? (separation = x3, cluster2) : separation;
    };
    cluster2.size = function(x3) {
      return arguments.length ? (nodeSize = false, dx = +x3[0], dy = +x3[1], cluster2) : nodeSize ? null : [dx, dy];
    };
    cluster2.nodeSize = function(x3) {
      return arguments.length ? (nodeSize = true, dx = +x3[0], dy = +x3[1], cluster2) : nodeSize ? [dx, dy] : null;
    };
    return cluster2;
  }

  // ../../../../../node_modules/d3-hierarchy/src/hierarchy/count.js
  function count3(node) {
    var sum3 = 0, children2 = node.children, i5 = children2 && children2.length;
    if (!i5) sum3 = 1;
    else while (--i5 >= 0) sum3 += children2[i5].value;
    node.value = sum3;
  }
  function count_default() {
    return this.eachAfter(count3);
  }

  // ../../../../../node_modules/d3-hierarchy/src/hierarchy/each.js
  function each_default2(callback, that) {
    let index2 = -1;
    for (const node of this) {
      callback.call(that, node, ++index2, this);
    }
    return this;
  }

  // ../../../../../node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
  function eachBefore_default(callback, that) {
    var node = this, nodes = [node], children2, i5, index2 = -1;
    while (node = nodes.pop()) {
      callback.call(that, node, ++index2, this);
      if (children2 = node.children) {
        for (i5 = children2.length - 1; i5 >= 0; --i5) {
          nodes.push(children2[i5]);
        }
      }
    }
    return this;
  }

  // ../../../../../node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
  function eachAfter_default(callback, that) {
    var node = this, nodes = [node], next = [], children2, i5, n9, index2 = -1;
    while (node = nodes.pop()) {
      next.push(node);
      if (children2 = node.children) {
        for (i5 = 0, n9 = children2.length; i5 < n9; ++i5) {
          nodes.push(children2[i5]);
        }
      }
    }
    while (node = next.pop()) {
      callback.call(that, node, ++index2, this);
    }
    return this;
  }

  // ../../../../../node_modules/d3-hierarchy/src/hierarchy/find.js
  function find_default(callback, that) {
    let index2 = -1;
    for (const node of this) {
      if (callback.call(that, node, ++index2, this)) {
        return node;
      }
    }
  }

  // ../../../../../node_modules/d3-hierarchy/src/hierarchy/sum.js
  function sum_default(value) {
    return this.eachAfter(function(node) {
      var sum3 = +value(node.data) || 0, children2 = node.children, i5 = children2 && children2.length;
      while (--i5 >= 0) sum3 += children2[i5].value;
      node.value = sum3;
    });
  }

  // ../../../../../node_modules/d3-hierarchy/src/hierarchy/sort.js
  function sort_default2(compare) {
    return this.eachBefore(function(node) {
      if (node.children) {
        node.children.sort(compare);
      }
    });
  }

  // ../../../../../node_modules/d3-hierarchy/src/hierarchy/path.js
  function path_default2(end) {
    var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];
    while (start2 !== ancestor) {
      start2 = start2.parent;
      nodes.push(start2);
    }
    var k3 = nodes.length;
    while (end !== ancestor) {
      nodes.splice(k3, 0, end);
      end = end.parent;
    }
    return nodes;
  }
  function leastCommonAncestor(a5, b2) {
    if (a5 === b2) return a5;
    var aNodes = a5.ancestors(), bNodes = b2.ancestors(), c9 = null;
    a5 = aNodes.pop();
    b2 = bNodes.pop();
    while (a5 === b2) {
      c9 = a5;
      a5 = aNodes.pop();
      b2 = bNodes.pop();
    }
    return c9;
  }

  // ../../../../../node_modules/d3-hierarchy/src/hierarchy/ancestors.js
  function ancestors_default() {
    var node = this, nodes = [node];
    while (node = node.parent) {
      nodes.push(node);
    }
    return nodes;
  }

  // ../../../../../node_modules/d3-hierarchy/src/hierarchy/descendants.js
  function descendants_default() {
    return Array.from(this);
  }

  // ../../../../../node_modules/d3-hierarchy/src/hierarchy/leaves.js
  function leaves_default() {
    var leaves = [];
    this.eachBefore(function(node) {
      if (!node.children) {
        leaves.push(node);
      }
    });
    return leaves;
  }

  // ../../../../../node_modules/d3-hierarchy/src/hierarchy/links.js
  function links_default() {
    var root2 = this, links = [];
    root2.each(function(node) {
      if (node !== root2) {
        links.push({ source: node.parent, target: node });
      }
    });
    return links;
  }

  // ../../../../../node_modules/d3-hierarchy/src/hierarchy/iterator.js
  function* iterator_default2() {
    var node = this, current, next = [node], children2, i5, n9;
    do {
      current = next.reverse(), next = [];
      while (node = current.pop()) {
        yield node;
        if (children2 = node.children) {
          for (i5 = 0, n9 = children2.length; i5 < n9; ++i5) {
            next.push(children2[i5]);
          }
        }
      }
    } while (next.length);
  }

  // ../../../../../node_modules/d3-hierarchy/src/hierarchy/index.js
  function hierarchy(data, children2) {
    if (data instanceof Map) {
      data = [void 0, data];
      if (children2 === void 0) children2 = mapChildren;
    } else if (children2 === void 0) {
      children2 = objectChildren;
    }
    var root2 = new Node2(data), node, nodes = [root2], child, childs, i5, n9;
    while (node = nodes.pop()) {
      if ((childs = children2(node.data)) && (n9 = (childs = Array.from(childs)).length)) {
        node.children = childs;
        for (i5 = n9 - 1; i5 >= 0; --i5) {
          nodes.push(child = childs[i5] = new Node2(childs[i5]));
          child.parent = node;
          child.depth = node.depth + 1;
        }
      }
    }
    return root2.eachBefore(computeHeight);
  }
  function node_copy() {
    return hierarchy(this).eachBefore(copyData);
  }
  function objectChildren(d3) {
    return d3.children;
  }
  function mapChildren(d3) {
    return Array.isArray(d3) ? d3[1] : null;
  }
  function copyData(node) {
    if (node.data.value !== void 0) node.value = node.data.value;
    node.data = node.data.data;
  }
  function computeHeight(node) {
    var height = 0;
    do
      node.height = height;
    while ((node = node.parent) && node.height < ++height);
  }
  function Node2(data) {
    this.data = data;
    this.depth = this.height = 0;
    this.parent = null;
  }
  Node2.prototype = hierarchy.prototype = {
    constructor: Node2,
    count: count_default,
    each: each_default2,
    eachAfter: eachAfter_default,
    eachBefore: eachBefore_default,
    find: find_default,
    sum: sum_default,
    sort: sort_default2,
    path: path_default2,
    ancestors: ancestors_default,
    descendants: descendants_default,
    leaves: leaves_default,
    links: links_default,
    copy: node_copy,
    [Symbol.iterator]: iterator_default2
  };

  // ../../../../../node_modules/d3-hierarchy/src/accessors.js
  function optional(f7) {
    return f7 == null ? null : required(f7);
  }
  function required(f7) {
    if (typeof f7 !== "function") throw new Error();
    return f7;
  }

  // ../../../../../node_modules/d3-hierarchy/src/stratify.js
  var preroot = { depth: -1 };
  var ambiguous = {};
  var imputed = {};
  function defaultId(d3) {
    return d3.id;
  }
  function defaultParentId(d3) {
    return d3.parentId;
  }
  function stratify_default() {
    var id2 = defaultId, parentId = defaultParentId, path2;
    function stratify(data) {
      var nodes = Array.from(data), currentId = id2, currentParentId = parentId, n9, d3, i5, root2, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
      if (path2 != null) {
        const I2 = nodes.map((d4, i6) => normalize(path2(d4, i6, data)));
        const P2 = I2.map(parentof);
        const S3 = new Set(I2).add("");
        for (const i6 of P2) {
          if (!S3.has(i6)) {
            S3.add(i6);
            I2.push(i6);
            P2.push(parentof(i6));
            nodes.push(imputed);
          }
        }
        currentId = (_2, i6) => I2[i6];
        currentParentId = (_2, i6) => P2[i6];
      }
      for (i5 = 0, n9 = nodes.length; i5 < n9; ++i5) {
        d3 = nodes[i5], node = nodes[i5] = new Node2(d3);
        if ((nodeId = currentId(d3, i5, data)) != null && (nodeId += "")) {
          nodeKey = node.id = nodeId;
          nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
        }
        if ((nodeId = currentParentId(d3, i5, data)) != null && (nodeId += "")) {
          node.parent = nodeId;
        }
      }
      for (i5 = 0; i5 < n9; ++i5) {
        node = nodes[i5];
        if (nodeId = node.parent) {
          parent = nodeByKey.get(nodeId);
          if (!parent) throw new Error("missing: " + nodeId);
          if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
          if (parent.children) parent.children.push(node);
          else parent.children = [node];
          node.parent = parent;
        } else {
          if (root2) throw new Error("multiple roots");
          root2 = node;
        }
      }
      if (!root2) throw new Error("no root");
      if (path2 != null) {
        while (root2.data === imputed && root2.children.length === 1) {
          root2 = root2.children[0], --n9;
        }
        for (let i6 = nodes.length - 1; i6 >= 0; --i6) {
          node = nodes[i6];
          if (node.data !== imputed) break;
          node.data = null;
        }
      }
      root2.parent = preroot;
      root2.eachBefore(function(node2) {
        node2.depth = node2.parent.depth + 1;
        --n9;
      }).eachBefore(computeHeight);
      root2.parent = null;
      if (n9 > 0) throw new Error("cycle");
      return root2;
    }
    stratify.id = function(x3) {
      return arguments.length ? (id2 = optional(x3), stratify) : id2;
    };
    stratify.parentId = function(x3) {
      return arguments.length ? (parentId = optional(x3), stratify) : parentId;
    };
    stratify.path = function(x3) {
      return arguments.length ? (path2 = optional(x3), stratify) : path2;
    };
    return stratify;
  }
  function normalize(path2) {
    path2 = `${path2}`;
    let i5 = path2.length;
    if (slash(path2, i5 - 1) && !slash(path2, i5 - 2)) path2 = path2.slice(0, -1);
    return path2[0] === "/" ? path2 : `/${path2}`;
  }
  function parentof(path2) {
    let i5 = path2.length;
    if (i5 < 2) return "";
    while (--i5 > 1) if (slash(path2, i5)) break;
    return path2.slice(0, i5);
  }
  function slash(path2, i5) {
    if (path2[i5] === "/") {
      let k3 = 0;
      while (i5 > 0 && path2[--i5] === "\\") ++k3;
      if ((k3 & 1) === 0) return true;
    }
    return false;
  }

  // ../../../../../node_modules/d3-hierarchy/src/tree.js
  function defaultSeparation2(a5, b2) {
    return a5.parent === b2.parent ? 1 : 2;
  }
  function nextLeft(v3) {
    var children2 = v3.children;
    return children2 ? children2[0] : v3.t;
  }
  function nextRight(v3) {
    var children2 = v3.children;
    return children2 ? children2[children2.length - 1] : v3.t;
  }
  function moveSubtree(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function executeShifts(v3) {
    var shift = 0, change = 0, children2 = v3.children, i5 = children2.length, w2;
    while (--i5 >= 0) {
      w2 = children2[i5];
      w2.z += shift;
      w2.m += shift;
      shift += w2.s + (change += w2.c);
    }
  }
  function nextAncestor(vim, v3, ancestor) {
    return vim.a.parent === v3.parent ? vim.a : ancestor;
  }
  function TreeNode(node, i5) {
    this._ = node;
    this.parent = null;
    this.children = null;
    this.A = null;
    this.a = this;
    this.z = 0;
    this.m = 0;
    this.c = 0;
    this.s = 0;
    this.t = null;
    this.i = i5;
  }
  TreeNode.prototype = Object.create(Node2.prototype);
  function treeRoot(root2) {
    var tree2 = new TreeNode(root2, 0), node, nodes = [tree2], child, children2, i5, n9;
    while (node = nodes.pop()) {
      if (children2 = node._.children) {
        node.children = new Array(n9 = children2.length);
        for (i5 = n9 - 1; i5 >= 0; --i5) {
          nodes.push(child = node.children[i5] = new TreeNode(children2[i5], i5));
          child.parent = node;
        }
      }
    }
    (tree2.parent = new TreeNode(null, 0)).children = [tree2];
    return tree2;
  }
  function tree_default() {
    var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
    function tree2(root2) {
      var t5 = treeRoot(root2);
      t5.eachAfter(firstWalk), t5.parent.m = -t5.z;
      t5.eachBefore(secondWalk);
      if (nodeSize) root2.eachBefore(sizeNode);
      else {
        var left2 = root2, right2 = root2, bottom2 = root2;
        root2.eachBefore(function(node) {
          if (node.x < left2.x) left2 = node;
          if (node.x > right2.x) right2 = node;
          if (node.depth > bottom2.depth) bottom2 = node;
        });
        var s8 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s8 - left2.x, kx2 = dx / (right2.x + s8 + tx), ky2 = dy / (bottom2.depth || 1);
        root2.eachBefore(function(node) {
          node.x = (node.x + tx) * kx2;
          node.y = node.depth * ky2;
        });
      }
      return root2;
    }
    function firstWalk(v3) {
      var children2 = v3.children, siblings = v3.parent.children, w2 = v3.i ? siblings[v3.i - 1] : null;
      if (children2) {
        executeShifts(v3);
        var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
        if (w2) {
          v3.z = w2.z + separation(v3._, w2._);
          v3.m = v3.z - midpoint;
        } else {
          v3.z = midpoint;
        }
      } else if (w2) {
        v3.z = w2.z + separation(v3._, w2._);
      }
      v3.parent.A = apportion(v3, w2, v3.parent.A || siblings[0]);
    }
    function secondWalk(v3) {
      v3._.x = v3.z + v3.parent.m;
      v3.m += v3.parent.m;
    }
    function apportion(v3, w2, ancestor) {
      if (w2) {
        var vip = v3, vop = v3, vim = w2, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
          vom = nextLeft(vom);
          vop = nextRight(vop);
          vop.a = v3;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            moveSubtree(nextAncestor(vim, v3, ancestor), v3, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !nextRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !nextLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v3;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= dx;
      node.y = node.depth * dy;
    }
    tree2.separation = function(x3) {
      return arguments.length ? (separation = x3, tree2) : separation;
    };
    tree2.size = function(x3) {
      return arguments.length ? (nodeSize = false, dx = +x3[0], dy = +x3[1], tree2) : nodeSize ? null : [dx, dy];
    };
    tree2.nodeSize = function(x3) {
      return arguments.length ? (nodeSize = true, dx = +x3[0], dy = +x3[1], tree2) : nodeSize ? [dx, dy] : null;
    };
    return tree2;
  }

  // ../../../../../node_modules/d3-random/src/lcg.js
  var mul = 1664525;
  var inc = 1013904223;
  var eps = 1 / 4294967296;
  function lcg(seed = Math.random()) {
    let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
    return () => (state = mul * state + inc | 0, eps * (state >>> 0));
  }

  // ../../../../../node_modules/d3-scale/src/init.js
  function initRange(domain, range3) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(domain);
        break;
      default:
        this.range(range3).domain(domain);
        break;
    }
    return this;
  }
  function initInterpolator(domain, interpolator) {
    switch (arguments.length) {
      case 0:
        break;
      case 1: {
        if (typeof domain === "function") this.interpolator(domain);
        else this.range(domain);
        break;
      }
      default: {
        this.domain(domain);
        if (typeof interpolator === "function") this.interpolator(interpolator);
        else this.range(interpolator);
        break;
      }
    }
    return this;
  }

  // ../../../../../node_modules/d3-scale/src/ordinal.js
  var implicit = Symbol("implicit");
  function ordinal() {
    var index2 = new InternMap(), domain = [], range3 = [], unknown = implicit;
    function scale3(d3) {
      let i5 = index2.get(d3);
      if (i5 === void 0) {
        if (unknown !== implicit) return unknown;
        index2.set(d3, i5 = domain.push(d3) - 1);
      }
      return range3[i5 % range3.length];
    }
    scale3.domain = function(_2) {
      if (!arguments.length) return domain.slice();
      domain = [], index2 = new InternMap();
      for (const value of _2) {
        if (index2.has(value)) continue;
        index2.set(value, domain.push(value) - 1);
      }
      return scale3;
    };
    scale3.range = function(_2) {
      return arguments.length ? (range3 = Array.from(_2), scale3) : range3.slice();
    };
    scale3.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale3) : unknown;
    };
    scale3.copy = function() {
      return ordinal(domain, range3).unknown(unknown);
    };
    initRange.apply(scale3, arguments);
    return scale3;
  }

  // ../../../../../node_modules/d3-scale/src/band.js
  function band() {
    var scale3 = ordinal().unknown(void 0), domain = scale3.domain, ordinalRange2 = scale3.range, r0 = 0, r1 = 1, step3, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
    delete scale3.unknown;
    function rescale() {
      var n9 = domain().length, reverse3 = r1 < r0, start2 = reverse3 ? r1 : r0, stop2 = reverse3 ? r0 : r1;
      step3 = (stop2 - start2) / Math.max(1, n9 - paddingInner + paddingOuter * 2);
      if (round2) step3 = Math.floor(step3);
      start2 += (stop2 - start2 - step3 * (n9 - paddingInner)) * align;
      bandwidth = step3 * (1 - paddingInner);
      if (round2) start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
      var values2 = range(n9).map(function(i5) {
        return start2 + step3 * i5;
      });
      return ordinalRange2(reverse3 ? values2.reverse() : values2);
    }
    scale3.domain = function(_2) {
      return arguments.length ? (domain(_2), rescale()) : domain();
    };
    scale3.range = function(_2) {
      return arguments.length ? ([r0, r1] = _2, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
    };
    scale3.rangeRound = function(_2) {
      return [r0, r1] = _2, r0 = +r0, r1 = +r1, round2 = true, rescale();
    };
    scale3.bandwidth = function() {
      return bandwidth;
    };
    scale3.step = function() {
      return step3;
    };
    scale3.round = function(_2) {
      return arguments.length ? (round2 = !!_2, rescale()) : round2;
    };
    scale3.padding = function(_2) {
      return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_2), rescale()) : paddingInner;
    };
    scale3.paddingInner = function(_2) {
      return arguments.length ? (paddingInner = Math.min(1, _2), rescale()) : paddingInner;
    };
    scale3.paddingOuter = function(_2) {
      return arguments.length ? (paddingOuter = +_2, rescale()) : paddingOuter;
    };
    scale3.align = function(_2) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _2)), rescale()) : align;
    };
    scale3.copy = function() {
      return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
    };
    return initRange.apply(rescale(), arguments);
  }
  function pointish(scale3) {
    var copy3 = scale3.copy;
    scale3.padding = scale3.paddingOuter;
    delete scale3.paddingInner;
    delete scale3.paddingOuter;
    scale3.copy = function() {
      return pointish(copy3());
    };
    return scale3;
  }
  function point() {
    return pointish(band.apply(null, arguments).paddingInner(1));
  }

  // ../../../../../node_modules/d3-scale/src/constant.js
  function constants(x3) {
    return function() {
      return x3;
    };
  }

  // ../../../../../node_modules/d3-scale/src/number.js
  function number3(x3) {
    return +x3;
  }

  // ../../../../../node_modules/d3-scale/src/continuous.js
  var unit = [0, 1];
  function identity3(x3) {
    return x3;
  }
  function normalize2(a5, b2) {
    return (b2 -= a5 = +a5) ? function(x3) {
      return (x3 - a5) / b2;
    } : constants(isNaN(b2) ? NaN : 0.5);
  }
  function clamper(a5, b2) {
    var t5;
    if (a5 > b2) t5 = a5, a5 = b2, b2 = t5;
    return function(x3) {
      return Math.max(a5, Math.min(b2, x3));
    };
  }
  function bimap(domain, range3, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range3[0], r1 = range3[1];
    if (d1 < d0) d0 = normalize2(d1, d0), r0 = interpolate(r1, r0);
    else d0 = normalize2(d0, d1), r0 = interpolate(r0, r1);
    return function(x3) {
      return r0(d0(x3));
    };
  }
  function polymap(domain, range3, interpolate) {
    var j2 = Math.min(domain.length, range3.length) - 1, d3 = new Array(j2), r6 = new Array(j2), i5 = -1;
    if (domain[j2] < domain[0]) {
      domain = domain.slice().reverse();
      range3 = range3.slice().reverse();
    }
    while (++i5 < j2) {
      d3[i5] = normalize2(domain[i5], domain[i5 + 1]);
      r6[i5] = interpolate(range3[i5], range3[i5 + 1]);
    }
    return function(x3) {
      var i6 = bisect_default(domain, x3, 1, j2) - 1;
      return r6[i6](d3[i6](x3));
    };
  }
  function copy(source, target) {
    return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
  }
  function transformer2() {
    var domain = unit, range3 = unit, interpolate = value_default, transform3, untransform, unknown, clamp = identity3, piecewise2, output, input;
    function rescale() {
      var n9 = Math.min(domain.length, range3.length);
      if (clamp !== identity3) clamp = clamper(domain[0], domain[n9 - 1]);
      piecewise2 = n9 > 2 ? polymap : bimap;
      output = input = null;
      return scale3;
    }
    function scale3(x3) {
      return x3 == null || isNaN(x3 = +x3) ? unknown : (output || (output = piecewise2(domain.map(transform3), range3, interpolate)))(transform3(clamp(x3)));
    }
    scale3.invert = function(y3) {
      return clamp(untransform((input || (input = piecewise2(range3, domain.map(transform3), number_default)))(y3)));
    };
    scale3.domain = function(_2) {
      return arguments.length ? (domain = Array.from(_2, number3), rescale()) : domain.slice();
    };
    scale3.range = function(_2) {
      return arguments.length ? (range3 = Array.from(_2), rescale()) : range3.slice();
    };
    scale3.rangeRound = function(_2) {
      return range3 = Array.from(_2), interpolate = round_default, rescale();
    };
    scale3.clamp = function(_2) {
      return arguments.length ? (clamp = _2 ? true : identity3, rescale()) : clamp !== identity3;
    };
    scale3.interpolate = function(_2) {
      return arguments.length ? (interpolate = _2, rescale()) : interpolate;
    };
    scale3.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale3) : unknown;
    };
    return function(t5, u7) {
      transform3 = t5, untransform = u7;
      return rescale();
    };
  }
  function continuous() {
    return transformer2()(identity3, identity3);
  }

  // ../../../../../node_modules/d3-scale/src/tickFormat.js
  function tickFormat(start2, stop2, count4, specifier) {
    var step3 = tickStep(start2, stop2, count4), precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start2), Math.abs(stop2));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step3, value))) specifier.precision = precision;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound_default(step3, Math.max(Math.abs(start2), Math.abs(stop2))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step3))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }

  // ../../../../../node_modules/d3-scale/src/linear.js
  function linearish(scale3) {
    var domain = scale3.domain;
    scale3.ticks = function(count4) {
      var d3 = domain();
      return ticks(d3[0], d3[d3.length - 1], count4 == null ? 10 : count4);
    };
    scale3.tickFormat = function(count4, specifier) {
      var d3 = domain();
      return tickFormat(d3[0], d3[d3.length - 1], count4 == null ? 10 : count4, specifier);
    };
    scale3.nice = function(count4) {
      if (count4 == null) count4 = 10;
      var d3 = domain();
      var i0 = 0;
      var i12 = d3.length - 1;
      var start2 = d3[i0];
      var stop2 = d3[i12];
      var prestep;
      var step3;
      var maxIter = 10;
      if (stop2 < start2) {
        step3 = start2, start2 = stop2, stop2 = step3;
        step3 = i0, i0 = i12, i12 = step3;
      }
      while (maxIter-- > 0) {
        step3 = tickIncrement(start2, stop2, count4);
        if (step3 === prestep) {
          d3[i0] = start2;
          d3[i12] = stop2;
          return domain(d3);
        } else if (step3 > 0) {
          start2 = Math.floor(start2 / step3) * step3;
          stop2 = Math.ceil(stop2 / step3) * step3;
        } else if (step3 < 0) {
          start2 = Math.ceil(start2 * step3) / step3;
          stop2 = Math.floor(stop2 * step3) / step3;
        } else {
          break;
        }
        prestep = step3;
      }
      return scale3;
    };
    return scale3;
  }
  function linear2() {
    var scale3 = continuous();
    scale3.copy = function() {
      return copy(scale3, linear2());
    };
    initRange.apply(scale3, arguments);
    return linearish(scale3);
  }

  // ../../../../../node_modules/d3-scale/src/identity.js
  function identity4(domain) {
    var unknown;
    function scale3(x3) {
      return x3 == null || isNaN(x3 = +x3) ? unknown : x3;
    }
    scale3.invert = scale3;
    scale3.domain = scale3.range = function(_2) {
      return arguments.length ? (domain = Array.from(_2, number3), scale3) : domain.slice();
    };
    scale3.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale3) : unknown;
    };
    scale3.copy = function() {
      return identity4(domain).unknown(unknown);
    };
    domain = arguments.length ? Array.from(domain, number3) : [0, 1];
    return linearish(scale3);
  }

  // ../../../../../node_modules/d3-scale/src/nice.js
  function nice2(domain, interval2) {
    domain = domain.slice();
    var i0 = 0, i12 = domain.length - 1, x06 = domain[i0], x12 = domain[i12], t5;
    if (x12 < x06) {
      t5 = i0, i0 = i12, i12 = t5;
      t5 = x06, x06 = x12, x12 = t5;
    }
    domain[i0] = interval2.floor(x06);
    domain[i12] = interval2.ceil(x12);
    return domain;
  }

  // ../../../../../node_modules/d3-scale/src/log.js
  function transformLog(x3) {
    return Math.log(x3);
  }
  function transformExp(x3) {
    return Math.exp(x3);
  }
  function transformLogn(x3) {
    return -Math.log(-x3);
  }
  function transformExpn(x3) {
    return -Math.exp(-x3);
  }
  function pow10(x3) {
    return isFinite(x3) ? +("1e" + x3) : x3 < 0 ? 0 : x3;
  }
  function powp(base) {
    return base === 10 ? pow10 : base === Math.E ? Math.exp : (x3) => Math.pow(base, x3);
  }
  function logp(base) {
    return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x3) => Math.log(x3) / base);
  }
  function reflect(f7) {
    return (x3, k3) => -f7(-x3, k3);
  }
  function loggish(transform3) {
    const scale3 = transform3(transformLog, transformExp);
    const domain = scale3.domain;
    let base = 10;
    let logs;
    let pows;
    function rescale() {
      logs = logp(base), pows = powp(base);
      if (domain()[0] < 0) {
        logs = reflect(logs), pows = reflect(pows);
        transform3(transformLogn, transformExpn);
      } else {
        transform3(transformLog, transformExp);
      }
      return scale3;
    }
    scale3.base = function(_2) {
      return arguments.length ? (base = +_2, rescale()) : base;
    };
    scale3.domain = function(_2) {
      return arguments.length ? (domain(_2), rescale()) : domain();
    };
    scale3.ticks = (count4) => {
      const d3 = domain();
      let u7 = d3[0];
      let v3 = d3[d3.length - 1];
      const r6 = v3 < u7;
      if (r6) [u7, v3] = [v3, u7];
      let i5 = logs(u7);
      let j2 = logs(v3);
      let k3;
      let t5;
      const n9 = count4 == null ? 10 : +count4;
      let z2 = [];
      if (!(base % 1) && j2 - i5 < n9) {
        i5 = Math.floor(i5), j2 = Math.ceil(j2);
        if (u7 > 0) for (; i5 <= j2; ++i5) {
          for (k3 = 1; k3 < base; ++k3) {
            t5 = i5 < 0 ? k3 / pows(-i5) : k3 * pows(i5);
            if (t5 < u7) continue;
            if (t5 > v3) break;
            z2.push(t5);
          }
        }
        else for (; i5 <= j2; ++i5) {
          for (k3 = base - 1; k3 >= 1; --k3) {
            t5 = i5 > 0 ? k3 / pows(-i5) : k3 * pows(i5);
            if (t5 < u7) continue;
            if (t5 > v3) break;
            z2.push(t5);
          }
        }
        if (z2.length * 2 < n9) z2 = ticks(u7, v3, n9);
      } else {
        z2 = ticks(i5, j2, Math.min(j2 - i5, n9)).map(pows);
      }
      return r6 ? z2.reverse() : z2;
    };
    scale3.tickFormat = (count4, specifier) => {
      if (count4 == null) count4 = 10;
      if (specifier == null) specifier = base === 10 ? "s" : ",";
      if (typeof specifier !== "function") {
        if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
        specifier = format(specifier);
      }
      if (count4 === Infinity) return specifier;
      const k3 = Math.max(1, base * count4 / scale3.ticks().length);
      return (d3) => {
        let i5 = d3 / pows(Math.round(logs(d3)));
        if (i5 * base < base - 0.5) i5 *= base;
        return i5 <= k3 ? specifier(d3) : "";
      };
    };
    scale3.nice = () => {
      return domain(nice2(domain(), {
        floor: (x3) => pows(Math.floor(logs(x3))),
        ceil: (x3) => pows(Math.ceil(logs(x3)))
      }));
    };
    return scale3;
  }
  function log2() {
    const scale3 = loggish(transformer2()).domain([1, 10]);
    scale3.copy = () => copy(scale3, log2()).base(scale3.base());
    initRange.apply(scale3, arguments);
    return scale3;
  }

  // ../../../../../node_modules/d3-scale/src/symlog.js
  function transformSymlog(c9) {
    return function(x3) {
      return Math.sign(x3) * Math.log1p(Math.abs(x3 / c9));
    };
  }
  function transformSymexp(c9) {
    return function(x3) {
      return Math.sign(x3) * Math.expm1(Math.abs(x3)) * c9;
    };
  }
  function symlogish(transform3) {
    var c9 = 1, scale3 = transform3(transformSymlog(c9), transformSymexp(c9));
    scale3.constant = function(_2) {
      return arguments.length ? transform3(transformSymlog(c9 = +_2), transformSymexp(c9)) : c9;
    };
    return linearish(scale3);
  }
  function symlog() {
    var scale3 = symlogish(transformer2());
    scale3.copy = function() {
      return copy(scale3, symlog()).constant(scale3.constant());
    };
    return initRange.apply(scale3, arguments);
  }

  // ../../../../../node_modules/d3-scale/src/pow.js
  function transformPow(exponent) {
    return function(x3) {
      return x3 < 0 ? -Math.pow(-x3, exponent) : Math.pow(x3, exponent);
    };
  }
  function transformSqrt(x3) {
    return x3 < 0 ? -Math.sqrt(-x3) : Math.sqrt(x3);
  }
  function transformSquare(x3) {
    return x3 < 0 ? -x3 * x3 : x3 * x3;
  }
  function powish(transform3) {
    var scale3 = transform3(identity3, identity3), exponent = 1;
    function rescale() {
      return exponent === 1 ? transform3(identity3, identity3) : exponent === 0.5 ? transform3(transformSqrt, transformSquare) : transform3(transformPow(exponent), transformPow(1 / exponent));
    }
    scale3.exponent = function(_2) {
      return arguments.length ? (exponent = +_2, rescale()) : exponent;
    };
    return linearish(scale3);
  }
  function pow3() {
    var scale3 = powish(transformer2());
    scale3.copy = function() {
      return copy(scale3, pow3()).exponent(scale3.exponent());
    };
    initRange.apply(scale3, arguments);
    return scale3;
  }

  // ../../../../../node_modules/d3-scale/src/quantile.js
  function quantile2() {
    var domain = [], range3 = [], thresholds = [], unknown;
    function rescale() {
      var i5 = 0, n9 = Math.max(1, range3.length);
      thresholds = new Array(n9 - 1);
      while (++i5 < n9) thresholds[i5 - 1] = quantileSorted(domain, i5 / n9);
      return scale3;
    }
    function scale3(x3) {
      return x3 == null || isNaN(x3 = +x3) ? unknown : range3[bisect_default(thresholds, x3)];
    }
    scale3.invertExtent = function(y3) {
      var i5 = range3.indexOf(y3);
      return i5 < 0 ? [NaN, NaN] : [
        i5 > 0 ? thresholds[i5 - 1] : domain[0],
        i5 < thresholds.length ? thresholds[i5] : domain[domain.length - 1]
      ];
    };
    scale3.domain = function(_2) {
      if (!arguments.length) return domain.slice();
      domain = [];
      for (let d3 of _2) if (d3 != null && !isNaN(d3 = +d3)) domain.push(d3);
      domain.sort(ascending);
      return rescale();
    };
    scale3.range = function(_2) {
      return arguments.length ? (range3 = Array.from(_2), rescale()) : range3.slice();
    };
    scale3.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale3) : unknown;
    };
    scale3.quantiles = function() {
      return thresholds.slice();
    };
    scale3.copy = function() {
      return quantile2().domain(domain).range(range3).unknown(unknown);
    };
    return initRange.apply(scale3, arguments);
  }

  // ../../../../../node_modules/d3-scale/src/threshold.js
  function threshold() {
    var domain = [0.5], range3 = [0, 1], unknown, n9 = 1;
    function scale3(x3) {
      return x3 != null && x3 <= x3 ? range3[bisect_default(domain, x3, 0, n9)] : unknown;
    }
    scale3.domain = function(_2) {
      return arguments.length ? (domain = Array.from(_2), n9 = Math.min(domain.length, range3.length - 1), scale3) : domain.slice();
    };
    scale3.range = function(_2) {
      return arguments.length ? (range3 = Array.from(_2), n9 = Math.min(domain.length, range3.length - 1), scale3) : range3.slice();
    };
    scale3.invertExtent = function(y3) {
      var i5 = range3.indexOf(y3);
      return [domain[i5 - 1], domain[i5]];
    };
    scale3.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale3) : unknown;
    };
    scale3.copy = function() {
      return threshold().domain(domain).range(range3).unknown(unknown);
    };
    return initRange.apply(scale3, arguments);
  }

  // ../../../../../node_modules/d3-time/src/interval.js
  var t02 = /* @__PURE__ */ new Date();
  var t12 = /* @__PURE__ */ new Date();
  function timeInterval(floori, offseti, count4, field2) {
    function interval2(date2) {
      return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
    }
    interval2.floor = (date2) => {
      return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
    };
    interval2.ceil = (date2) => {
      return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
    };
    interval2.round = (date2) => {
      const d0 = interval2(date2), d1 = interval2.ceil(date2);
      return date2 - d0 < d1 - date2 ? d0 : d1;
    };
    interval2.offset = (date2, step3) => {
      return offseti(date2 = /* @__PURE__ */ new Date(+date2), step3 == null ? 1 : Math.floor(step3)), date2;
    };
    interval2.range = (start2, stop2, step3) => {
      const range3 = [];
      start2 = interval2.ceil(start2);
      step3 = step3 == null ? 1 : Math.floor(step3);
      if (!(start2 < stop2) || !(step3 > 0)) return range3;
      let previous;
      do
        range3.push(previous = /* @__PURE__ */ new Date(+start2)), offseti(start2, step3), floori(start2);
      while (previous < start2 && start2 < stop2);
      return range3;
    };
    interval2.filter = (test) => {
      return timeInterval((date2) => {
        if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
      }, (date2, step3) => {
        if (date2 >= date2) {
          if (step3 < 0) while (++step3 <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
          else while (--step3 >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
        }
      });
    };
    if (count4) {
      interval2.count = (start2, end) => {
        t02.setTime(+start2), t12.setTime(+end);
        floori(t02), floori(t12);
        return Math.floor(count4(t02, t12));
      };
      interval2.every = (step3) => {
        step3 = Math.floor(step3);
        return !isFinite(step3) || !(step3 > 0) ? null : !(step3 > 1) ? interval2 : interval2.filter(field2 ? (d3) => field2(d3) % step3 === 0 : (d3) => interval2.count(0, d3) % step3 === 0);
      };
    }
    return interval2;
  }

  // ../../../../../node_modules/d3-time/src/millisecond.js
  var millisecond = timeInterval(() => {
  }, (date2, step3) => {
    date2.setTime(+date2 + step3);
  }, (start2, end) => {
    return end - start2;
  });
  millisecond.every = (k3) => {
    k3 = Math.floor(k3);
    if (!isFinite(k3) || !(k3 > 0)) return null;
    if (!(k3 > 1)) return millisecond;
    return timeInterval((date2) => {
      date2.setTime(Math.floor(date2 / k3) * k3);
    }, (date2, step3) => {
      date2.setTime(+date2 + step3 * k3);
    }, (start2, end) => {
      return (end - start2) / k3;
    });
  };
  var milliseconds = millisecond.range;

  // ../../../../../node_modules/d3-time/src/duration.js
  var durationSecond = 1e3;
  var durationMinute = durationSecond * 60;
  var durationHour = durationMinute * 60;
  var durationDay = durationHour * 24;
  var durationWeek = durationDay * 7;
  var durationMonth = durationDay * 30;
  var durationYear = durationDay * 365;

  // ../../../../../node_modules/d3-time/src/second.js
  var second = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds());
  }, (date2, step3) => {
    date2.setTime(+date2 + step3 * durationSecond);
  }, (start2, end) => {
    return (end - start2) / durationSecond;
  }, (date2) => {
    return date2.getUTCSeconds();
  });
  var seconds = second.range;

  // ../../../../../node_modules/d3-time/src/minute.js
  var timeMinute = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
  }, (date2, step3) => {
    date2.setTime(+date2 + step3 * durationMinute);
  }, (start2, end) => {
    return (end - start2) / durationMinute;
  }, (date2) => {
    return date2.getMinutes();
  });
  var timeMinutes = timeMinute.range;
  var utcMinute = timeInterval((date2) => {
    date2.setUTCSeconds(0, 0);
  }, (date2, step3) => {
    date2.setTime(+date2 + step3 * durationMinute);
  }, (start2, end) => {
    return (end - start2) / durationMinute;
  }, (date2) => {
    return date2.getUTCMinutes();
  });
  var utcMinutes = utcMinute.range;

  // ../../../../../node_modules/d3-time/src/hour.js
  var timeHour = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
  }, (date2, step3) => {
    date2.setTime(+date2 + step3 * durationHour);
  }, (start2, end) => {
    return (end - start2) / durationHour;
  }, (date2) => {
    return date2.getHours();
  });
  var timeHours = timeHour.range;
  var utcHour = timeInterval((date2) => {
    date2.setUTCMinutes(0, 0, 0);
  }, (date2, step3) => {
    date2.setTime(+date2 + step3 * durationHour);
  }, (start2, end) => {
    return (end - start2) / durationHour;
  }, (date2) => {
    return date2.getUTCHours();
  });
  var utcHours = utcHour.range;

  // ../../../../../node_modules/d3-time/src/day.js
  var timeDay = timeInterval(
    (date2) => date2.setHours(0, 0, 0, 0),
    (date2, step3) => date2.setDate(date2.getDate() + step3),
    (start2, end) => (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationDay,
    (date2) => date2.getDate() - 1
  );
  var timeDays = timeDay.range;
  var utcDay = timeInterval((date2) => {
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step3) => {
    date2.setUTCDate(date2.getUTCDate() + step3);
  }, (start2, end) => {
    return (end - start2) / durationDay;
  }, (date2) => {
    return date2.getUTCDate() - 1;
  });
  var utcDays = utcDay.range;
  var unixDay = timeInterval((date2) => {
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step3) => {
    date2.setUTCDate(date2.getUTCDate() + step3);
  }, (start2, end) => {
    return (end - start2) / durationDay;
  }, (date2) => {
    return Math.floor(date2 / durationDay);
  });
  var unixDays = unixDay.range;

  // ../../../../../node_modules/d3-time/src/week.js
  function timeWeekday(i5) {
    return timeInterval((date2) => {
      date2.setDate(date2.getDate() - (date2.getDay() + 7 - i5) % 7);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step3) => {
      date2.setDate(date2.getDate() + step3 * 7);
    }, (start2, end) => {
      return (end - start2 - (end.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute) / durationWeek;
    });
  }
  var timeSunday = timeWeekday(0);
  var timeMonday = timeWeekday(1);
  var timeTuesday = timeWeekday(2);
  var timeWednesday = timeWeekday(3);
  var timeThursday = timeWeekday(4);
  var timeFriday = timeWeekday(5);
  var timeSaturday = timeWeekday(6);
  var timeSundays = timeSunday.range;
  var timeMondays = timeMonday.range;
  var timeTuesdays = timeTuesday.range;
  var timeWednesdays = timeWednesday.range;
  var timeThursdays = timeThursday.range;
  var timeFridays = timeFriday.range;
  var timeSaturdays = timeSaturday.range;
  function utcWeekday(i5) {
    return timeInterval((date2) => {
      date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i5) % 7);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step3) => {
      date2.setUTCDate(date2.getUTCDate() + step3 * 7);
    }, (start2, end) => {
      return (end - start2) / durationWeek;
    });
  }
  var utcSunday = utcWeekday(0);
  var utcMonday = utcWeekday(1);
  var utcTuesday = utcWeekday(2);
  var utcWednesday = utcWeekday(3);
  var utcThursday = utcWeekday(4);
  var utcFriday = utcWeekday(5);
  var utcSaturday = utcWeekday(6);
  var utcSundays = utcSunday.range;
  var utcMondays = utcMonday.range;
  var utcTuesdays = utcTuesday.range;
  var utcWednesdays = utcWednesday.range;
  var utcThursdays = utcThursday.range;
  var utcFridays = utcFriday.range;
  var utcSaturdays = utcSaturday.range;

  // ../../../../../node_modules/d3-time/src/month.js
  var timeMonth = timeInterval((date2) => {
    date2.setDate(1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step3) => {
    date2.setMonth(date2.getMonth() + step3);
  }, (start2, end) => {
    return end.getMonth() - start2.getMonth() + (end.getFullYear() - start2.getFullYear()) * 12;
  }, (date2) => {
    return date2.getMonth();
  });
  var timeMonths = timeMonth.range;
  var utcMonth = timeInterval((date2) => {
    date2.setUTCDate(1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step3) => {
    date2.setUTCMonth(date2.getUTCMonth() + step3);
  }, (start2, end) => {
    return end.getUTCMonth() - start2.getUTCMonth() + (end.getUTCFullYear() - start2.getUTCFullYear()) * 12;
  }, (date2) => {
    return date2.getUTCMonth();
  });
  var utcMonths = utcMonth.range;

  // ../../../../../node_modules/d3-time/src/year.js
  var timeYear = timeInterval((date2) => {
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step3) => {
    date2.setFullYear(date2.getFullYear() + step3);
  }, (start2, end) => {
    return end.getFullYear() - start2.getFullYear();
  }, (date2) => {
    return date2.getFullYear();
  });
  timeYear.every = (k3) => {
    return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval((date2) => {
      date2.setFullYear(Math.floor(date2.getFullYear() / k3) * k3);
      date2.setMonth(0, 1);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step3) => {
      date2.setFullYear(date2.getFullYear() + step3 * k3);
    });
  };
  var timeYears = timeYear.range;
  var utcYear = timeInterval((date2) => {
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step3) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step3);
  }, (start2, end) => {
    return end.getUTCFullYear() - start2.getUTCFullYear();
  }, (date2) => {
    return date2.getUTCFullYear();
  });
  utcYear.every = (k3) => {
    return !isFinite(k3 = Math.floor(k3)) || !(k3 > 0) ? null : timeInterval((date2) => {
      date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k3) * k3);
      date2.setUTCMonth(0, 1);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step3) => {
      date2.setUTCFullYear(date2.getUTCFullYear() + step3 * k3);
    });
  };
  var utcYears = utcYear.range;

  // ../../../../../node_modules/d3-time/src/ticks.js
  function ticker(year, month, week, day, hour, minute) {
    const tickIntervals2 = [
      [second, 1, durationSecond],
      [second, 5, 5 * durationSecond],
      [second, 15, 15 * durationSecond],
      [second, 30, 30 * durationSecond],
      [minute, 1, durationMinute],
      [minute, 5, 5 * durationMinute],
      [minute, 15, 15 * durationMinute],
      [minute, 30, 30 * durationMinute],
      [hour, 1, durationHour],
      [hour, 3, 3 * durationHour],
      [hour, 6, 6 * durationHour],
      [hour, 12, 12 * durationHour],
      [day, 1, durationDay],
      [day, 2, 2 * durationDay],
      [week, 1, durationWeek],
      [month, 1, durationMonth],
      [month, 3, 3 * durationMonth],
      [year, 1, durationYear]
    ];
    function ticks2(start2, stop2, count4) {
      const reverse3 = stop2 < start2;
      if (reverse3) [start2, stop2] = [stop2, start2];
      const interval2 = count4 && typeof count4.range === "function" ? count4 : tickInterval(start2, stop2, count4);
      const ticks3 = interval2 ? interval2.range(start2, +stop2 + 1) : [];
      return reverse3 ? ticks3.reverse() : ticks3;
    }
    function tickInterval(start2, stop2, count4) {
      const target = Math.abs(stop2 - start2) / count4;
      const i5 = bisector(([, , step4]) => step4).right(tickIntervals2, target);
      if (i5 === tickIntervals2.length) return year.every(tickStep(start2 / durationYear, stop2 / durationYear, count4));
      if (i5 === 0) return millisecond.every(Math.max(tickStep(start2, stop2, count4), 1));
      const [t5, step3] = tickIntervals2[target / tickIntervals2[i5 - 1][2] < tickIntervals2[i5][2] / target ? i5 - 1 : i5];
      return t5.every(step3);
    }
    return [ticks2, tickInterval];
  }
  var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
  var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

  // ../../../../../node_modules/d3-time-format/src/locale.js
  function localDate(d3) {
    if (0 <= d3.y && d3.y < 100) {
      var date2 = new Date(-1, d3.m, d3.d, d3.H, d3.M, d3.S, d3.L);
      date2.setFullYear(d3.y);
      return date2;
    }
    return new Date(d3.y, d3.m, d3.d, d3.H, d3.M, d3.S, d3.L);
  }
  function utcDate(d3) {
    if (0 <= d3.y && d3.y < 100) {
      var date2 = new Date(Date.UTC(-1, d3.m, d3.d, d3.H, d3.M, d3.S, d3.L));
      date2.setUTCFullYear(d3.y);
      return date2;
    }
    return new Date(Date.UTC(d3.y, d3.m, d3.d, d3.H, d3.M, d3.S, d3.L));
  }
  function newDate(y3, m3, d3) {
    return { y: y3, m: m3, d: d3, H: 0, M: 0, S: 0, L: 0 };
  }
  function formatLocale(locale3) {
    var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
    var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
    var formats = {
      "a": formatShortWeekday,
      "A": formatWeekday2,
      "b": formatShortMonth,
      "B": formatMonth2,
      "c": null,
      "d": formatDayOfMonth,
      "e": formatDayOfMonth,
      "f": formatMicroseconds,
      "g": formatYearISO,
      "G": formatFullYearISO,
      "H": formatHour24,
      "I": formatHour12,
      "j": formatDayOfYear,
      "L": formatMilliseconds,
      "m": formatMonthNumber,
      "M": formatMinutes,
      "p": formatPeriod,
      "q": formatQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatSeconds,
      "u": formatWeekdayNumberMonday,
      "U": formatWeekNumberSunday,
      "V": formatWeekNumberISO,
      "w": formatWeekdayNumberSunday,
      "W": formatWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatYear,
      "Y": formatFullYear,
      "Z": formatZone,
      "%": formatLiteralPercent
    };
    var utcFormats = {
      "a": formatUTCShortWeekday,
      "A": formatUTCWeekday,
      "b": formatUTCShortMonth,
      "B": formatUTCMonth,
      "c": null,
      "d": formatUTCDayOfMonth,
      "e": formatUTCDayOfMonth,
      "f": formatUTCMicroseconds,
      "g": formatUTCYearISO,
      "G": formatUTCFullYearISO,
      "H": formatUTCHour24,
      "I": formatUTCHour12,
      "j": formatUTCDayOfYear,
      "L": formatUTCMilliseconds,
      "m": formatUTCMonthNumber,
      "M": formatUTCMinutes,
      "p": formatUTCPeriod,
      "q": formatUTCQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatUTCSeconds,
      "u": formatUTCWeekdayNumberMonday,
      "U": formatUTCWeekNumberSunday,
      "V": formatUTCWeekNumberISO,
      "w": formatUTCWeekdayNumberSunday,
      "W": formatUTCWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatUTCYear,
      "Y": formatUTCFullYear,
      "Z": formatUTCZone,
      "%": formatLiteralPercent
    };
    var parses = {
      "a": parseShortWeekday,
      "A": parseWeekday,
      "b": parseShortMonth,
      "B": parseMonth,
      "c": parseLocaleDateTime,
      "d": parseDayOfMonth,
      "e": parseDayOfMonth,
      "f": parseMicroseconds,
      "g": parseYear,
      "G": parseFullYear,
      "H": parseHour24,
      "I": parseHour24,
      "j": parseDayOfYear,
      "L": parseMilliseconds,
      "m": parseMonthNumber,
      "M": parseMinutes,
      "p": parsePeriod,
      "q": parseQuarter,
      "Q": parseUnixTimestamp,
      "s": parseUnixTimestampSeconds,
      "S": parseSeconds,
      "u": parseWeekdayNumberMonday,
      "U": parseWeekNumberSunday,
      "V": parseWeekNumberISO,
      "w": parseWeekdayNumberSunday,
      "W": parseWeekNumberMonday,
      "x": parseLocaleDate,
      "X": parseLocaleTime,
      "y": parseYear,
      "Y": parseFullYear,
      "Z": parseZone,
      "%": parseLiteralPercent
    };
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);
    function newFormat(specifier, formats2) {
      return function(date2) {
        var string2 = [], i5 = -1, j2 = 0, n9 = specifier.length, c9, pad3, format3;
        if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
        while (++i5 < n9) {
          if (specifier.charCodeAt(i5) === 37) {
            string2.push(specifier.slice(j2, i5));
            if ((pad3 = pads[c9 = specifier.charAt(++i5)]) != null) c9 = specifier.charAt(++i5);
            else pad3 = c9 === "e" ? " " : "0";
            if (format3 = formats2[c9]) c9 = format3(date2, pad3);
            string2.push(c9);
            j2 = i5 + 1;
          }
        }
        string2.push(specifier.slice(j2, i5));
        return string2.join("");
      };
    }
    function newParse(specifier, Z3) {
      return function(string2) {
        var d3 = newDate(1900, void 0, 1), i5 = parseSpecifier(d3, specifier, string2 += "", 0), week, day;
        if (i5 != string2.length) return null;
        if ("Q" in d3) return new Date(d3.Q);
        if ("s" in d3) return new Date(d3.s * 1e3 + ("L" in d3 ? d3.L : 0));
        if (Z3 && !("Z" in d3)) d3.Z = 0;
        if ("p" in d3) d3.H = d3.H % 12 + d3.p * 12;
        if (d3.m === void 0) d3.m = "q" in d3 ? d3.q : 0;
        if ("V" in d3) {
          if (d3.V < 1 || d3.V > 53) return null;
          if (!("w" in d3)) d3.w = 1;
          if ("Z" in d3) {
            week = utcDate(newDate(d3.y, 0, 1)), day = week.getUTCDay();
            week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
            week = utcDay.offset(week, (d3.V - 1) * 7);
            d3.y = week.getUTCFullYear();
            d3.m = week.getUTCMonth();
            d3.d = week.getUTCDate() + (d3.w + 6) % 7;
          } else {
            week = localDate(newDate(d3.y, 0, 1)), day = week.getDay();
            week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
            week = timeDay.offset(week, (d3.V - 1) * 7);
            d3.y = week.getFullYear();
            d3.m = week.getMonth();
            d3.d = week.getDate() + (d3.w + 6) % 7;
          }
        } else if ("W" in d3 || "U" in d3) {
          if (!("w" in d3)) d3.w = "u" in d3 ? d3.u % 7 : "W" in d3 ? 1 : 0;
          day = "Z" in d3 ? utcDate(newDate(d3.y, 0, 1)).getUTCDay() : localDate(newDate(d3.y, 0, 1)).getDay();
          d3.m = 0;
          d3.d = "W" in d3 ? (d3.w + 6) % 7 + d3.W * 7 - (day + 5) % 7 : d3.w + d3.U * 7 - (day + 6) % 7;
        }
        if ("Z" in d3) {
          d3.H += d3.Z / 100 | 0;
          d3.M += d3.Z % 100;
          return utcDate(d3);
        }
        return localDate(d3);
      };
    }
    function parseSpecifier(d3, specifier, string2, j2) {
      var i5 = 0, n9 = specifier.length, m3 = string2.length, c9, parse3;
      while (i5 < n9) {
        if (j2 >= m3) return -1;
        c9 = specifier.charCodeAt(i5++);
        if (c9 === 37) {
          c9 = specifier.charAt(i5++);
          parse3 = parses[c9 in pads ? specifier.charAt(i5++) : c9];
          if (!parse3 || (j2 = parse3(d3, string2, j2)) < 0) return -1;
        } else if (c9 != string2.charCodeAt(j2++)) {
          return -1;
        }
      }
      return j2;
    }
    function parsePeriod(d3, string2, i5) {
      var n9 = periodRe.exec(string2.slice(i5));
      return n9 ? (d3.p = periodLookup.get(n9[0].toLowerCase()), i5 + n9[0].length) : -1;
    }
    function parseShortWeekday(d3, string2, i5) {
      var n9 = shortWeekdayRe.exec(string2.slice(i5));
      return n9 ? (d3.w = shortWeekdayLookup.get(n9[0].toLowerCase()), i5 + n9[0].length) : -1;
    }
    function parseWeekday(d3, string2, i5) {
      var n9 = weekdayRe.exec(string2.slice(i5));
      return n9 ? (d3.w = weekdayLookup.get(n9[0].toLowerCase()), i5 + n9[0].length) : -1;
    }
    function parseShortMonth(d3, string2, i5) {
      var n9 = shortMonthRe.exec(string2.slice(i5));
      return n9 ? (d3.m = shortMonthLookup.get(n9[0].toLowerCase()), i5 + n9[0].length) : -1;
    }
    function parseMonth(d3, string2, i5) {
      var n9 = monthRe.exec(string2.slice(i5));
      return n9 ? (d3.m = monthLookup.get(n9[0].toLowerCase()), i5 + n9[0].length) : -1;
    }
    function parseLocaleDateTime(d3, string2, i5) {
      return parseSpecifier(d3, locale_dateTime, string2, i5);
    }
    function parseLocaleDate(d3, string2, i5) {
      return parseSpecifier(d3, locale_date, string2, i5);
    }
    function parseLocaleTime(d3, string2, i5) {
      return parseSpecifier(d3, locale_time, string2, i5);
    }
    function formatShortWeekday(d3) {
      return locale_shortWeekdays[d3.getDay()];
    }
    function formatWeekday2(d3) {
      return locale_weekdays[d3.getDay()];
    }
    function formatShortMonth(d3) {
      return locale_shortMonths[d3.getMonth()];
    }
    function formatMonth2(d3) {
      return locale_months[d3.getMonth()];
    }
    function formatPeriod(d3) {
      return locale_periods[+(d3.getHours() >= 12)];
    }
    function formatQuarter(d3) {
      return 1 + ~~(d3.getMonth() / 3);
    }
    function formatUTCShortWeekday(d3) {
      return locale_shortWeekdays[d3.getUTCDay()];
    }
    function formatUTCWeekday(d3) {
      return locale_weekdays[d3.getUTCDay()];
    }
    function formatUTCShortMonth(d3) {
      return locale_shortMonths[d3.getUTCMonth()];
    }
    function formatUTCMonth(d3) {
      return locale_months[d3.getUTCMonth()];
    }
    function formatUTCPeriod(d3) {
      return locale_periods[+(d3.getUTCHours() >= 12)];
    }
    function formatUTCQuarter(d3) {
      return 1 + ~~(d3.getUTCMonth() / 3);
    }
    return {
      format: function(specifier) {
        var f7 = newFormat(specifier += "", formats);
        f7.toString = function() {
          return specifier;
        };
        return f7;
      },
      parse: function(specifier) {
        var p11 = newParse(specifier += "", false);
        p11.toString = function() {
          return specifier;
        };
        return p11;
      },
      utcFormat: function(specifier) {
        var f7 = newFormat(specifier += "", utcFormats);
        f7.toString = function() {
          return specifier;
        };
        return f7;
      },
      utcParse: function(specifier) {
        var p11 = newParse(specifier += "", true);
        p11.toString = function() {
          return specifier;
        };
        return p11;
      }
    };
  }
  var pads = { "-": "", "_": " ", "0": "0" };
  var numberRe = /^\s*\d+/;
  var percentRe = /^%/;
  var requoteRe = /[\\^$*+?|[\]().{}]/g;
  function pad(value, fill, width) {
    var sign4 = value < 0 ? "-" : "", string2 = (sign4 ? -value : value) + "", length4 = string2.length;
    return sign4 + (length4 < width ? new Array(width - length4 + 1).join(fill) + string2 : string2);
  }
  function requote(s8) {
    return s8.replace(requoteRe, "\\$&");
  }
  function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
  }
  function formatLookup(names) {
    return new Map(names.map((name, i5) => [name.toLowerCase(), i5]));
  }
  function parseWeekdayNumberSunday(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5, i5 + 1));
    return n9 ? (d3.w = +n9[0], i5 + n9[0].length) : -1;
  }
  function parseWeekdayNumberMonday(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5, i5 + 1));
    return n9 ? (d3.u = +n9[0], i5 + n9[0].length) : -1;
  }
  function parseWeekNumberSunday(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5, i5 + 2));
    return n9 ? (d3.U = +n9[0], i5 + n9[0].length) : -1;
  }
  function parseWeekNumberISO(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5, i5 + 2));
    return n9 ? (d3.V = +n9[0], i5 + n9[0].length) : -1;
  }
  function parseWeekNumberMonday(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5, i5 + 2));
    return n9 ? (d3.W = +n9[0], i5 + n9[0].length) : -1;
  }
  function parseFullYear(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5, i5 + 4));
    return n9 ? (d3.y = +n9[0], i5 + n9[0].length) : -1;
  }
  function parseYear(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5, i5 + 2));
    return n9 ? (d3.y = +n9[0] + (+n9[0] > 68 ? 1900 : 2e3), i5 + n9[0].length) : -1;
  }
  function parseZone(d3, string2, i5) {
    var n9 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string2.slice(i5, i5 + 6));
    return n9 ? (d3.Z = n9[1] ? 0 : -(n9[2] + (n9[3] || "00")), i5 + n9[0].length) : -1;
  }
  function parseQuarter(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5, i5 + 1));
    return n9 ? (d3.q = n9[0] * 3 - 3, i5 + n9[0].length) : -1;
  }
  function parseMonthNumber(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5, i5 + 2));
    return n9 ? (d3.m = n9[0] - 1, i5 + n9[0].length) : -1;
  }
  function parseDayOfMonth(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5, i5 + 2));
    return n9 ? (d3.d = +n9[0], i5 + n9[0].length) : -1;
  }
  function parseDayOfYear(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5, i5 + 3));
    return n9 ? (d3.m = 0, d3.d = +n9[0], i5 + n9[0].length) : -1;
  }
  function parseHour24(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5, i5 + 2));
    return n9 ? (d3.H = +n9[0], i5 + n9[0].length) : -1;
  }
  function parseMinutes(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5, i5 + 2));
    return n9 ? (d3.M = +n9[0], i5 + n9[0].length) : -1;
  }
  function parseSeconds(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5, i5 + 2));
    return n9 ? (d3.S = +n9[0], i5 + n9[0].length) : -1;
  }
  function parseMilliseconds(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5, i5 + 3));
    return n9 ? (d3.L = +n9[0], i5 + n9[0].length) : -1;
  }
  function parseMicroseconds(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5, i5 + 6));
    return n9 ? (d3.L = Math.floor(n9[0] / 1e3), i5 + n9[0].length) : -1;
  }
  function parseLiteralPercent(d3, string2, i5) {
    var n9 = percentRe.exec(string2.slice(i5, i5 + 1));
    return n9 ? i5 + n9[0].length : -1;
  }
  function parseUnixTimestamp(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5));
    return n9 ? (d3.Q = +n9[0], i5 + n9[0].length) : -1;
  }
  function parseUnixTimestampSeconds(d3, string2, i5) {
    var n9 = numberRe.exec(string2.slice(i5));
    return n9 ? (d3.s = +n9[0], i5 + n9[0].length) : -1;
  }
  function formatDayOfMonth(d3, p11) {
    return pad(d3.getDate(), p11, 2);
  }
  function formatHour24(d3, p11) {
    return pad(d3.getHours(), p11, 2);
  }
  function formatHour12(d3, p11) {
    return pad(d3.getHours() % 12 || 12, p11, 2);
  }
  function formatDayOfYear(d3, p11) {
    return pad(1 + timeDay.count(timeYear(d3), d3), p11, 3);
  }
  function formatMilliseconds(d3, p11) {
    return pad(d3.getMilliseconds(), p11, 3);
  }
  function formatMicroseconds(d3, p11) {
    return formatMilliseconds(d3, p11) + "000";
  }
  function formatMonthNumber(d3, p11) {
    return pad(d3.getMonth() + 1, p11, 2);
  }
  function formatMinutes(d3, p11) {
    return pad(d3.getMinutes(), p11, 2);
  }
  function formatSeconds(d3, p11) {
    return pad(d3.getSeconds(), p11, 2);
  }
  function formatWeekdayNumberMonday(d3) {
    var day = d3.getDay();
    return day === 0 ? 7 : day;
  }
  function formatWeekNumberSunday(d3, p11) {
    return pad(timeSunday.count(timeYear(d3) - 1, d3), p11, 2);
  }
  function dISO(d3) {
    var day = d3.getDay();
    return day >= 4 || day === 0 ? timeThursday(d3) : timeThursday.ceil(d3);
  }
  function formatWeekNumberISO(d3, p11) {
    d3 = dISO(d3);
    return pad(timeThursday.count(timeYear(d3), d3) + (timeYear(d3).getDay() === 4), p11, 2);
  }
  function formatWeekdayNumberSunday(d3) {
    return d3.getDay();
  }
  function formatWeekNumberMonday(d3, p11) {
    return pad(timeMonday.count(timeYear(d3) - 1, d3), p11, 2);
  }
  function formatYear(d3, p11) {
    return pad(d3.getFullYear() % 100, p11, 2);
  }
  function formatYearISO(d3, p11) {
    d3 = dISO(d3);
    return pad(d3.getFullYear() % 100, p11, 2);
  }
  function formatFullYear(d3, p11) {
    return pad(d3.getFullYear() % 1e4, p11, 4);
  }
  function formatFullYearISO(d3, p11) {
    var day = d3.getDay();
    d3 = day >= 4 || day === 0 ? timeThursday(d3) : timeThursday.ceil(d3);
    return pad(d3.getFullYear() % 1e4, p11, 4);
  }
  function formatZone(d3) {
    var z2 = d3.getTimezoneOffset();
    return (z2 > 0 ? "-" : (z2 *= -1, "+")) + pad(z2 / 60 | 0, "0", 2) + pad(z2 % 60, "0", 2);
  }
  function formatUTCDayOfMonth(d3, p11) {
    return pad(d3.getUTCDate(), p11, 2);
  }
  function formatUTCHour24(d3, p11) {
    return pad(d3.getUTCHours(), p11, 2);
  }
  function formatUTCHour12(d3, p11) {
    return pad(d3.getUTCHours() % 12 || 12, p11, 2);
  }
  function formatUTCDayOfYear(d3, p11) {
    return pad(1 + utcDay.count(utcYear(d3), d3), p11, 3);
  }
  function formatUTCMilliseconds(d3, p11) {
    return pad(d3.getUTCMilliseconds(), p11, 3);
  }
  function formatUTCMicroseconds(d3, p11) {
    return formatUTCMilliseconds(d3, p11) + "000";
  }
  function formatUTCMonthNumber(d3, p11) {
    return pad(d3.getUTCMonth() + 1, p11, 2);
  }
  function formatUTCMinutes(d3, p11) {
    return pad(d3.getUTCMinutes(), p11, 2);
  }
  function formatUTCSeconds(d3, p11) {
    return pad(d3.getUTCSeconds(), p11, 2);
  }
  function formatUTCWeekdayNumberMonday(d3) {
    var dow = d3.getUTCDay();
    return dow === 0 ? 7 : dow;
  }
  function formatUTCWeekNumberSunday(d3, p11) {
    return pad(utcSunday.count(utcYear(d3) - 1, d3), p11, 2);
  }
  function UTCdISO(d3) {
    var day = d3.getUTCDay();
    return day >= 4 || day === 0 ? utcThursday(d3) : utcThursday.ceil(d3);
  }
  function formatUTCWeekNumberISO(d3, p11) {
    d3 = UTCdISO(d3);
    return pad(utcThursday.count(utcYear(d3), d3) + (utcYear(d3).getUTCDay() === 4), p11, 2);
  }
  function formatUTCWeekdayNumberSunday(d3) {
    return d3.getUTCDay();
  }
  function formatUTCWeekNumberMonday(d3, p11) {
    return pad(utcMonday.count(utcYear(d3) - 1, d3), p11, 2);
  }
  function formatUTCYear(d3, p11) {
    return pad(d3.getUTCFullYear() % 100, p11, 2);
  }
  function formatUTCYearISO(d3, p11) {
    d3 = UTCdISO(d3);
    return pad(d3.getUTCFullYear() % 100, p11, 2);
  }
  function formatUTCFullYear(d3, p11) {
    return pad(d3.getUTCFullYear() % 1e4, p11, 4);
  }
  function formatUTCFullYearISO(d3, p11) {
    var day = d3.getUTCDay();
    d3 = day >= 4 || day === 0 ? utcThursday(d3) : utcThursday.ceil(d3);
    return pad(d3.getUTCFullYear() % 1e4, p11, 4);
  }
  function formatUTCZone() {
    return "+0000";
  }
  function formatLiteralPercent() {
    return "%";
  }
  function formatUnixTimestamp(d3) {
    return +d3;
  }
  function formatUnixTimestampSeconds(d3) {
    return Math.floor(+d3 / 1e3);
  }

  // ../../../../../node_modules/d3-time-format/src/defaultLocale.js
  var locale2;
  var timeFormat;
  var timeParse;
  var utcFormat;
  var utcParse;
  defaultLocale2({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });
  function defaultLocale2(definition) {
    locale2 = formatLocale(definition);
    timeFormat = locale2.format;
    timeParse = locale2.parse;
    utcFormat = locale2.utcFormat;
    utcParse = locale2.utcParse;
    return locale2;
  }

  // ../../../../../node_modules/d3-scale/src/time.js
  function date(t5) {
    return new Date(t5);
  }
  function number4(t5) {
    return t5 instanceof Date ? +t5 : +/* @__PURE__ */ new Date(+t5);
  }
  function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3) {
    var scale3 = continuous(), invert = scale3.invert, domain = scale3.domain;
    var formatMillisecond = format3(".%L"), formatSecond = format3(":%S"), formatMinute = format3("%I:%M"), formatHour = format3("%I %p"), formatDay = format3("%a %d"), formatWeek = format3("%b %d"), formatMonth2 = format3("%B"), formatYear3 = format3("%Y");
    function tickFormat2(date2) {
      return (second3(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth2 : formatYear3)(date2);
    }
    scale3.invert = function(y3) {
      return new Date(invert(y3));
    };
    scale3.domain = function(_2) {
      return arguments.length ? domain(Array.from(_2, number4)) : domain().map(date);
    };
    scale3.ticks = function(interval2) {
      var d3 = domain();
      return ticks2(d3[0], d3[d3.length - 1], interval2 == null ? 10 : interval2);
    };
    scale3.tickFormat = function(count4, specifier) {
      return specifier == null ? tickFormat2 : format3(specifier);
    };
    scale3.nice = function(interval2) {
      var d3 = domain();
      if (!interval2 || typeof interval2.range !== "function") interval2 = tickInterval(d3[0], d3[d3.length - 1], interval2 == null ? 10 : interval2);
      return interval2 ? domain(nice2(d3, interval2)) : scale3;
    };
    scale3.copy = function() {
      return copy(scale3, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second3, format3));
    };
    return scale3;
  }
  function time() {
    return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
  }

  // ../../../../../node_modules/d3-scale/src/utcTime.js
  function utcTime() {
    return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
  }

  // ../../../../../node_modules/d3-scale/src/sequential.js
  function copy2(source, target) {
    return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
  }

  // ../../../../../node_modules/d3-scale/src/diverging.js
  function transformer3() {
    var x06 = 0, x12 = 0.5, x22 = 1, s8 = 1, t03, t13, t23, k10, k21, interpolator = identity3, transform3, clamp = false, unknown;
    function scale3(x3) {
      return isNaN(x3 = +x3) ? unknown : (x3 = 0.5 + ((x3 = +transform3(x3)) - t13) * (s8 * x3 < s8 * t13 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x3)) : x3));
    }
    scale3.domain = function(_2) {
      return arguments.length ? ([x06, x12, x22] = _2, t03 = transform3(x06 = +x06), t13 = transform3(x12 = +x12), t23 = transform3(x22 = +x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t23 ? 0 : 0.5 / (t23 - t13), s8 = t13 < t03 ? -1 : 1, scale3) : [x06, x12, x22];
    };
    scale3.clamp = function(_2) {
      return arguments.length ? (clamp = !!_2, scale3) : clamp;
    };
    scale3.interpolator = function(_2) {
      return arguments.length ? (interpolator = _2, scale3) : interpolator;
    };
    function range3(interpolate) {
      return function(_2) {
        var r0, r1, r22;
        return arguments.length ? ([r0, r1, r22] = _2, interpolator = piecewise(interpolate, [r0, r1, r22]), scale3) : [interpolator(0), interpolator(0.5), interpolator(1)];
      };
    }
    scale3.range = range3(value_default);
    scale3.rangeRound = range3(round_default);
    scale3.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale3) : unknown;
    };
    return function(t5) {
      transform3 = t5, t03 = t5(x06), t13 = t5(x12), t23 = t5(x22), k10 = t03 === t13 ? 0 : 0.5 / (t13 - t03), k21 = t13 === t23 ? 0 : 0.5 / (t23 - t13), s8 = t13 < t03 ? -1 : 1;
      return scale3;
    };
  }
  function diverging() {
    var scale3 = linearish(transformer3()(identity3));
    scale3.copy = function() {
      return copy2(scale3, diverging());
    };
    return initInterpolator.apply(scale3, arguments);
  }
  function divergingLog() {
    var scale3 = loggish(transformer3()).domain([0.1, 1, 10]);
    scale3.copy = function() {
      return copy2(scale3, divergingLog()).base(scale3.base());
    };
    return initInterpolator.apply(scale3, arguments);
  }
  function divergingSymlog() {
    var scale3 = symlogish(transformer3());
    scale3.copy = function() {
      return copy2(scale3, divergingSymlog()).constant(scale3.constant());
    };
    return initInterpolator.apply(scale3, arguments);
  }
  function divergingPow() {
    var scale3 = powish(transformer3());
    scale3.copy = function() {
      return copy2(scale3, divergingPow()).exponent(scale3.exponent());
    };
    return initInterpolator.apply(scale3, arguments);
  }

  // ../../../../../node_modules/d3-scale-chromatic/src/colors.js
  function colors_default(specifier) {
    var n9 = specifier.length / 6 | 0, colors = new Array(n9), i5 = 0;
    while (i5 < n9) colors[i5] = "#" + specifier.slice(i5 * 6, ++i5 * 6);
    return colors;
  }

  // ../../../../../node_modules/d3-scale-chromatic/src/categorical/category10.js
  var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

  // ../../../../../node_modules/d3-scale-chromatic/src/categorical/Accent.js
  var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

  // ../../../../../node_modules/d3-scale-chromatic/src/categorical/Dark2.js
  var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

  // ../../../../../node_modules/d3-scale-chromatic/src/categorical/observable10.js
  var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

  // ../../../../../node_modules/d3-scale-chromatic/src/categorical/Paired.js
  var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

  // ../../../../../node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
  var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

  // ../../../../../node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
  var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

  // ../../../../../node_modules/d3-scale-chromatic/src/categorical/Set1.js
  var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

  // ../../../../../node_modules/d3-scale-chromatic/src/categorical/Set2.js
  var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

  // ../../../../../node_modules/d3-scale-chromatic/src/categorical/Set3.js
  var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

  // ../../../../../node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
  var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

  // ../../../../../node_modules/d3-scale-chromatic/src/ramp.js
  var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

  // ../../../../../node_modules/d3-scale-chromatic/src/diverging/BrBG.js
  var scheme = new Array(3).concat(
    "d8b365f5f5f55ab4ac",
    "a6611adfc27d80cdc1018571",
    "a6611adfc27df5f5f580cdc1018571",
    "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
    "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
    "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
    "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
    "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
    "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
  ).map(colors_default);
  var BrBG_default = ramp_default(scheme);

  // ../../../../../node_modules/d3-scale-chromatic/src/diverging/PRGn.js
  var scheme2 = new Array(3).concat(
    "af8dc3f7f7f77fbf7b",
    "7b3294c2a5cfa6dba0008837",
    "7b3294c2a5cff7f7f7a6dba0008837",
    "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
    "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
    "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
    "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
    "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
    "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
  ).map(colors_default);
  var PRGn_default = ramp_default(scheme2);

  // ../../../../../node_modules/d3-scale-chromatic/src/diverging/PiYG.js
  var scheme3 = new Array(3).concat(
    "e9a3c9f7f7f7a1d76a",
    "d01c8bf1b6dab8e1864dac26",
    "d01c8bf1b6daf7f7f7b8e1864dac26",
    "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
    "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
    "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
    "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
    "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
    "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
  ).map(colors_default);
  var PiYG_default = ramp_default(scheme3);

  // ../../../../../node_modules/d3-scale-chromatic/src/diverging/PuOr.js
  var scheme4 = new Array(3).concat(
    "998ec3f7f7f7f1a340",
    "5e3c99b2abd2fdb863e66101",
    "5e3c99b2abd2f7f7f7fdb863e66101",
    "542788998ec3d8daebfee0b6f1a340b35806",
    "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
    "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
    "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
    "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
    "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
  ).map(colors_default);
  var PuOr_default = ramp_default(scheme4);

  // ../../../../../node_modules/d3-scale-chromatic/src/diverging/RdBu.js
  var scheme5 = new Array(3).concat(
    "ef8a62f7f7f767a9cf",
    "ca0020f4a58292c5de0571b0",
    "ca0020f4a582f7f7f792c5de0571b0",
    "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
    "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
    "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
    "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
    "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
    "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
  ).map(colors_default);
  var RdBu_default = ramp_default(scheme5);

  // ../../../../../node_modules/d3-scale-chromatic/src/diverging/RdGy.js
  var scheme6 = new Array(3).concat(
    "ef8a62ffffff999999",
    "ca0020f4a582bababa404040",
    "ca0020f4a582ffffffbababa404040",
    "b2182bef8a62fddbc7e0e0e09999994d4d4d",
    "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
    "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
    "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
    "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
    "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
  ).map(colors_default);
  var RdGy_default = ramp_default(scheme6);

  // ../../../../../node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
  var scheme7 = new Array(3).concat(
    "fc8d59ffffbf91bfdb",
    "d7191cfdae61abd9e92c7bb6",
    "d7191cfdae61ffffbfabd9e92c7bb6",
    "d73027fc8d59fee090e0f3f891bfdb4575b4",
    "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
    "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
    "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
    "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
    "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
  ).map(colors_default);
  var RdYlBu_default = ramp_default(scheme7);

  // ../../../../../node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
  var scheme8 = new Array(3).concat(
    "fc8d59ffffbf91cf60",
    "d7191cfdae61a6d96a1a9641",
    "d7191cfdae61ffffbfa6d96a1a9641",
    "d73027fc8d59fee08bd9ef8b91cf601a9850",
    "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
    "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
    "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
    "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
    "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
  ).map(colors_default);
  var RdYlGn_default = ramp_default(scheme8);

  // ../../../../../node_modules/d3-scale-chromatic/src/diverging/Spectral.js
  var scheme9 = new Array(3).concat(
    "fc8d59ffffbf99d594",
    "d7191cfdae61abdda42b83ba",
    "d7191cfdae61ffffbfabdda42b83ba",
    "d53e4ffc8d59fee08be6f59899d5943288bd",
    "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
    "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
    "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
    "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
    "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
  ).map(colors_default);
  var Spectral_default = ramp_default(scheme9);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
  var scheme10 = new Array(3).concat(
    "e5f5f999d8c92ca25f",
    "edf8fbb2e2e266c2a4238b45",
    "edf8fbb2e2e266c2a42ca25f006d2c",
    "edf8fbccece699d8c966c2a42ca25f006d2c",
    "edf8fbccece699d8c966c2a441ae76238b45005824",
    "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
    "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
  ).map(colors_default);
  var BuGn_default = ramp_default(scheme10);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
  var scheme11 = new Array(3).concat(
    "e0ecf49ebcda8856a7",
    "edf8fbb3cde38c96c688419d",
    "edf8fbb3cde38c96c68856a7810f7c",
    "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
    "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
    "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
    "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
  ).map(colors_default);
  var BuPu_default = ramp_default(scheme11);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
  var scheme12 = new Array(3).concat(
    "e0f3dba8ddb543a2ca",
    "f0f9e8bae4bc7bccc42b8cbe",
    "f0f9e8bae4bc7bccc443a2ca0868ac",
    "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
    "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
    "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
    "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
  ).map(colors_default);
  var GnBu_default = ramp_default(scheme12);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
  var scheme13 = new Array(3).concat(
    "fee8c8fdbb84e34a33",
    "fef0d9fdcc8afc8d59d7301f",
    "fef0d9fdcc8afc8d59e34a33b30000",
    "fef0d9fdd49efdbb84fc8d59e34a33b30000",
    "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
    "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
    "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
  ).map(colors_default);
  var OrRd_default = ramp_default(scheme13);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
  var scheme14 = new Array(3).concat(
    "ece2f0a6bddb1c9099",
    "f6eff7bdc9e167a9cf02818a",
    "f6eff7bdc9e167a9cf1c9099016c59",
    "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
    "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
    "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
    "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
  ).map(colors_default);
  var PuBuGn_default = ramp_default(scheme14);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
  var scheme15 = new Array(3).concat(
    "ece7f2a6bddb2b8cbe",
    "f1eef6bdc9e174a9cf0570b0",
    "f1eef6bdc9e174a9cf2b8cbe045a8d",
    "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
    "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
    "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
    "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
  ).map(colors_default);
  var PuBu_default = ramp_default(scheme15);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
  var scheme16 = new Array(3).concat(
    "e7e1efc994c7dd1c77",
    "f1eef6d7b5d8df65b0ce1256",
    "f1eef6d7b5d8df65b0dd1c77980043",
    "f1eef6d4b9dac994c7df65b0dd1c77980043",
    "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
    "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
    "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
  ).map(colors_default);
  var PuRd_default = ramp_default(scheme16);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
  var scheme17 = new Array(3).concat(
    "fde0ddfa9fb5c51b8a",
    "feebe2fbb4b9f768a1ae017e",
    "feebe2fbb4b9f768a1c51b8a7a0177",
    "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
    "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
    "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
    "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
  ).map(colors_default);
  var RdPu_default = ramp_default(scheme17);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
  var scheme18 = new Array(3).concat(
    "edf8b17fcdbb2c7fb8",
    "ffffcca1dab441b6c4225ea8",
    "ffffcca1dab441b6c42c7fb8253494",
    "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
    "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
    "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
    "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
  ).map(colors_default);
  var YlGnBu_default = ramp_default(scheme18);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
  var scheme19 = new Array(3).concat(
    "f7fcb9addd8e31a354",
    "ffffccc2e69978c679238443",
    "ffffccc2e69978c67931a354006837",
    "ffffccd9f0a3addd8e78c67931a354006837",
    "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
    "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
    "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
  ).map(colors_default);
  var YlGn_default = ramp_default(scheme19);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
  var scheme20 = new Array(3).concat(
    "fff7bcfec44fd95f0e",
    "ffffd4fed98efe9929cc4c02",
    "ffffd4fed98efe9929d95f0e993404",
    "ffffd4fee391fec44ffe9929d95f0e993404",
    "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
    "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
    "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
  ).map(colors_default);
  var YlOrBr_default = ramp_default(scheme20);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
  var scheme21 = new Array(3).concat(
    "ffeda0feb24cf03b20",
    "ffffb2fecc5cfd8d3ce31a1c",
    "ffffb2fecc5cfd8d3cf03b20bd0026",
    "ffffb2fed976feb24cfd8d3cf03b20bd0026",
    "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
    "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
    "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
  ).map(colors_default);
  var YlOrRd_default = ramp_default(scheme21);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
  var scheme22 = new Array(3).concat(
    "deebf79ecae13182bd",
    "eff3ffbdd7e76baed62171b5",
    "eff3ffbdd7e76baed63182bd08519c",
    "eff3ffc6dbef9ecae16baed63182bd08519c",
    "eff3ffc6dbef9ecae16baed64292c62171b5084594",
    "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
    "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
  ).map(colors_default);
  var Blues_default = ramp_default(scheme22);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
  var scheme23 = new Array(3).concat(
    "e5f5e0a1d99b31a354",
    "edf8e9bae4b374c476238b45",
    "edf8e9bae4b374c47631a354006d2c",
    "edf8e9c7e9c0a1d99b74c47631a354006d2c",
    "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
    "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
    "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
  ).map(colors_default);
  var Greens_default = ramp_default(scheme23);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
  var scheme24 = new Array(3).concat(
    "f0f0f0bdbdbd636363",
    "f7f7f7cccccc969696525252",
    "f7f7f7cccccc969696636363252525",
    "f7f7f7d9d9d9bdbdbd969696636363252525",
    "f7f7f7d9d9d9bdbdbd969696737373525252252525",
    "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
    "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
  ).map(colors_default);
  var Greys_default = ramp_default(scheme24);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
  var scheme25 = new Array(3).concat(
    "efedf5bcbddc756bb1",
    "f2f0f7cbc9e29e9ac86a51a3",
    "f2f0f7cbc9e29e9ac8756bb154278f",
    "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
    "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
    "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
    "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
  ).map(colors_default);
  var Purples_default = ramp_default(scheme25);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
  var scheme26 = new Array(3).concat(
    "fee0d2fc9272de2d26",
    "fee5d9fcae91fb6a4acb181d",
    "fee5d9fcae91fb6a4ade2d26a50f15",
    "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
    "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
    "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
    "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
  ).map(colors_default);
  var Reds_default = ramp_default(scheme26);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
  var scheme27 = new Array(3).concat(
    "fee6cefdae6be6550d",
    "feeddefdbe85fd8d3cd94701",
    "feeddefdbe85fd8d3ce6550da63603",
    "feeddefdd0a2fdae6bfd8d3ce6550da63603",
    "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
    "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
    "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
  ).map(colors_default);
  var Oranges_default = ramp_default(scheme27);

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
  function cividis_default(t5) {
    t5 = Math.max(0, Math.min(1, t5));
    return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t5 * (35.34 - t5 * (2381.73 - t5 * (6402.7 - t5 * (7024.72 - t5 * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t5 * (170.73 + t5 * (52.82 - t5 * (131.46 - t5 * (176.58 - t5 * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t5 * (442.36 - t5 * (2482.43 - t5 * (6167.24 - t5 * (6614.94 - t5 * 2475.67))))))) + ")";
  }

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
  var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
  var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
  var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
  var c6 = cubehelix();
  function rainbow_default(t5) {
    if (t5 < 0 || t5 > 1) t5 -= Math.floor(t5);
    var ts = Math.abs(t5 - 0.5);
    c6.h = 360 * t5 - 100;
    c6.s = 1.5 - 1.5 * ts;
    c6.l = 0.8 - 0.9 * ts;
    return c6 + "";
  }

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
  var c7 = rgb();
  var pi_1_3 = Math.PI / 3;
  var pi_2_3 = Math.PI * 2 / 3;
  function sinebow_default(t5) {
    var x3;
    t5 = (0.5 - t5) * Math.PI;
    c7.r = 255 * (x3 = Math.sin(t5)) * x3;
    c7.g = 255 * (x3 = Math.sin(t5 + pi_1_3)) * x3;
    c7.b = 255 * (x3 = Math.sin(t5 + pi_2_3)) * x3;
    return c7 + "";
  }

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
  function turbo_default(t5) {
    t5 = Math.max(0, Math.min(1, t5));
    return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t5 * (1172.33 - t5 * (10793.56 - t5 * (33300.12 - t5 * (38394.49 - t5 * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t5 * (557.33 + t5 * (1225.33 - t5 * (3574.96 - t5 * (1073.77 + t5 * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t5 * (3211.1 - t5 * (15327.97 - t5 * (27814 - t5 * (22569.18 - t5 * 6838.66))))))) + ")";
  }

  // ../../../../../node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
  function ramp(range3) {
    var n9 = range3.length;
    return function(t5) {
      return range3[Math.max(0, Math.min(n9 - 1, Math.floor(t5 * n9)))];
    };
  }
  var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
  var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
  var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
  var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

  // ../../../../../node_modules/d3-shape/src/constant.js
  function constant_default5(x3) {
    return function constant2() {
      return x3;
    };
  }

  // ../../../../../node_modules/d3-shape/src/math.js
  var cos2 = Math.cos;
  var min3 = Math.min;
  var sin2 = Math.sin;
  var sqrt3 = Math.sqrt;
  var epsilon6 = 1e-12;
  var pi3 = Math.PI;
  var halfPi2 = pi3 / 2;
  var tau4 = 2 * pi3;

  // ../../../../../node_modules/d3-shape/src/path.js
  function withPath(shape2) {
    let digits = 3;
    shape2.digits = function(_2) {
      if (!arguments.length) return digits;
      if (_2 == null) {
        digits = null;
      } else {
        const d3 = Math.floor(_2);
        if (!(d3 >= 0)) throw new RangeError(`invalid digits: ${_2}`);
        digits = d3;
      }
      return shape2;
    };
    return () => new Path(digits);
  }

  // ../../../../../node_modules/d3-shape/src/array.js
  var slice2 = Array.prototype.slice;
  function array_default(x3) {
    return typeof x3 === "object" && "length" in x3 ? x3 : Array.from(x3);
  }

  // ../../../../../node_modules/d3-shape/src/curve/linear.js
  function Linear(context) {
    this._context = context;
  }
  Linear.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
          break;
        case 1:
          this._point = 2;
        // falls through
        default:
          this._context.lineTo(x3, y3);
          break;
      }
    }
  };
  function linear_default(context) {
    return new Linear(context);
  }

  // ../../../../../node_modules/d3-shape/src/point.js
  function x2(p11) {
    return p11[0];
  }
  function y2(p11) {
    return p11[1];
  }

  // ../../../../../node_modules/d3-shape/src/line.js
  function line_default2(x3, y3) {
    var defined2 = constant_default5(true), context = null, curve = linear_default, output = null, path2 = withPath(line2);
    x3 = typeof x3 === "function" ? x3 : x3 === void 0 ? x2 : constant_default5(x3);
    y3 = typeof y3 === "function" ? y3 : y3 === void 0 ? y2 : constant_default5(y3);
    function line2(data) {
      var i5, n9 = (data = array_default(data)).length, d3, defined0 = false, buffer2;
      if (context == null) output = curve(buffer2 = path2());
      for (i5 = 0; i5 <= n9; ++i5) {
        if (!(i5 < n9 && defined2(d3 = data[i5], i5, data)) === defined0) {
          if (defined0 = !defined0) output.lineStart();
          else output.lineEnd();
        }
        if (defined0) output.point(+x3(d3, i5, data), +y3(d3, i5, data));
      }
      if (buffer2) return output = null, buffer2 + "" || null;
    }
    line2.x = function(_2) {
      return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default5(+_2), line2) : x3;
    };
    line2.y = function(_2) {
      return arguments.length ? (y3 = typeof _2 === "function" ? _2 : constant_default5(+_2), line2) : y3;
    };
    line2.defined = function(_2) {
      return arguments.length ? (defined2 = typeof _2 === "function" ? _2 : constant_default5(!!_2), line2) : defined2;
    };
    line2.curve = function(_2) {
      return arguments.length ? (curve = _2, context != null && (output = curve(context)), line2) : curve;
    };
    line2.context = function(_2) {
      return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line2) : context;
    };
    return line2;
  }

  // ../../../../../node_modules/d3-shape/src/area.js
  function area_default3(x06, y06, y12) {
    var x12 = null, defined2 = constant_default5(true), context = null, curve = linear_default, output = null, path2 = withPath(area2);
    x06 = typeof x06 === "function" ? x06 : x06 === void 0 ? x2 : constant_default5(+x06);
    y06 = typeof y06 === "function" ? y06 : y06 === void 0 ? constant_default5(0) : constant_default5(+y06);
    y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y2 : constant_default5(+y12);
    function area2(data) {
      var i5, j2, k3, n9 = (data = array_default(data)).length, d3, defined0 = false, buffer2, x0z = new Array(n9), y0z = new Array(n9);
      if (context == null) output = curve(buffer2 = path2());
      for (i5 = 0; i5 <= n9; ++i5) {
        if (!(i5 < n9 && defined2(d3 = data[i5], i5, data)) === defined0) {
          if (defined0 = !defined0) {
            j2 = i5;
            output.areaStart();
            output.lineStart();
          } else {
            output.lineEnd();
            output.lineStart();
            for (k3 = i5 - 1; k3 >= j2; --k3) {
              output.point(x0z[k3], y0z[k3]);
            }
            output.lineEnd();
            output.areaEnd();
          }
        }
        if (defined0) {
          x0z[i5] = +x06(d3, i5, data), y0z[i5] = +y06(d3, i5, data);
          output.point(x12 ? +x12(d3, i5, data) : x0z[i5], y12 ? +y12(d3, i5, data) : y0z[i5]);
        }
      }
      if (buffer2) return output = null, buffer2 + "" || null;
    }
    function arealine() {
      return line_default2().defined(defined2).curve(curve).context(context);
    }
    area2.x = function(_2) {
      return arguments.length ? (x06 = typeof _2 === "function" ? _2 : constant_default5(+_2), x12 = null, area2) : x06;
    };
    area2.x0 = function(_2) {
      return arguments.length ? (x06 = typeof _2 === "function" ? _2 : constant_default5(+_2), area2) : x06;
    };
    area2.x1 = function(_2) {
      return arguments.length ? (x12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default5(+_2), area2) : x12;
    };
    area2.y = function(_2) {
      return arguments.length ? (y06 = typeof _2 === "function" ? _2 : constant_default5(+_2), y12 = null, area2) : y06;
    };
    area2.y0 = function(_2) {
      return arguments.length ? (y06 = typeof _2 === "function" ? _2 : constant_default5(+_2), area2) : y06;
    };
    area2.y1 = function(_2) {
      return arguments.length ? (y12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default5(+_2), area2) : y12;
    };
    area2.lineX0 = area2.lineY0 = function() {
      return arealine().x(x06).y(y06);
    };
    area2.lineY1 = function() {
      return arealine().x(x06).y(y12);
    };
    area2.lineX1 = function() {
      return arealine().x(x12).y(y06);
    };
    area2.defined = function(_2) {
      return arguments.length ? (defined2 = typeof _2 === "function" ? _2 : constant_default5(!!_2), area2) : defined2;
    };
    area2.curve = function(_2) {
      return arguments.length ? (curve = _2, context != null && (output = curve(context)), area2) : curve;
    };
    area2.context = function(_2) {
      return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), area2) : context;
    };
    return area2;
  }

  // ../../../../../node_modules/d3-shape/src/curve/bump.js
  var Bump = class {
    constructor(context, x3) {
      this._context = context;
      this._x = x3;
    }
    areaStart() {
      this._line = 0;
    }
    areaEnd() {
      this._line = NaN;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    }
    point(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0: {
          this._point = 1;
          if (this._line) this._context.lineTo(x3, y3);
          else this._context.moveTo(x3, y3);
          break;
        }
        case 1:
          this._point = 2;
        // falls through
        default: {
          if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x3) / 2, this._y0, this._x0, y3, x3, y3);
          else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y3) / 2, x3, this._y0, x3, y3);
          break;
        }
      }
      this._x0 = x3, this._y0 = y3;
    }
  };
  function bumpX(context) {
    return new Bump(context, true);
  }
  function bumpY(context) {
    return new Bump(context, false);
  }

  // ../../../../../node_modules/d3-shape/src/symbol/asterisk.js
  var sqrt32 = sqrt3(3);
  var asterisk_default = {
    draw(context, size) {
      const r6 = sqrt3(size + min3(size / 28, 0.75)) * 0.59436;
      const t5 = r6 / 2;
      const u7 = t5 * sqrt32;
      context.moveTo(0, r6);
      context.lineTo(0, -r6);
      context.moveTo(-u7, -t5);
      context.lineTo(u7, t5);
      context.moveTo(-u7, t5);
      context.lineTo(u7, -t5);
    }
  };

  // ../../../../../node_modules/d3-shape/src/symbol/circle.js
  var circle_default2 = {
    draw(context, size) {
      const r6 = sqrt3(size / pi3);
      context.moveTo(r6, 0);
      context.arc(0, 0, r6, 0, tau4);
    }
  };

  // ../../../../../node_modules/d3-shape/src/symbol/cross.js
  var cross_default = {
    draw(context, size) {
      const r6 = sqrt3(size / 5) / 2;
      context.moveTo(-3 * r6, -r6);
      context.lineTo(-r6, -r6);
      context.lineTo(-r6, -3 * r6);
      context.lineTo(r6, -3 * r6);
      context.lineTo(r6, -r6);
      context.lineTo(3 * r6, -r6);
      context.lineTo(3 * r6, r6);
      context.lineTo(r6, r6);
      context.lineTo(r6, 3 * r6);
      context.lineTo(-r6, 3 * r6);
      context.lineTo(-r6, r6);
      context.lineTo(-3 * r6, r6);
      context.closePath();
    }
  };

  // ../../../../../node_modules/d3-shape/src/symbol/diamond.js
  var tan30 = sqrt3(1 / 3);
  var tan30_2 = tan30 * 2;
  var diamond_default = {
    draw(context, size) {
      const y3 = sqrt3(size / tan30_2);
      const x3 = y3 * tan30;
      context.moveTo(0, -y3);
      context.lineTo(x3, 0);
      context.lineTo(0, y3);
      context.lineTo(-x3, 0);
      context.closePath();
    }
  };

  // ../../../../../node_modules/d3-shape/src/symbol/diamond2.js
  var diamond2_default = {
    draw(context, size) {
      const r6 = sqrt3(size) * 0.62625;
      context.moveTo(0, -r6);
      context.lineTo(r6, 0);
      context.lineTo(0, r6);
      context.lineTo(-r6, 0);
      context.closePath();
    }
  };

  // ../../../../../node_modules/d3-shape/src/symbol/plus.js
  var plus_default = {
    draw(context, size) {
      const r6 = sqrt3(size - min3(size / 7, 2)) * 0.87559;
      context.moveTo(-r6, 0);
      context.lineTo(r6, 0);
      context.moveTo(0, r6);
      context.lineTo(0, -r6);
    }
  };

  // ../../../../../node_modules/d3-shape/src/symbol/square.js
  var square_default = {
    draw(context, size) {
      const w2 = sqrt3(size);
      const x3 = -w2 / 2;
      context.rect(x3, x3, w2, w2);
    }
  };

  // ../../../../../node_modules/d3-shape/src/symbol/square2.js
  var square2_default = {
    draw(context, size) {
      const r6 = sqrt3(size) * 0.4431;
      context.moveTo(r6, r6);
      context.lineTo(r6, -r6);
      context.lineTo(-r6, -r6);
      context.lineTo(-r6, r6);
      context.closePath();
    }
  };

  // ../../../../../node_modules/d3-shape/src/symbol/star.js
  var ka = 0.8908130915292852;
  var kr = sin2(pi3 / 10) / sin2(7 * pi3 / 10);
  var kx = sin2(tau4 / 10) * kr;
  var ky = -cos2(tau4 / 10) * kr;
  var star_default = {
    draw(context, size) {
      const r6 = sqrt3(size * ka);
      const x3 = kx * r6;
      const y3 = ky * r6;
      context.moveTo(0, -r6);
      context.lineTo(x3, y3);
      for (let i5 = 1; i5 < 5; ++i5) {
        const a5 = tau4 * i5 / 5;
        const c9 = cos2(a5);
        const s8 = sin2(a5);
        context.lineTo(s8 * r6, -c9 * r6);
        context.lineTo(c9 * x3 - s8 * y3, s8 * x3 + c9 * y3);
      }
      context.closePath();
    }
  };

  // ../../../../../node_modules/d3-shape/src/symbol/triangle.js
  var sqrt33 = sqrt3(3);
  var triangle_default = {
    draw(context, size) {
      const y3 = -sqrt3(size / (sqrt33 * 3));
      context.moveTo(0, y3 * 2);
      context.lineTo(-sqrt33 * y3, -y3);
      context.lineTo(sqrt33 * y3, -y3);
      context.closePath();
    }
  };

  // ../../../../../node_modules/d3-shape/src/symbol/triangle2.js
  var sqrt34 = sqrt3(3);
  var triangle2_default = {
    draw(context, size) {
      const s8 = sqrt3(size) * 0.6824;
      const t5 = s8 / 2;
      const u7 = s8 * sqrt34 / 2;
      context.moveTo(0, -s8);
      context.lineTo(u7, t5);
      context.lineTo(-u7, t5);
      context.closePath();
    }
  };

  // ../../../../../node_modules/d3-shape/src/symbol/wye.js
  var c8 = -0.5;
  var s7 = sqrt3(3) / 2;
  var k2 = 1 / sqrt3(12);
  var a4 = (k2 / 2 + 1) * 3;
  var wye_default = {
    draw(context, size) {
      const r6 = sqrt3(size / a4);
      const x06 = r6 / 2, y06 = r6 * k2;
      const x12 = x06, y12 = r6 * k2 + r6;
      const x22 = -x12, y22 = y12;
      context.moveTo(x06, y06);
      context.lineTo(x12, y12);
      context.lineTo(x22, y22);
      context.lineTo(c8 * x06 - s7 * y06, s7 * x06 + c8 * y06);
      context.lineTo(c8 * x12 - s7 * y12, s7 * x12 + c8 * y12);
      context.lineTo(c8 * x22 - s7 * y22, s7 * x22 + c8 * y22);
      context.lineTo(c8 * x06 + s7 * y06, c8 * y06 - s7 * x06);
      context.lineTo(c8 * x12 + s7 * y12, c8 * y12 - s7 * x12);
      context.lineTo(c8 * x22 + s7 * y22, c8 * y22 - s7 * x22);
      context.closePath();
    }
  };

  // ../../../../../node_modules/d3-shape/src/symbol/times.js
  var times_default = {
    draw(context, size) {
      const r6 = sqrt3(size - min3(size / 6, 1.7)) * 0.6189;
      context.moveTo(-r6, -r6);
      context.lineTo(r6, r6);
      context.moveTo(-r6, r6);
      context.lineTo(r6, -r6);
    }
  };

  // ../../../../../node_modules/d3-shape/src/symbol.js
  var symbolsFill = [
    circle_default2,
    cross_default,
    diamond_default,
    square_default,
    star_default,
    triangle_default,
    wye_default
  ];
  var symbolsStroke = [
    circle_default2,
    plus_default,
    times_default,
    triangle2_default,
    asterisk_default,
    square2_default,
    diamond2_default
  ];

  // ../../../../../node_modules/d3-shape/src/noop.js
  function noop_default2() {
  }

  // ../../../../../node_modules/d3-shape/src/curve/basis.js
  function point2(that, x3, y3) {
    that._context.bezierCurveTo(
      (2 * that._x0 + that._x1) / 3,
      (2 * that._y0 + that._y1) / 3,
      (that._x0 + 2 * that._x1) / 3,
      (that._y0 + 2 * that._y1) / 3,
      (that._x0 + 4 * that._x1 + x3) / 6,
      (that._y0 + 4 * that._y1 + y3) / 6
    );
  }
  function Basis(context) {
    this._context = context;
  }
  Basis.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 3:
          point2(this, this._x1, this._y1);
        // falls through
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
        // falls through
        default:
          point2(this, x3, y3);
          break;
      }
      this._x0 = this._x1, this._x1 = x3;
      this._y0 = this._y1, this._y1 = y3;
    }
  };
  function basis_default2(context) {
    return new Basis(context);
  }

  // ../../../../../node_modules/d3-shape/src/curve/basisClosed.js
  function BasisClosed(context) {
    this._context = context;
  }
  BasisClosed.prototype = {
    areaStart: noop_default2,
    areaEnd: noop_default2,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x2, this._y2);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x2, this._y2);
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          break;
        }
      }
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x2 = x3, this._y2 = y3;
          break;
        case 1:
          this._point = 2;
          this._x3 = x3, this._y3 = y3;
          break;
        case 2:
          this._point = 3;
          this._x4 = x3, this._y4 = y3;
          this._context.moveTo((this._x0 + 4 * this._x1 + x3) / 6, (this._y0 + 4 * this._y1 + y3) / 6);
          break;
        default:
          point2(this, x3, y3);
          break;
      }
      this._x0 = this._x1, this._x1 = x3;
      this._y0 = this._y1, this._y1 = y3;
    }
  };
  function basisClosed_default2(context) {
    return new BasisClosed(context);
  }

  // ../../../../../node_modules/d3-shape/src/curve/basisOpen.js
  function BasisOpen(context) {
    this._context = context;
  }
  BasisOpen.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          var x06 = (this._x0 + 4 * this._x1 + x3) / 6, y06 = (this._y0 + 4 * this._y1 + y3) / 6;
          this._line ? this._context.lineTo(x06, y06) : this._context.moveTo(x06, y06);
          break;
        case 3:
          this._point = 4;
        // falls through
        default:
          point2(this, x3, y3);
          break;
      }
      this._x0 = this._x1, this._x1 = x3;
      this._y0 = this._y1, this._y1 = y3;
    }
  };
  function basisOpen_default(context) {
    return new BasisOpen(context);
  }

  // ../../../../../node_modules/d3-shape/src/curve/bundle.js
  function Bundle(context, beta) {
    this._basis = new Basis(context);
    this._beta = beta;
  }
  Bundle.prototype = {
    lineStart: function() {
      this._x = [];
      this._y = [];
      this._basis.lineStart();
    },
    lineEnd: function() {
      var x3 = this._x, y3 = this._y, j2 = x3.length - 1;
      if (j2 > 0) {
        var x06 = x3[0], y06 = y3[0], dx = x3[j2] - x06, dy = y3[j2] - y06, i5 = -1, t5;
        while (++i5 <= j2) {
          t5 = i5 / j2;
          this._basis.point(
            this._beta * x3[i5] + (1 - this._beta) * (x06 + t5 * dx),
            this._beta * y3[i5] + (1 - this._beta) * (y06 + t5 * dy)
          );
        }
      }
      this._x = this._y = null;
      this._basis.lineEnd();
    },
    point: function(x3, y3) {
      this._x.push(+x3);
      this._y.push(+y3);
    }
  };
  var bundle_default = function custom(beta) {
    function bundle(context) {
      return beta === 1 ? new Basis(context) : new Bundle(context, beta);
    }
    bundle.beta = function(beta2) {
      return custom(+beta2);
    };
    return bundle;
  }(0.85);

  // ../../../../../node_modules/d3-shape/src/curve/cardinal.js
  function point3(that, x3, y3) {
    that._context.bezierCurveTo(
      that._x1 + that._k * (that._x2 - that._x0),
      that._y1 + that._k * (that._y2 - that._y0),
      that._x2 + that._k * (that._x1 - x3),
      that._y2 + that._k * (that._y1 - y3),
      that._x2,
      that._y2
    );
  }
  function Cardinal(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  Cardinal.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          point3(this, this._x1, this._y1);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
          break;
        case 1:
          this._point = 2;
          this._x1 = x3, this._y1 = y3;
          break;
        case 2:
          this._point = 3;
        // falls through
        default:
          point3(this, x3, y3);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
    }
  };
  var cardinal_default = function custom2(tension) {
    function cardinal(context) {
      return new Cardinal(context, tension);
    }
    cardinal.tension = function(tension2) {
      return custom2(+tension2);
    };
    return cardinal;
  }(0);

  // ../../../../../node_modules/d3-shape/src/curve/cardinalClosed.js
  function CardinalClosed(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  CardinalClosed.prototype = {
    areaStart: noop_default2,
    areaEnd: noop_default2,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x3 = x3, this._y3 = y3;
          break;
        case 1:
          this._point = 2;
          this._context.moveTo(this._x4 = x3, this._y4 = y3);
          break;
        case 2:
          this._point = 3;
          this._x5 = x3, this._y5 = y3;
          break;
        default:
          point3(this, x3, y3);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
    }
  };
  var cardinalClosed_default = function custom3(tension) {
    function cardinal(context) {
      return new CardinalClosed(context, tension);
    }
    cardinal.tension = function(tension2) {
      return custom3(+tension2);
    };
    return cardinal;
  }(0);

  // ../../../../../node_modules/d3-shape/src/curve/cardinalOpen.js
  function CardinalOpen(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  CardinalOpen.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;
        case 3:
          this._point = 4;
        // falls through
        default:
          point3(this, x3, y3);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
    }
  };
  var cardinalOpen_default = function custom4(tension) {
    function cardinal(context) {
      return new CardinalOpen(context, tension);
    }
    cardinal.tension = function(tension2) {
      return custom4(+tension2);
    };
    return cardinal;
  }(0);

  // ../../../../../node_modules/d3-shape/src/curve/catmullRom.js
  function point4(that, x3, y3) {
    var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
    if (that._l01_a > epsilon6) {
      var a5 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n9 = 3 * that._l01_a * (that._l01_a + that._l12_a);
      x12 = (x12 * a5 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n9;
      y12 = (y12 * a5 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n9;
    }
    if (that._l23_a > epsilon6) {
      var b2 = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m3 = 3 * that._l23_a * (that._l23_a + that._l12_a);
      x22 = (x22 * b2 + that._x1 * that._l23_2a - x3 * that._l12_2a) / m3;
      y22 = (y22 * b2 + that._y1 * that._l23_2a - y3 * that._l12_2a) / m3;
    }
    that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
  }
  function CatmullRom(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }
  CatmullRom.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          this.point(this._x2, this._y2);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      if (this._point) {
        var x23 = this._x2 - x3, y23 = this._y2 - y3;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
        // falls through
        default:
          point4(this, x3, y3);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
    }
  };
  var catmullRom_default = function custom5(alpha) {
    function catmullRom(context) {
      return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
    }
    catmullRom.alpha = function(alpha2) {
      return custom5(+alpha2);
    };
    return catmullRom;
  }(0.5);

  // ../../../../../node_modules/d3-shape/src/curve/catmullRomClosed.js
  function CatmullRomClosed(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }
  CatmullRomClosed.prototype = {
    areaStart: noop_default2,
    areaEnd: noop_default2,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      if (this._point) {
        var x23 = this._x2 - x3, y23 = this._y2 - y3;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x3 = x3, this._y3 = y3;
          break;
        case 1:
          this._point = 2;
          this._context.moveTo(this._x4 = x3, this._y4 = y3);
          break;
        case 2:
          this._point = 3;
          this._x5 = x3, this._y5 = y3;
          break;
        default:
          point4(this, x3, y3);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
    }
  };
  var catmullRomClosed_default = function custom6(alpha) {
    function catmullRom(context) {
      return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
    }
    catmullRom.alpha = function(alpha2) {
      return custom6(+alpha2);
    };
    return catmullRom;
  }(0.5);

  // ../../../../../node_modules/d3-shape/src/curve/catmullRomOpen.js
  function CatmullRomOpen(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }
  CatmullRomOpen.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      if (this._point) {
        var x23 = this._x2 - x3, y23 = this._y2 - y3;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
          break;
        case 3:
          this._point = 4;
        // falls through
        default:
          point4(this, x3, y3);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
    }
  };
  var catmullRomOpen_default = function custom7(alpha) {
    function catmullRom(context) {
      return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
    }
    catmullRom.alpha = function(alpha2) {
      return custom7(+alpha2);
    };
    return catmullRom;
  }(0.5);

  // ../../../../../node_modules/d3-shape/src/curve/linearClosed.js
  function LinearClosed(context) {
    this._context = context;
  }
  LinearClosed.prototype = {
    areaStart: noop_default2,
    areaEnd: noop_default2,
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._point) this._context.closePath();
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      if (this._point) this._context.lineTo(x3, y3);
      else this._point = 1, this._context.moveTo(x3, y3);
    }
  };
  function linearClosed_default(context) {
    return new LinearClosed(context);
  }

  // ../../../../../node_modules/d3-shape/src/curve/monotone.js
  function sign3(x3) {
    return x3 < 0 ? -1 : 1;
  }
  function slope3(that, x22, y22) {
    var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p11 = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign3(s0) + sign3(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p11)) || 0;
  }
  function slope2(that, t5) {
    var h5 = that._x1 - that._x0;
    return h5 ? (3 * (that._y1 - that._y0) / h5 - t5) / 2 : t5;
  }
  function point5(that, t03, t13) {
    var x06 = that._x0, y06 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x06) / 3;
    that._context.bezierCurveTo(x06 + dx, y06 + dx * t03, x12 - dx, y12 - dx * t13, x12, y12);
  }
  function MonotoneX(context) {
    this._context = context;
  }
  MonotoneX.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
        case 3:
          point5(this, this._t0, slope2(this, this._t0));
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      var t13 = NaN;
      x3 = +x3, y3 = +y3;
      if (x3 === this._x1 && y3 === this._y1) return;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          point5(this, slope2(this, t13 = slope3(this, x3, y3)), t13);
          break;
        default:
          point5(this, this._t0, t13 = slope3(this, x3, y3));
          break;
      }
      this._x0 = this._x1, this._x1 = x3;
      this._y0 = this._y1, this._y1 = y3;
      this._t0 = t13;
    }
  };
  function MonotoneY(context) {
    this._context = new ReflectContext(context);
  }
  (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x3, y3) {
    MonotoneX.prototype.point.call(this, y3, x3);
  };
  function ReflectContext(context) {
    this._context = context;
  }
  ReflectContext.prototype = {
    moveTo: function(x3, y3) {
      this._context.moveTo(y3, x3);
    },
    closePath: function() {
      this._context.closePath();
    },
    lineTo: function(x3, y3) {
      this._context.lineTo(y3, x3);
    },
    bezierCurveTo: function(x12, y12, x22, y22, x3, y3) {
      this._context.bezierCurveTo(y12, x12, y22, x22, y3, x3);
    }
  };
  function monotoneX(context) {
    return new MonotoneX(context);
  }
  function monotoneY(context) {
    return new MonotoneY(context);
  }

  // ../../../../../node_modules/d3-shape/src/curve/natural.js
  function Natural(context) {
    this._context = context;
  }
  Natural.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = [];
      this._y = [];
    },
    lineEnd: function() {
      var x3 = this._x, y3 = this._y, n9 = x3.length;
      if (n9) {
        this._line ? this._context.lineTo(x3[0], y3[0]) : this._context.moveTo(x3[0], y3[0]);
        if (n9 === 2) {
          this._context.lineTo(x3[1], y3[1]);
        } else {
          var px = controlPoints(x3), py = controlPoints(y3);
          for (var i0 = 0, i12 = 1; i12 < n9; ++i0, ++i12) {
            this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x3[i12], y3[i12]);
          }
        }
      }
      if (this._line || this._line !== 0 && n9 === 1) this._context.closePath();
      this._line = 1 - this._line;
      this._x = this._y = null;
    },
    point: function(x3, y3) {
      this._x.push(+x3);
      this._y.push(+y3);
    }
  };
  function controlPoints(x3) {
    var i5, n9 = x3.length - 1, m3, a5 = new Array(n9), b2 = new Array(n9), r6 = new Array(n9);
    a5[0] = 0, b2[0] = 2, r6[0] = x3[0] + 2 * x3[1];
    for (i5 = 1; i5 < n9 - 1; ++i5) a5[i5] = 1, b2[i5] = 4, r6[i5] = 4 * x3[i5] + 2 * x3[i5 + 1];
    a5[n9 - 1] = 2, b2[n9 - 1] = 7, r6[n9 - 1] = 8 * x3[n9 - 1] + x3[n9];
    for (i5 = 1; i5 < n9; ++i5) m3 = a5[i5] / b2[i5 - 1], b2[i5] -= m3, r6[i5] -= m3 * r6[i5 - 1];
    a5[n9 - 1] = r6[n9 - 1] / b2[n9 - 1];
    for (i5 = n9 - 2; i5 >= 0; --i5) a5[i5] = (r6[i5] - a5[i5 + 1]) / b2[i5];
    b2[n9 - 1] = (x3[n9] + a5[n9 - 1]) / 2;
    for (i5 = 0; i5 < n9 - 1; ++i5) b2[i5] = 2 * x3[i5 + 1] - a5[i5 + 1];
    return [a5, b2];
  }
  function natural_default(context) {
    return new Natural(context);
  }

  // ../../../../../node_modules/d3-shape/src/curve/step.js
  function Step(context, t5) {
    this._context = context;
    this._t = t5;
  }
  Step.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = this._y = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
          break;
        case 1:
          this._point = 2;
        // falls through
        default: {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y3);
            this._context.lineTo(x3, y3);
          } else {
            var x12 = this._x * (1 - this._t) + x3 * this._t;
            this._context.lineTo(x12, this._y);
            this._context.lineTo(x12, y3);
          }
          break;
        }
      }
      this._x = x3, this._y = y3;
    }
  };
  function step_default(context) {
    return new Step(context, 0.5);
  }
  function stepBefore(context) {
    return new Step(context, 0);
  }
  function stepAfter(context) {
    return new Step(context, 1);
  }

  // ../../../../../node_modules/d3-zoom/src/transform.js
  function Transform(k3, x3, y3) {
    this.k = k3;
    this.x = x3;
    this.y = y3;
  }
  Transform.prototype = {
    constructor: Transform,
    scale: function(k3) {
      return k3 === 1 ? this : new Transform(this.k * k3, this.x, this.y);
    },
    translate: function(x3, y3) {
      return x3 === 0 & y3 === 0 ? this : new Transform(this.k, this.x + this.k * x3, this.y + this.k * y3);
    },
    apply: function(point6) {
      return [point6[0] * this.k + this.x, point6[1] * this.k + this.y];
    },
    applyX: function(x3) {
      return x3 * this.k + this.x;
    },
    applyY: function(y3) {
      return y3 * this.k + this.y;
    },
    invert: function(location) {
      return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
    },
    invertX: function(x3) {
      return (x3 - this.x) / this.k;
    },
    invertY: function(y3) {
      return (y3 - this.y) / this.k;
    },
    rescaleX: function(x3) {
      return x3.copy().domain(x3.range().map(this.invertX, this).map(x3.invert, x3));
    },
    rescaleY: function(y3) {
      return y3.copy().domain(y3.range().map(this.invertY, this).map(y3.invert, y3));
    },
    toString: function() {
      return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
    }
  };
  var identity5 = new Transform(1, 0, 0);
  transform2.prototype = Transform.prototype;
  function transform2(node) {
    while (!node.__zoom) if (!(node = node.parentNode)) return identity5;
    return node.__zoom;
  }

  // ../../../../../node_modules/@observablehq/plot/src/defined.js
  function defined(x3) {
    return x3 != null && !Number.isNaN(x3);
  }
  function ascendingDefined2(a5, b2) {
    return +defined(b2) - +defined(a5) || ascending(a5, b2);
  }
  function descendingDefined(a5, b2) {
    return +defined(b2) - +defined(a5) || descending(a5, b2);
  }
  function nonempty(x3) {
    return x3 != null && `${x3}` !== "";
  }
  function finite2(x3) {
    return isFinite(x3) ? x3 : NaN;
  }
  function positive(x3) {
    return x3 > 0 && isFinite(x3) ? x3 : NaN;
  }
  function negative(x3) {
    return x3 < 0 && isFinite(x3) ? x3 : NaN;
  }

  // ../../../../../node_modules/isoformat/src/format.js
  function format2(date2, fallback) {
    if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
    if (isNaN(date2)) return typeof fallback === "function" ? fallback(date2) : fallback;
    const hours = date2.getUTCHours();
    const minutes = date2.getUTCMinutes();
    const seconds2 = date2.getUTCSeconds();
    const milliseconds2 = date2.getUTCMilliseconds();
    return `${formatYear2(date2.getUTCFullYear(), 4)}-${pad2(date2.getUTCMonth() + 1, 2)}-${pad2(date2.getUTCDate(), 2)}${hours || minutes || seconds2 || milliseconds2 ? `T${pad2(hours, 2)}:${pad2(minutes, 2)}${seconds2 || milliseconds2 ? `:${pad2(seconds2, 2)}${milliseconds2 ? `.${pad2(milliseconds2, 3)}` : ``}` : ``}Z` : ``}`;
  }
  function formatYear2(year) {
    return year < 0 ? `-${pad2(-year, 6)}` : year > 9999 ? `+${pad2(year, 6)}` : pad2(year, 4);
  }
  function pad2(value, width) {
    return `${value}`.padStart(width, "0");
  }

  // ../../../../../node_modules/isoformat/src/parse.js
  var re2 = /^(?:[-+]\d{2})?\d{4}(?:-\d{2}(?:-\d{2})?)?(?:T\d{2}:\d{2}(?::\d{2}(?:\.\d{3})?)?(?:Z|[-+]\d{2}:?\d{2})?)?$/;
  function parse2(string2, fallback) {
    if (!re2.test(string2 += "")) return typeof fallback === "function" ? fallback(string2) : fallback;
    return new Date(string2);
  }

  // ../../../../../node_modules/@observablehq/plot/src/order.js
  function orderof(values2) {
    if (values2 == null) return;
    const first2 = values2[0];
    const last = values2[values2.length - 1];
    return descending(first2, last);
  }

  // ../../../../../node_modules/@observablehq/plot/src/time.js
  var durationSecond2 = 1e3;
  var durationMinute2 = durationSecond2 * 60;
  var durationHour2 = durationMinute2 * 60;
  var durationDay2 = durationHour2 * 24;
  var durationWeek2 = durationDay2 * 7;
  var durationMonth2 = durationDay2 * 30;
  var durationYear2 = durationDay2 * 365;
  var tickIntervals = [
    ["millisecond", 1],
    ["2 milliseconds", 2],
    ["5 milliseconds", 5],
    ["10 milliseconds", 10],
    ["20 milliseconds", 20],
    ["50 milliseconds", 50],
    ["100 milliseconds", 100],
    ["200 milliseconds", 200],
    ["500 milliseconds", 500],
    ["second", durationSecond2],
    ["5 seconds", 5 * durationSecond2],
    ["15 seconds", 15 * durationSecond2],
    ["30 seconds", 30 * durationSecond2],
    ["minute", durationMinute2],
    ["5 minutes", 5 * durationMinute2],
    ["15 minutes", 15 * durationMinute2],
    ["30 minutes", 30 * durationMinute2],
    ["hour", durationHour2],
    ["3 hours", 3 * durationHour2],
    ["6 hours", 6 * durationHour2],
    ["12 hours", 12 * durationHour2],
    ["day", durationDay2],
    ["2 days", 2 * durationDay2],
    ["week", durationWeek2],
    ["2 weeks", 2 * durationWeek2],
    // https://github.com/d3/d3-time/issues/46
    ["month", durationMonth2],
    ["3 months", 3 * durationMonth2],
    ["6 months", 6 * durationMonth2],
    // https://github.com/d3/d3-time/issues/46
    ["year", durationYear2],
    ["2 years", 2 * durationYear2],
    ["5 years", 5 * durationYear2],
    ["10 years", 10 * durationYear2],
    ["20 years", 20 * durationYear2],
    ["50 years", 50 * durationYear2],
    ["100 years", 100 * durationYear2]
    // TODO generalize to longer time scales
  ];
  var durations = /* @__PURE__ */ new Map([
    ["second", durationSecond2],
    ["minute", durationMinute2],
    ["hour", durationHour2],
    ["day", durationDay2],
    ["monday", durationWeek2],
    ["tuesday", durationWeek2],
    ["wednesday", durationWeek2],
    ["thursday", durationWeek2],
    ["friday", durationWeek2],
    ["saturday", durationWeek2],
    ["sunday", durationWeek2],
    ["week", durationWeek2],
    ["month", durationMonth2],
    ["year", durationYear2]
  ]);
  var timeIntervals = /* @__PURE__ */ new Map([
    ["second", second],
    ["minute", timeMinute],
    ["hour", timeHour],
    ["day", timeDay],
    // https://github.com/d3/d3-time/issues/62
    ["monday", timeMonday],
    ["tuesday", timeTuesday],
    ["wednesday", timeWednesday],
    ["thursday", timeThursday],
    ["friday", timeFriday],
    ["saturday", timeSaturday],
    ["sunday", timeSunday],
    ["week", timeSunday],
    ["month", timeMonth],
    ["year", timeYear]
  ]);
  var utcIntervals = /* @__PURE__ */ new Map([
    ["second", second],
    ["minute", utcMinute],
    ["hour", utcHour],
    ["day", unixDay],
    ["monday", utcMonday],
    ["tuesday", utcTuesday],
    ["wednesday", utcWednesday],
    ["thursday", utcThursday],
    ["friday", utcFriday],
    ["saturday", utcSaturday],
    ["sunday", utcSunday],
    ["week", utcSunday],
    ["month", utcMonth],
    ["year", utcYear]
  ]);
  var intervalDuration = Symbol("intervalDuration");
  var intervalType = Symbol("intervalType");
  for (const [name, interval2] of timeIntervals) {
    interval2[intervalDuration] = durations.get(name);
    interval2[intervalType] = "time";
  }
  for (const [name, interval2] of utcIntervals) {
    interval2[intervalDuration] = durations.get(name);
    interval2[intervalType] = "utc";
  }
  var utcFormatIntervals = [
    ["year", utcYear, "utc"],
    ["month", utcMonth, "utc"],
    ["day", unixDay, "utc", 6 * durationMonth2],
    ["hour", utcHour, "utc", 3 * durationDay2],
    ["minute", utcMinute, "utc", 6 * durationHour2],
    ["second", second, "utc", 30 * durationMinute2]
  ];
  var timeFormatIntervals = [
    ["year", timeYear, "time"],
    ["month", timeMonth, "time"],
    ["day", timeDay, "time", 6 * durationMonth2],
    ["hour", timeHour, "time", 3 * durationDay2],
    ["minute", timeMinute, "time", 6 * durationHour2],
    ["second", second, "time", 30 * durationMinute2]
  ];
  var formatIntervals = [
    utcFormatIntervals[0],
    timeFormatIntervals[0],
    utcFormatIntervals[1],
    timeFormatIntervals[1],
    utcFormatIntervals[2],
    timeFormatIntervals[2],
    // Below day, local time typically has an hourly offset from UTC and hence the
    // two are aligned and indistinguishable; therefore, we only consider UTC, and
    // we dont consider these if the domain only has a single value.
    ...utcFormatIntervals.slice(3)
  ];
  function parseTimeInterval(input) {
    let name = `${input}`.toLowerCase();
    if (name.endsWith("s")) name = name.slice(0, -1);
    let period = 1;
    const match = /^(?:(\d+)\s+)/.exec(name);
    if (match) {
      name = name.slice(match[0].length);
      period = +match[1];
    }
    switch (name) {
      case "quarter":
        name = "month";
        period *= 3;
        break;
      case "half":
        name = "month";
        period *= 6;
        break;
    }
    let interval2 = utcIntervals.get(name);
    if (!interval2) throw new Error(`unknown interval: ${input}`);
    if (period > 1 && !interval2.every) throw new Error(`non-periodic interval: ${name}`);
    return [name, period];
  }
  function timeInterval2(input) {
    return asInterval(parseTimeInterval(input), "time");
  }
  function utcInterval(input) {
    return asInterval(parseTimeInterval(input), "utc");
  }
  function asInterval([name, period], type2) {
    let interval2 = (type2 === "time" ? timeIntervals : utcIntervals).get(name);
    if (period > 1) {
      interval2 = interval2.every(period);
      interval2[intervalDuration] = durations.get(name) * period;
      interval2[intervalType] = type2;
    }
    return interval2;
  }
  function generalizeTimeInterval(interval2, n9) {
    if (!(n9 > 1)) return;
    const duration = interval2[intervalDuration];
    if (!tickIntervals.some(([, d3]) => d3 === duration)) return;
    if (duration % durationDay2 === 0 && durationDay2 < duration && duration < durationMonth2) return;
    const [i5] = tickIntervals[bisector(([, step3]) => Math.log(step3)).center(tickIntervals, Math.log(duration * n9))];
    return (interval2[intervalType] === "time" ? timeInterval2 : utcInterval)(i5);
  }
  function formatTimeInterval(name, type2, anchor) {
    const format3 = type2 === "time" ? timeFormat : utcFormat;
    if (anchor == null) {
      return format3(
        name === "year" ? "%Y" : name === "month" ? "%Y-%m" : name === "day" ? "%Y-%m-%d" : name === "hour" || name === "minute" ? "%Y-%m-%dT%H:%M" : name === "second" ? "%Y-%m-%dT%H:%M:%S" : "%Y-%m-%dT%H:%M:%S.%L"
      );
    }
    const template2 = getTimeTemplate(anchor);
    switch (name) {
      case "millisecond":
        return formatConditional(format3(".%L"), format3(":%M:%S"), template2);
      case "second":
        return formatConditional(format3(":%S"), format3("%-I:%M"), template2);
      case "minute":
        return formatConditional(format3("%-I:%M"), format3("%p"), template2);
      case "hour":
        return formatConditional(format3("%-I %p"), format3("%b %-d"), template2);
      case "day":
        return formatConditional(format3("%-d"), format3("%b"), template2);
      case "month":
        return formatConditional(format3("%b"), format3("%Y"), template2);
      case "year":
        return format3("%Y");
    }
    throw new Error("unable to format time ticks");
  }
  function getTimeTemplate(anchor) {
    return anchor === "left" || anchor === "right" ? (f12, f22) => `
${f12}
${f22}` : anchor === "top" ? (f12, f22) => `${f22}
${f12}` : (f12, f22) => `${f12}
${f22}`;
  }
  function getFormatIntervals(type2) {
    return type2 === "time" ? timeFormatIntervals : type2 === "utc" ? utcFormatIntervals : formatIntervals;
  }
  function inferTimeFormat(type2, dates, anchor) {
    const step3 = max(pairs(dates, (a5, b2) => Math.abs(b2 - a5)));
    if (step3 < 1e3) return formatTimeInterval("millisecond", "utc", anchor);
    for (const [name, interval2, intervalType2, maxStep] of getFormatIntervals(type2)) {
      if (step3 > maxStep) break;
      if (name === "hour" && !step3) break;
      if (dates.every((d3) => interval2.floor(d3) >= d3)) return formatTimeInterval(name, intervalType2, anchor);
    }
  }
  function formatConditional(format1, format22, template2) {
    return (x3, i5, X3) => {
      const f12 = format1(x3, i5);
      const f22 = format22(x3, i5);
      const j2 = i5 - orderof(X3);
      return i5 !== j2 && X3[j2] !== void 0 && f22 === format22(X3[j2], j2) ? f12 : template2(f12, f22);
    };
  }

  // ../../../../../node_modules/@observablehq/plot/src/options.js
  var TypedArray = Object.getPrototypeOf(Uint8Array);
  var objectToString = Object.prototype.toString;
  function isArray(value) {
    return value instanceof Array || value instanceof TypedArray;
  }
  function isNumberArray2(value) {
    return value instanceof TypedArray && !isBigIntArray(value);
  }
  function isNumberType(type2) {
    return type2?.prototype instanceof TypedArray && !isBigIntType(type2);
  }
  function isBigIntArray(value) {
    return value instanceof BigInt64Array || value instanceof BigUint64Array;
  }
  function isBigIntType(type2) {
    return type2 === BigInt64Array || type2 === BigUint64Array;
  }
  var reindex = Symbol("reindex");
  function valueof(data, value, type2) {
    const valueType = typeof value;
    return valueType === "string" ? isArrowTable(data) ? maybeTypedArrowify(data.getChild(value), type2) : maybeTypedMap(data, field(value), type2) : valueType === "function" ? maybeTypedMap(data, value, type2) : valueType === "number" || value instanceof Date || valueType === "boolean" ? map2(data, constant(value), type2) : typeof value?.transform === "function" ? maybeTypedArrayify(value.transform(data), type2) : maybeTake(maybeTypedArrayify(value, type2), data?.[reindex]);
  }
  function maybeTake(values2, index2) {
    return values2 != null && index2 ? take(values2, index2) : values2;
  }
  function maybeTypedMap(data, f7, type2) {
    return map2(data, isNumberType(type2) ? (d3, i5) => coerceNumber(f7(d3, i5)) : f7, type2);
  }
  function maybeTypedArrayify(data, type2) {
    return type2 === void 0 ? arrayify2(data) : isArrowVector(data) ? maybeTypedArrowify(data, type2) : data instanceof type2 ? data : type2.from(data, isNumberType(type2) && !isNumberArray2(data) ? coerceNumber : void 0);
  }
  function maybeTypedArrowify(vector2, type2) {
    return vector2 == null ? vector2 : (type2 === void 0 || type2 === Array) && isArrowDateType(vector2.type) ? coerceDates(vectorToArray(vector2)) : maybeTypedArrayify(vectorToArray(vector2), type2);
  }
  function vectorToArray(vector2) {
    return vector2.nullCount ? vector2.toJSON() : vector2.toArray();
  }
  var singleton = [null];
  var field = (name) => (d3) => {
    const v3 = d3[name];
    return v3 === void 0 && d3.type === "Feature" ? d3.properties?.[name] : v3;
  };
  var indexOf = { transform: range2 };
  var identity6 = { transform: (d3) => d3 };
  var one3 = () => 1;
  var yes = () => true;
  var string = (x3) => x3 == null ? x3 : `${x3}`;
  var number5 = (x3) => x3 == null ? x3 : +x3;
  var first = (x3) => x3 ? x3[0] : void 0;
  var second2 = (x3) => x3 ? x3[1] : void 0;
  var third = (x3) => x3 ? x3[2] : void 0;
  var constant = (x3) => () => x3;
  function percentile(reduce) {
    const p11 = +`${reduce}`.slice(1) / 100;
    return (I2, f7) => quantile(I2, p11, f7);
  }
  function coerceNumbers(values2) {
    return isNumberArray2(values2) ? values2 : map2(values2, coerceNumber, Float64Array);
  }
  function coerceNumber(x3) {
    return x3 == null ? NaN : Number(x3);
  }
  function coerceDates(values2) {
    return map2(values2, coerceDate);
  }
  function coerceDate(x3) {
    return x3 instanceof Date && !isNaN(x3) ? x3 : typeof x3 === "string" ? parse2(x3) : x3 == null || isNaN(x3 = Number(x3)) ? void 0 : new Date(x3);
  }
  function maybeColorChannel(value, defaultValue) {
    if (value === void 0) value = defaultValue;
    return value === null ? [void 0, "none"] : isColor(value) ? [void 0, value] : [value, void 0];
  }
  function maybeNumberChannel(value, defaultValue) {
    if (value === void 0) value = defaultValue;
    return value === null || typeof value === "number" ? [void 0, value] : [value, void 0];
  }
  function maybeKeyword(input, name, allowed) {
    if (input != null) return keyword(input, name, allowed);
  }
  function keyword(input, name, allowed) {
    const i5 = `${input}`.toLowerCase();
    if (!allowed.includes(i5)) throw new Error(`invalid ${name}: ${input}`);
    return i5;
  }
  function dataify(data) {
    return isArrowTable(data) ? data : arrayify2(data);
  }
  function arrayify2(values2) {
    if (values2 == null || isArray(values2)) return values2;
    if (isArrowVector(values2)) return maybeTypedArrowify(values2);
    if (isGeoJSON(values2)) {
      switch (values2.type) {
        case "FeatureCollection":
          return values2.features;
        case "GeometryCollection":
          return values2.geometries;
        default:
          return [values2];
      }
    }
    return Array.from(values2);
  }
  function isGeoJSON(x3) {
    switch (x3?.type) {
      case "FeatureCollection":
      case "GeometryCollection":
      case "Feature":
      case "LineString":
      case "MultiLineString":
      case "MultiPoint":
      case "MultiPolygon":
      case "Point":
      case "Polygon":
      case "Sphere":
        return true;
      default:
        return false;
    }
  }
  function map2(values2, f7, type2 = Array) {
    return values2 == null ? values2 : values2 instanceof type2 ? values2.map(f7) : type2.from(values2, f7);
  }
  function slice3(values2, type2 = Array) {
    return values2 instanceof type2 ? values2.slice() : type2.from(values2);
  }
  function hasX({ x: x3, x1: x12, x2: x22 }) {
    return x3 !== void 0 || x12 !== void 0 || x22 !== void 0;
  }
  function hasY({ y: y3, y1: y12, y2: y22 }) {
    return y3 !== void 0 || y12 !== void 0 || y22 !== void 0;
  }
  function hasXY(options) {
    return hasX(options) || hasY(options) || options.interval !== void 0;
  }
  function isObject(option) {
    return option?.toString === objectToString;
  }
  function isScaleOptions(option) {
    return isObject(option) && (option.type !== void 0 || option.domain !== void 0);
  }
  function isOptions(option) {
    return isObject(option) && typeof option.transform !== "function";
  }
  function isDomainSort(sort3) {
    return isOptions(sort3) && sort3.value === void 0 && sort3.channel === void 0;
  }
  function maybeZero(x3, x12, x22, x32 = identity6) {
    if (x12 === void 0 && x22 === void 0) {
      x12 = 0, x22 = x3 === void 0 ? x32 : x3;
    } else if (x12 === void 0) {
      x12 = x3 === void 0 ? 0 : x3;
    } else if (x22 === void 0) {
      x22 = x3 === void 0 ? 0 : x3;
    }
    return [x12, x22];
  }
  function maybeTuple(x3, y3) {
    return x3 === void 0 && y3 === void 0 ? [first, second2] : [x3, y3];
  }
  function maybeZ({ z: z2, fill, stroke } = {}) {
    if (z2 === void 0) [z2] = maybeColorChannel(fill);
    if (z2 === void 0) [z2] = maybeColorChannel(stroke);
    return z2;
  }
  function lengthof(data) {
    return isArray(data) ? data.length : data?.numRows;
  }
  function range2(data) {
    const n9 = lengthof(data);
    const r6 = new Uint32Array(n9);
    for (let i5 = 0; i5 < n9; ++i5) r6[i5] = i5;
    return r6;
  }
  function take(values2, index2) {
    return isArray(values2) ? map2(index2, (i5) => values2[i5], values2.constructor) : map2(index2, (i5) => values2.at(i5));
  }
  function taker(f7) {
    return f7.length === 1 ? (index2, values2) => f7(take(values2, index2)) : f7;
  }
  function subarray(I2, i5, j2) {
    return I2.subarray ? I2.subarray(i5, j2) : I2.slice(i5, j2);
  }
  function keyof2(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }
  function maybeInput(key, options) {
    if (options[key] !== void 0) return options[key];
    switch (key) {
      case "x1":
      case "x2":
        key = "x";
        break;
      case "y1":
      case "y2":
        key = "y";
        break;
    }
    return options[key];
  }
  function column(source) {
    let value;
    return [
      {
        transform: () => value,
        label: labelof(source)
      },
      (v3) => value = v3
    ];
  }
  function maybeColumn(source) {
    return source == null ? [source] : column(source);
  }
  function labelof(value, defaultValue) {
    return typeof value === "string" ? value : value && value.label !== void 0 ? value.label : defaultValue;
  }
  function mid(x12, x22) {
    return {
      transform(data) {
        const X13 = x12.transform(data);
        const X23 = x22.transform(data);
        return isTemporal(X13) || isTemporal(X23) ? map2(X13, (_2, i5) => new Date((+X13[i5] + +X23[i5]) / 2)) : map2(X13, (_2, i5) => (+X13[i5] + +X23[i5]) / 2, Float64Array);
      },
      label: x12.label
    };
  }
  function maybeApplyInterval(V2, scale3) {
    const t5 = maybeIntervalTransform(scale3?.interval, scale3?.type);
    return t5 ? map2(V2, t5) : V2;
  }
  function maybeIntervalTransform(interval2, type2) {
    const i5 = maybeInterval(interval2, type2);
    return i5 && ((v3) => defined(v3) ? i5.floor(v3) : v3);
  }
  function maybeInterval(interval2, type2) {
    if (interval2 == null) return;
    if (typeof interval2 === "number") return numberInterval(interval2);
    if (typeof interval2 === "string") return (type2 === "time" ? timeInterval2 : utcInterval)(interval2);
    if (typeof interval2.floor !== "function") throw new Error("invalid interval; missing floor method");
    if (typeof interval2.offset !== "function") throw new Error("invalid interval; missing offset method");
    return interval2;
  }
  function numberInterval(interval2) {
    interval2 = +interval2;
    if (0 < interval2 && interval2 < 1 && Number.isInteger(1 / interval2)) interval2 = -1 / interval2;
    const n9 = Math.abs(interval2);
    return interval2 < 0 ? {
      floor: (d3) => Math.floor(d3 * n9) / n9,
      offset: (d3, s8 = 1) => (d3 * n9 + Math.floor(s8)) / n9,
      range: (lo, hi) => range(Math.ceil(lo * n9), hi * n9).map((x3) => x3 / n9)
    } : {
      floor: (d3) => Math.floor(d3 / n9) * n9,
      offset: (d3, s8 = 1) => d3 + n9 * Math.floor(s8),
      range: (lo, hi) => range(Math.ceil(lo / n9), hi / n9).map((x3) => x3 * n9)
    };
  }
  function maybeRangeInterval(interval2, type2) {
    interval2 = maybeInterval(interval2, type2);
    if (interval2 && typeof interval2.range !== "function") throw new Error("invalid interval: missing range method");
    return interval2;
  }
  function maybeNiceInterval(interval2, type2) {
    interval2 = maybeRangeInterval(interval2, type2);
    if (interval2 && typeof interval2.ceil !== "function") throw new Error("invalid interval: missing ceil method");
    return interval2;
  }
  function isTimeInterval(t5) {
    return isInterval(t5) && typeof t5?.floor === "function" && t5.floor() instanceof Date;
  }
  function isInterval(t5) {
    return typeof t5?.range === "function";
  }
  function maybeValue(value) {
    return value === void 0 || isOptions(value) ? value : { value };
  }
  function numberChannel(source) {
    return source == null ? null : {
      transform: (data) => valueof(data, source, Float64Array),
      label: labelof(source)
    };
  }
  function isTuples(data) {
    if (!isIterable(data)) return false;
    for (const d3 of data) {
      if (d3 == null) continue;
      return typeof d3 === "object" && "0" in d3 && "1" in d3;
    }
  }
  function isIterable(value) {
    return value && typeof value[Symbol.iterator] === "function";
  }
  function isTextual(values2) {
    for (const value of values2) {
      if (value == null) continue;
      return typeof value !== "object" || value instanceof Date;
    }
  }
  function isOrdinal(values2) {
    for (const value of values2) {
      if (value == null) continue;
      const type2 = typeof value;
      return type2 === "string" || type2 === "boolean";
    }
  }
  function isTemporal(values2) {
    for (const value of values2) {
      if (value == null) continue;
      return value instanceof Date;
    }
  }
  function isTemporalString(values2) {
    for (const value of values2) {
      if (value == null) continue;
      return typeof value === "string" && isNaN(value) && parse2(value);
    }
  }
  function isNumericString(values2) {
    for (const value of values2) {
      if (value == null) continue;
      if (typeof value !== "string") return false;
      if (!value.trim()) continue;
      return !isNaN(value);
    }
  }
  function isNumeric(values2) {
    for (const value of values2) {
      if (value == null) continue;
      return typeof value === "number";
    }
  }
  function isEvery(values2, is) {
    let every;
    for (const value of values2) {
      if (value == null) continue;
      if (!is(value)) return false;
      every = true;
    }
    return every;
  }
  var namedColors = new Set("none,currentcolor,transparent,aliceblue,antiquewhite,aqua,aquamarine,azure,beige,bisque,black,blanchedalmond,blue,blueviolet,brown,burlywood,cadetblue,chartreuse,chocolate,coral,cornflowerblue,cornsilk,crimson,cyan,darkblue,darkcyan,darkgoldenrod,darkgray,darkgreen,darkgrey,darkkhaki,darkmagenta,darkolivegreen,darkorange,darkorchid,darkred,darksalmon,darkseagreen,darkslateblue,darkslategray,darkslategrey,darkturquoise,darkviolet,deeppink,deepskyblue,dimgray,dimgrey,dodgerblue,firebrick,floralwhite,forestgreen,fuchsia,gainsboro,ghostwhite,gold,goldenrod,gray,green,greenyellow,grey,honeydew,hotpink,indianred,indigo,ivory,khaki,lavender,lavenderblush,lawngreen,lemonchiffon,lightblue,lightcoral,lightcyan,lightgoldenrodyellow,lightgray,lightgreen,lightgrey,lightpink,lightsalmon,lightseagreen,lightskyblue,lightslategray,lightslategrey,lightsteelblue,lightyellow,lime,limegreen,linen,magenta,maroon,mediumaquamarine,mediumblue,mediumorchid,mediumpurple,mediumseagreen,mediumslateblue,mediumspringgreen,mediumturquoise,mediumvioletred,midnightblue,mintcream,mistyrose,moccasin,navajowhite,navy,oldlace,olive,olivedrab,orange,orangered,orchid,palegoldenrod,palegreen,paleturquoise,palevioletred,papayawhip,peachpuff,peru,pink,plum,powderblue,purple,rebeccapurple,red,rosybrown,royalblue,saddlebrown,salmon,sandybrown,seagreen,seashell,sienna,silver,skyblue,slateblue,slategray,slategrey,snow,springgreen,steelblue,tan,teal,thistle,tomato,turquoise,violet,wheat,white,whitesmoke,yellow".split(","));
  function isColor(value) {
    if (typeof value !== "string") return false;
    value = value.toLowerCase().trim();
    return /^#[0-9a-f]{3,8}$/.test(value) || // hex rgb, rgba, rrggbb, rrggbbaa
    /^(?:url|var|rgb|rgba|hsl|hsla|hwb|lab|lch|oklab|oklch|color|color-mix)\(.*\)$/.test(value) || // <funciri>, CSS variable, color, etc.
    namedColors.has(value);
  }
  function isOpacity(value) {
    return typeof value === "number" && (0 <= value && value <= 1 || isNaN(value));
  }
  function isNoneish(value) {
    return value == null || isNone(value);
  }
  function isNone(value) {
    return /^\s*none\s*$/i.test(value);
  }
  function isRound(value) {
    return /^\s*round\s*$/i.test(value);
  }
  function maybeAnchor(value, name) {
    return maybeKeyword(value, name, [
      "middle",
      "top-left",
      "top",
      "top-right",
      "right",
      "bottom-right",
      "bottom",
      "bottom-left",
      "left"
    ]);
  }
  function maybeFrameAnchor(value = "middle") {
    return maybeAnchor(value, "frameAnchor");
  }
  function inherit2(options = {}, ...rest) {
    let o12 = options;
    for (const defaults22 of rest) {
      for (const key in defaults22) {
        if (o12[key] === void 0) {
          const value = defaults22[key];
          if (o12 === options) o12 = { ...o12, [key]: value };
          else o12[key] = value;
        }
      }
    }
    return o12;
  }
  function named2(things) {
    console.warn("named iterables are deprecated; please use an object instead");
    const names = /* @__PURE__ */ new Set();
    return Object.fromEntries(
      Array.from(things, (thing) => {
        const { name } = thing;
        if (name == null) throw new Error("missing name");
        const key = `${name}`;
        if (key === "__proto__") throw new Error(`illegal name: ${key}`);
        if (names.has(key)) throw new Error(`duplicate name: ${key}`);
        names.add(key);
        return [name, thing];
      })
    );
  }
  function maybeNamed(things) {
    return isIterable(things) ? named2(things) : things;
  }
  function maybeClip(clip) {
    if (clip === true) clip = "frame";
    else if (clip === false) clip = null;
    else if (!isGeoJSON(clip) && clip != null) {
      clip = keyword(clip, "clip", ["frame", "sphere"]);
      if (clip === "sphere") clip = { type: "Sphere" };
    }
    return clip;
  }
  function isArrowTable(value) {
    return value && typeof value.getChild === "function" && typeof value.toArray === "function" && value.schema && Array.isArray(value.schema.fields);
  }
  function isArrowVector(value) {
    return value && typeof value.toArray === "function" && value.type;
  }
  function isArrowDateType(type2) {
    return type2 && (type2.typeId === 8 || // date
    type2.typeId === 10) && // timestamp
    type2.unit === 1;
  }

  // ../../../../../node_modules/@observablehq/plot/src/scales/index.js
  var position = Symbol("position");
  var color2 = Symbol("color");
  var radius = Symbol("radius");
  var length3 = Symbol("length");
  var opacity = Symbol("opacity");
  var symbol2 = Symbol("symbol");
  var projection2 = Symbol("projection");
  var registry = /* @__PURE__ */ new Map([
    ["x", position],
    ["y", position],
    ["fx", position],
    ["fy", position],
    ["r", radius],
    ["color", color2],
    ["opacity", opacity],
    ["symbol", symbol2],
    ["length", length3],
    ["projection", projection2]
  ]);
  function isPosition(kind) {
    return kind === position || kind === projection2;
  }
  function hasNumericRange(kind) {
    return kind === position || kind === radius || kind === length3 || kind === opacity;
  }

  // ../../../../../node_modules/@observablehq/plot/src/symbol.js
  var sqrt35 = Math.sqrt(3);
  var sqrt4_3 = 2 / sqrt35;
  var symbolHexagon = {
    draw(context, size) {
      const rx = Math.sqrt(size / Math.PI), ry = rx * sqrt4_3, hy = ry / 2;
      context.moveTo(0, ry);
      context.lineTo(rx, hy);
      context.lineTo(rx, -hy);
      context.lineTo(0, -ry);
      context.lineTo(-rx, -hy);
      context.lineTo(-rx, hy);
      context.closePath();
    }
  };
  var symbols = /* @__PURE__ */ new Map([
    ["asterisk", asterisk_default],
    ["circle", circle_default2],
    ["cross", cross_default],
    ["diamond", diamond_default],
    ["diamond2", diamond2_default],
    ["hexagon", symbolHexagon],
    ["plus", plus_default],
    ["square", square_default],
    ["square2", square2_default],
    ["star", star_default],
    ["times", times_default],
    ["triangle", triangle_default],
    ["triangle2", triangle2_default],
    ["wye", wye_default]
  ]);
  function isSymbolObject(value) {
    return value && typeof value.draw === "function";
  }
  function isSymbol(value) {
    if (isSymbolObject(value)) return true;
    if (typeof value !== "string") return false;
    return symbols.has(value.toLowerCase());
  }
  function maybeSymbol(symbol3) {
    if (symbol3 == null || isSymbolObject(symbol3)) return symbol3;
    const value = symbols.get(`${symbol3}`.toLowerCase());
    if (value) return value;
    throw new Error(`invalid symbol: ${symbol3}`);
  }
  function maybeSymbolChannel(symbol3) {
    if (symbol3 == null || isSymbolObject(symbol3)) return [void 0, symbol3];
    if (typeof symbol3 === "string") {
      const value = symbols.get(`${symbol3}`.toLowerCase());
      if (value) return [void 0, value];
    }
    return [symbol3, void 0];
  }

  // ../../../../../node_modules/@observablehq/plot/src/transforms/basic.js
  function basic({ filter: f12, sort: s1, reverse: r1, transform: t13, initializer: i12, ...options } = {}, transform3) {
    if (t13 === void 0) {
      if (f12 != null) t13 = filterTransform(f12);
      if (s1 != null && !isDomainSort(s1)) t13 = composeTransform(t13, sortTransform(s1));
      if (r1) t13 = composeTransform(t13, reverseTransform);
    }
    if (transform3 != null && i12 != null) throw new Error("transforms cannot be applied after initializers");
    return {
      ...options,
      ...(s1 === null || isDomainSort(s1)) && { sort: s1 },
      transform: composeTransform(t13, transform3)
    };
  }
  function initializer({ filter: f12, sort: s1, reverse: r1, initializer: i12, ...options } = {}, initializer2) {
    if (i12 === void 0) {
      if (f12 != null) i12 = filterTransform(f12);
      if (s1 != null && !isDomainSort(s1)) i12 = composeInitializer(i12, sortTransform(s1));
      if (r1) i12 = composeInitializer(i12, reverseTransform);
    }
    return {
      ...options,
      ...(s1 === null || isDomainSort(s1)) && { sort: s1 },
      initializer: composeInitializer(i12, initializer2)
    };
  }
  function composeTransform(t13, t23) {
    if (t13 == null) return t23 === null ? void 0 : t23;
    if (t23 == null) return t13 === null ? void 0 : t13;
    return function(data, facets, plotOptions) {
      ({ data, facets } = t13.call(this, data, facets, plotOptions));
      return t23.call(this, dataify(data), facets, plotOptions);
    };
  }
  function composeInitializer(i12, i22) {
    if (i12 == null) return i22 === null ? void 0 : i22;
    if (i22 == null) return i12 === null ? void 0 : i12;
    return function(data, facets, channels, ...args2) {
      let c1, d1, f12, c22, d22, f22;
      ({ data: d1 = data, facets: f12 = facets, channels: c1 } = i12.call(this, data, facets, channels, ...args2));
      ({ data: d22 = d1, facets: f22 = f12, channels: c22 } = i22.call(this, d1, f12, { ...channels, ...c1 }, ...args2));
      return { data: d22, facets: f22, channels: { ...c1, ...c22 } };
    };
  }
  function apply(options, t5) {
    return (options.initializer != null ? initializer : basic)(options, t5);
  }
  function filter4(test, options) {
    return apply(options, filterTransform(test));
  }
  function filterTransform(value) {
    return (data, facets) => {
      const V2 = valueof(data, value);
      return { data, facets: facets.map((I2) => I2.filter((i5) => V2[i5])) };
    };
  }
  function reverse2({ sort: sort3, ...options } = {}) {
    return {
      ...apply(options, reverseTransform),
      sort: isDomainSort(sort3) ? sort3 : null
    };
  }
  function reverseTransform(data, facets) {
    return { data, facets: facets.map((I2) => I2.slice().reverse()) };
  }
  function shuffle({ seed, sort: sort3, ...options } = {}) {
    return {
      ...apply(options, sortValue(seed == null ? Math.random : lcg(seed))),
      sort: isDomainSort(sort3) ? sort3 : null
    };
  }
  function sort2(order, { sort: sort3, ...options } = {}) {
    return {
      ...(isOptions(order) && order.channel !== void 0 ? initializer : apply)(options, sortTransform(order)),
      sort: isDomainSort(sort3) ? sort3 : null
    };
  }
  function sortTransform(value) {
    return (typeof value === "function" && value.length !== 1 ? sortData : sortValue)(value);
  }
  function sortData(compare) {
    return (data, facets) => {
      const compareData = isArray(data) ? (i5, j2) => compare(data[i5], data[j2]) : (i5, j2) => compare(data.get(i5), data.get(j2));
      return { data, facets: facets.map((I2) => I2.slice().sort(compareData)) };
    };
  }
  function sortValue(value) {
    let channel, order;
    ({ channel, value, order } = { ...maybeValue(value) });
    const negate3 = channel?.startsWith("-");
    if (negate3) channel = channel.slice(1);
    if (order === void 0) order = negate3 ? descendingDefined : ascendingDefined2;
    if (typeof order !== "function") {
      switch (`${order}`.toLowerCase()) {
        case "ascending":
          order = ascendingDefined2;
          break;
        case "descending":
          order = descendingDefined;
          break;
        default:
          throw new Error(`invalid order: ${order}`);
      }
    }
    return (data, facets, channels) => {
      let V2;
      if (channel === void 0) {
        V2 = valueof(data, value);
      } else {
        if (channels === void 0) throw new Error("channel sort requires an initializer");
        V2 = channels[channel];
        if (!V2) return {};
        V2 = V2.value;
      }
      const compareValue = (i5, j2) => order(V2[i5], V2[j2]);
      return { data, facets: facets.map((I2) => I2.slice().sort(compareValue)) };
    };
  }

  // ../../../../../node_modules/@observablehq/plot/src/transforms/group.js
  function groupZ(outputs, options) {
    return groupn(null, null, outputs, options);
  }
  function groupX(outputs = { y: "count" }, options = {}) {
    const { x: x3 = identity6 } = options;
    if (x3 == null) throw new Error("missing channel: x");
    return groupn(x3, null, outputs, options);
  }
  function groupY(outputs = { x: "count" }, options = {}) {
    const { y: y3 = identity6 } = options;
    if (y3 == null) throw new Error("missing channel: y");
    return groupn(null, y3, outputs, options);
  }
  function group2(outputs = { fill: "count" }, options = {}) {
    let { x: x3, y: y3 } = options;
    [x3, y3] = maybeTuple(x3, y3);
    if (x3 == null) throw new Error("missing channel: x");
    if (y3 == null) throw new Error("missing channel: y");
    return groupn(x3, y3, outputs, options);
  }
  function groupn(x3, y3, {
    data: reduceData = reduceIdentity,
    filter: filter5,
    sort: sort3,
    reverse: reverse3,
    ...outputs
    // output channel definitions
  } = {}, inputs = {}) {
    outputs = maybeGroupOutputs(outputs, inputs);
    reduceData = maybeGroupReduce(reduceData, identity6);
    sort3 = sort3 == null ? void 0 : maybeGroupOutput("sort", sort3, inputs);
    filter5 = filter5 == null ? void 0 : maybeGroupEvaluator("filter", filter5, inputs);
    const [GX, setGX] = maybeColumn(x3);
    const [GY, setGY] = maybeColumn(y3);
    const {
      z: z2,
      fill,
      stroke,
      x1: x12,
      x2: x22,
      // consumed if x is an output
      y1: y12,
      y2: y22,
      // consumed if y is an output
      ...options
    } = inputs;
    const [GZ, setGZ] = maybeColumn(z2);
    const [vfill] = maybeColorChannel(fill);
    const [vstroke] = maybeColorChannel(stroke);
    const [GF, setGF] = maybeColumn(vfill);
    const [GS, setGS] = maybeColumn(vstroke);
    return {
      ..."z" in inputs && { z: GZ || z2 },
      ..."fill" in inputs && { fill: GF || fill },
      ..."stroke" in inputs && { stroke: GS || stroke },
      ...basic(options, (data, facets, plotOptions) => {
        const X3 = maybeApplyInterval(valueof(data, x3), plotOptions?.x);
        const Y3 = maybeApplyInterval(valueof(data, y3), plotOptions?.y);
        const Z3 = valueof(data, z2);
        const F = valueof(data, vfill);
        const S3 = valueof(data, vstroke);
        const G = maybeSubgroup(outputs, { z: Z3, fill: F, stroke: S3 });
        const groupFacets = [];
        const groupData = [];
        const GX2 = X3 && setGX([]);
        const GY2 = Y3 && setGY([]);
        const GZ2 = Z3 && setGZ([]);
        const GF2 = F && setGF([]);
        const GS2 = S3 && setGS([]);
        let i5 = 0;
        for (const o12 of outputs) o12.initialize(data);
        if (sort3) sort3.initialize(data);
        if (filter5) filter5.initialize(data);
        for (const facet of facets) {
          const groupFacet = [];
          for (const o12 of outputs) o12.scope("facet", facet);
          if (sort3) sort3.scope("facet", facet);
          if (filter5) filter5.scope("facet", facet);
          for (const [f7, I2] of maybeGroup(facet, G)) {
            for (const [y4, gg] of maybeGroup(I2, Y3)) {
              for (const [x4, g2] of maybeGroup(gg, X3)) {
                const extent3 = { data };
                if (X3) extent3.x = x4;
                if (Y3) extent3.y = y4;
                if (G) extent3.z = f7;
                if (filter5 && !filter5.reduce(g2, extent3)) continue;
                groupFacet.push(i5++);
                groupData.push(reduceData.reduceIndex(g2, data, extent3));
                if (X3) GX2.push(x4);
                if (Y3) GY2.push(y4);
                if (Z3) GZ2.push(G === Z3 ? f7 : Z3[g2[0]]);
                if (F) GF2.push(G === F ? f7 : F[g2[0]]);
                if (S3) GS2.push(G === S3 ? f7 : S3[g2[0]]);
                for (const o12 of outputs) o12.reduce(g2, extent3);
                if (sort3) sort3.reduce(g2, extent3);
              }
            }
          }
          groupFacets.push(groupFacet);
        }
        maybeSort(groupFacets, sort3, reverse3);
        return { data: groupData, facets: groupFacets };
      }),
      ...!hasOutput(outputs, "x") && (GX ? { x: GX } : { x1: x12, x2: x22 }),
      ...!hasOutput(outputs, "y") && (GY ? { y: GY } : { y1: y12, y2: y22 }),
      ...Object.fromEntries(outputs.map(({ name, output }) => [name, output]))
    };
  }
  function hasOutput(outputs, ...names) {
    for (const { name } of outputs) {
      if (names.includes(name)) {
        return true;
      }
    }
    return false;
  }
  function maybeOutputs(outputs, inputs, asOutput = maybeOutput) {
    const entries = Object.entries(outputs);
    if (inputs.title != null && outputs.title === void 0) entries.push(["title", reduceTitle]);
    if (inputs.href != null && outputs.href === void 0) entries.push(["href", reduceFirst]);
    return entries.filter(([, reduce]) => reduce !== void 0).map(([name, reduce]) => reduce === null ? nullOutput(name) : asOutput(name, reduce, inputs));
  }
  function maybeOutput(name, reduce, inputs, asEvaluator = maybeEvaluator) {
    let scale3;
    if (isObject(reduce) && "reduce" in reduce) scale3 = reduce.scale, reduce = reduce.reduce;
    const evaluator = asEvaluator(name, reduce, inputs);
    const [output, setOutput] = column(evaluator.label);
    let O;
    return {
      name,
      output: scale3 === void 0 ? output : { value: output, scale: scale3 },
      initialize(data) {
        evaluator.initialize(data);
        O = setOutput([]);
      },
      scope(scope, I2) {
        evaluator.scope(scope, I2);
      },
      reduce(I2, extent3) {
        O.push(evaluator.reduce(I2, extent3));
      }
    };
  }
  function nullOutput(name) {
    return { name, initialize() {
    }, scope() {
    }, reduce() {
    } };
  }
  function maybeEvaluator(name, reduce, inputs, asReduce = maybeReduce) {
    const input = maybeInput(name, inputs);
    const reducer2 = asReduce(reduce, input);
    let V2, context;
    return {
      label: labelof(reducer2 === reduceCount ? null : input, reducer2.label),
      initialize(data) {
        V2 = input === void 0 ? data : valueof(data, input);
        if (reducer2.scope === "data") {
          context = reducer2.reduceIndex(range2(data), V2);
        }
      },
      scope(scope, I2) {
        if (reducer2.scope === scope) {
          context = reducer2.reduceIndex(I2, V2);
        }
      },
      reduce(I2, extent3) {
        return reducer2.scope == null ? reducer2.reduceIndex(I2, V2, extent3) : reducer2.reduceIndex(I2, V2, context, extent3);
      }
    };
  }
  function maybeGroup(I2, X3) {
    return X3 ? group(I2, (i5) => X3[i5]) : [[, I2]];
  }
  function maybeReduce(reduce, value, fallback = invalidReduce) {
    if (reduce == null) return fallback(reduce);
    if (typeof reduce.reduceIndex === "function") return reduce;
    if (typeof reduce.reduce === "function" && isObject(reduce)) return reduceReduce(reduce);
    if (typeof reduce === "function") return reduceFunction(reduce);
    if (/^p\d{2}$/i.test(reduce)) return reduceAccessor(percentile(reduce));
    switch (`${reduce}`.toLowerCase()) {
      case "first":
        return reduceFirst;
      case "last":
        return reduceLast;
      case "identity":
        return reduceIdentity;
      case "count":
        return reduceCount;
      case "distinct":
        return reduceDistinct;
      case "sum":
        return value == null ? reduceCount : reduceSum;
      case "proportion":
        return reduceProportion(value, "data");
      case "proportion-facet":
        return reduceProportion(value, "facet");
      case "deviation":
        return reduceAccessor(deviation);
      case "min":
        return reduceAccessor(min);
      case "min-index":
        return reduceAccessor(minIndex);
      case "max":
        return reduceAccessor(max);
      case "max-index":
        return reduceAccessor(maxIndex);
      case "mean":
        return reduceMaybeTemporalAccessor(mean);
      case "median":
        return reduceMaybeTemporalAccessor(median);
      case "variance":
        return reduceAccessor(variance);
      case "mode":
        return reduceAccessor(mode);
    }
    return fallback(reduce);
  }
  function invalidReduce(reduce) {
    throw new Error(`invalid reduce: ${reduce}`);
  }
  function maybeGroupOutputs(outputs, inputs) {
    return maybeOutputs(outputs, inputs, maybeGroupOutput);
  }
  function maybeGroupOutput(name, reduce, inputs) {
    return maybeOutput(name, reduce, inputs, maybeGroupEvaluator);
  }
  function maybeGroupEvaluator(name, reduce, inputs) {
    return maybeEvaluator(name, reduce, inputs, maybeGroupReduce);
  }
  function maybeGroupReduce(reduce, value) {
    return maybeReduce(reduce, value, maybeGroupReduceFallback);
  }
  function maybeGroupReduceFallback(reduce) {
    switch (`${reduce}`.toLowerCase()) {
      case "x":
        return reduceX;
      case "y":
        return reduceY;
      case "z":
        return reduceZ;
    }
    throw new Error(`invalid group reduce: ${reduce}`);
  }
  function maybeSubgroup(outputs, inputs) {
    for (const name in inputs) {
      const value = inputs[name];
      if (value !== void 0 && !outputs.some((o12) => o12.name === name)) {
        return value;
      }
    }
  }
  function maybeSort(facets, sort3, reverse3) {
    if (sort3) {
      const S3 = sort3.output.transform();
      const compare = (i5, j2) => ascendingDefined2(S3[i5], S3[j2]);
      facets.forEach((f7) => f7.sort(compare));
    }
    if (reverse3) {
      facets.forEach((f7) => f7.reverse());
    }
  }
  function reduceReduce(reduce) {
    console.warn("deprecated reduce interface; implement reduceIndex instead.");
    return { ...reduce, reduceIndex: reduce.reduce.bind(reduce) };
  }
  function reduceFunction(f7) {
    return {
      reduceIndex(I2, X3, extent3) {
        return f7(take(X3, I2), extent3);
      }
    };
  }
  function reduceAccessor(f7) {
    return {
      reduceIndex(I2, X3) {
        return f7(I2, (i5) => X3[i5]);
      }
    };
  }
  function reduceMaybeTemporalAccessor(f7) {
    return {
      reduceIndex(I2, X3) {
        const x3 = f7(I2, (i5) => X3[i5]);
        return isTemporal(X3) ? new Date(x3) : x3;
      }
    };
  }
  var reduceIdentity = {
    reduceIndex(I2, X3) {
      return take(X3, I2);
    }
  };
  var reduceFirst = {
    reduceIndex(I2, X3) {
      return X3[I2[0]];
    }
  };
  var reduceTitle = {
    reduceIndex(I2, X3) {
      const n9 = 5;
      const groups2 = sort(
        rollup(
          I2,
          (V2) => V2.length,
          (i5) => X3[i5]
        ),
        second2
      );
      const top3 = groups2.slice(-n9).reverse();
      if (top3.length < groups2.length) {
        const bottom2 = groups2.slice(0, 1 - n9);
        top3[n9 - 1] = [`\u2026 ${bottom2.length.toLocaleString("en-US")} more`, sum(bottom2, second2)];
      }
      return top3.map(([key, value]) => `${key} (${value.toLocaleString("en-US")})`).join("\n");
    }
  };
  var reduceLast = {
    reduceIndex(I2, X3) {
      return X3[I2[I2.length - 1]];
    }
  };
  var reduceCount = {
    label: "Frequency",
    reduceIndex(I2) {
      return I2.length;
    }
  };
  var reduceDistinct = {
    label: "Distinct",
    reduceIndex(I2, X3) {
      const s8 = new InternSet();
      for (const i5 of I2) s8.add(X3[i5]);
      return s8.size;
    }
  };
  var reduceSum = reduceAccessor(sum);
  function reduceProportion(value, scope) {
    return value == null ? { scope, label: "Frequency", reduceIndex: (I2, V2, basis2 = 1) => I2.length / basis2 } : { scope, reduceIndex: (I2, V2, basis2 = 1) => sum(I2, (i5) => V2[i5]) / basis2 };
  }
  var reduceX = {
    reduceIndex(I2, X3, { x: x3 }) {
      return x3;
    }
  };
  var reduceY = {
    reduceIndex(I2, X3, { y: y3 }) {
      return y3;
    }
  };
  var reduceZ = {
    reduceIndex(I2, X3, { z: z2 }) {
      return z2;
    }
  };
  function find2(test) {
    if (typeof test !== "function") throw new Error(`invalid test function: ${test}`);
    return {
      reduceIndex(I2, V2, { data }) {
        return V2[I2.find(isArray(data) ? (i5) => test(data[i5], i5, data) : (i5) => test(data.get(i5), i5, data))];
      }
    };
  }

  // ../../../../../node_modules/@observablehq/plot/src/channel.js
  function createChannel(data, { scale: scale3, type: type2, value, filter: filter5, hint, label = labelof(value) }, name) {
    if (hint === void 0 && typeof value?.transform === "function") hint = value.hint;
    return inferChannelScale(name, {
      scale: scale3,
      type: type2,
      value: valueof(data, value),
      label,
      filter: filter5,
      hint
    });
  }
  function createChannels(channels, data) {
    return Object.fromEntries(
      Object.entries(channels).map(([name, channel]) => [name, createChannel(data, channel, name)])
    );
  }
  function valueObject(channels, scales) {
    const values2 = Object.fromEntries(
      Object.entries(channels).map(([name, { scale: scaleName, value }]) => {
        const scale3 = scaleName == null ? null : scales[scaleName];
        return [name, scale3 == null ? value : map2(value, scale3)];
      })
    );
    values2.channels = channels;
    return values2;
  }
  function inferChannelScale(name, channel) {
    const { scale: scale3, value } = channel;
    if (scale3 === true || scale3 === "auto") {
      switch (name) {
        case "fill":
        case "stroke":
        case "color":
          channel.scale = scale3 !== true && isEvery(value, isColor) ? null : "color";
          channel.defaultScale = "color";
          break;
        case "fillOpacity":
        case "strokeOpacity":
        case "opacity":
          channel.scale = scale3 !== true && isEvery(value, isOpacity) ? null : "opacity";
          channel.defaultScale = "opacity";
          break;
        case "symbol":
          if (scale3 !== true && isEvery(value, isSymbol)) {
            channel.scale = null;
            channel.value = map2(value, maybeSymbol);
          } else {
            channel.scale = "symbol";
          }
          channel.defaultScale = "symbol";
          break;
        default:
          channel.scale = registry.has(name) ? name : null;
          break;
      }
    } else if (scale3 === false) {
      channel.scale = null;
    } else if (scale3 != null && !registry.has(scale3)) {
      throw new Error(`unknown scale: ${scale3}`);
    }
    return channel;
  }
  function channelDomain(data, facets, channels, facetChannels, options) {
    const { order: defaultOrder, reverse: defaultReverse, reduce: defaultReduce = true, limit: defaultLimit } = options;
    for (const x3 in options) {
      if (!registry.has(x3)) continue;
      let { value: y3, order = defaultOrder, reverse: reverse3 = defaultReverse, reduce = defaultReduce, limit = defaultLimit } = maybeValue(options[x3]);
      const negate3 = y3?.startsWith("-");
      if (negate3) y3 = y3.slice(1);
      order = order === void 0 ? negate3 !== (y3 === "width" || y3 === "height") ? descendingGroup : ascendingGroup : maybeOrder(order);
      if (reduce == null || reduce === false) continue;
      const X3 = x3 === "fx" || x3 === "fy" ? reindexFacetChannel(facets, facetChannels[x3]) : findScaleChannel(channels, x3);
      if (!X3) throw new Error(`missing channel for scale: ${x3}`);
      const XV = X3.value;
      const [lo = 0, hi = Infinity] = isIterable(limit) ? limit : limit < 0 ? [limit] : [0, limit];
      if (y3 == null) {
        X3.domain = () => {
          let domain = Array.from(new InternSet(XV));
          if (reverse3) domain = domain.reverse();
          if (lo !== 0 || hi !== Infinity) domain = domain.slice(lo, hi);
          return domain;
        };
      } else {
        const YV = y3 === "data" ? data : y3 === "height" ? difference(channels, "y1", "y2") : y3 === "width" ? difference(channels, "x1", "x2") : values(channels, y3, y3 === "y" ? "y2" : y3 === "x" ? "x2" : void 0);
        const reducer2 = maybeReduce(reduce === true ? "max" : reduce, YV);
        X3.domain = () => {
          let domain = rollups(
            range2(XV),
            (I2) => reducer2.reduceIndex(I2, YV),
            (i5) => XV[i5]
          );
          if (order) domain.sort(order);
          if (reverse3) domain.reverse();
          if (lo !== 0 || hi !== Infinity) domain = domain.slice(lo, hi);
          return domain.map(first);
        };
      }
    }
  }
  function findScaleChannel(channels, scale3) {
    for (const name in channels) {
      const channel = channels[name];
      if (channel.scale === scale3) return channel;
    }
  }
  function reindexFacetChannel(facets, channel) {
    const originalFacets = facets.original;
    if (originalFacets === facets) return channel;
    const V1 = channel.value;
    const V2 = channel.value = [];
    for (let i5 = 0; i5 < originalFacets.length; ++i5) {
      const vi = V1[originalFacets[i5][0]];
      for (const j2 of facets[i5]) V2[j2] = vi;
    }
    return channel;
  }
  function difference(channels, k1, k22) {
    const X13 = values(channels, k1);
    const X23 = values(channels, k22);
    return map2(X23, (x22, i5) => Math.abs(x22 - X13[i5]), Float64Array);
  }
  function values(channels, name, alias) {
    let channel = channels[name];
    if (!channel && alias !== void 0) channel = channels[alias];
    if (channel) return channel.value;
    throw new Error(`missing channel: ${name}`);
  }
  function maybeOrder(order) {
    if (order == null || typeof order === "function") return order;
    switch (`${order}`.toLowerCase()) {
      case "ascending":
        return ascendingGroup;
      case "descending":
        return descendingGroup;
    }
    throw new Error(`invalid order: ${order}`);
  }
  function ascendingGroup([ak, av], [bk, bv]) {
    return ascendingDefined2(av, bv) || ascendingDefined2(ak, bk);
  }
  function descendingGroup([ak, av], [bk, bv]) {
    return descendingDefined(av, bv) || ascendingDefined2(ak, bk);
  }
  function getSource(channels, key) {
    let channel = channels[key];
    if (!channel) return;
    while (channel.source) channel = channel.source;
    return channel.source === null ? null : channel;
  }

  // ../../../../../node_modules/@observablehq/plot/src/scales/schemes.js
  var categoricalSchemes = /* @__PURE__ */ new Map([
    ["accent", Accent_default],
    ["category10", category10_default],
    ["dark2", Dark2_default],
    ["observable10", observable10_default],
    ["paired", Paired_default],
    ["pastel1", Pastel1_default],
    ["pastel2", Pastel2_default],
    ["set1", Set1_default],
    ["set2", Set2_default],
    ["set3", Set3_default],
    ["tableau10", Tableau10_default]
  ]);
  function isCategoricalScheme(scheme28) {
    return scheme28 != null && categoricalSchemes.has(`${scheme28}`.toLowerCase());
  }
  var ordinalSchemes = new Map([
    ...categoricalSchemes,
    // diverging
    ["brbg", scheme112(scheme, BrBG_default)],
    ["prgn", scheme112(scheme2, PRGn_default)],
    ["piyg", scheme112(scheme3, PiYG_default)],
    ["puor", scheme112(scheme4, PuOr_default)],
    ["rdbu", scheme112(scheme5, RdBu_default)],
    ["rdgy", scheme112(scheme6, RdGy_default)],
    ["rdylbu", scheme112(scheme7, RdYlBu_default)],
    ["rdylgn", scheme112(scheme8, RdYlGn_default)],
    ["spectral", scheme112(scheme9, Spectral_default)],
    // reversed diverging (for temperature data)
    ["burd", scheme11r(scheme5, RdBu_default)],
    ["buylrd", scheme11r(scheme7, RdYlBu_default)],
    // sequential (single-hue)
    ["blues", scheme92(scheme22, Blues_default)],
    ["greens", scheme92(scheme23, Greens_default)],
    ["greys", scheme92(scheme24, Greys_default)],
    ["oranges", scheme92(scheme27, Oranges_default)],
    ["purples", scheme92(scheme25, Purples_default)],
    ["reds", scheme92(scheme26, Reds_default)],
    // sequential (multi-hue)
    ["turbo", schemei(turbo_default)],
    ["viridis", schemei(viridis_default)],
    ["magma", schemei(magma)],
    ["inferno", schemei(inferno)],
    ["plasma", schemei(plasma)],
    ["cividis", schemei(cividis_default)],
    ["cubehelix", schemei(cubehelix_default2)],
    ["warm", schemei(warm)],
    ["cool", schemei(cool)],
    ["bugn", scheme92(scheme10, BuGn_default)],
    ["bupu", scheme92(scheme11, BuPu_default)],
    ["gnbu", scheme92(scheme12, GnBu_default)],
    ["orrd", scheme92(scheme13, OrRd_default)],
    ["pubu", scheme92(scheme15, PuBu_default)],
    ["pubugn", scheme92(scheme14, PuBuGn_default)],
    ["purd", scheme92(scheme16, PuRd_default)],
    ["rdpu", scheme92(scheme17, RdPu_default)],
    ["ylgn", scheme92(scheme19, YlGn_default)],
    ["ylgnbu", scheme92(scheme18, YlGnBu_default)],
    ["ylorbr", scheme92(scheme20, YlOrBr_default)],
    ["ylorrd", scheme92(scheme21, YlOrRd_default)],
    // cyclical
    ["rainbow", schemeicyclical(rainbow_default)],
    ["sinebow", schemeicyclical(sinebow_default)]
  ]);
  function scheme92(scheme28, interpolate) {
    return ({ length: n9 }) => {
      if (n9 === 1) return [scheme28[3][1]];
      if (n9 === 2) return [scheme28[3][1], scheme28[3][2]];
      n9 = Math.max(3, Math.floor(n9));
      return n9 > 9 ? quantize_default(interpolate, n9) : scheme28[n9];
    };
  }
  function scheme112(scheme28, interpolate) {
    return ({ length: n9 }) => {
      if (n9 === 2) return [scheme28[3][0], scheme28[3][2]];
      n9 = Math.max(3, Math.floor(n9));
      return n9 > 11 ? quantize_default(interpolate, n9) : scheme28[n9];
    };
  }
  function scheme11r(scheme28, interpolate) {
    return ({ length: n9 }) => {
      if (n9 === 2) return [scheme28[3][2], scheme28[3][0]];
      n9 = Math.max(3, Math.floor(n9));
      return n9 > 11 ? quantize_default((t5) => interpolate(1 - t5), n9) : scheme28[n9].slice().reverse();
    };
  }
  function schemei(interpolate) {
    return ({ length: n9 }) => quantize_default(interpolate, Math.max(2, Math.floor(n9)));
  }
  function schemeicyclical(interpolate) {
    return ({ length: n9 }) => quantize_default(interpolate, Math.floor(n9) + 1).slice(0, -1);
  }
  function ordinalScheme(scheme28) {
    const s8 = `${scheme28}`.toLowerCase();
    if (!ordinalSchemes.has(s8)) throw new Error(`unknown ordinal scheme: ${s8}`);
    return ordinalSchemes.get(s8);
  }
  function ordinalRange(scheme28, length4) {
    const s8 = ordinalScheme(scheme28);
    const r6 = typeof s8 === "function" ? s8({ length: length4 }) : s8;
    return r6.length !== length4 ? r6.slice(0, length4) : r6;
  }
  function maybeBooleanRange(domain, scheme28 = "greys") {
    const range3 = /* @__PURE__ */ new Set();
    const [f7, t5] = ordinalRange(scheme28, 2);
    for (const value of domain) {
      if (value == null) continue;
      if (value === true) range3.add(t5);
      else if (value === false) range3.add(f7);
      else return;
    }
    return [...range3];
  }
  var quantitativeSchemes = /* @__PURE__ */ new Map([
    // diverging
    ["brbg", BrBG_default],
    ["prgn", PRGn_default],
    ["piyg", PiYG_default],
    ["puor", PuOr_default],
    ["rdbu", RdBu_default],
    ["rdgy", RdGy_default],
    ["rdylbu", RdYlBu_default],
    ["rdylgn", RdYlGn_default],
    ["spectral", Spectral_default],
    // reversed diverging (for temperature data)
    ["burd", (t5) => RdBu_default(1 - t5)],
    ["buylrd", (t5) => RdYlBu_default(1 - t5)],
    // sequential (single-hue)
    ["blues", Blues_default],
    ["greens", Greens_default],
    ["greys", Greys_default],
    ["purples", Purples_default],
    ["reds", Reds_default],
    ["oranges", Oranges_default],
    // sequential (multi-hue)
    ["turbo", turbo_default],
    ["viridis", viridis_default],
    ["magma", magma],
    ["inferno", inferno],
    ["plasma", plasma],
    ["cividis", cividis_default],
    ["cubehelix", cubehelix_default2],
    ["warm", warm],
    ["cool", cool],
    ["bugn", BuGn_default],
    ["bupu", BuPu_default],
    ["gnbu", GnBu_default],
    ["orrd", OrRd_default],
    ["pubugn", PuBuGn_default],
    ["pubu", PuBu_default],
    ["purd", PuRd_default],
    ["rdpu", RdPu_default],
    ["ylgnbu", YlGnBu_default],
    ["ylgn", YlGn_default],
    ["ylorbr", YlOrBr_default],
    ["ylorrd", YlOrRd_default],
    // cyclical
    ["rainbow", rainbow_default],
    ["sinebow", sinebow_default]
  ]);
  function quantitativeScheme(scheme28) {
    const s8 = `${scheme28}`.toLowerCase();
    if (!quantitativeSchemes.has(s8)) throw new Error(`unknown quantitative scheme: ${s8}`);
    return quantitativeSchemes.get(s8);
  }
  var divergingSchemes = /* @__PURE__ */ new Set([
    "brbg",
    "prgn",
    "piyg",
    "puor",
    "rdbu",
    "rdgy",
    "rdylbu",
    "rdylgn",
    "spectral",
    "burd",
    "buylrd"
  ]);
  function isDivergingScheme(scheme28) {
    return scheme28 != null && divergingSchemes.has(`${scheme28}`.toLowerCase());
  }

  // ../../../../../node_modules/@observablehq/plot/src/scales/quantitative.js
  var flip = (i5) => (t5) => i5(1 - t5);
  var unit2 = [0, 1];
  var interpolators = /* @__PURE__ */ new Map([
    // numbers
    ["number", number_default],
    // color spaces
    ["rgb", rgb_default],
    ["hsl", hsl_default],
    ["hcl", hcl_default],
    ["lab", lab2]
  ]);
  function maybeInterpolator(interpolate) {
    const i5 = `${interpolate}`.toLowerCase();
    if (!interpolators.has(i5)) throw new Error(`unknown interpolator: ${i5}`);
    return interpolators.get(i5);
  }
  function createScaleQ(key, scale3, channels, {
    type: type2,
    nice: nice3,
    clamp,
    zero: zero4,
    domain = inferAutoDomain(key, channels),
    unknown,
    round: round2,
    scheme: scheme28,
    interval: interval2,
    range: range3 = registry.get(key) === radius ? inferRadialRange(channels, domain) : registry.get(key) === length3 ? inferLengthRange(channels, domain) : registry.get(key) === opacity ? unit2 : void 0,
    interpolate = registry.get(key) === color2 ? scheme28 == null && range3 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : type2 === "cyclical" ? "rainbow" : "turbo") : round2 ? round_default : number_default,
    reverse: reverse3
  }) {
    domain = maybeRepeat(domain);
    interval2 = maybeRangeInterval(interval2, type2);
    if (type2 === "cyclical" || type2 === "sequential") type2 = "linear";
    if (typeof interpolate !== "function") interpolate = maybeInterpolator(interpolate);
    reverse3 = !!reverse3;
    if (range3 !== void 0) {
      const n9 = domain.length;
      const m3 = (range3 = maybeRepeat(range3)).length;
      if (n9 !== m3) {
        if (interpolate.length === 1) throw new Error("invalid piecewise interpolator");
        interpolate = piecewise(interpolate, range3);
        range3 = void 0;
      }
    }
    if (interpolate.length === 1) {
      if (reverse3) {
        interpolate = flip(interpolate);
        reverse3 = false;
      }
      if (range3 === void 0) {
        range3 = Float64Array.from(domain, (_2, i5) => i5 / (domain.length - 1));
        if (range3.length === 2) range3 = unit2;
      }
      scale3.interpolate((range3 === unit2 ? constant : interpolatePiecewise)(interpolate));
    } else {
      scale3.interpolate(interpolate);
    }
    if (zero4) {
      const [min4, max3] = extent(domain);
      if (min4 > 0 || max3 < 0) {
        domain = slice3(domain);
        const o12 = orderof(domain) || 1;
        if (o12 === Math.sign(min4)) domain[0] = 0;
        else domain[domain.length - 1] = 0;
      }
    }
    if (reverse3) domain = reverse(domain);
    scale3.domain(domain).unknown(unknown);
    if (nice3) scale3.nice(maybeNice(nice3, type2)), domain = scale3.domain();
    if (range3 !== void 0) scale3.range(range3);
    if (clamp) scale3.clamp(clamp);
    return { type: type2, domain, range: range3, scale: scale3, interpolate, interval: interval2 };
  }
  function maybeRepeat(values2) {
    values2 = arrayify2(values2);
    return values2.length >= 2 ? values2 : [values2[0], values2[0]];
  }
  function maybeNice(nice3, type2) {
    return nice3 === true ? void 0 : typeof nice3 === "number" ? nice3 : maybeNiceInterval(nice3, type2);
  }
  function createScaleLinear(key, channels, options) {
    return createScaleQ(key, linear2(), channels, options);
  }
  function createScaleSqrt(key, channels, options) {
    return createScalePow(key, channels, { ...options, exponent: 0.5 });
  }
  function createScalePow(key, channels, { exponent = 1, ...options }) {
    return createScaleQ(key, pow3().exponent(exponent), channels, { ...options, type: "pow" });
  }
  function createScaleLog(key, channels, { base = 10, domain = inferLogDomain(channels), ...options }) {
    return createScaleQ(key, log2().base(base), channels, { ...options, domain });
  }
  function createScaleSymlog(key, channels, { constant: constant2 = 1, ...options }) {
    return createScaleQ(key, symlog().constant(constant2), channels, options);
  }
  function createScaleQuantile(key, channels, {
    range: range3,
    quantiles = range3 === void 0 ? 5 : (range3 = [...range3]).length,
    // deprecated; use n instead
    n: n9 = quantiles,
    scheme: scheme28 = "rdylbu",
    domain = inferQuantileDomain(channels),
    unknown,
    interpolate,
    reverse: reverse3
  }) {
    if (range3 === void 0) {
      range3 = interpolate !== void 0 ? quantize_default(interpolate, n9) : registry.get(key) === color2 ? ordinalRange(scheme28, n9) : void 0;
    }
    if (domain.length > 0) {
      domain = quantile2(domain, range3 === void 0 ? { length: n9 } : range3).quantiles();
    }
    return createScaleThreshold(key, channels, { domain, range: range3, reverse: reverse3, unknown });
  }
  function createScaleQuantize(key, channels, {
    range: range3,
    n: n9 = range3 === void 0 ? 5 : (range3 = [...range3]).length,
    scheme: scheme28 = "rdylbu",
    domain = inferAutoDomain(key, channels),
    unknown,
    interpolate,
    reverse: reverse3
  }) {
    const [min4, max3] = extent(domain);
    let thresholds;
    if (range3 === void 0) {
      thresholds = ticks(min4, max3, n9);
      if (thresholds[0] <= min4) thresholds.splice(0, 1);
      if (thresholds[thresholds.length - 1] >= max3) thresholds.pop();
      n9 = thresholds.length + 1;
      range3 = interpolate !== void 0 ? quantize_default(interpolate, n9) : registry.get(key) === color2 ? ordinalRange(scheme28, n9) : void 0;
    } else {
      thresholds = quantize_default(number_default(min4, max3), n9 + 1).slice(1, -1);
      if (min4 instanceof Date) thresholds = thresholds.map((x3) => new Date(x3));
    }
    if (orderof(arrayify2(domain)) < 0) thresholds.reverse();
    return createScaleThreshold(key, channels, { domain: thresholds, range: range3, reverse: reverse3, unknown });
  }
  function createScaleThreshold(key, channels, {
    domain = [0],
    // explicit thresholds in ascending order
    unknown,
    scheme: scheme28 = "rdylbu",
    interpolate,
    range: range3 = interpolate !== void 0 ? quantize_default(interpolate, domain.length + 1) : registry.get(key) === color2 ? ordinalRange(scheme28, domain.length + 1) : void 0,
    reverse: reverse3
  }) {
    domain = arrayify2(domain);
    const sign4 = orderof(domain);
    if (!isNaN(sign4) && !isOrdered(domain, sign4)) throw new Error(`the ${key} scale has a non-monotonic domain`);
    if (reverse3) range3 = reverse(range3);
    return {
      type: "threshold",
      scale: threshold(sign4 < 0 ? reverse(domain) : domain, range3 === void 0 ? [] : range3).unknown(unknown),
      domain,
      range: range3
    };
  }
  function isOrdered(domain, sign4) {
    for (let i5 = 1, n9 = domain.length, d3 = domain[0]; i5 < n9; ++i5) {
      const s8 = descending(d3, d3 = domain[i5]);
      if (s8 !== 0 && s8 !== sign4) return false;
    }
    return true;
  }
  function createScaleIdentity(key) {
    return { type: "identity", scale: hasNumericRange(registry.get(key)) ? identity4() : (d3) => d3 };
  }
  function inferDomain(channels, f7 = finite2) {
    return channels.length ? [
      min(channels, ({ value }) => value === void 0 ? value : min(value, f7)),
      max(channels, ({ value }) => value === void 0 ? value : max(value, f7))
    ] : [0, 1];
  }
  function inferAutoDomain(key, channels) {
    const type2 = registry.get(key);
    return (type2 === radius || type2 === opacity || type2 === length3 ? inferZeroDomain : inferDomain)(channels);
  }
  function inferZeroDomain(channels) {
    return [0, channels.length ? max(channels, ({ value }) => value === void 0 ? value : max(value, finite2)) : 1];
  }
  function inferRadialRange(channels, domain) {
    const hint = channels.find(({ radius: radius2 }) => radius2 !== void 0);
    if (hint !== void 0) return [0, hint.radius];
    const h25 = quantile(channels, 0.5, ({ value }) => value === void 0 ? NaN : quantile(value, 0.25, positive));
    const range3 = domain.map((d3) => 3 * Math.sqrt(d3 / h25));
    const k3 = 30 / max(range3);
    return k3 < 1 ? range3.map((r6) => r6 * k3) : range3;
  }
  function inferLengthRange(channels, domain) {
    const h50 = median(channels, ({ value }) => value === void 0 ? NaN : median(value, Math.abs));
    const range3 = domain.map((d3) => 12 * d3 / h50);
    const k3 = 60 / max(range3);
    return k3 < 1 ? range3.map((r6) => r6 * k3) : range3;
  }
  function inferLogDomain(channels) {
    for (const { value } of channels) {
      if (value !== void 0) {
        for (let v3 of value) {
          if (v3 > 0) return inferDomain(channels, positive);
          if (v3 < 0) return inferDomain(channels, negative);
        }
      }
    }
    return [1, 10];
  }
  function inferQuantileDomain(channels) {
    const domain = [];
    for (const { value } of channels) {
      if (value === void 0) continue;
      for (const v3 of value) domain.push(v3);
    }
    return domain;
  }
  function interpolatePiecewise(interpolate) {
    return (i5, j2) => (t5) => interpolate(i5 + t5 * (j2 - i5));
  }

  // ../../../../../node_modules/@observablehq/plot/src/warnings.js
  var warnings = 0;
  var lastMessage;
  function consumeWarnings() {
    const w2 = warnings;
    warnings = 0;
    lastMessage = void 0;
    return w2;
  }
  function warn(message) {
    if (message === lastMessage) return;
    lastMessage = message;
    console.warn(message);
    ++warnings;
  }

  // ../../../../../node_modules/@observablehq/plot/src/scales/diverging.js
  function createScaleD(key, scale3, transform3, channels, {
    type: type2,
    nice: nice3,
    clamp,
    domain = inferDomain(channels),
    unknown,
    pivot = 0,
    scheme: scheme28,
    range: range3,
    symmetric = true,
    interpolate = registry.get(key) === color2 ? scheme28 == null && range3 !== void 0 ? rgb_default : quantitativeScheme(scheme28 !== void 0 ? scheme28 : "rdbu") : number_default,
    reverse: reverse3
  }) {
    pivot = +pivot;
    domain = arrayify2(domain);
    let [min4, max3] = domain;
    if (domain.length > 2) warn(`Warning: the diverging ${key} scale domain contains extra elements.`);
    if (descending(min4, max3) < 0) [min4, max3] = [max3, min4], reverse3 = !reverse3;
    min4 = Math.min(min4, pivot);
    max3 = Math.max(max3, pivot);
    if (typeof interpolate !== "function") {
      interpolate = maybeInterpolator(interpolate);
    }
    if (range3 !== void 0) {
      interpolate = interpolate.length === 1 ? interpolatePiecewise(interpolate)(...range3) : piecewise(interpolate, range3);
    }
    if (reverse3) interpolate = flip(interpolate);
    if (symmetric) {
      const mid2 = transform3.apply(pivot);
      const mindelta = mid2 - transform3.apply(min4);
      const maxdelta = transform3.apply(max3) - mid2;
      if (mindelta < maxdelta) min4 = transform3.invert(mid2 - maxdelta);
      else if (mindelta > maxdelta) max3 = transform3.invert(mid2 + mindelta);
    }
    scale3.domain([min4, pivot, max3]).unknown(unknown).interpolator(interpolate);
    if (clamp) scale3.clamp(clamp);
    if (nice3) scale3.nice(nice3);
    return { type: type2, domain: [min4, max3], pivot, interpolate, scale: scale3 };
  }
  function createScaleDiverging(key, channels, options) {
    return createScaleD(key, diverging(), transformIdentity, channels, options);
  }
  function createScaleDivergingSqrt(key, channels, options) {
    return createScaleDivergingPow(key, channels, { ...options, exponent: 0.5 });
  }
  function createScaleDivergingPow(key, channels, { exponent = 1, ...options }) {
    return createScaleD(key, divergingPow().exponent(exponent = +exponent), transformPow2(exponent), channels, {
      ...options,
      type: "diverging-pow"
    });
  }
  function createScaleDivergingLog(key, channels, { base = 10, pivot = 1, domain = inferDomain(channels, pivot < 0 ? negative : positive), ...options }) {
    return createScaleD(key, divergingLog().base(base = +base), transformLog2, channels, {
      domain,
      pivot,
      ...options
    });
  }
  function createScaleDivergingSymlog(key, channels, { constant: constant2 = 1, ...options }) {
    return createScaleD(
      key,
      divergingSymlog().constant(constant2 = +constant2),
      transformSymlog2(constant2),
      channels,
      options
    );
  }
  var transformIdentity = {
    apply(x3) {
      return x3;
    },
    invert(x3) {
      return x3;
    }
  };
  var transformLog2 = {
    apply: Math.log,
    invert: Math.exp
  };
  var transformSqrt2 = {
    apply(x3) {
      return Math.sign(x3) * Math.sqrt(Math.abs(x3));
    },
    invert(x3) {
      return Math.sign(x3) * (x3 * x3);
    }
  };
  function transformPow2(exponent) {
    return exponent === 0.5 ? transformSqrt2 : {
      apply(x3) {
        return Math.sign(x3) * Math.pow(Math.abs(x3), exponent);
      },
      invert(x3) {
        return Math.sign(x3) * Math.pow(Math.abs(x3), 1 / exponent);
      }
    };
  }
  function transformSymlog2(constant2) {
    return {
      apply(x3) {
        return Math.sign(x3) * Math.log1p(Math.abs(x3 / constant2));
      },
      invert(x3) {
        return Math.sign(x3) * Math.expm1(Math.abs(x3)) * constant2;
      }
    };
  }

  // ../../../../../node_modules/@observablehq/plot/src/scales/temporal.js
  function createScaleT(key, scale3, channels, options) {
    return createScaleQ(key, scale3, channels, options);
  }
  function createScaleTime(key, channels, options) {
    return createScaleT(key, time(), channels, options);
  }
  function createScaleUtc(key, channels, options) {
    return createScaleT(key, utcTime(), channels, options);
  }

  // ../../../../../node_modules/@observablehq/plot/src/scales/ordinal.js
  var ordinalImplicit = Symbol("ordinal");
  function createScaleO(key, scale3, channels, { type: type2, interval: interval2, domain, range: range3, reverse: reverse3, hint }) {
    interval2 = maybeRangeInterval(interval2, type2);
    if (domain === void 0) domain = inferDomain2(channels, interval2, key);
    if (type2 === "categorical" || type2 === ordinalImplicit) type2 = "ordinal";
    if (reverse3) domain = reverse(domain);
    domain = scale3.domain(domain).domain();
    if (range3 !== void 0) {
      if (typeof range3 === "function") range3 = range3(domain);
      scale3.range(range3);
    }
    return { type: type2, domain, range: range3, scale: scale3, hint, interval: interval2 };
  }
  function createScaleOrdinal(key, channels, { type: type2, interval: interval2, domain, range: range3, scheme: scheme28, unknown, ...options }) {
    interval2 = maybeRangeInterval(interval2, type2);
    if (domain === void 0) domain = inferDomain2(channels, interval2, key);
    let hint;
    if (registry.get(key) === symbol2) {
      hint = inferSymbolHint(channels);
      range3 = range3 === void 0 ? inferSymbolRange(hint) : map2(range3, maybeSymbol);
    } else if (registry.get(key) === color2) {
      if (range3 === void 0 && (type2 === "ordinal" || type2 === ordinalImplicit)) {
        range3 = maybeBooleanRange(domain, scheme28);
        if (range3 !== void 0) scheme28 = void 0;
      }
      if (scheme28 === void 0 && range3 === void 0) {
        scheme28 = type2 === "ordinal" ? "turbo" : "observable10";
      }
      if (scheme28 !== void 0) {
        if (range3 !== void 0) {
          const interpolate = quantitativeScheme(scheme28);
          const t03 = range3[0], d3 = range3[1] - range3[0];
          range3 = ({ length: n9 }) => quantize_default((t5) => interpolate(t03 + d3 * t5), n9);
        } else {
          range3 = ordinalScheme(scheme28);
        }
      }
    }
    if (unknown === implicit) {
      throw new Error(`implicit unknown on ${key} scale is not supported`);
    }
    return createScaleO(key, ordinal().unknown(unknown), channels, { ...options, type: type2, domain, range: range3, hint });
  }
  function createScalePoint(key, channels, { align = 0.5, padding = 0.5, ...options }) {
    return maybeRound(point().align(align).padding(padding), channels, options, key);
  }
  function createScaleBand(key, channels, {
    align = 0.5,
    padding = 0.1,
    paddingInner = padding,
    paddingOuter = key === "fx" || key === "fy" ? 0 : padding,
    ...options
  }) {
    return maybeRound(
      band().align(align).paddingInner(paddingInner).paddingOuter(paddingOuter),
      channels,
      options,
      key
    );
  }
  function maybeRound(scale3, channels, options, key) {
    let { round: round2 } = options;
    if (round2 !== void 0) scale3.round(round2 = !!round2);
    scale3 = createScaleO(key, scale3, channels, options);
    scale3.round = round2;
    return scale3;
  }
  function inferDomain2(channels, interval2, key) {
    const values2 = new InternSet();
    for (const { value, domain } of channels) {
      if (domain !== void 0) return domain();
      if (value === void 0) continue;
      for (const v3 of value) values2.add(v3);
    }
    if (interval2 !== void 0) {
      const [min4, max3] = extent(values2).map(interval2.floor, interval2);
      return interval2.range(min4, interval2.offset(max3));
    }
    if (values2.size > 1e4 && registry.get(key) === position) {
      throw new Error(`implicit ordinal domain of ${key} scale has more than 10,000 values`);
    }
    return sort(values2, ascendingDefined2);
  }
  function inferHint(channels, key) {
    let value;
    for (const { hint } of channels) {
      const candidate = hint?.[key];
      if (candidate === void 0) continue;
      if (value === void 0) value = candidate;
      else if (value !== candidate) return;
    }
    return value;
  }
  function inferSymbolHint(channels) {
    return {
      fill: inferHint(channels, "fill"),
      stroke: inferHint(channels, "stroke")
    };
  }
  function inferSymbolRange(hint) {
    return isNoneish(hint.fill) ? symbolsStroke : symbolsFill;
  }

  // ../../../../../node_modules/@observablehq/plot/src/scales.js
  function createScales(channelsByScale, {
    label: globalLabel,
    inset: globalInset = 0,
    insetTop: globalInsetTop = globalInset,
    insetRight: globalInsetRight = globalInset,
    insetBottom: globalInsetBottom = globalInset,
    insetLeft: globalInsetLeft = globalInset,
    round: round2,
    nice: nice3,
    clamp,
    zero: zero4,
    align,
    padding,
    projection: projection3,
    facet: { label: facetLabel = globalLabel } = {},
    ...options
  } = {}) {
    const scales = {};
    for (const [key, channels] of channelsByScale) {
      const scaleOptions = options[key];
      const scale3 = createScale(key, channels, {
        round: registry.get(key) === position ? round2 : void 0,
        // only for position
        nice: nice3,
        clamp,
        zero: zero4,
        align,
        padding,
        projection: projection3,
        ...scaleOptions
      });
      if (scale3) {
        let {
          label = key === "fx" || key === "fy" ? facetLabel : globalLabel,
          percent,
          transform: transform3,
          inset,
          insetTop = inset !== void 0 ? inset : key === "y" ? globalInsetTop : 0,
          // not fy
          insetRight = inset !== void 0 ? inset : key === "x" ? globalInsetRight : 0,
          // not fx
          insetBottom = inset !== void 0 ? inset : key === "y" ? globalInsetBottom : 0,
          // not fy
          insetLeft = inset !== void 0 ? inset : key === "x" ? globalInsetLeft : 0
          // not fx
        } = scaleOptions || {};
        if (transform3 == null) transform3 = void 0;
        else if (typeof transform3 !== "function") throw new Error("invalid scale transform; not a function");
        scale3.percent = !!percent;
        scale3.label = label === void 0 ? inferScaleLabel(channels, scale3) : label;
        scale3.transform = transform3;
        if (key === "x" || key === "fx") {
          scale3.insetLeft = +insetLeft;
          scale3.insetRight = +insetRight;
        } else if (key === "y" || key === "fy") {
          scale3.insetTop = +insetTop;
          scale3.insetBottom = +insetBottom;
        }
        scales[key] = scale3;
      }
    }
    return scales;
  }
  function createScaleFunctions(descriptors) {
    const scales = {};
    const scaleFunctions = { scales };
    for (const [key, descriptor] of Object.entries(descriptors)) {
      const { scale: scale3, type: type2, interval: interval2, label } = descriptor;
      scales[key] = exposeScale(descriptor);
      scaleFunctions[key] = scale3;
      scale3.type = type2;
      if (interval2 != null) scale3.interval = interval2;
      if (label != null) scale3.label = label;
    }
    return scaleFunctions;
  }
  function autoScaleRange(scales, dimensions) {
    const { x: x3, y: y3, fx, fy } = scales;
    const superdimensions = fx || fy ? outerDimensions(dimensions) : dimensions;
    if (fx) autoScaleRangeX(fx, superdimensions);
    if (fy) autoScaleRangeY(fy, superdimensions);
    const subdimensions = fx || fy ? innerDimensions(scales, dimensions) : dimensions;
    if (x3) autoScaleRangeX(x3, subdimensions);
    if (y3) autoScaleRangeY(y3, subdimensions);
  }
  function inferScaleLabel(channels = [], scale3) {
    let label;
    for (const { label: l8 } of channels) {
      if (l8 === void 0) continue;
      if (label === void 0) label = l8;
      else if (label !== l8) return;
    }
    if (label === void 0) return;
    if (!isOrdinalScale(scale3) && scale3.percent) label = `${label} (%)`;
    return { inferred: true, toString: () => label };
  }
  function inferScaleOrder(scale3) {
    return Math.sign(orderof(scale3.domain())) * Math.sign(orderof(scale3.range()));
  }
  function outerDimensions(dimensions) {
    const {
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      width,
      height,
      facet: {
        marginTop: facetMarginTop,
        marginRight: facetMarginRight,
        marginBottom: facetMarginBottom,
        marginLeft: facetMarginLeft
      }
    } = dimensions;
    return {
      marginTop: Math.max(marginTop, facetMarginTop),
      marginRight: Math.max(marginRight, facetMarginRight),
      marginBottom: Math.max(marginBottom, facetMarginBottom),
      marginLeft: Math.max(marginLeft, facetMarginLeft),
      width,
      height
    };
  }
  function innerDimensions({ fx, fy }, dimensions) {
    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = outerDimensions(dimensions);
    return {
      marginTop,
      marginRight,
      marginBottom,
      marginLeft,
      width: fx ? fx.scale.bandwidth() + marginLeft + marginRight : width,
      height: fy ? fy.scale.bandwidth() + marginTop + marginBottom : height,
      facet: { width, height }
    };
  }
  function autoScaleRangeX(scale3, dimensions) {
    if (scale3.range === void 0) {
      const { insetLeft, insetRight } = scale3;
      const { width, marginLeft = 0, marginRight = 0 } = dimensions;
      const left2 = marginLeft + insetLeft;
      const right2 = width - marginRight - insetRight;
      scale3.range = [left2, Math.max(left2, right2)];
      if (!isOrdinalScale(scale3)) scale3.range = piecewiseRange(scale3);
      scale3.scale.range(scale3.range);
    }
    autoScaleRound(scale3);
  }
  function autoScaleRangeY(scale3, dimensions) {
    if (scale3.range === void 0) {
      const { insetTop, insetBottom } = scale3;
      const { height, marginTop = 0, marginBottom = 0 } = dimensions;
      const top3 = marginTop + insetTop;
      const bottom2 = height - marginBottom - insetBottom;
      scale3.range = [Math.max(top3, bottom2), top3];
      if (!isOrdinalScale(scale3)) scale3.range = piecewiseRange(scale3);
      else scale3.range.reverse();
      scale3.scale.range(scale3.range);
    }
    autoScaleRound(scale3);
  }
  function autoScaleRound(scale3) {
    if (scale3.round === void 0 && isBandScale(scale3) && roundError(scale3) <= 30) {
      scale3.scale.round(true);
    }
  }
  function roundError({ scale: scale3 }) {
    const n9 = scale3.domain().length;
    const [start2, stop2] = scale3.range();
    const paddingInner = scale3.paddingInner ? scale3.paddingInner() : 1;
    const paddingOuter = scale3.paddingOuter ? scale3.paddingOuter() : scale3.padding();
    const m3 = n9 - paddingInner;
    const step3 = Math.abs(stop2 - start2) / Math.max(1, m3 + paddingOuter * 2);
    return (step3 - Math.floor(step3)) * m3;
  }
  function piecewiseRange(scale3) {
    const length4 = scale3.scale.domain().length + isThresholdScale(scale3);
    if (!(length4 > 2)) return scale3.range;
    const [start2, end] = scale3.range;
    return Array.from({ length: length4 }, (_2, i5) => start2 + i5 / (length4 - 1) * (end - start2));
  }
  function normalizeScale(key, scale3, hint) {
    return createScale(key, hint === void 0 ? void 0 : [{ hint }], { ...scale3 });
  }
  function createScale(key, channels = [], options = {}) {
    const type2 = inferScaleType(key, channels, options);
    if (options.type === void 0 && options.domain === void 0 && options.range === void 0 && options.interval == null && key !== "fx" && key !== "fy" && isOrdinalScale({ type: type2 })) {
      const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
      if (values2.some(isTemporal))
        warn(
          `Warning: some data associated with the ${key} scale are dates. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
            type2
          )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., d3.utcDay), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
            type2
          )}".`
        );
      else if (values2.some(isTemporalString))
        warn(
          `Warning: some data associated with the ${key} scale are strings that appear to be dates (e.g., YYYY-MM-DD). If these strings represent dates, you should parse them to Date objects. Dates are typically associated with a "utc" or "time" scale rather than a "${formatScaleType(
            type2
          )}" scale. If you are using a bar mark, you probably want a rect mark with the interval option instead; if you are using a group transform, you probably want a bin transform instead. If you want to treat this data as ordinal, you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
            type2
          )}".`
        );
      else if (values2.some(isNumericString))
        warn(
          `Warning: some data associated with the ${key} scale are strings that appear to be numbers. If these strings represent numbers, you should parse or coerce them to numbers. Numbers are typically associated with a "linear" scale rather than a "${formatScaleType(
            type2
          )}" scale. If you want to treat this data as ordinal, you can specify the interval of the ${key} scale (e.g., 1 for integers), or you can suppress this warning by setting the type of the ${key} scale to "${formatScaleType(
            type2
          )}".`
        );
    }
    options.type = type2;
    switch (type2) {
      case "diverging":
      case "diverging-sqrt":
      case "diverging-pow":
      case "diverging-log":
      case "diverging-symlog":
      case "cyclical":
      case "sequential":
      case "linear":
      case "sqrt":
      case "threshold":
      case "quantile":
      case "pow":
      case "log":
      case "symlog":
        options = coerceType(channels, options, coerceNumbers);
        break;
      case "identity":
        switch (registry.get(key)) {
          case position:
            options = coerceType(channels, options, coerceNumbers);
            break;
          case symbol2:
            options = coerceType(channels, options, coerceSymbols);
            break;
        }
        break;
      case "utc":
      case "time":
        options = coerceType(channels, options, coerceDates);
        break;
    }
    switch (type2) {
      case "diverging":
        return createScaleDiverging(key, channels, options);
      case "diverging-sqrt":
        return createScaleDivergingSqrt(key, channels, options);
      case "diverging-pow":
        return createScaleDivergingPow(key, channels, options);
      case "diverging-log":
        return createScaleDivergingLog(key, channels, options);
      case "diverging-symlog":
        return createScaleDivergingSymlog(key, channels, options);
      case "categorical":
      case "ordinal":
      case ordinalImplicit:
        return createScaleOrdinal(key, channels, options);
      case "cyclical":
      case "sequential":
      case "linear":
        return createScaleLinear(key, channels, options);
      case "sqrt":
        return createScaleSqrt(key, channels, options);
      case "threshold":
        return createScaleThreshold(key, channels, options);
      case "quantile":
        return createScaleQuantile(key, channels, options);
      case "quantize":
        return createScaleQuantize(key, channels, options);
      case "pow":
        return createScalePow(key, channels, options);
      case "log":
        return createScaleLog(key, channels, options);
      case "symlog":
        return createScaleSymlog(key, channels, options);
      case "utc":
        return createScaleUtc(key, channels, options);
      case "time":
        return createScaleTime(key, channels, options);
      case "point":
        return createScalePoint(key, channels, options);
      case "band":
        return createScaleBand(key, channels, options);
      case "identity":
        return createScaleIdentity(key);
      case void 0:
        return;
      default:
        throw new Error(`unknown scale type: ${type2}`);
    }
  }
  function formatScaleType(type2) {
    return typeof type2 === "symbol" ? type2.description : type2;
  }
  function maybeScaleType(type2) {
    return typeof type2 === "string" ? `${type2}`.toLowerCase() : type2;
  }
  var typeProjection = { toString: () => "projection" };
  function inferScaleType(key, channels, { type: type2, domain, range: range3, scheme: scheme28, pivot, projection: projection3 }) {
    type2 = maybeScaleType(type2);
    if (key === "fx" || key === "fy") return "band";
    if ((key === "x" || key === "y") && projection3 != null) type2 = typeProjection;
    for (const channel of channels) {
      const t5 = maybeScaleType(channel.type);
      if (t5 === void 0) continue;
      else if (type2 === void 0) type2 = t5;
      else if (type2 !== t5) throw new Error(`scale incompatible with channel: ${type2} !== ${t5}`);
    }
    if (type2 === typeProjection) return;
    if (type2 !== void 0) return type2;
    if (domain === void 0 && !channels.some(({ value }) => value !== void 0)) return;
    const kind = registry.get(key);
    if (kind === radius) return "sqrt";
    if (kind === opacity || kind === length3) return "linear";
    if (kind === symbol2) return "ordinal";
    const n9 = (domain ?? range3)?.length;
    if (n9 < 2 || n9 > 2) return asOrdinalType(kind);
    if (domain !== void 0) {
      if (isOrdinal(domain)) return asOrdinalType(kind);
      if (isTemporal(domain)) return "utc";
    } else {
      const values2 = channels.map(({ value }) => value).filter((value) => value !== void 0);
      if (values2.some(isOrdinal)) return asOrdinalType(kind);
      if (values2.some(isTemporal)) return "utc";
    }
    if (kind === color2) {
      if (pivot != null || isDivergingScheme(scheme28)) return "diverging";
      if (isCategoricalScheme(scheme28)) return "categorical";
    }
    return "linear";
  }
  function asOrdinalType(kind) {
    switch (kind) {
      case position:
        return "point";
      case color2:
        return ordinalImplicit;
      default:
        return "ordinal";
    }
  }
  function isOrdinalScale({ type: type2 }) {
    return type2 === "ordinal" || type2 === "point" || type2 === "band" || type2 === ordinalImplicit;
  }
  function isThresholdScale({ type: type2 }) {
    return type2 === "threshold";
  }
  function isBandScale({ type: type2 }) {
    return type2 === "point" || type2 === "band";
  }
  function isCollapsed(scale3) {
    if (scale3 === void 0) return true;
    const domain = scale3.domain();
    const value = scale3(domain[0]);
    for (let i5 = 1, n9 = domain.length; i5 < n9; ++i5) {
      if (scale3(domain[i5]) - value) {
        return false;
      }
    }
    return true;
  }
  function coerceType(channels, { domain, ...options }, coerceValues) {
    for (const c9 of channels) {
      if (c9.value !== void 0) {
        if (domain === void 0) domain = c9.value?.domain;
        c9.value = coerceValues(c9.value);
      }
    }
    return {
      domain: domain === void 0 ? domain : coerceValues(domain),
      ...options
    };
  }
  function coerceSymbols(values2) {
    return map2(values2, maybeSymbol);
  }
  function scale2(options = {}) {
    let scale3;
    for (const key in options) {
      if (!registry.has(key)) continue;
      if (!isScaleOptions(options[key])) continue;
      if (scale3 !== void 0) throw new Error("ambiguous scale definition; multiple scales found");
      scale3 = exposeScale(normalizeScale(key, options[key]));
    }
    if (scale3 === void 0) throw new Error("invalid scale definition; no scale found");
    return scale3;
  }
  function exposeScales(scales) {
    return (key) => {
      if (!registry.has(key = `${key}`)) throw new Error(`unknown scale: ${key}`);
      return scales[key];
    };
  }
  function exposeScale({ scale: scale3, type: type2, domain, range: range3, interpolate, interval: interval2, transform: transform3, percent, pivot }) {
    if (type2 === "identity") return { type: "identity", apply: (d3) => d3, invert: (d3) => d3 };
    const unknown = scale3.unknown ? scale3.unknown() : void 0;
    return {
      type: type2,
      domain: slice3(domain),
      // defensive copy
      ...range3 !== void 0 && { range: slice3(range3) },
      // defensive copy
      ...transform3 !== void 0 && { transform: transform3 },
      ...percent && { percent },
      // only exposed if truthy
      ...unknown !== void 0 && { unknown },
      ...interval2 !== void 0 && { interval: interval2 },
      // quantitative
      ...interpolate !== void 0 && { interpolate },
      ...scale3.clamp && { clamp: scale3.clamp() },
      // diverging (always asymmetric; we never want to apply the symmetric transform twice)
      ...pivot !== void 0 && { pivot, symmetric: false },
      // log, diverging-log
      ...scale3.base && { base: scale3.base() },
      // pow, diverging-pow
      ...scale3.exponent && { exponent: scale3.exponent() },
      // symlog, diverging-symlog
      ...scale3.constant && { constant: scale3.constant() },
      // band, point
      ...scale3.align && { align: scale3.align(), round: scale3.round() },
      ...scale3.padding && (scale3.paddingInner ? { paddingInner: scale3.paddingInner(), paddingOuter: scale3.paddingOuter() } : { padding: scale3.padding() }),
      ...scale3.bandwidth && { bandwidth: scale3.bandwidth(), step: scale3.step() },
      // utilities
      apply: (t5) => scale3(t5),
      ...scale3.invert && { invert: (t5) => scale3.invert(t5) }
    };
  }

  // ../../../../../node_modules/@observablehq/plot/src/facet.js
  function createFacets(channelsByScale, options) {
    const { fx, fy } = createScales(channelsByScale, options);
    const fxDomain = fx?.scale.domain();
    const fyDomain = fy?.scale.domain();
    return fxDomain && fyDomain ? cross(fxDomain, fyDomain).map(([x3, y3], i5) => ({ x: x3, y: y3, i: i5 })) : fxDomain ? fxDomain.map((x3, i5) => ({ x: x3, i: i5 })) : fyDomain ? fyDomain.map((y3, i5) => ({ y: y3, i: i5 })) : void 0;
  }
  function recreateFacets(facets, { x: X3, y: Y3 }) {
    X3 &&= facetIndex(X3);
    Y3 &&= facetIndex(Y3);
    return facets.filter(
      X3 && Y3 ? (f7) => X3.has(f7.x) && Y3.has(f7.y) : X3 ? (f7) => X3.has(f7.x) : (f7) => Y3.has(f7.y)
    ).sort(
      X3 && Y3 ? (a5, b2) => X3.get(a5.x) - X3.get(b2.x) || Y3.get(a5.y) - Y3.get(b2.y) : X3 ? (a5, b2) => X3.get(a5.x) - X3.get(b2.x) : (a5, b2) => Y3.get(a5.y) - Y3.get(b2.y)
    );
  }
  function facetGroups(data, { fx, fy }) {
    const I2 = range2(data);
    const FX = fx?.value;
    const FY = fy?.value;
    return fx && fy ? rollup(
      I2,
      (G) => (G.fx = FX[G[0]], G.fy = FY[G[0]], G),
      (i5) => FX[i5],
      (i5) => FY[i5]
    ) : fx ? rollup(
      I2,
      (G) => (G.fx = FX[G[0]], G),
      (i5) => FX[i5]
    ) : rollup(
      I2,
      (G) => (G.fy = FY[G[0]], G),
      (i5) => FY[i5]
    );
  }
  function facetTranslator(fx, fy, { marginTop, marginLeft }) {
    const x3 = fx ? ({ x: x4 }) => fx(x4) - marginLeft : () => 0;
    const y3 = fy ? ({ y: y4 }) => fy(y4) - marginTop : () => 0;
    return function(d3) {
      if (this.tagName === "svg") {
        this.setAttribute("x", x3(d3));
        this.setAttribute("y", y3(d3));
      } else {
        this.setAttribute("transform", `translate(${x3(d3)},${y3(d3)})`);
      }
    };
  }
  function facetExclude(index2) {
    const ex = [];
    const e11 = new Uint32Array(sum(index2, (d3) => d3.length));
    for (const i5 of index2) {
      let n9 = 0;
      for (const j2 of index2) {
        if (i5 === j2) continue;
        e11.set(j2, n9);
        n9 += j2.length;
      }
      ex.push(e11.slice(0, n9));
    }
    return ex;
  }
  var facetAnchors = /* @__PURE__ */ new Map([
    ["top", facetAnchorTop],
    ["right", facetAnchorRight],
    ["bottom", facetAnchorBottom],
    ["left", facetAnchorLeft],
    ["top-left", and(facetAnchorTop, facetAnchorLeft)],
    ["top-right", and(facetAnchorTop, facetAnchorRight)],
    ["bottom-left", and(facetAnchorBottom, facetAnchorLeft)],
    ["bottom-right", and(facetAnchorBottom, facetAnchorRight)],
    ["top-empty", facetAnchorTopEmpty],
    ["right-empty", facetAnchorRightEmpty],
    ["bottom-empty", facetAnchorBottomEmpty],
    ["left-empty", facetAnchorLeftEmpty],
    ["empty", facetAnchorEmpty]
  ]);
  function maybeFacetAnchor(facetAnchor) {
    if (facetAnchor == null) return null;
    const anchor = facetAnchors.get(`${facetAnchor}`.toLowerCase());
    if (anchor) return anchor;
    throw new Error(`invalid facet anchor: ${facetAnchor}`);
  }
  var indexCache = /* @__PURE__ */ new WeakMap();
  function facetIndex(V2) {
    let I2 = indexCache.get(V2);
    if (!I2) indexCache.set(V2, I2 = new InternMap(map2(V2, (v3, i5) => [v3, i5])));
    return I2;
  }
  function facetIndexOf(V2, v3) {
    return facetIndex(V2).get(v3);
  }
  function facetFind(facets, x3, y3) {
    x3 = keyof2(x3);
    y3 = keyof2(y3);
    return facets.find((f7) => Object.is(keyof2(f7.x), x3) && Object.is(keyof2(f7.y), y3));
  }
  function facetEmpty(facets, x3, y3) {
    return facetFind(facets, x3, y3)?.empty;
  }
  function facetAnchorTop(facets, { y: Y3 }, { y: y3 }) {
    return Y3 ? facetIndexOf(Y3, y3) === 0 : true;
  }
  function facetAnchorBottom(facets, { y: Y3 }, { y: y3 }) {
    return Y3 ? facetIndexOf(Y3, y3) === Y3.length - 1 : true;
  }
  function facetAnchorLeft(facets, { x: X3 }, { x: x3 }) {
    return X3 ? facetIndexOf(X3, x3) === 0 : true;
  }
  function facetAnchorRight(facets, { x: X3 }, { x: x3 }) {
    return X3 ? facetIndexOf(X3, x3) === X3.length - 1 : true;
  }
  function facetAnchorTopEmpty(facets, { y: Y3 }, { x: x3, y: y3, empty: empty3 }) {
    if (empty3) return false;
    if (!Y3) return;
    const i5 = facetIndexOf(Y3, y3);
    if (i5 > 0) return facetEmpty(facets, x3, Y3[i5 - 1]);
  }
  function facetAnchorBottomEmpty(facets, { y: Y3 }, { x: x3, y: y3, empty: empty3 }) {
    if (empty3) return false;
    if (!Y3) return;
    const i5 = facetIndexOf(Y3, y3);
    if (i5 < Y3.length - 1) return facetEmpty(facets, x3, Y3[i5 + 1]);
  }
  function facetAnchorLeftEmpty(facets, { x: X3 }, { x: x3, y: y3, empty: empty3 }) {
    if (empty3) return false;
    if (!X3) return;
    const i5 = facetIndexOf(X3, x3);
    if (i5 > 0) return facetEmpty(facets, X3[i5 - 1], y3);
  }
  function facetAnchorRightEmpty(facets, { x: X3 }, { x: x3, y: y3, empty: empty3 }) {
    if (empty3) return false;
    if (!X3) return;
    const i5 = facetIndexOf(X3, x3);
    if (i5 < X3.length - 1) return facetEmpty(facets, X3[i5 + 1], y3);
  }
  function facetAnchorEmpty(facets, channels, { empty: empty3 }) {
    return empty3;
  }
  function and(a5, b2) {
    return function() {
      return a5.apply(null, arguments) && b2.apply(null, arguments);
    };
  }
  function facetFilter(facets, { channels: { fx, fy }, groups: groups2 }) {
    return fx && fy ? facets.map(({ x: x3, y: y3 }) => groups2.get(x3)?.get(y3) ?? []) : fx ? facets.map(({ x: x3 }) => groups2.get(x3) ?? []) : facets.map(({ y: y3 }) => groups2.get(y3) ?? []);
  }

  // ../../../../../node_modules/@observablehq/plot/src/projection.js
  var pi4 = Math.PI;
  var tau5 = 2 * pi4;
  var defaultAspectRatio = 0.618;
  function createProjection({
    projection: projection3,
    inset: globalInset = 0,
    insetTop = globalInset,
    insetRight = globalInset,
    insetBottom = globalInset,
    insetLeft = globalInset
  } = {}, dimensions) {
    if (projection3 == null) return;
    if (typeof projection3.stream === "function") return projection3;
    let options;
    let domain;
    let clip = "frame";
    if (isObject(projection3)) {
      let inset;
      ({
        type: projection3,
        domain,
        inset,
        insetTop = inset !== void 0 ? inset : insetTop,
        insetRight = inset !== void 0 ? inset : insetRight,
        insetBottom = inset !== void 0 ? inset : insetBottom,
        insetLeft = inset !== void 0 ? inset : insetLeft,
        clip = clip,
        ...options
      } = projection3);
      if (projection3 == null) return;
    }
    if (typeof projection3 !== "function") ({ type: projection3 } = namedProjection(projection3));
    const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;
    const dx = width - marginLeft - marginRight - insetLeft - insetRight;
    const dy = height - marginTop - marginBottom - insetTop - insetBottom;
    projection3 = projection3?.({ width: dx, height: dy, clip, ...options });
    if (projection3 == null) return;
    clip = maybePostClip(clip, marginLeft, marginTop, width - marginRight, height - marginBottom);
    let tx = marginLeft + insetLeft;
    let ty = marginTop + insetTop;
    let transform3;
    if (domain != null) {
      const [[x06, y06], [x12, y12]] = path_default(projection3).bounds(domain);
      const k3 = Math.min(dx / (x12 - x06), dy / (y12 - y06));
      if (k3 > 0) {
        tx -= (k3 * (x06 + x12) - dx) / 2;
        ty -= (k3 * (y06 + y12) - dy) / 2;
        transform3 = transform_default({
          point(x3, y3) {
            this.stream.point(x3 * k3 + tx, y3 * k3 + ty);
          }
        });
      } else {
        warn(`Warning: the projection could not be fit to the specified domain; using the default scale.`);
      }
    }
    transform3 ??= tx === 0 && ty === 0 ? identity7() : transform_default({
      point(x3, y3) {
        this.stream.point(x3 + tx, y3 + ty);
      }
    });
    return { stream: (s8) => projection3.stream(transform3.stream(clip(s8))) };
  }
  function namedProjection(projection3) {
    switch (`${projection3}`.toLowerCase()) {
      case "albers-usa":
        return scaleProjection(albersUsa_default, 0.7463, 0.4673);
      case "albers":
        return conicProjection2(albers_default, 0.7463, 0.4673);
      case "azimuthal-equal-area":
        return scaleProjection(azimuthalEqualArea_default, 4, 4);
      case "azimuthal-equidistant":
        return scaleProjection(azimuthalEquidistant_default, tau5, tau5);
      case "conic-conformal":
        return conicProjection2(conicConformal_default, tau5, tau5);
      case "conic-equal-area":
        return conicProjection2(conicEqualArea_default, 6.1702, 2.9781);
      case "conic-equidistant":
        return conicProjection2(conicEquidistant_default, 7.312, 3.6282);
      case "equal-earth":
        return scaleProjection(equalEarth_default, 5.4133, 2.6347);
      case "equirectangular":
        return scaleProjection(equirectangular_default, tau5, pi4);
      case "gnomonic":
        return scaleProjection(gnomonic_default, 3.4641, 3.4641);
      case "identity":
        return { type: identity7 };
      case "reflect-y":
        return { type: reflectY };
      case "mercator":
        return scaleProjection(mercator_default, tau5, tau5);
      case "orthographic":
        return scaleProjection(orthographic_default, 2, 2);
      case "stereographic":
        return scaleProjection(stereographic_default, 2, 2);
      case "transverse-mercator":
        return scaleProjection(transverseMercator_default, tau5, tau5);
      default:
        throw new Error(`unknown projection type: ${projection3}`);
    }
  }
  function maybePostClip(clip, x12, y12, x22, y22) {
    if (clip === false || clip == null || typeof clip === "number") return (s8) => s8;
    if (clip === true) clip = "frame";
    switch (`${clip}`.toLowerCase()) {
      case "frame":
        return clipRectangle(x12, y12, x22, y22);
      default:
        throw new Error(`unknown projection clip type: ${clip}`);
    }
  }
  function scaleProjection(createProjection2, kx2, ky2) {
    return {
      type: ({ width, height, rotate, precision = 0.15, clip }) => {
        const projection3 = createProjection2();
        if (precision != null) projection3.precision?.(precision);
        if (rotate != null) projection3.rotate?.(rotate);
        if (typeof clip === "number") projection3.clipAngle?.(clip);
        if (width != null) {
          projection3.scale(Math.min(width / kx2, height / ky2));
          projection3.translate([width / 2, height / 2]);
        }
        return projection3;
      },
      aspectRatio: ky2 / kx2
    };
  }
  function conicProjection2(createProjection2, kx2, ky2) {
    const { type: type2, aspectRatio } = scaleProjection(createProjection2, kx2, ky2);
    return {
      type: (options) => {
        const { parallels, domain, width, height } = options;
        const projection3 = type2(options);
        if (parallels != null) {
          projection3.parallels(parallels);
          if (domain === void 0 && width != null) {
            projection3.fitSize([width, height], { type: "Sphere" });
          }
        }
        return projection3;
      },
      aspectRatio
    };
  }
  var identity7 = constant({ stream: (stream) => stream });
  var reflectY = constant(
    transform_default({
      point(x3, y3) {
        this.stream.point(x3, -y3);
      }
    })
  );
  function project(cx, cy, values2, projection3) {
    const x3 = values2[cx];
    const y3 = values2[cy];
    const n9 = x3.length;
    const X3 = values2[cx] = new Float64Array(n9).fill(NaN);
    const Y3 = values2[cy] = new Float64Array(n9).fill(NaN);
    let i5;
    const stream = projection3.stream({
      point(x4, y4) {
        X3[i5] = x4;
        Y3[i5] = y4;
      }
    });
    for (i5 = 0; i5 < n9; ++i5) {
      stream.point(x3[i5], y3[i5]);
    }
  }
  function hasProjection({ projection: projection3 } = {}) {
    if (projection3 == null) return false;
    if (typeof projection3.stream === "function") return true;
    if (isObject(projection3)) projection3 = projection3.type;
    return projection3 != null;
  }
  function projectionAspectRatio(projection3) {
    if (typeof projection3?.stream === "function") return defaultAspectRatio;
    if (isObject(projection3)) {
      let domain, options;
      ({ domain, type: projection3, ...options } = projection3);
      if (domain != null && projection3 != null) {
        const type2 = typeof projection3 === "string" ? namedProjection(projection3).type : projection3;
        const [[x06, y06], [x12, y12]] = path_default(type2({ ...options, width: 100, height: 100 })).bounds(domain);
        const r6 = (y12 - y06) / (x12 - x06);
        return r6 && isFinite(r6) ? r6 < 0.2 ? 0.2 : r6 > 5 ? 5 : r6 : defaultAspectRatio;
      }
    }
    if (projection3 == null) return;
    if (typeof projection3 !== "function") {
      const { aspectRatio } = namedProjection(projection3);
      if (aspectRatio) return aspectRatio;
    }
    return defaultAspectRatio;
  }
  function applyPosition(channels, scales, { projection: projection3 }) {
    const { x: x3, y: y3 } = channels;
    let position3 = {};
    if (x3) position3.x = x3;
    if (y3) position3.y = y3;
    position3 = valueObject(position3, scales);
    if (projection3 && x3?.scale === "x" && y3?.scale === "y") project("x", "y", position3, projection3);
    if (x3) position3.x = coerceNumbers(position3.x);
    if (y3) position3.y = coerceNumbers(position3.y);
    return position3;
  }
  function getGeometryChannels(channel) {
    const X3 = [];
    const Y3 = [];
    const x3 = { scale: "x", value: X3 };
    const y3 = { scale: "y", value: Y3 };
    const sink = {
      point(x4, y4) {
        X3.push(x4);
        Y3.push(y4);
      },
      lineStart() {
      },
      lineEnd() {
      },
      polygonStart() {
      },
      polygonEnd() {
      },
      sphere() {
      }
    };
    for (const object of channel.value) stream_default(object, sink);
    return [x3, y3];
  }
  function xyProjection({ x: X3, y: Y3 }) {
    if (X3 || Y3) {
      X3 ??= (x3) => x3;
      Y3 ??= (y3) => y3;
      return transform_default({
        point(x3, y3) {
          this.stream.point(X3(x3), Y3(y3));
        }
      });
    }
  }

  // ../../../../../node_modules/@observablehq/plot/src/context.js
  function createContext(options = {}) {
    const { document: document2 = typeof window !== "undefined" ? window.document : void 0, clip } = options;
    return { document: document2, clip: maybeClip(clip) };
  }
  function create2(name, { document: document2 }) {
    return select_default2(creator_default(name).call(document2.documentElement));
  }

  // ../../../../../node_modules/@observablehq/plot/src/memoize.js
  var unset = Symbol("unset");
  function memoize1(compute) {
    return (compute.length === 1 ? memoize1Arg : memoize1Args)(compute);
  }
  function memoize1Arg(compute) {
    let cacheValue;
    let cacheKey = unset;
    return (key) => {
      if (!Object.is(cacheKey, key)) {
        cacheKey = key;
        cacheValue = compute(key);
      }
      return cacheValue;
    };
  }
  function memoize1Args(compute) {
    let cacheValue, cacheKeys;
    return (...keys) => {
      if (cacheKeys?.length !== keys.length || cacheKeys.some((k3, i5) => !Object.is(k3, keys[i5]))) {
        cacheKeys = keys;
        cacheValue = compute(...keys);
      }
      return cacheValue;
    };
  }

  // ../../../../../node_modules/@observablehq/plot/src/format.js
  var numberFormat = memoize1((locale3) => {
    return new Intl.NumberFormat(locale3);
  });
  var monthFormat = memoize1((locale3, month) => {
    return new Intl.DateTimeFormat(locale3, { timeZone: "UTC", ...month && { month } });
  });
  var weekdayFormat = memoize1((locale3, weekday) => {
    return new Intl.DateTimeFormat(locale3, { timeZone: "UTC", ...weekday && { weekday } });
  });
  function formatNumber(locale3 = "en-US") {
    const format3 = numberFormat(locale3);
    return (i5) => i5 != null && !isNaN(i5) ? format3.format(i5) : void 0;
  }
  function formatMonth(locale3 = "en-US", format3 = "short") {
    const fmt = monthFormat(locale3, format3);
    return (i5) => i5 != null && !isNaN(i5 = +new Date(Date.UTC(2e3, +i5))) ? fmt.format(i5) : void 0;
  }
  function formatWeekday(locale3 = "en-US", format3 = "short") {
    const fmt = weekdayFormat(locale3, format3);
    return (i5) => i5 != null && !isNaN(i5 = +new Date(Date.UTC(2001, 0, +i5))) ? fmt.format(i5) : void 0;
  }
  function formatIsoDate(date2) {
    return format2(date2, "Invalid Date");
  }
  function formatAuto(locale3 = "en-US") {
    const number7 = formatNumber(locale3);
    return (v3) => (v3 instanceof Date ? formatIsoDate : typeof v3 === "number" ? number7 : string)(v3);
  }
  var formatDefault = formatAuto();

  // ../../../../../node_modules/@observablehq/plot/src/style.js
  var offset = (typeof window !== "undefined" ? window.devicePixelRatio > 1 : typeof it === "undefined") ? 0 : 0.5;
  var nextClipId = 0;
  var nextPatternId = 0;
  function getClipId() {
    return `plot-clip-${++nextClipId}`;
  }
  function getPatternId() {
    return `plot-pattern-${++nextPatternId}`;
  }
  function styles2(mark, {
    title,
    href,
    ariaLabel: variaLabel,
    ariaDescription,
    ariaHidden,
    target,
    fill,
    fillOpacity,
    stroke,
    strokeWidth,
    strokeOpacity,
    strokeLinejoin,
    strokeLinecap,
    strokeMiterlimit,
    strokeDasharray,
    strokeDashoffset,
    opacity: opacity2,
    mixBlendMode,
    imageFilter,
    paintOrder,
    pointerEvents,
    shapeRendering,
    channels
  }, {
    ariaLabel: cariaLabel,
    fill: defaultFill = "currentColor",
    fillOpacity: defaultFillOpacity,
    stroke: defaultStroke = "none",
    strokeOpacity: defaultStrokeOpacity,
    strokeWidth: defaultStrokeWidth,
    strokeLinecap: defaultStrokeLinecap,
    strokeLinejoin: defaultStrokeLinejoin,
    strokeMiterlimit: defaultStrokeMiterlimit,
    paintOrder: defaultPaintOrder
  }) {
    if (defaultFill === null) {
      fill = null;
      fillOpacity = null;
    }
    if (defaultStroke === null) {
      stroke = null;
      strokeOpacity = null;
    }
    if (isNoneish(defaultFill)) {
      if (!isNoneish(defaultStroke) && (!isNoneish(fill) || channels?.fill)) defaultStroke = "none";
    } else {
      if (isNoneish(defaultStroke) && (!isNoneish(stroke) || channels?.stroke)) defaultFill = "none";
    }
    const [vfill, cfill] = maybeColorChannel(fill, defaultFill);
    const [vfillOpacity, cfillOpacity] = maybeNumberChannel(fillOpacity, defaultFillOpacity);
    const [vstroke, cstroke] = maybeColorChannel(stroke, defaultStroke);
    const [vstrokeOpacity, cstrokeOpacity] = maybeNumberChannel(strokeOpacity, defaultStrokeOpacity);
    const [vopacity, copacity] = maybeNumberChannel(opacity2);
    if (!isNone(cstroke)) {
      if (strokeWidth === void 0) strokeWidth = defaultStrokeWidth;
      if (strokeLinecap === void 0) strokeLinecap = defaultStrokeLinecap;
      if (strokeLinejoin === void 0) strokeLinejoin = defaultStrokeLinejoin;
      if (strokeMiterlimit === void 0 && !isRound(strokeLinejoin)) strokeMiterlimit = defaultStrokeMiterlimit;
      if (!isNone(cfill) && paintOrder === void 0) paintOrder = defaultPaintOrder;
    }
    const [vstrokeWidth, cstrokeWidth] = maybeNumberChannel(strokeWidth);
    if (defaultFill !== null) {
      mark.fill = impliedString(cfill, "currentColor");
      mark.fillOpacity = impliedNumber(cfillOpacity, 1);
    }
    if (defaultStroke !== null) {
      mark.stroke = impliedString(cstroke, "none");
      mark.strokeWidth = impliedNumber(cstrokeWidth, 1);
      mark.strokeOpacity = impliedNumber(cstrokeOpacity, 1);
      mark.strokeLinejoin = impliedString(strokeLinejoin, "miter");
      mark.strokeLinecap = impliedString(strokeLinecap, "butt");
      mark.strokeMiterlimit = impliedNumber(strokeMiterlimit, 4);
      mark.strokeDasharray = impliedString(strokeDasharray, "none");
      mark.strokeDashoffset = impliedString(strokeDashoffset, "0");
    }
    mark.target = string(target);
    mark.ariaLabel = string(cariaLabel);
    mark.ariaDescription = string(ariaDescription);
    mark.ariaHidden = string(ariaHidden);
    mark.opacity = impliedNumber(copacity, 1);
    mark.mixBlendMode = impliedString(mixBlendMode, "normal");
    mark.imageFilter = impliedString(imageFilter, "none");
    mark.paintOrder = impliedString(paintOrder, "normal");
    mark.pointerEvents = impliedString(pointerEvents, "auto");
    mark.shapeRendering = impliedString(shapeRendering, "auto");
    return {
      title: { value: title, optional: true, filter: null },
      href: { value: href, optional: true, filter: null },
      ariaLabel: { value: variaLabel, optional: true, filter: null },
      fill: { value: vfill, scale: "auto", optional: true },
      fillOpacity: { value: vfillOpacity, scale: "auto", optional: true },
      stroke: { value: vstroke, scale: "auto", optional: true },
      strokeOpacity: { value: vstrokeOpacity, scale: "auto", optional: true },
      strokeWidth: { value: vstrokeWidth, optional: true },
      opacity: { value: vopacity, scale: "auto", optional: true }
    };
  }
  function applyTitle(selection2, L2) {
    if (L2)
      selection2.filter((i5) => nonempty(L2[i5])).append("title").call(applyText, L2);
  }
  function applyTitleGroup(selection2, L2) {
    if (L2)
      selection2.filter(([i5]) => nonempty(L2[i5])).append("title").call(applyTextGroup, L2);
  }
  function applyText(selection2, T2) {
    if (T2) selection2.text((i5) => formatDefault(T2[i5]));
  }
  function applyTextGroup(selection2, T2) {
    if (T2) selection2.text(([i5]) => formatDefault(T2[i5]));
  }
  function applyChannelStyles(selection2, { target, tip: tip2 }, {
    ariaLabel: AL,
    title: T2,
    fill: F,
    fillOpacity: FO,
    stroke: S3,
    strokeOpacity: SO,
    strokeWidth: SW,
    opacity: O,
    href: H2
  }) {
    if (AL) applyAttr(selection2, "aria-label", (i5) => AL[i5]);
    if (F) applyAttr(selection2, "fill", (i5) => F[i5]);
    if (FO) applyAttr(selection2, "fill-opacity", (i5) => FO[i5]);
    if (S3) applyAttr(selection2, "stroke", (i5) => S3[i5]);
    if (SO) applyAttr(selection2, "stroke-opacity", (i5) => SO[i5]);
    if (SW) applyAttr(selection2, "stroke-width", (i5) => SW[i5]);
    if (O) applyAttr(selection2, "opacity", (i5) => O[i5]);
    if (H2) applyHref(selection2, (i5) => H2[i5], target);
    if (!tip2) applyTitle(selection2, T2);
  }
  function applyGroupedChannelStyles(selection2, { target, tip: tip2 }, {
    ariaLabel: AL,
    title: T2,
    fill: F,
    fillOpacity: FO,
    stroke: S3,
    strokeOpacity: SO,
    strokeWidth: SW,
    opacity: O,
    href: H2
  }) {
    if (AL) applyAttr(selection2, "aria-label", ([i5]) => AL[i5]);
    if (F) applyAttr(selection2, "fill", ([i5]) => F[i5]);
    if (FO) applyAttr(selection2, "fill-opacity", ([i5]) => FO[i5]);
    if (S3) applyAttr(selection2, "stroke", ([i5]) => S3[i5]);
    if (SO) applyAttr(selection2, "stroke-opacity", ([i5]) => SO[i5]);
    if (SW) applyAttr(selection2, "stroke-width", ([i5]) => SW[i5]);
    if (O) applyAttr(selection2, "opacity", ([i5]) => O[i5]);
    if (H2) applyHref(selection2, ([i5]) => H2[i5], target);
    if (!tip2) applyTitleGroup(selection2, T2);
  }
  function groupAesthetics({
    ariaLabel: AL,
    title: T2,
    fill: F,
    fillOpacity: FO,
    stroke: S3,
    strokeOpacity: SO,
    strokeWidth: SW,
    opacity: O,
    href: H2
  }, { tip: tip2 }) {
    return [AL, tip2 ? void 0 : T2, F, FO, S3, SO, SW, O, H2].filter((c9) => c9 !== void 0);
  }
  function groupZ2(I2, Z3, z2) {
    const G = group(I2, (i5) => Z3[i5]);
    if (z2 === void 0 && G.size > 1 + I2.length >> 1) {
      warn(
        `Warning: the implicit z channel has high cardinality. This may occur when the fill or stroke channel is associated with quantitative data rather than ordinal or categorical data. You can suppress this warning by setting the z option explicitly; if this data represents a single series, set z to null.`
      );
    }
    return G.values();
  }
  function* groupIndex(I2, position3, mark, channels) {
    const { z: z2 } = mark;
    const { z: Z3 } = channels;
    const A5 = groupAesthetics(channels, mark);
    const C8 = [...position3, ...A5];
    for (const G of Z3 ? groupZ2(I2, Z3, z2) : [I2]) {
      let Ag;
      let Gg;
      out: for (const i5 of G) {
        for (const c9 of C8) {
          if (!defined(c9[i5])) {
            if (Gg) Gg.push(-1);
            continue out;
          }
        }
        if (Ag === void 0) {
          if (Gg) yield Gg;
          Ag = A5.map((c9) => keyof2(c9[i5])), Gg = [i5];
          continue;
        }
        Gg.push(i5);
        for (let j2 = 0; j2 < A5.length; ++j2) {
          const k3 = keyof2(A5[j2][i5]);
          if (k3 !== Ag[j2]) {
            yield Gg;
            Ag = A5.map((c9) => keyof2(c9[i5])), Gg = [i5];
            continue out;
          }
        }
      }
      if (Gg) yield Gg;
    }
  }
  function applyClip(selection2, mark, dimensions, context) {
    let clipUrl;
    const { clip = context.clip } = mark;
    if (clip === "frame") {
      selection2 = create2("svg:g", context).each(function() {
        this.appendChild(selection2.node());
        selection2.node = () => this;
      });
      clipUrl = getFrameClip(context, dimensions);
    } else if (clip) {
      clipUrl = getGeoClip(clip, context);
    }
    applyAttr(selection2, "aria-label", mark.ariaLabel);
    applyAttr(selection2, "aria-description", mark.ariaDescription);
    applyAttr(selection2, "aria-hidden", mark.ariaHidden);
    applyAttr(selection2, "clip-path", clipUrl);
  }
  function memoizeClip(clip) {
    const cache = /* @__PURE__ */ new WeakMap();
    return (context, dimensions) => {
      let url = cache.get(context);
      if (!url) {
        const id2 = getClipId();
        select_default2(context.ownerSVGElement).append("clipPath").attr("id", id2).call(clip, context, dimensions);
        cache.set(context, url = `url(#${id2})`);
      }
      return url;
    };
  }
  var getFrameClip = memoizeClip((clipPath, context, dimensions) => {
    const { width, height, marginLeft, marginRight, marginTop, marginBottom } = dimensions;
    clipPath.append("rect").attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginRight - marginLeft).attr("height", height - marginTop - marginBottom);
  });
  var geoClipCache = /* @__PURE__ */ new WeakMap();
  var sphere = { type: "Sphere" };
  function getGeoClip(geo2, context) {
    let cache, url;
    if (!(cache = geoClipCache.get(context))) geoClipCache.set(context, cache = /* @__PURE__ */ new WeakMap());
    if (geo2.type === "Sphere") geo2 = sphere;
    if (!(url = cache.get(geo2))) {
      const id2 = getClipId();
      select_default2(context.ownerSVGElement).append("clipPath").attr("id", id2).append("path").attr("d", context.path()(geo2));
      cache.set(geo2, url = `url(#${id2})`);
    }
    return url;
  }
  function applyIndirectStyles(selection2, mark, dimensions, context) {
    applyClip(selection2, mark, dimensions, context);
    applyAttr(selection2, "class", mark.className);
    applyAttr(selection2, "fill", mark.fill);
    applyAttr(selection2, "fill-opacity", mark.fillOpacity);
    applyAttr(selection2, "stroke", mark.stroke);
    applyAttr(selection2, "stroke-width", mark.strokeWidth);
    applyAttr(selection2, "stroke-opacity", mark.strokeOpacity);
    applyAttr(selection2, "stroke-linejoin", mark.strokeLinejoin);
    applyAttr(selection2, "stroke-linecap", mark.strokeLinecap);
    applyAttr(selection2, "stroke-miterlimit", mark.strokeMiterlimit);
    applyAttr(selection2, "stroke-dasharray", mark.strokeDasharray);
    applyAttr(selection2, "stroke-dashoffset", mark.strokeDashoffset);
    applyAttr(selection2, "shape-rendering", mark.shapeRendering);
    applyAttr(selection2, "filter", mark.imageFilter);
    applyAttr(selection2, "paint-order", mark.paintOrder);
    const { pointerEvents = context.pointerSticky === false ? "none" : void 0 } = mark;
    applyAttr(selection2, "pointer-events", pointerEvents);
  }
  function applyDirectStyles(selection2, mark) {
    applyStyle(selection2, "mix-blend-mode", mark.mixBlendMode);
    applyAttr(selection2, "opacity", mark.opacity);
  }
  function applyHref(selection2, href, target) {
    selection2.each(function(i5) {
      const h5 = href(i5);
      if (h5 != null) {
        const a5 = this.ownerDocument.createElementNS(namespaces_default.svg, "a");
        a5.setAttribute("fill", "inherit");
        a5.setAttributeNS(namespaces_default.xlink, "href", h5);
        if (target != null) a5.setAttribute("target", target);
        this.parentNode.insertBefore(a5, this).appendChild(this);
      }
    });
  }
  function applyAttr(selection2, name, value) {
    if (value != null) selection2.attr(name, value);
  }
  function applyStyle(selection2, name, value) {
    if (value != null) selection2.style(name, value);
  }
  function applyTransform(selection2, mark, { x: x3, y: y3 }, tx = offset, ty = offset) {
    tx += mark.dx;
    ty += mark.dy;
    if (x3?.bandwidth) tx += x3.bandwidth() / 2;
    if (y3?.bandwidth) ty += y3.bandwidth() / 2;
    if (tx || ty) selection2.attr("transform", `translate(${tx},${ty})`);
  }
  function impliedString(value, impliedValue) {
    if ((value = string(value)) !== impliedValue) return value;
  }
  function impliedNumber(value, impliedValue) {
    if ((value = number5(value)) !== impliedValue) return value;
  }
  var validClassName = /^-?([_a-z]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])([_a-z0-9-]|[\240-\377]|\\[0-9a-f]{1,6}(\r\n|[ \t\r\n\f])?|\\[^\r\n\f0-9a-f])*$/i;
  function maybeClassName(name) {
    if (name === void 0) return "plot-d6a7b5";
    name = `${name}`;
    if (!validClassName.test(name)) throw new Error(`invalid class name: ${name}`);
    return name;
  }
  function applyInlineStyles(selection2, style) {
    if (typeof style === "string") {
      selection2.property("style", style);
    } else if (style != null) {
      for (const element of selection2) {
        Object.assign(element.style, style);
      }
    }
  }
  function applyFrameAnchor({ frameAnchor }, { width, height, marginTop, marginRight, marginBottom, marginLeft }) {
    return [
      /left$/.test(frameAnchor) ? marginLeft : /right$/.test(frameAnchor) ? width - marginRight : (marginLeft + width - marginRight) / 2,
      /^top/.test(frameAnchor) ? marginTop : /^bottom/.test(frameAnchor) ? height - marginBottom : (marginTop + height - marginBottom) / 2
    ];
  }

  // ../../../../../node_modules/@observablehq/plot/src/mark.js
  var Mark = class {
    constructor(data, channels = {}, options = {}, defaults22) {
      const {
        facet = "auto",
        facetAnchor,
        fx,
        fy,
        sort: sort3,
        dx = 0,
        dy = 0,
        margin = 0,
        marginTop = margin,
        marginRight = margin,
        marginBottom = margin,
        marginLeft = margin,
        className,
        clip = defaults22?.clip,
        channels: extraChannels,
        tip: tip2,
        render
      } = options;
      this.data = data;
      this.sort = isDomainSort(sort3) ? sort3 : null;
      this.initializer = initializer(options).initializer;
      this.transform = this.initializer ? options.transform : basic(options).transform;
      if (facet === null || facet === false) {
        this.facet = null;
      } else {
        this.facet = keyword(facet === true ? "include" : facet, "facet", ["auto", "include", "exclude", "super"]);
        this.fx = data === singleton && typeof fx === "string" ? [fx] : fx;
        this.fy = data === singleton && typeof fy === "string" ? [fy] : fy;
      }
      this.facetAnchor = maybeFacetAnchor(facetAnchor);
      channels = maybeNamed(channels);
      if (extraChannels !== void 0) channels = { ...maybeChannels(extraChannels), ...channels };
      if (defaults22 !== void 0) channels = { ...styles2(this, options, defaults22), ...channels };
      this.channels = Object.fromEntries(
        Object.entries(channels).map(([name, channel]) => {
          if (isOptions(channel.value)) {
            const { value, label = channel.label, scale: scale3 = channel.scale } = channel.value;
            channel = { ...channel, label, scale: scale3, value };
          }
          if (data === singleton && typeof channel.value === "string") {
            const { value } = channel;
            channel = { ...channel, value: [value] };
          }
          return [name, channel];
        }).filter(([name, { value, optional: optional2 }]) => {
          if (value != null) return true;
          if (optional2) return false;
          throw new Error(`missing channel value: ${name}`);
        })
      );
      this.dx = +dx;
      this.dy = +dy;
      this.marginTop = +marginTop;
      this.marginRight = +marginRight;
      this.marginBottom = +marginBottom;
      this.marginLeft = +marginLeft;
      this.clip = maybeClip(clip);
      this.tip = maybeTip(tip2);
      this.className = string(className);
      if (this.facet === "super") {
        if (fx || fy) throw new Error(`super-faceting cannot use fx or fy`);
        for (const name in this.channels) {
          const { scale: scale3 } = channels[name];
          if (scale3 !== "x" && scale3 !== "y") continue;
          throw new Error(`super-faceting cannot use x or y`);
        }
      }
      if (render != null) {
        this.render = composeRender(render, this.render);
      }
    }
    initialize(facets, facetChannels, plotOptions) {
      let data = dataify(this.data);
      if (facets === void 0 && data != null) facets = [range2(data)];
      const originalFacets = facets;
      if (this.transform != null) ({ facets, data } = this.transform(data, facets, plotOptions)), data = dataify(data);
      if (facets !== void 0) facets.original = originalFacets;
      const channels = createChannels(this.channels, data);
      if (this.sort != null) channelDomain(data, facets, channels, facetChannels, this.sort);
      return { data, facets, channels };
    }
    filter(index2, channels, values2) {
      for (const name in channels) {
        const { filter: filter5 = defined } = channels[name];
        if (filter5 !== null) {
          const value = values2[name];
          index2 = index2.filter((i5) => filter5(value[i5]));
        }
      }
      return index2;
    }
    // If there is a projection, and there are paired x and y channels associated
    // with the x and y scale respectively (and not already in screen coordinates
    // as with an initializer), then apply the projection, replacing the x and y
    // values. Note that the x and y scales themselves dont exist if there is a
    // projection, but whether the channels are associated with scales still
    // determines whether the projection should apply; think of the projection as
    // a combination xy-scale.
    project(channels, values2, context) {
      for (const cx in channels) {
        if (channels[cx].scale === "x" && /^x|x$/.test(cx)) {
          const cy = cx.replace(/^x|x$/, "y");
          if (cy in channels && channels[cy].scale === "y") {
            project(cx, cy, values2, context.projection);
          }
        }
      }
    }
    scale(channels, scales, context) {
      const values2 = valueObject(channels, scales);
      if (context.projection) this.project(channels, values2, context);
      return values2;
    }
  };
  function marks(...marks2) {
    marks2.plot = Mark.prototype.plot;
    return marks2;
  }
  function composeRender(r1, r22) {
    if (r1 == null) return r22 === null ? void 0 : r22;
    if (r22 == null) return r1 === null ? void 0 : r1;
    if (typeof r1 !== "function") throw new TypeError(`invalid render transform: ${r1}`);
    if (typeof r22 !== "function") throw new TypeError(`invalid render transform: ${r22}`);
    return function(i5, s8, v3, d3, c9, next) {
      return r1.call(this, i5, s8, v3, d3, c9, (i6, s9, v4, d4, c10) => {
        return r22.call(this, i6, s9, v4, d4, c10, next);
      });
    };
  }
  function maybeChannels(channels) {
    return Object.fromEntries(
      Object.entries(maybeNamed(channels)).map(([name, channel]) => {
        channel = typeof channel === "string" ? { value: channel, label: name } : maybeValue(channel);
        if (channel.filter === void 0 && channel.scale == null) channel = { ...channel, filter: null };
        return [name, channel];
      })
    );
  }
  function maybeTip(tip2) {
    return tip2 === true ? "xy" : tip2 === false || tip2 == null ? null : typeof tip2 === "string" ? keyword(tip2, "tip", ["x", "y", "xy"]) : tip2;
  }
  function withTip(options, pointer2) {
    return options?.tip === true ? { ...options, tip: pointer2 } : isObject(options?.tip) && options.tip.pointer === void 0 ? { ...options, tip: { ...options.tip, pointer: pointer2 } } : options;
  }

  // ../../../../../node_modules/@observablehq/plot/src/dimensions.js
  function createDimensions(scales, marks2, options = {}) {
    let marginTopDefault = 0.5 - offset, marginRightDefault = 0.5 + offset, marginBottomDefault = 0.5 + offset, marginLeftDefault = 0.5 - offset;
    for (const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } of marks2) {
      if (marginTop2 > marginTopDefault) marginTopDefault = marginTop2;
      if (marginRight2 > marginRightDefault) marginRightDefault = marginRight2;
      if (marginBottom2 > marginBottomDefault) marginBottomDefault = marginBottom2;
      if (marginLeft2 > marginLeftDefault) marginLeftDefault = marginLeft2;
    }
    let {
      margin,
      marginTop = margin !== void 0 ? margin : marginTopDefault,
      marginRight = margin !== void 0 ? margin : marginRightDefault,
      marginBottom = margin !== void 0 ? margin : marginBottomDefault,
      marginLeft = margin !== void 0 ? margin : marginLeftDefault
    } = options;
    marginTop = +marginTop;
    marginRight = +marginRight;
    marginBottom = +marginBottom;
    marginLeft = +marginLeft;
    let {
      width = 640,
      height = autoHeight(scales, options, {
        width,
        marginTopDefault,
        marginRightDefault,
        marginBottomDefault,
        marginLeftDefault
      }) + Math.max(0, marginTop - marginTopDefault + marginBottom - marginBottomDefault)
    } = options;
    width = +width;
    height = +height;
    const dimensions = {
      width,
      height,
      marginTop,
      marginRight,
      marginBottom,
      marginLeft
    };
    if (scales.fx || scales.fy) {
      let {
        margin: facetMargin,
        marginTop: facetMarginTop = facetMargin !== void 0 ? facetMargin : marginTop,
        marginRight: facetMarginRight = facetMargin !== void 0 ? facetMargin : marginRight,
        marginBottom: facetMarginBottom = facetMargin !== void 0 ? facetMargin : marginBottom,
        marginLeft: facetMarginLeft = facetMargin !== void 0 ? facetMargin : marginLeft
      } = options.facet ?? {};
      facetMarginTop = +facetMarginTop;
      facetMarginRight = +facetMarginRight;
      facetMarginBottom = +facetMarginBottom;
      facetMarginLeft = +facetMarginLeft;
      dimensions.facet = {
        marginTop: facetMarginTop,
        marginRight: facetMarginRight,
        marginBottom: facetMarginBottom,
        marginLeft: facetMarginLeft
      };
    }
    return dimensions;
  }
  function autoHeight({ x: x3, y: y3, fy, fx }, { projection: projection3, aspectRatio }, { width, marginTopDefault, marginRightDefault, marginBottomDefault, marginLeftDefault }) {
    const nfy = fy ? fy.scale.domain().length || 1 : 1;
    const ar = projectionAspectRatio(projection3);
    if (ar) {
      const nfx = fx ? fx.scale.domain().length : 1;
      const far = (1.1 * nfy - 0.1) / (1.1 * nfx - 0.1) * ar;
      const lar = Math.max(0.1, Math.min(10, far));
      return Math.round((width - marginLeftDefault - marginRightDefault) * lar + marginTopDefault + marginBottomDefault);
    }
    const ny = y3 ? isOrdinalScale(y3) ? y3.scale.domain().length || 1 : Math.max(7, 17 / nfy) : 1;
    if (aspectRatio != null) {
      aspectRatio = +aspectRatio;
      if (!(isFinite(aspectRatio) && aspectRatio > 0)) throw new Error(`invalid aspectRatio: ${aspectRatio}`);
      const ratio = aspectRatioLength("y", y3) / (aspectRatioLength("x", x3) * aspectRatio);
      const fxb = fx ? fx.scale.bandwidth() : 1;
      const fyb = fy ? fy.scale.bandwidth() : 1;
      const w2 = fxb * (width - marginLeftDefault - marginRightDefault) - x3.insetLeft - x3.insetRight;
      return (ratio * w2 + y3.insetTop + y3.insetBottom) / fyb + marginTopDefault + marginBottomDefault;
    }
    return !!(y3 || fy) * Math.max(1, Math.min(60, ny * nfy)) * 20 + !!fx * 30 + 60;
  }
  function aspectRatioLength(k3, scale3) {
    if (!scale3) throw new Error(`aspectRatio requires ${k3} scale`);
    const { type: type2, domain } = scale3;
    let transform3;
    switch (type2) {
      case "linear":
      case "utc":
      case "time":
        transform3 = Number;
        break;
      case "pow": {
        const exponent = scale3.scale.exponent();
        transform3 = (x3) => Math.pow(x3, exponent);
        break;
      }
      case "log":
        transform3 = Math.log;
        break;
      case "point":
      case "band":
        return domain.length;
      default:
        throw new Error(`unsupported ${k3} scale for aspectRatio: ${type2}`);
    }
    const [min4, max3] = extent(domain);
    return Math.abs(transform3(max3) - transform3(min4));
  }

  // ../../../../../node_modules/@observablehq/plot/src/interactions/pointer.js
  var states = /* @__PURE__ */ new WeakMap();
  function pointerK(kx2, ky2, { x: x3, y: y3, px, py, maxRadius = 40, channels, render, ...options } = {}) {
    maxRadius = +maxRadius;
    if (px != null) x3 ??= null, channels = { ...channels, px: { value: px, scale: "x" } };
    if (py != null) y3 ??= null, channels = { ...channels, py: { value: py, scale: "y" } };
    return {
      x: x3,
      y: y3,
      channels,
      ...options,
      // Unlike other composed transforms, the render transform must be the
      // outermost render function because it will re-render dynamically in
      // response to pointer events.
      render: composeRender(function(index2, scales, values2, dimensions, context, next) {
        context = { ...context, pointerSticky: false };
        const svg = context.ownerSVGElement;
        const { data } = context.getMarkState(this);
        let state = states.get(svg);
        if (!state) states.set(svg, state = { sticky: false, roots: [], renders: [] });
        let renderIndex = state.renders.push(render2) - 1;
        const { x: x4, y: y4, fx, fy } = scales;
        let tx = fx ? fx(index2.fx) - dimensions.marginLeft : 0;
        let ty = fy ? fy(index2.fy) - dimensions.marginTop : 0;
        if (x4?.bandwidth) tx += x4.bandwidth() / 2;
        if (y4?.bandwidth) ty += y4.bandwidth() / 2;
        const faceted = index2.fi != null;
        let facetState;
        if (faceted) {
          let facetStates = state.facetStates;
          if (!facetStates) state.facetStates = facetStates = /* @__PURE__ */ new Map();
          facetState = facetStates.get(this);
          if (!facetState) facetStates.set(this, facetState = /* @__PURE__ */ new Map());
        }
        const [cx, cy] = applyFrameAnchor(this, dimensions);
        const { px: PX, py: PY } = values2;
        const px2 = PX ? (i6) => PX[i6] : anchorX(values2, cx);
        const py2 = PY ? (i6) => PY[i6] : anchorY(values2, cy);
        let i5;
        let g2;
        let s8;
        let f7;
        function update(ii, ri) {
          if (faceted) {
            if (f7) f7 = cancelAnimationFrame(f7);
            if (ii == null) facetState.delete(index2.fi);
            else {
              facetState.set(index2.fi, ri);
              f7 = requestAnimationFrame(() => {
                f7 = null;
                for (const [fi, r6] of facetState) {
                  if (r6 < ri || r6 === ri && fi < index2.fi) {
                    ii = null;
                    break;
                  }
                }
                render2(ii);
              });
              return;
            }
          }
          render2(ii);
        }
        function render2(ii) {
          if (i5 === ii && s8 === state.sticky) return;
          i5 = ii;
          s8 = context.pointerSticky = state.sticky;
          const I2 = i5 == null ? [] : [i5];
          if (faceted) I2.fx = index2.fx, I2.fy = index2.fy, I2.fi = index2.fi;
          const r6 = next(I2, scales, values2, dimensions, context);
          if (g2) {
            if (faceted) {
              const p11 = g2.parentNode;
              const ft = g2.getAttribute("transform");
              const mt = r6.getAttribute("transform");
              ft ? r6.setAttribute("transform", ft) : r6.removeAttribute("transform");
              mt ? p11.setAttribute("transform", mt) : p11.removeAttribute("transform");
              r6.removeAttribute("aria-label");
              r6.removeAttribute("aria-description");
              r6.removeAttribute("aria-hidden");
            }
            g2.replaceWith(r6);
          }
          state.roots[renderIndex] = g2 = r6;
          if (!(i5 == null && facetState?.size > 1)) {
            const value = i5 == null ? null : isArray(data) ? data[i5] : data.get(i5);
            context.dispatchValue(value);
          }
          return r6;
        }
        function pointermove(event) {
          if (state.sticky || event.pointerType === "mouse" && event.buttons === 1) return;
          let [xp, yp] = pointer_default(event);
          xp -= tx, yp -= ty;
          const kpx = xp < dimensions.marginLeft || xp > dimensions.width - dimensions.marginRight ? 1 : kx2;
          const kpy = yp < dimensions.marginTop || yp > dimensions.height - dimensions.marginBottom ? 1 : ky2;
          let ii = null;
          let ri = maxRadius * maxRadius;
          for (const j2 of index2) {
            const dx = kpx * (px2(j2) - xp);
            const dy = kpy * (py2(j2) - yp);
            const rj = dx * dx + dy * dy;
            if (rj <= ri) ii = j2, ri = rj;
          }
          if (ii != null && (kx2 !== 1 || ky2 !== 1)) {
            const dx = px2(ii) - xp;
            const dy = py2(ii) - yp;
            ri = dx * dx + dy * dy;
          }
          update(ii, ri);
        }
        function pointerdown(event) {
          if (event.pointerType !== "mouse") return;
          if (i5 == null) return;
          if (state.sticky && state.roots.some((r6) => r6?.contains(event.target))) return;
          if (state.sticky) state.sticky = false, state.renders.forEach((r6) => r6(null));
          else state.sticky = true, render2(i5);
          event.stopImmediatePropagation();
        }
        function pointerleave(event) {
          if (event.pointerType !== "mouse") return;
          if (!state.sticky) update(null);
        }
        svg.addEventListener("pointerenter", pointermove);
        svg.addEventListener("pointermove", pointermove);
        svg.addEventListener("pointerdown", pointerdown);
        svg.addEventListener("pointerleave", pointerleave);
        return render2(null);
      }, render)
    };
  }
  function pointer(options) {
    return pointerK(1, 1, options);
  }
  function pointerX(options) {
    return pointerK(1, 0.01, options);
  }
  function pointerY(options) {
    return pointerK(0.01, 1, options);
  }
  function anchorX({ x1: X13, x2: X23, x: X3 = X13 }, cx) {
    return X13 && X23 ? (i5) => (X13[i5] + X23[i5]) / 2 : X3 ? (i5) => X3[i5] : () => cx;
  }
  function anchorY({ y1: Y13, y2: Y23, y: Y3 = Y13 }, cy) {
    return Y13 && Y23 ? (i5) => (Y13[i5] + Y23[i5]) / 2 : Y3 ? (i5) => Y3[i5] : () => cy;
  }

  // ../../../../../node_modules/@observablehq/plot/src/axes.js
  function inferFontVariant(scale3) {
    return isOrdinalScale(scale3) && scale3.interval === void 0 ? void 0 : "tabular-nums";
  }

  // ../../../../../node_modules/@observablehq/plot/src/legends/ramp.js
  function legendRamp(color3, options) {
    let {
      label = color3.label,
      tickSize = 6,
      width = 240,
      height = 44 + tickSize,
      marginTop = 18,
      marginRight = 0,
      marginBottom = 16 + tickSize,
      marginLeft = 0,
      style,
      ticks: ticks2 = (width - marginLeft - marginRight) / 64,
      tickFormat: tickFormat2,
      fontVariant = inferFontVariant(color3),
      round: round2 = true,
      opacity: opacity2,
      className
    } = options;
    const context = createContext(options);
    className = maybeClassName(className);
    opacity2 = maybeNumberChannel(opacity2)[1];
    if (tickFormat2 === null) tickFormat2 = () => null;
    const svg = create2("svg", context).attr("class", `${className}-ramp`).attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).call(
      (svg2) => (
        // Warning: if you edit this, change defaultClassName.
        svg2.append("style").text(
          `:where(.${className}-ramp) {
  display: block;
  height: auto;
  height: intrinsic;
  max-width: 100%;
  overflow: visible;
}
:where(.${className}-ramp text) {
  white-space: pre;
}`
        )
      )
    ).call(applyInlineStyles, style);
    let tickAdjust = (g2) => g2.selectAll(".tick line").attr("y1", marginTop + marginBottom - height);
    let x3;
    const applyRange = round2 ? (x4, range4) => x4.rangeRound(range4) : (x4, range4) => x4.range(range4);
    const { type: type2, domain, range: range3, interpolate, scale: scale3, pivot } = color3;
    if (interpolate) {
      const interpolator = range3 === void 0 ? interpolate : piecewise(interpolate.length === 1 ? interpolatePiecewise(interpolate) : interpolate, range3);
      x3 = applyRange(
        scale3.copy(),
        quantize_default(
          number_default(marginLeft, width - marginRight),
          Math.min(domain.length + (pivot !== void 0), range3 === void 0 ? Infinity : range3.length)
        )
      );
      const n9 = 256;
      const canvas = context.document.createElement("canvas");
      canvas.width = n9;
      canvas.height = 1;
      const context2 = canvas.getContext("2d");
      for (let i5 = 0, j2 = n9 - 1; i5 < n9; ++i5) {
        context2.fillStyle = interpolator(i5 / j2);
        context2.fillRect(i5, 0, 1, 1);
      }
      svg.append("image").attr("opacity", opacity2).attr("x", marginLeft).attr("y", marginTop).attr("width", width - marginLeft - marginRight).attr("height", height - marginTop - marginBottom).attr("preserveAspectRatio", "none").attr("xlink:href", canvas.toDataURL());
    } else if (type2 === "threshold") {
      const thresholds = domain;
      const thresholdFormat = tickFormat2 === void 0 ? (d3) => d3 : typeof tickFormat2 === "string" ? format(tickFormat2) : tickFormat2;
      x3 = applyRange(linear2().domain([-1, range3.length - 1]), [marginLeft, width - marginRight]);
      svg.append("g").attr("fill-opacity", opacity2).selectAll().data(range3).enter().append("rect").attr("x", (d3, i5) => x3(i5 - 1)).attr("y", marginTop).attr("width", (d3, i5) => x3(i5) - x3(i5 - 1)).attr("height", height - marginTop - marginBottom).attr("fill", (d3) => d3);
      ticks2 = map2(thresholds, (_2, i5) => i5);
      tickFormat2 = (i5) => thresholdFormat(thresholds[i5], i5);
    } else {
      x3 = applyRange(band().domain(domain), [marginLeft, width - marginRight]);
      svg.append("g").attr("fill-opacity", opacity2).selectAll().data(domain).enter().append("rect").attr("x", x3).attr("y", marginTop).attr("width", Math.max(0, x3.bandwidth() - 1)).attr("height", height - marginTop - marginBottom).attr("fill", scale3);
      tickAdjust = () => {
      };
    }
    svg.append("g").attr("transform", `translate(0,${height - marginBottom})`).call(
      axisBottom(x3).ticks(Array.isArray(ticks2) ? null : ticks2, typeof tickFormat2 === "string" ? tickFormat2 : void 0).tickFormat(typeof tickFormat2 === "function" ? tickFormat2 : void 0).tickSize(tickSize).tickValues(Array.isArray(ticks2) ? ticks2 : null)
    ).attr("font-size", null).attr("font-family", null).attr("font-variant", impliedString(fontVariant, "normal")).call(tickAdjust).call((g2) => g2.select(".domain").remove());
    if (label !== void 0) {
      svg.append("text").attr("x", marginLeft).attr("y", marginTop - 6).attr("fill", "currentColor").attr("font-weight", "bold").text(label);
    }
    return svg.node();
  }

  // ../../../../../node_modules/@observablehq/plot/src/math.js
  var radians3 = Math.PI / 180;

  // ../../../../../node_modules/@observablehq/plot/src/marker.js
  function markers(mark, { marker, markerStart = marker, markerMid = marker, markerEnd = marker } = {}) {
    mark.markerStart = maybeMarker(markerStart);
    mark.markerMid = maybeMarker(markerMid);
    mark.markerEnd = maybeMarker(markerEnd);
  }
  function maybeMarker(marker) {
    if (marker == null || marker === false) return null;
    if (marker === true) return markerCircleFill;
    if (typeof marker === "function") return marker;
    switch (`${marker}`.toLowerCase()) {
      case "none":
        return null;
      case "arrow":
        return markerArrow("auto");
      case "arrow-reverse":
        return markerArrow("auto-start-reverse");
      case "dot":
        return markerDot;
      case "circle":
      case "circle-fill":
        return markerCircleFill;
      case "circle-stroke":
        return markerCircleStroke;
      case "tick":
        return markerTick("auto");
      case "tick-x":
        return markerTick(90);
      case "tick-y":
        return markerTick(0);
    }
    throw new Error(`invalid marker: ${marker}`);
  }
  function markerArrow(orient) {
    return (color3, context) => create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("orient", orient).attr("fill", "none").attr("stroke", color3).attr("stroke-width", 1.5).attr("stroke-linecap", "round").attr("stroke-linejoin", "round").call((marker) => marker.append("path").attr("d", "M-1.5,-3l3,3l-3,3")).node();
  }
  function markerDot(color3, context) {
    return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color3).attr("stroke", "none").call((marker) => marker.append("circle").attr("r", 2.5)).node();
  }
  function markerCircleFill(color3, context) {
    return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", color3).attr("stroke", "var(--plot-background)").attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
  }
  function markerCircleStroke(color3, context) {
    return create2("svg:marker", context).attr("viewBox", "-5 -5 10 10").attr("markerWidth", 6.67).attr("markerHeight", 6.67).attr("fill", "var(--plot-background)").attr("stroke", color3).attr("stroke-width", 1.5).call((marker) => marker.append("circle").attr("r", 3)).node();
  }
  function markerTick(orient) {
    return (color3, context) => create2("svg:marker", context).attr("viewBox", "-3 -3 6 6").attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", orient).attr("stroke", color3).call((marker) => marker.append("path").attr("d", "M0,-3v6")).node();
  }
  var nextMarkerId = 0;
  function applyMarkers(path2, mark, { stroke: S3 }, context) {
    return applyMarkersColor(path2, mark, S3 && ((i5) => S3[i5]), null, context);
  }
  function applyGroupedMarkers(path2, mark, { stroke: S3, z: Z3 }, context) {
    return applyMarkersColor(path2, mark, S3 && (([i5]) => S3[i5]), Z3, context);
  }
  var START = 1;
  var END = 2;
  function getGroupedOrientation(path2, Z3) {
    const O = new Uint8Array(Z3.length);
    const D4 = path2.data().filter((I2) => I2.length > 1);
    const n9 = D4.length;
    for (let i5 = 0, z2 = unset; i5 < n9; ++i5) {
      const I2 = D4[i5];
      if (I2.length > 1) {
        const i6 = I2[0];
        if (z2 !== (z2 = keyof2(Z3[i6]))) O[i6] |= START;
      }
    }
    for (let i5 = n9 - 1, z2 = unset; i5 >= 0; --i5) {
      const I2 = D4[i5];
      if (I2.length > 1) {
        const i6 = I2[0];
        if (z2 !== (z2 = keyof2(Z3[i6]))) O[i6] |= END;
      }
    }
    return ([i5]) => O[i5];
  }
  function applyMarkersColor(path2, { markerStart, markerMid, markerEnd, stroke }, strokeof = () => stroke, Z3, context) {
    if (!markerStart && !markerMid && !markerEnd) return;
    const iriByMarkerColor = /* @__PURE__ */ new Map();
    const orient = Z3 && getGroupedOrientation(path2, Z3);
    function applyMarker(name, marker, filter5) {
      return function(i5) {
        if (filter5 && !filter5(i5)) return;
        const color3 = strokeof(i5);
        let iriByColor = iriByMarkerColor.get(marker);
        if (!iriByColor) iriByMarkerColor.set(marker, iriByColor = /* @__PURE__ */ new Map());
        let iri = iriByColor.get(color3);
        if (!iri) {
          const node = this.parentNode.insertBefore(marker(color3, context), this);
          const id2 = `plot-marker-${++nextMarkerId}`;
          node.setAttribute("id", id2);
          iriByColor.set(color3, iri = `url(#${id2})`);
        }
        this.setAttribute(name, iri);
      };
    }
    if (markerStart) path2.each(applyMarker("marker-start", markerStart, orient && ((i5) => orient(i5) & START)));
    if (markerMid && orient) path2.each(applyMarker("marker-start", markerMid, (i5) => !(orient(i5) & START)));
    if (markerMid) path2.each(applyMarker("marker-mid", markerMid));
    if (markerEnd) path2.each(applyMarker("marker-end", markerEnd, orient && ((i5) => orient(i5) & END)));
  }

  // ../../../../../node_modules/@observablehq/plot/src/transforms/inset.js
  function maybeInsetX({ inset, insetLeft, insetRight, ...options } = {}) {
    [insetLeft, insetRight] = maybeInset(inset, insetLeft, insetRight);
    return { inset, insetLeft, insetRight, ...options };
  }
  function maybeInsetY({ inset, insetTop, insetBottom, ...options } = {}) {
    [insetTop, insetBottom] = maybeInset(inset, insetTop, insetBottom);
    return { inset, insetTop, insetBottom, ...options };
  }
  function maybeInset(inset, inset1, inset2) {
    return inset === void 0 && inset1 === void 0 && inset2 === void 0 ? offset ? [1, 0] : [0.5, 0.5] : [inset1, inset2];
  }

  // ../../../../../node_modules/@observablehq/plot/src/transforms/interval.js
  function maybeIntervalValue(value, { interval: interval2 }) {
    value = { ...maybeValue(value) };
    value.interval = maybeInterval(value.interval === void 0 ? interval2 : value.interval);
    return value;
  }
  function maybeIntervalK(k3, maybeInsetK, options, trivial) {
    const { [k3]: v3, [`${k3}1`]: v1, [`${k3}2`]: v22 } = options;
    const { value, interval: interval2 } = maybeIntervalValue(v3, options);
    if (value == null || interval2 == null && !trivial) return options;
    const label = labelof(v3);
    if (interval2 == null) {
      let V2;
      const kv = { transform: (data) => V2 || (V2 = valueof(data, value)), label };
      return {
        ...options,
        [k3]: void 0,
        [`${k3}1`]: v1 === void 0 ? kv : v1,
        [`${k3}2`]: v22 === void 0 && !(v1 === v22 && trivial) ? kv : v22
      };
    }
    let D1, V1;
    function transform3(data) {
      if (V1 !== void 0 && data === D1) return V1;
      return V1 = map2(valueof(D1 = data, value), (v4) => interval2.floor(v4));
    }
    return maybeInsetK({
      ...options,
      [k3]: void 0,
      [`${k3}1`]: v1 === void 0 ? { transform: transform3, label } : v1,
      [`${k3}2`]: v22 === void 0 ? { transform: (data) => transform3(data).map((v4) => interval2.offset(v4)), label } : v22
    });
  }
  function maybeIntervalMidK(k3, maybeInsetK, options) {
    const { [k3]: v3 } = options;
    const { value, interval: interval2 } = maybeIntervalValue(v3, options);
    if (value == null || interval2 == null) return options;
    return maybeInsetK({
      ...options,
      [k3]: {
        label: labelof(v3),
        transform: (data) => {
          const V1 = map2(valueof(data, value), (v4) => interval2.floor(v4));
          const V2 = V1.map((v4) => interval2.offset(v4));
          return V1.map(
            isTemporal(V1) ? (v1, v22) => v1 == null || isNaN(v1 = +v1) || (v22 = V2[v22], v22 == null) || isNaN(v22 = +v22) ? void 0 : new Date((v1 + v22) / 2) : (v1, v22) => v1 == null || (v22 = V2[v22], v22 == null) ? NaN : (+v1 + +v22) / 2
          );
        }
      }
    });
  }
  function maybeTrivialIntervalX(options = {}) {
    return maybeIntervalK("x", maybeInsetX, options, true);
  }
  function maybeTrivialIntervalY(options = {}) {
    return maybeIntervalK("y", maybeInsetY, options, true);
  }
  function maybeIntervalX(options = {}) {
    return maybeIntervalK("x", maybeInsetX, options);
  }
  function maybeIntervalY(options = {}) {
    return maybeIntervalK("y", maybeInsetY, options);
  }
  function maybeIntervalMidX(options = {}) {
    return maybeIntervalMidK("x", maybeInsetX, options);
  }
  function maybeIntervalMidY(options = {}) {
    return maybeIntervalMidK("y", maybeInsetY, options);
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/rule.js
  var defaults = {
    ariaLabel: "rule",
    fill: null,
    stroke: "currentColor"
  };
  var RuleX = class extends Mark {
    constructor(data, options = {}) {
      const { x: x3, y1: y12, y2: y22, inset = 0, insetTop = inset, insetBottom = inset } = options;
      super(
        data,
        {
          x: { value: x3, scale: "x", optional: true },
          y1: { value: y12, scale: "y", optional: true },
          y2: { value: y22, scale: "y", optional: true }
        },
        withTip(options, "x"),
        defaults
      );
      this.insetTop = number5(insetTop);
      this.insetBottom = number5(insetBottom);
      markers(this, options);
    }
    render(index2, scales, channels, dimensions, context) {
      const { x: x3, y: y3 } = scales;
      const { x: X3, y1: Y13, y2: Y23 } = channels;
      const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;
      const { insetTop, insetBottom } = this;
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x3 }, offset, 0).call(
        (g2) => g2.selectAll().data(index2).enter().append("line").call(applyDirectStyles, this).attr("x1", X3 ? (i5) => X3[i5] : (marginLeft + width - marginRight) / 2).attr("x2", X3 ? (i5) => X3[i5] : (marginLeft + width - marginRight) / 2).attr("y1", Y13 && !isCollapsed(y3) ? (i5) => Y13[i5] + insetTop : marginTop + insetTop).attr(
          "y2",
          Y23 && !isCollapsed(y3) ? y3.bandwidth ? (i5) => Y23[i5] + y3.bandwidth() - insetBottom : (i5) => Y23[i5] - insetBottom : height - marginBottom - insetBottom
        ).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
      ).node();
    }
  };
  var RuleY = class extends Mark {
    constructor(data, options = {}) {
      const { x1: x12, x2: x22, y: y3, inset = 0, insetRight = inset, insetLeft = inset } = options;
      super(
        data,
        {
          y: { value: y3, scale: "y", optional: true },
          x1: { value: x12, scale: "x", optional: true },
          x2: { value: x22, scale: "x", optional: true }
        },
        withTip(options, "y"),
        defaults
      );
      this.insetRight = number5(insetRight);
      this.insetLeft = number5(insetLeft);
      markers(this, options);
    }
    render(index2, scales, channels, dimensions, context) {
      const { x: x3, y: y3 } = scales;
      const { y: Y3, x1: X13, x2: X23 } = channels;
      const { width, height, marginTop, marginRight, marginLeft, marginBottom } = dimensions;
      const { insetLeft, insetRight } = this;
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { y: Y3 && y3 }, 0, offset).call(
        (g2) => g2.selectAll().data(index2).enter().append("line").call(applyDirectStyles, this).attr("x1", X13 && !isCollapsed(x3) ? (i5) => X13[i5] + insetLeft : marginLeft + insetLeft).attr(
          "x2",
          X23 && !isCollapsed(x3) ? x3.bandwidth ? (i5) => X23[i5] + x3.bandwidth() - insetRight : (i5) => X23[i5] - insetRight : width - marginRight - insetRight
        ).attr("y1", Y3 ? (i5) => Y3[i5] : (marginTop + height - marginBottom) / 2).attr("y2", Y3 ? (i5) => Y3[i5] : (marginTop + height - marginBottom) / 2).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
      ).node();
    }
  };
  function ruleX(data, options) {
    let { x: x3 = identity6, y: y3, y1: y12, y2: y22, ...rest } = maybeIntervalY(options);
    [y12, y22] = maybeOptionalZero(y3, y12, y22);
    return new RuleX(data, { ...rest, x: x3, y1: y12, y2: y22 });
  }
  function ruleY(data, options) {
    let { y: y3 = identity6, x: x3, x1: x12, x2: x22, ...rest } = maybeIntervalX(options);
    [x12, x22] = maybeOptionalZero(x3, x12, x22);
    return new RuleY(data, { ...rest, y: y3, x1: x12, x2: x22 });
  }
  function maybeOptionalZero(x3, x12, x22) {
    if (x3 == null) {
      if (x12 === void 0) {
        if (x22 !== void 0) return [0, x22];
      } else {
        if (x22 === void 0) return [0, x12];
      }
    } else if (x12 === void 0) {
      return x22 === void 0 ? [0, x3] : [x3, x22];
    } else if (x22 === void 0) {
      return [x3, x12];
    }
    return [x12, x22];
  }

  // ../../../../../node_modules/@observablehq/plot/src/template.js
  function template(strings, ...parts) {
    let n9 = parts.length;
    for (let j2 = 0, copy3 = true; j2 < n9; ++j2) {
      if (typeof parts[j2] !== "function") {
        if (copy3) {
          strings = strings.slice();
          copy3 = false;
        }
        strings.splice(j2, 2, strings[j2] + parts[j2] + strings[j2 + 1]);
        parts.splice(j2, 1);
        --j2, --n9;
      }
    }
    return (i5) => {
      let s8 = strings[0];
      for (let j2 = 0; j2 < n9; ++j2) {
        s8 += parts[j2](i5) + strings[j2 + 1];
      }
      return s8;
    };
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/text.js
  var defaults2 = {
    ariaLabel: "text",
    strokeLinejoin: "round",
    strokeWidth: 3,
    paintOrder: "stroke"
  };
  var softHyphen = "\xAD";
  var Text = class extends Mark {
    constructor(data, options = {}) {
      const {
        x: x3,
        y: y3,
        text: text2 = isIterable(data) && isTextual(data) ? identity6 : indexOf,
        frameAnchor,
        textAnchor = /right$/i.test(frameAnchor) ? "end" : /left$/i.test(frameAnchor) ? "start" : "middle",
        lineAnchor = /^top/i.test(frameAnchor) ? "top" : /^bottom/i.test(frameAnchor) ? "bottom" : "middle",
        lineHeight = 1,
        lineWidth = Infinity,
        textOverflow,
        monospace,
        fontFamily = monospace ? "ui-monospace, monospace" : void 0,
        fontSize,
        fontStyle,
        fontVariant,
        fontWeight,
        rotate
      } = options;
      const [vrotate, crotate] = maybeNumberChannel(rotate, 0);
      const [vfontSize, cfontSize] = maybeFontSizeChannel(fontSize);
      super(
        data,
        {
          x: { value: x3, scale: "x", optional: true },
          y: { value: y3, scale: "y", optional: true },
          fontSize: { value: vfontSize, optional: true },
          rotate: { value: numberChannel(vrotate), optional: true },
          text: { value: text2, filter: nonempty, optional: true }
        },
        options,
        defaults2
      );
      this.rotate = crotate;
      this.textAnchor = impliedString(textAnchor, "middle");
      this.lineAnchor = keyword(lineAnchor, "lineAnchor", ["top", "middle", "bottom"]);
      this.lineHeight = +lineHeight;
      this.lineWidth = +lineWidth;
      this.textOverflow = maybeTextOverflow(textOverflow);
      this.monospace = !!monospace;
      this.fontFamily = string(fontFamily);
      this.fontSize = cfontSize;
      this.fontStyle = string(fontStyle);
      this.fontVariant = string(fontVariant);
      this.fontWeight = string(fontWeight);
      this.frameAnchor = maybeFrameAnchor(frameAnchor);
      if (!(this.lineWidth >= 0)) throw new Error(`invalid lineWidth: ${lineWidth}`);
      this.splitLines = splitter2(this);
      this.clipLine = clipper(this);
    }
    render(index2, scales, channels, dimensions, context) {
      const { x: x3, y: y3 } = scales;
      const { x: X3, y: Y3, rotate: R2, text: T2, title: TL, fontSize: FS } = channels;
      const { rotate } = this;
      const [cx, cy] = applyFrameAnchor(this, dimensions);
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this, T2, dimensions).call(applyTransform, this, { x: X3 && x3, y: Y3 && y3 }).call(
        (g2) => g2.selectAll().data(index2).enter().append("text").call(applyDirectStyles, this).call(applyMultilineText, this, T2, TL).attr(
          "transform",
          template`translate(${X3 ? (i5) => X3[i5] : cx},${Y3 ? (i5) => Y3[i5] : cy})${R2 ? (i5) => ` rotate(${R2[i5]})` : rotate ? ` rotate(${rotate})` : ``}`
        ).call(applyAttr, "font-size", FS && ((i5) => FS[i5])).call(applyChannelStyles, this, channels)
      ).node();
    }
  };
  function maybeTextOverflow(textOverflow) {
    return textOverflow == null ? null : keyword(textOverflow, "textOverflow", [
      "clip",
      // shorthand for clip-end
      "ellipsis",
      //  ellipsis-end
      "clip-start",
      "clip-end",
      "ellipsis-start",
      "ellipsis-middle",
      "ellipsis-end"
    ]).replace(/^(clip|ellipsis)$/, "$1-end");
  }
  function applyMultilineText(selection2, mark, T2, TL) {
    if (!T2) return;
    const { lineAnchor, lineHeight, textOverflow, splitLines, clipLine } = mark;
    selection2.each(function(i5) {
      const lines = splitLines(formatDefault(T2[i5]) ?? "").map(clipLine);
      const n9 = lines.length;
      const y3 = lineAnchor === "top" ? 0.71 : lineAnchor === "bottom" ? 1 - n9 : (164 - n9 * 100) / 200;
      if (n9 > 1) {
        let m3 = 0;
        for (let i6 = 0; i6 < n9; ++i6) {
          ++m3;
          if (!lines[i6]) continue;
          const tspan = this.ownerDocument.createElementNS(namespaces_default.svg, "tspan");
          tspan.setAttribute("x", 0);
          if (i6 === m3 - 1) tspan.setAttribute("y", `${(y3 + i6) * lineHeight}em`);
          else tspan.setAttribute("dy", `${m3 * lineHeight}em`);
          tspan.textContent = lines[i6];
          this.appendChild(tspan);
          m3 = 0;
        }
      } else {
        if (y3) this.setAttribute("y", `${y3 * lineHeight}em`);
        this.textContent = lines[0];
      }
      if (textOverflow && !TL && lines[0] !== T2[i5]) {
        const title = this.ownerDocument.createElementNS(namespaces_default.svg, "title");
        title.textContent = T2[i5];
        this.appendChild(title);
      }
    });
  }
  function text(data, { x: x3, y: y3, ...options } = {}) {
    if (options.frameAnchor === void 0) [x3, y3] = maybeTuple(x3, y3);
    return new Text(data, { ...options, x: x3, y: y3 });
  }
  function textX(data, { x: x3 = identity6, ...options } = {}) {
    return new Text(data, maybeIntervalMidY({ ...options, x: x3 }));
  }
  function textY(data, { y: y3 = identity6, ...options } = {}) {
    return new Text(data, maybeIntervalMidX({ ...options, y: y3 }));
  }
  function applyIndirectTextStyles(selection2, mark, T2) {
    applyAttr(selection2, "text-anchor", mark.textAnchor);
    applyAttr(selection2, "font-family", mark.fontFamily);
    applyAttr(selection2, "font-size", mark.fontSize);
    applyAttr(selection2, "font-style", mark.fontStyle);
    applyAttr(selection2, "font-variant", mark.fontVariant === void 0 ? inferFontVariant2(T2) : mark.fontVariant);
    applyAttr(selection2, "font-weight", mark.fontWeight);
  }
  function inferFontVariant2(T2) {
    return T2 && (isNumeric(T2) || isTemporal(T2)) ? "tabular-nums" : void 0;
  }
  var fontSizes = /* @__PURE__ */ new Set([
    // global keywords
    "inherit",
    "initial",
    "revert",
    "unset",
    // absolute keywords
    "xx-small",
    "x-small",
    "small",
    "medium",
    "large",
    "x-large",
    "xx-large",
    "xxx-large",
    // relative keywords
    "larger",
    "smaller"
  ]);
  function maybeFontSizeChannel(fontSize) {
    if (fontSize == null || typeof fontSize === "number") return [void 0, fontSize];
    if (typeof fontSize !== "string") return [fontSize, void 0];
    fontSize = fontSize.trim().toLowerCase();
    return fontSizes.has(fontSize) || /^[+-]?\d*\.?\d+(e[+-]?\d+)?(\w*|%)$/.test(fontSize) ? [void 0, fontSize] : [fontSize, void 0];
  }
  function lineWrap(input, maxWidth, widthof) {
    const lines = [];
    let lineStart, lineEnd = 0;
    for (const [wordStart, wordEnd, required2] of lineBreaks(input)) {
      if (lineStart === void 0) lineStart = wordStart;
      if (lineEnd > lineStart && widthof(input, lineStart, wordEnd) > maxWidth) {
        lines.push(input.slice(lineStart, lineEnd) + (input[lineEnd - 1] === softHyphen ? "-" : ""));
        lineStart = wordStart;
      }
      if (required2) {
        lines.push(input.slice(lineStart, wordEnd));
        lineStart = void 0;
        continue;
      }
      lineEnd = wordEnd;
    }
    return lines;
  }
  function* lineBreaks(input) {
    let i5 = 0, j2 = 0;
    const n9 = input.length;
    while (j2 < n9) {
      let k3 = 1;
      switch (input[j2]) {
        case softHyphen:
        case "-":
          ++j2;
          yield [i5, j2, false];
          i5 = j2;
          break;
        case " ":
          yield [i5, j2, false];
          while (input[++j2] === " ") ;
          i5 = j2;
          break;
        case "\r":
          if (input[j2 + 1] === "\n") ++k3;
        // falls through
        case "\n":
          yield [i5, j2, true];
          j2 += k3;
          i5 = j2;
          break;
        default:
          ++j2;
          break;
      }
    }
    yield [i5, j2, true];
  }
  var defaultWidthMap = {
    a: 56,
    b: 63,
    c: 57,
    d: 63,
    e: 58,
    f: 37,
    g: 62,
    h: 60,
    i: 26,
    j: 26,
    k: 55,
    l: 26,
    m: 88,
    n: 60,
    o: 60,
    p: 62,
    q: 62,
    r: 39,
    s: 54,
    t: 38,
    u: 60,
    v: 55,
    w: 79,
    x: 54,
    y: 55,
    z: 55,
    A: 69,
    B: 67,
    C: 73,
    D: 74,
    E: 61,
    F: 58,
    G: 76,
    H: 75,
    I: 28,
    J: 55,
    K: 67,
    L: 58,
    M: 89,
    N: 75,
    O: 78,
    P: 65,
    Q: 78,
    R: 67,
    S: 65,
    T: 65,
    U: 75,
    V: 69,
    W: 98,
    X: 69,
    Y: 67,
    Z: 67,
    0: 64,
    1: 48,
    2: 62,
    3: 64,
    4: 66,
    5: 63,
    6: 65,
    7: 58,
    8: 65,
    9: 65,
    " ": 29,
    "!": 32,
    '"': 49,
    "'": 31,
    "(": 39,
    ")": 39,
    ",": 31,
    "-": 48,
    ".": 31,
    "/": 32,
    ":": 31,
    ";": 31,
    "?": 52,
    "\u2018": 31,
    "\u2019": 31,
    "\u201C": 47,
    "\u201D": 47,
    "\u2026": 82
  };
  function defaultWidth(text2, start2 = 0, end = text2.length) {
    let sum3 = 0;
    for (let i5 = start2; i5 < end; i5 = readCharacter(text2, i5)) {
      sum3 += defaultWidthMap[text2[i5]] ?? (isPictographic(text2, i5) ? 120 : defaultWidthMap.e);
    }
    return sum3;
  }
  function monospaceWidth(text2, start2 = 0, end = text2.length) {
    let sum3 = 0;
    for (let i5 = start2; i5 < end; i5 = readCharacter(text2, i5)) {
      sum3 += isPictographic(text2, i5) ? 126 : 63;
    }
    return sum3;
  }
  function splitter2({ monospace, lineWidth, textOverflow }) {
    if (textOverflow != null || lineWidth == Infinity) return (text2) => text2.split(/\r\n?|\n/g);
    const widthof = monospace ? monospaceWidth : defaultWidth;
    const maxWidth = lineWidth * 100;
    return (text2) => lineWrap(text2, maxWidth, widthof);
  }
  function clipper({ monospace, lineWidth, textOverflow }) {
    if (textOverflow == null || lineWidth == Infinity) return (text2) => text2;
    const widthof = monospace ? monospaceWidth : defaultWidth;
    const maxWidth = lineWidth * 100;
    switch (textOverflow) {
      case "clip-start":
        return (text2) => clipStart(text2, maxWidth, widthof, "");
      case "clip-end":
        return (text2) => clipEnd(text2, maxWidth, widthof, "");
      case "ellipsis-start":
        return (text2) => clipStart(text2, maxWidth, widthof, ellipsis);
      case "ellipsis-middle":
        return (text2) => clipMiddle(text2, maxWidth, widthof, ellipsis);
      case "ellipsis-end":
        return (text2) => clipEnd(text2, maxWidth, widthof, ellipsis);
    }
  }
  var ellipsis = "\u2026";
  function cut(text2, width, widthof, inset) {
    const I2 = [];
    let w2 = 0;
    for (let i5 = 0, j2 = 0, n9 = text2.length; i5 < n9; i5 = j2) {
      j2 = readCharacter(text2, i5);
      const l8 = widthof(text2, i5, j2);
      if (w2 + l8 > width) {
        w2 += inset;
        while (w2 > width && i5 > 0) j2 = i5, i5 = I2.pop(), w2 -= widthof(text2, i5, j2);
        return [i5, width - w2];
      }
      w2 += l8;
      I2.push(i5);
    }
    return [-1, 0];
  }
  function clipEnd(text2, width, widthof, ellipsis2) {
    text2 = text2.trim();
    const e11 = widthof(ellipsis2);
    const [i5] = cut(text2, width, widthof, e11);
    return i5 < 0 ? text2 : text2.slice(0, i5).trimEnd() + ellipsis2;
  }
  function clipMiddle(text2, width, widthof, ellipsis2) {
    text2 = text2.trim();
    const w2 = widthof(text2);
    if (w2 <= width) return text2;
    const e11 = widthof(ellipsis2) / 2;
    const [i5, ei] = cut(text2, width / 2, widthof, e11);
    const [j2] = cut(text2, w2 - width / 2 - ei + e11, widthof, -e11);
    return j2 < 0 ? ellipsis2 : text2.slice(0, i5).trimEnd() + ellipsis2 + text2.slice(readCharacter(text2, j2)).trimStart();
  }
  function clipStart(text2, width, widthof, ellipsis2) {
    text2 = text2.trim();
    const w2 = widthof(text2);
    if (w2 <= width) return text2;
    const e11 = widthof(ellipsis2);
    const [j2] = cut(text2, w2 - width + e11, widthof, -e11);
    return j2 < 0 ? ellipsis2 : ellipsis2 + text2.slice(readCharacter(text2, j2)).trimStart();
  }
  var reCombiner = /[\p{Combining_Mark}\p{Emoji_Modifier}]+/uy;
  var rePictographic = /\p{Extended_Pictographic}/uy;
  function readCharacter(text2, i5) {
    i5 += isSurrogatePair(text2, i5) ? 2 : 1;
    if (isCombiner(text2, i5)) i5 = reCombiner.lastIndex;
    if (isZeroWidthJoiner(text2, i5)) return readCharacter(text2, i5 + 1);
    return i5;
  }
  function isAscii(text2, i5) {
    return text2.charCodeAt(i5) < 128;
  }
  function isSurrogatePair(text2, i5) {
    const hi = text2.charCodeAt(i5);
    if (hi >= 55296 && hi < 56320) {
      const lo = text2.charCodeAt(i5 + 1);
      return lo >= 56320 && lo < 57344;
    }
    return false;
  }
  function isZeroWidthJoiner(text2, i5) {
    return text2.charCodeAt(i5) === 8205;
  }
  function isCombiner(text2, i5) {
    return isAscii(text2, i5) ? false : (reCombiner.lastIndex = i5, reCombiner.test(text2));
  }
  function isPictographic(text2, i5) {
    return isAscii(text2, i5) ? false : (rePictographic.lastIndex = i5, rePictographic.test(text2));
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/vector.js
  var defaults3 = {
    ariaLabel: "vector",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 1.5,
    strokeLinejoin: "round",
    strokeLinecap: "round"
  };
  var defaultRadius = 3.5;
  var wingRatio = defaultRadius * 5;
  var shapeArrow = {
    draw(context, l8, r6) {
      const wing = l8 * r6 / wingRatio;
      context.moveTo(0, 0);
      context.lineTo(0, -l8);
      context.moveTo(-wing, wing - l8);
      context.lineTo(0, -l8);
      context.lineTo(wing, wing - l8);
    }
  };
  var shapeSpike = {
    draw(context, l8, r6) {
      context.moveTo(-r6, 0);
      context.lineTo(0, -l8);
      context.lineTo(r6, 0);
    }
  };
  var shapes = /* @__PURE__ */ new Map([
    ["arrow", shapeArrow],
    ["spike", shapeSpike]
  ]);
  function isShapeObject(value) {
    return value && typeof value.draw === "function";
  }
  function maybeShape(shape2) {
    if (isShapeObject(shape2)) return shape2;
    const value = shapes.get(`${shape2}`.toLowerCase());
    if (value) return value;
    throw new Error(`invalid shape: ${shape2}`);
  }
  var Vector = class extends Mark {
    constructor(data, options = {}) {
      const { x: x3, y: y3, r: r6 = defaultRadius, length: length4, rotate, shape: shape2 = shapeArrow, anchor = "middle", frameAnchor } = options;
      const [vl, cl] = maybeNumberChannel(length4, 12);
      const [vr, cr] = maybeNumberChannel(rotate, 0);
      super(
        data,
        {
          x: { value: x3, scale: "x", optional: true },
          y: { value: y3, scale: "y", optional: true },
          length: { value: vl, scale: "length", optional: true },
          rotate: { value: vr, optional: true }
        },
        options,
        defaults3
      );
      this.r = +r6;
      this.length = cl;
      this.rotate = cr;
      this.shape = maybeShape(shape2);
      this.anchor = keyword(anchor, "anchor", ["start", "middle", "end"]);
      this.frameAnchor = maybeFrameAnchor(frameAnchor);
    }
    render(index2, scales, channels, dimensions, context) {
      const { x: x3, y: y3 } = scales;
      const { x: X3, y: Y3, length: L2, rotate: A5 } = channels;
      const { length: length4, rotate, anchor, shape: shape2, r: r6 } = this;
      const [cx, cy] = applyFrameAnchor(this, dimensions);
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x3, y: Y3 && y3 }).call(
        (g2) => g2.selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).attr(
          "transform",
          template`translate(${X3 ? (i5) => X3[i5] : cx},${Y3 ? (i5) => Y3[i5] : cy})${A5 ? (i5) => ` rotate(${A5[i5]})` : rotate ? ` rotate(${rotate})` : ``}${anchor === "start" ? `` : anchor === "end" ? L2 ? (i5) => ` translate(0,${L2[i5]})` : ` translate(0,${length4})` : L2 ? (i5) => ` translate(0,${L2[i5] / 2})` : ` translate(0,${length4 / 2})`}`
        ).attr(
          "d",
          L2 ? (i5) => {
            const p11 = pathRound();
            shape2.draw(p11, L2[i5], r6);
            return p11;
          } : (() => {
            const p11 = pathRound();
            shape2.draw(p11, length4, r6);
            return p11;
          })()
        ).call(applyChannelStyles, this, channels)
      ).node();
    }
  };
  function vector(data, options = {}) {
    let { x: x3, y: y3, ...rest } = options;
    if (options.frameAnchor === void 0) [x3, y3] = maybeTuple(x3, y3);
    return new Vector(data, { ...rest, x: x3, y: y3 });
  }
  function vectorX(data, options = {}) {
    const { x: x3 = identity6, ...rest } = options;
    return new Vector(data, { ...rest, x: x3 });
  }
  function vectorY(data, options = {}) {
    const { y: y3 = identity6, ...rest } = options;
    return new Vector(data, { ...rest, y: y3 });
  }
  function spike(data, options = {}) {
    const {
      shape: shape2 = shapeSpike,
      stroke = defaults3.stroke,
      strokeWidth = 1,
      fill = stroke,
      fillOpacity = 0.3,
      anchor = "start",
      ...rest
    } = options;
    return vector(data, { ...rest, shape: shape2, stroke, strokeWidth, fill, fillOpacity, anchor });
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/axis.js
  function maybeData(data, options) {
    if (arguments.length < 2 && !isIterable(data)) options = data, data = null;
    if (options === void 0) options = {};
    return [data, options];
  }
  function maybeAnchor2({ anchor } = {}, anchors) {
    return anchor === void 0 ? anchors[0] : keyword(anchor, "anchor", anchors);
  }
  function anchorY2(options) {
    return maybeAnchor2(options, ["left", "right"]);
  }
  function anchorFy(options) {
    return maybeAnchor2(options, ["right", "left"]);
  }
  function anchorX2(options) {
    return maybeAnchor2(options, ["bottom", "top"]);
  }
  function anchorFx(options) {
    return maybeAnchor2(options, ["top", "bottom"]);
  }
  function axisY() {
    const [data, options] = maybeData(...arguments);
    return axisKy("y", anchorY2(options), data, options);
  }
  function axisFy() {
    const [data, options] = maybeData(...arguments);
    return axisKy("fy", anchorFy(options), data, options);
  }
  function axisX() {
    const [data, options] = maybeData(...arguments);
    return axisKx("x", anchorX2(options), data, options);
  }
  function axisFx() {
    const [data, options] = maybeData(...arguments);
    return axisKx("fx", anchorFx(options), data, options);
  }
  function axisKy(k3, anchor, data, {
    color: color3 = "currentColor",
    opacity: opacity2 = 1,
    stroke = color3,
    strokeOpacity = opacity2,
    strokeWidth = 1,
    fill = color3,
    fillOpacity = opacity2,
    textAnchor,
    textStroke,
    textStrokeOpacity,
    textStrokeWidth,
    tickSize = k3 === "y" ? 6 : 0,
    tickPadding,
    tickRotate,
    x: x3,
    margin,
    marginTop = margin === void 0 ? 20 : margin,
    marginRight = margin === void 0 ? anchor === "right" ? 40 : 0 : margin,
    marginBottom = margin === void 0 ? 20 : margin,
    marginLeft = margin === void 0 ? anchor === "left" ? 40 : 0 : margin,
    label,
    labelAnchor,
    labelArrow,
    labelOffset,
    ariaLabel = `${k3}-axis`,
    ...options
  }) {
    tickSize = number5(tickSize);
    tickPadding = number5(tickPadding);
    tickRotate = number5(tickRotate);
    if (labelAnchor !== void 0) labelAnchor = keyword(labelAnchor, "labelAnchor", ["center", "top", "bottom"]);
    labelArrow = maybeLabelArrow(labelArrow);
    return marks(
      tickSize && !isNoneish(stroke) ? axisTickKy(k3, anchor, data, {
        stroke,
        strokeOpacity,
        strokeWidth,
        tickSize,
        tickPadding,
        tickRotate,
        x: x3,
        ariaLabel,
        ...options
      }) : null,
      !isNoneish(fill) ? axisTextKy(k3, anchor, data, {
        fill,
        fillOpacity,
        stroke: textStroke,
        strokeOpacity: textStrokeOpacity,
        strokeWidth: textStrokeWidth,
        textAnchor,
        tickSize,
        tickPadding,
        tickRotate,
        x: x3,
        marginTop,
        marginRight,
        marginBottom,
        marginLeft,
        ariaLabel,
        ...options
      }) : null,
      !isNoneish(fill) && label !== null ? text(
        [],
        labelOptions({ fill, fillOpacity, ...options }, function(data2, facets, channels, scales, dimensions) {
          const scale3 = scales[k3];
          const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = k3 === "y" && dimensions.inset || dimensions;
          const cla = labelAnchor ?? (scale3.bandwidth ? "center" : "top");
          const clo = labelOffset ?? (anchor === "right" ? marginRight2 : marginLeft2) - 3;
          if (cla === "center") {
            this.textAnchor = void 0;
            this.lineAnchor = anchor === "right" ? "bottom" : "top";
            this.frameAnchor = anchor;
            this.rotate = -90;
          } else {
            this.textAnchor = anchor === "right" ? "end" : "start";
            this.lineAnchor = cla;
            this.frameAnchor = `${cla}-${anchor}`;
            this.rotate = 0;
          }
          this.dy = cla === "top" ? 3 - marginTop2 : cla === "bottom" ? marginBottom2 - 3 : 0;
          this.dx = anchor === "right" ? clo : -clo;
          this.ariaLabel = `${ariaLabel} label`;
          return {
            facets: [[0]],
            channels: { text: { value: [formatAxisLabel(k3, scale3, { anchor, label, labelAnchor: cla, labelArrow })] } }
          };
        })
      ) : null
    );
  }
  function axisKx(k3, anchor, data, {
    color: color3 = "currentColor",
    opacity: opacity2 = 1,
    stroke = color3,
    strokeOpacity = opacity2,
    strokeWidth = 1,
    fill = color3,
    fillOpacity = opacity2,
    textAnchor,
    textStroke,
    textStrokeOpacity,
    textStrokeWidth,
    tickSize = k3 === "x" ? 6 : 0,
    tickPadding,
    tickRotate,
    y: y3,
    margin,
    marginTop = margin === void 0 ? anchor === "top" ? 30 : 0 : margin,
    marginRight = margin === void 0 ? 20 : margin,
    marginBottom = margin === void 0 ? anchor === "bottom" ? 30 : 0 : margin,
    marginLeft = margin === void 0 ? 20 : margin,
    label,
    labelAnchor,
    labelArrow,
    labelOffset,
    ariaLabel = `${k3}-axis`,
    ...options
  }) {
    tickSize = number5(tickSize);
    tickPadding = number5(tickPadding);
    tickRotate = number5(tickRotate);
    if (labelAnchor !== void 0) labelAnchor = keyword(labelAnchor, "labelAnchor", ["center", "left", "right"]);
    labelArrow = maybeLabelArrow(labelArrow);
    return marks(
      tickSize && !isNoneish(stroke) ? axisTickKx(k3, anchor, data, {
        stroke,
        strokeOpacity,
        strokeWidth,
        tickSize,
        tickPadding,
        tickRotate,
        y: y3,
        ariaLabel,
        ...options
      }) : null,
      !isNoneish(fill) ? axisTextKx(k3, anchor, data, {
        fill,
        fillOpacity,
        stroke: textStroke,
        strokeOpacity: textStrokeOpacity,
        strokeWidth: textStrokeWidth,
        textAnchor,
        tickSize,
        tickPadding,
        tickRotate,
        y: y3,
        marginTop,
        marginRight,
        marginBottom,
        marginLeft,
        ariaLabel,
        ...options
      }) : null,
      !isNoneish(fill) && label !== null ? text(
        [],
        labelOptions({ fill, fillOpacity, ...options }, function(data2, facets, channels, scales, dimensions) {
          const scale3 = scales[k3];
          const { marginTop: marginTop2, marginRight: marginRight2, marginBottom: marginBottom2, marginLeft: marginLeft2 } = k3 === "x" && dimensions.inset || dimensions;
          const cla = labelAnchor ?? (scale3.bandwidth ? "center" : "right");
          const clo = labelOffset ?? (anchor === "top" ? marginTop2 : marginBottom2) - 3;
          if (cla === "center") {
            this.frameAnchor = anchor;
            this.textAnchor = void 0;
          } else {
            this.frameAnchor = `${anchor}-${cla}`;
            this.textAnchor = cla === "right" ? "end" : "start";
          }
          this.lineAnchor = anchor;
          this.dy = anchor === "top" ? -clo : clo;
          this.dx = cla === "right" ? marginRight2 - 3 : cla === "left" ? 3 - marginLeft2 : 0;
          this.ariaLabel = `${ariaLabel} label`;
          return {
            facets: [[0]],
            channels: { text: { value: [formatAxisLabel(k3, scale3, { anchor, label, labelAnchor: cla, labelArrow })] } }
          };
        })
      ) : null
    );
  }
  function axisTickKy(k3, anchor, data, {
    strokeWidth = 1,
    strokeLinecap = null,
    strokeLinejoin = null,
    facetAnchor = anchor + (k3 === "y" ? "-empty" : ""),
    frameAnchor = anchor,
    tickSize,
    inset = 0,
    insetLeft = inset,
    insetRight = inset,
    dx = 0,
    y: y3 = k3 === "y" ? void 0 : null,
    ariaLabel,
    ...options
  }) {
    return axisMark(
      vectorY,
      k3,
      data,
      {
        ariaLabel: `${ariaLabel} tick`,
        ariaHidden: true
      },
      {
        strokeWidth,
        strokeLinecap,
        strokeLinejoin,
        facetAnchor,
        frameAnchor,
        y: y3,
        ...options,
        dx: anchor === "left" ? +dx - offset + +insetLeft : +dx + offset - insetRight,
        anchor: "start",
        length: tickSize,
        shape: anchor === "left" ? shapeTickLeft : shapeTickRight
      }
    );
  }
  function axisTickKx(k3, anchor, data, {
    strokeWidth = 1,
    strokeLinecap = null,
    strokeLinejoin = null,
    facetAnchor = anchor + (k3 === "x" ? "-empty" : ""),
    frameAnchor = anchor,
    tickSize,
    inset = 0,
    insetTop = inset,
    insetBottom = inset,
    dy = 0,
    x: x3 = k3 === "x" ? void 0 : null,
    ariaLabel,
    ...options
  }) {
    return axisMark(
      vectorX,
      k3,
      data,
      {
        ariaLabel: `${ariaLabel} tick`,
        ariaHidden: true
      },
      {
        strokeWidth,
        strokeLinejoin,
        strokeLinecap,
        facetAnchor,
        frameAnchor,
        x: x3,
        ...options,
        dy: anchor === "bottom" ? +dy - offset - insetBottom : +dy + offset + +insetTop,
        anchor: "start",
        length: tickSize,
        shape: anchor === "bottom" ? shapeTickBottom : shapeTickTop
      }
    );
  }
  function axisTextKy(k3, anchor, data, {
    facetAnchor = anchor + (k3 === "y" ? "-empty" : ""),
    frameAnchor = anchor,
    tickSize,
    tickRotate = 0,
    tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) > 60 ? 4 * Math.cos(tickRotate * radians3) : 0),
    text: text2,
    textAnchor = Math.abs(tickRotate) > 60 ? "middle" : anchor === "left" ? "end" : "start",
    lineAnchor = tickRotate > 60 ? "top" : tickRotate < -60 ? "bottom" : "middle",
    fontVariant,
    inset = 0,
    insetLeft = inset,
    insetRight = inset,
    dx = 0,
    ariaLabel,
    y: y3 = k3 === "y" ? void 0 : null,
    ...options
  }) {
    return axisMark(
      textY,
      k3,
      data,
      { ariaLabel: `${ariaLabel} tick label` },
      {
        facetAnchor,
        frameAnchor,
        text: text2,
        textAnchor,
        lineAnchor,
        fontVariant,
        rotate: tickRotate,
        y: y3,
        ...options,
        dx: anchor === "left" ? +dx - tickSize - tickPadding + +insetLeft : +dx + +tickSize + +tickPadding - insetRight
      },
      function(scale3, data2, ticks2, tickFormat2, channels) {
        if (fontVariant === void 0) this.fontVariant = inferFontVariant3(scale3);
        if (text2 === void 0) channels.text = inferTextChannel(scale3, data2, ticks2, tickFormat2, anchor);
      }
    );
  }
  function axisTextKx(k3, anchor, data, {
    facetAnchor = anchor + (k3 === "x" ? "-empty" : ""),
    frameAnchor = anchor,
    tickSize,
    tickRotate = 0,
    tickPadding = Math.max(3, 9 - tickSize) + (Math.abs(tickRotate) >= 10 ? 4 * Math.cos(tickRotate * radians3) : 0),
    text: text2,
    textAnchor = Math.abs(tickRotate) >= 10 ? tickRotate < 0 ^ anchor === "bottom" ? "start" : "end" : "middle",
    lineAnchor = Math.abs(tickRotate) >= 10 ? "middle" : anchor === "bottom" ? "top" : "bottom",
    fontVariant,
    inset = 0,
    insetTop = inset,
    insetBottom = inset,
    dy = 0,
    x: x3 = k3 === "x" ? void 0 : null,
    ariaLabel,
    ...options
  }) {
    return axisMark(
      textX,
      k3,
      data,
      { ariaLabel: `${ariaLabel} tick label` },
      {
        facetAnchor,
        frameAnchor,
        text: text2 === void 0 ? null : text2,
        textAnchor,
        lineAnchor,
        fontVariant,
        rotate: tickRotate,
        x: x3,
        ...options,
        dy: anchor === "bottom" ? +dy + +tickSize + +tickPadding - insetBottom : +dy - tickSize - tickPadding + +insetTop
      },
      function(scale3, data2, ticks2, tickFormat2, channels) {
        if (fontVariant === void 0) this.fontVariant = inferFontVariant3(scale3);
        if (text2 === void 0) channels.text = inferTextChannel(scale3, data2, ticks2, tickFormat2, anchor);
      }
    );
  }
  function gridY() {
    const [data, options] = maybeData(...arguments);
    return gridKy("y", anchorY2(options), data, options);
  }
  function gridFy() {
    const [data, options] = maybeData(...arguments);
    return gridKy("fy", anchorFy(options), data, options);
  }
  function gridX() {
    const [data, options] = maybeData(...arguments);
    return gridKx("x", anchorX2(options), data, options);
  }
  function gridFx() {
    const [data, options] = maybeData(...arguments);
    return gridKx("fx", anchorFx(options), data, options);
  }
  function gridKy(k3, anchor, data, {
    y: y3 = k3 === "y" ? void 0 : null,
    x: x3 = null,
    x1: x12 = anchor === "left" ? x3 : null,
    x2: x22 = anchor === "right" ? x3 : null,
    ariaLabel = `${k3}-grid`,
    ariaHidden = true,
    ...options
  }) {
    return axisMark(ruleY, k3, data, { ariaLabel, ariaHidden }, { y: y3, x1: x12, x2: x22, ...gridDefaults(options) });
  }
  function gridKx(k3, anchor, data, {
    x: x3 = k3 === "x" ? void 0 : null,
    y: y3 = null,
    y1: y12 = anchor === "top" ? y3 : null,
    y2: y22 = anchor === "bottom" ? y3 : null,
    ariaLabel = `${k3}-grid`,
    ariaHidden = true,
    ...options
  }) {
    return axisMark(ruleX, k3, data, { ariaLabel, ariaHidden }, { x: x3, y1: y12, y2: y22, ...gridDefaults(options) });
  }
  function gridDefaults({
    color: color3 = "currentColor",
    opacity: opacity2 = 0.1,
    stroke = color3,
    strokeOpacity = opacity2,
    strokeWidth = 1,
    ...options
  }) {
    return { stroke, strokeOpacity, strokeWidth, ...options };
  }
  function labelOptions({
    fill,
    fillOpacity,
    fontFamily,
    fontSize,
    fontStyle,
    fontVariant,
    fontWeight,
    monospace,
    pointerEvents,
    shapeRendering,
    clip = false
  }, initializer2) {
    [, fill] = maybeColorChannel(fill);
    [, fillOpacity] = maybeNumberChannel(fillOpacity);
    return {
      facet: "super",
      x: null,
      y: null,
      fill,
      fillOpacity,
      fontFamily,
      fontSize,
      fontStyle,
      fontVariant,
      fontWeight,
      monospace,
      pointerEvents,
      shapeRendering,
      clip,
      initializer: initializer2
    };
  }
  function axisMark(mark, k3, data, properties, options, initialize) {
    let channels;
    function axisInitializer(data2, facets, _channels, scales, dimensions, context) {
      const initializeFacets = data2 == null && (k3 === "fx" || k3 === "fy");
      const { [k3]: scale3 } = scales;
      if (!scale3) throw new Error(`missing scale: ${k3}`);
      const domain = scale3.domain();
      let { interval: interval2, ticks: ticks2, tickFormat: tickFormat2, tickSpacing = k3 === "x" ? 80 : 35 } = options;
      if (typeof ticks2 === "string" && hasTemporalDomain(scale3)) interval2 = ticks2, ticks2 = void 0;
      if (ticks2 === void 0) ticks2 = maybeRangeInterval(interval2, scale3.type) ?? inferTickCount(scale3, tickSpacing);
      if (data2 == null) {
        if (isIterable(ticks2)) {
          data2 = arrayify2(ticks2);
        } else if (isInterval(ticks2)) {
          data2 = inclusiveRange(ticks2, ...extent(domain));
        } else if (scale3.interval) {
          let interval3 = scale3.interval;
          if (scale3.ticks) {
            const [min4, max3] = extent(domain);
            const n9 = (max3 - min4) / interval3[intervalDuration];
            interval3 = generalizeTimeInterval(interval3, n9 / ticks2) ?? interval3;
            data2 = inclusiveRange(interval3, min4, max3);
          } else {
            data2 = domain;
            const n9 = data2.length;
            interval3 = generalizeTimeInterval(interval3, n9 / ticks2) ?? interval3;
            if (interval3 !== scale3.interval) data2 = inclusiveRange(interval3, ...extent(data2));
          }
          if (interval3 === scale3.interval) {
            const n9 = Math.round(data2.length / ticks2);
            if (n9 > 1) data2 = data2.filter((d3, i5) => i5 % n9 === 0);
          }
        } else if (scale3.ticks) {
          data2 = scale3.ticks(ticks2);
        } else {
          data2 = domain;
        }
        if (!scale3.ticks && data2.length && data2 !== domain) {
          const domainSet = new InternSet(domain);
          data2 = data2.filter((d3) => domainSet.has(d3));
          if (!data2.length) warn(`Warning: the ${k3}-axis ticks appear to not align with the scale domain, resulting in no ticks. Try different ticks?`);
        }
        if (k3 === "y" || k3 === "x") {
          facets = [range2(data2)];
        } else {
          channels[k3] = { scale: k3, value: identity6 };
        }
      }
      initialize?.call(this, scale3, data2, ticks2, tickFormat2, channels);
      const initializedChannels = Object.fromEntries(
        Object.entries(channels).map(([name, channel]) => {
          return [name, { ...channel, value: valueof(data2, channel.value) }];
        })
      );
      if (initializeFacets) facets = context.filterFacets(data2, initializedChannels);
      return { data: data2, facets, channels: initializedChannels };
    }
    const basicInitializer = initializer(options).initializer;
    const m3 = mark(data, initializer({ ...options, initializer: axisInitializer }, basicInitializer));
    if (data == null) {
      channels = m3.channels;
      m3.channels = {};
    } else {
      channels = {};
    }
    if (properties !== void 0) Object.assign(m3, properties);
    if (m3.clip === void 0) m3.clip = false;
    return m3;
  }
  function inferTickCount(scale3, tickSpacing) {
    const [min4, max3] = extent(scale3.range());
    return (max3 - min4) / tickSpacing;
  }
  function inferTextChannel(scale3, data, ticks2, tickFormat2, anchor) {
    return { value: inferTickFormat(scale3, data, ticks2, tickFormat2, anchor) };
  }
  function inferTickFormat(scale3, data, ticks2, tickFormat2, anchor) {
    return typeof tickFormat2 === "function" && !(scale3.type === "log" && scale3.tickFormat) ? tickFormat2 : tickFormat2 === void 0 && data && isTemporal(data) ? inferTimeFormat(scale3.type, data, anchor) ?? formatDefault : scale3.tickFormat ? scale3.tickFormat(typeof ticks2 === "number" ? ticks2 : null, tickFormat2) : typeof tickFormat2 === "string" && scale3.domain().length > 0 ? (isTemporal(scale3.domain()) ? utcFormat : format)(tickFormat2) : tickFormat2 === void 0 ? formatDefault : constant(tickFormat2);
  }
  function inclusiveRange(interval2, min4, max3) {
    return interval2.range(min4, interval2.offset(interval2.floor(max3)));
  }
  var shapeTickBottom = {
    draw(context, l8) {
      context.moveTo(0, 0);
      context.lineTo(0, l8);
    }
  };
  var shapeTickTop = {
    draw(context, l8) {
      context.moveTo(0, 0);
      context.lineTo(0, -l8);
    }
  };
  var shapeTickLeft = {
    draw(context, l8) {
      context.moveTo(0, 0);
      context.lineTo(-l8, 0);
    }
  };
  var shapeTickRight = {
    draw(context, l8) {
      context.moveTo(0, 0);
      context.lineTo(l8, 0);
    }
  };
  function inferFontVariant3(scale3) {
    return scale3.bandwidth && !scale3.interval ? void 0 : "tabular-nums";
  }
  function formatAxisLabel(k3, scale3, { anchor, label = scale3.label, labelAnchor, labelArrow } = {}) {
    if (label == null || label.inferred && hasTemporalDomain(scale3) && /^(date|time|year)$/i.test(label)) return;
    label = String(label);
    if (labelArrow === "auto") labelArrow = (!scale3.bandwidth || scale3.interval) && !/[]/.test(label);
    if (!labelArrow) return label;
    if (labelArrow === true) {
      const order = inferScaleOrder(scale3);
      if (order)
        labelArrow = /x$/.test(k3) || labelAnchor === "center" ? /x$/.test(k3) === order < 0 ? "left" : "right" : order < 0 ? "up" : "down";
    }
    switch (labelArrow) {
      case "left":
        return `\u2190 ${label}`;
      case "right":
        return `${label} \u2192`;
      case "up":
        return anchor === "right" ? `${label} \u2191` : `\u2191 ${label}`;
      case "down":
        return anchor === "right" ? `${label} \u2193` : `\u2193 ${label}`;
    }
    return label;
  }
  function maybeLabelArrow(labelArrow = "auto") {
    return isNoneish(labelArrow) ? false : typeof labelArrow === "boolean" ? labelArrow : keyword(labelArrow, "labelArrow", ["auto", "up", "right", "down", "left"]);
  }
  function hasTemporalDomain(scale3) {
    return isTemporal(scale3.domain());
  }

  // ../../../../../node_modules/@observablehq/plot/src/legends/swatches.js
  function maybeScale(scale3, key) {
    if (key == null) return key;
    const s8 = scale3(key);
    if (!s8) throw new Error(`scale not found: ${key}`);
    return s8;
  }
  function legendSwatches(color3, { opacity: opacity2, ...options } = {}) {
    if (!isOrdinalScale(color3) && !isThresholdScale(color3))
      throw new Error(`swatches legend requires ordinal or threshold color scale (not ${color3.type})`);
    return legendItems(
      color3,
      options,
      (selection2, scale3, width, height) => selection2.append("svg").attr("width", width).attr("height", height).attr("fill", scale3.scale).attr("fill-opacity", maybeNumberChannel(opacity2)[1]).append("rect").attr("width", "100%").attr("height", "100%")
    );
  }
  function legendSymbols(symbol3, {
    fill = symbol3.hint?.fill !== void 0 ? symbol3.hint.fill : "none",
    fillOpacity = 1,
    stroke = symbol3.hint?.stroke !== void 0 ? symbol3.hint.stroke : isNoneish(fill) ? "currentColor" : "none",
    strokeOpacity = 1,
    strokeWidth = 1.5,
    r: r6 = 4.5,
    ...options
  } = {}, scale3) {
    const [vf, cf] = maybeColorChannel(fill);
    const [vs, cs] = maybeColorChannel(stroke);
    const sf = maybeScale(scale3, vf);
    const ss = maybeScale(scale3, vs);
    const size = r6 * r6 * Math.PI;
    fillOpacity = maybeNumberChannel(fillOpacity)[1];
    strokeOpacity = maybeNumberChannel(strokeOpacity)[1];
    strokeWidth = maybeNumberChannel(strokeWidth)[1];
    return legendItems(
      symbol3,
      options,
      (selection2, scale4, width, height) => selection2.append("svg").attr("viewBox", "-8 -8 16 16").attr("width", width).attr("height", height).attr("fill", vf === "color" ? (d3) => sf.scale(d3) : cf).attr("fill-opacity", fillOpacity).attr("stroke", vs === "color" ? (d3) => ss.scale(d3) : cs).attr("stroke-opacity", strokeOpacity).attr("stroke-width", strokeWidth).append("path").attr("d", (d3) => {
        const p11 = pathRound();
        symbol3.scale(d3).draw(p11, size);
        return p11;
      })
    );
  }
  function legendItems(scale3, options = {}, swatch) {
    let {
      columns,
      tickFormat: tickFormat2,
      fontVariant = inferFontVariant(scale3),
      // TODO label,
      swatchSize = 15,
      swatchWidth = swatchSize,
      swatchHeight = swatchSize,
      marginLeft = 0,
      className,
      style,
      width
    } = options;
    const context = createContext(options);
    className = maybeClassName(className);
    tickFormat2 = inferTickFormat(scale3.scale, scale3.domain, void 0, tickFormat2);
    const swatches = create2("div", context).attr(
      "class",
      `${className}-swatches ${className}-swatches-${columns != null ? "columns" : "wrap"}`
    );
    let extraStyle;
    if (columns != null) {
      extraStyle = `:where(.${className}-swatches-columns .${className}-swatch) {
  display: flex;
  align-items: center;
  break-inside: avoid;
  padding-bottom: 1px;
}
:where(.${className}-swatches-columns .${className}-swatch::before) {
  flex-shrink: 0;
}
:where(.${className}-swatches-columns .${className}-swatch-label) {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}`;
      swatches.style("columns", columns).selectAll().data(scale3.domain).enter().append("div").attr("class", `${className}-swatch`).call(swatch, scale3, swatchWidth, swatchHeight).call(
        (item) => item.append("div").attr("class", `${className}-swatch-label`).attr("title", tickFormat2).text(tickFormat2)
      );
    } else {
      extraStyle = `:where(.${className}-swatches-wrap) {
  display: flex;
  align-items: center;
  min-height: 33px;
  flex-wrap: wrap;
}
:where(.${className}-swatches-wrap .${className}-swatch) {
  display: inline-flex;
  align-items: center;
  margin-right: 1em;
}`;
      swatches.selectAll().data(scale3.domain).enter().append("span").attr("class", `${className}-swatch`).call(swatch, scale3, swatchWidth, swatchHeight).append(function() {
        return this.ownerDocument.createTextNode(tickFormat2.apply(this, arguments));
      });
    }
    return swatches.call(
      (div) => div.insert("style", "*").text(
        `:where(.${className}-swatches) {
  font-family: system-ui, sans-serif;
  font-size: 10px;
  margin-bottom: 0.5em;
}
:where(.${className}-swatch > svg) {
  margin-right: 0.5em;
  overflow: visible;
}
${extraStyle}`
      )
    ).style("margin-left", marginLeft ? `${+marginLeft}px` : null).style("width", width === void 0 ? null : `${+width}px`).style("font-variant", impliedString(fontVariant, "normal")).call(applyInlineStyles, style).node();
  }

  // ../../../../../node_modules/@observablehq/plot/src/legends.js
  var legendRegistry = /* @__PURE__ */ new Map([
    ["symbol", legendSymbols],
    ["color", legendColor],
    ["opacity", legendOpacity]
  ]);
  function legend(options = {}) {
    for (const [key, value] of legendRegistry) {
      const scale3 = options[key];
      if (isScaleOptions(scale3)) {
        const context = createContext(options);
        let hint;
        if (key === "symbol") {
          const { fill, stroke = fill === void 0 && isScaleOptions(options.color) ? "color" : void 0 } = options;
          hint = { fill, stroke };
        }
        return value(
          normalizeScale(key, scale3, hint),
          legendOptions(context, scale3, options),
          (key2) => isScaleOptions(options[key2]) ? normalizeScale(key2, options[key2]) : null
        );
      }
    }
    throw new Error("unknown legend type; no scale found");
  }
  function exposeLegends(scales, context, defaults22 = {}) {
    return (key, options) => {
      if (!legendRegistry.has(key)) throw new Error(`unknown legend type: ${key}`);
      if (!(key in scales)) return;
      return legendRegistry.get(key)(scales[key], legendOptions(context, defaults22[key], options), (key2) => scales[key2]);
    };
  }
  function legendOptions({ className, ...context }, { label, ticks: ticks2, tickFormat: tickFormat2 } = {}, options) {
    return inherit2(options, { className, ...context }, { label, ticks: ticks2, tickFormat: tickFormat2 });
  }
  function legendColor(color3, { legend: legend2 = true, ...options }) {
    if (legend2 === true) legend2 = color3.type === "ordinal" ? "swatches" : "ramp";
    if (color3.domain === void 0) return;
    switch (`${legend2}`.toLowerCase()) {
      case "swatches":
        return legendSwatches(color3, options);
      case "ramp":
        return legendRamp(color3, options);
      default:
        throw new Error(`unknown legend type: ${legend2}`);
    }
  }
  function legendOpacity({ type: type2, interpolate, ...scale3 }, { legend: legend2 = true, color: color3 = rgb(0, 0, 0), ...options }) {
    if (!interpolate) throw new Error(`${type2} opacity scales are not supported`);
    if (legend2 === true) legend2 = "ramp";
    if (`${legend2}`.toLowerCase() !== "ramp") throw new Error(`${legend2} opacity legends are not supported`);
    return legendColor({ type: type2, ...scale3, interpolate: interpolateOpacity(color3) }, { legend: legend2, ...options });
  }
  function interpolateOpacity(color3) {
    const { r: r6, g: g2, b: b2 } = rgb(color3) || rgb(0, 0, 0);
    return (t5) => `rgba(${r6},${g2},${b2},${t5})`;
  }
  function createLegends(scales, context, options) {
    const legends = [];
    for (const [key, value] of legendRegistry) {
      const o12 = options[key];
      if (o12?.legend && key in scales) {
        const legend2 = value(scales[key], legendOptions(context, scales[key], o12), (key2) => scales[key2]);
        if (legend2 != null) legends.push(legend2);
      }
    }
    return legends;
  }

  // ../../../../../node_modules/@observablehq/plot/src/transforms/identity.js
  function maybeIdentityX(options = {}, k3 = "x") {
    return hasX(options) ? options : { ...options, [k3]: identity6 };
  }
  function maybeIdentityY(options = {}, k3 = "y") {
    return hasY(options) ? options : { ...options, [k3]: identity6 };
  }

  // ../../../../../node_modules/@observablehq/plot/src/transforms/exclusiveFacets.js
  function exclusiveFacets(data, facets) {
    if (facets.length === 1) return { data, facets };
    const n9 = lengthof(data);
    const O = new Uint8Array(n9);
    let overlaps = 0;
    for (const facet of facets) {
      for (const i5 of facet) {
        if (O[i5]) ++overlaps;
        O[i5] = 1;
      }
    }
    if (overlaps === 0) return { data, facets };
    data = slice3(data);
    const R2 = data[reindex] = new Uint32Array(n9 + overlaps);
    facets = facets.map((facet) => slice3(facet, Uint32Array));
    let j2 = n9;
    O.fill(0);
    for (const facet of facets) {
      for (let k3 = 0, m3 = facet.length; k3 < m3; ++k3) {
        const i5 = facet[k3];
        if (O[i5]) facet[k3] = j2, data[j2] = data[i5], R2[j2] = i5, ++j2;
        else R2[i5] = i5;
        O[i5] = 1;
      }
    }
    return { data, facets };
  }

  // ../../../../../node_modules/@observablehq/plot/src/transforms/stack.js
  function stackX(stackOptions = {}, options = {}) {
    if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);
    const { y1: y12, y: y3 = y12, x: x3, ...rest } = options;
    const [transform3, Y3, x12, x22] = stack2(y3, x3, "y", "x", stackOptions, rest);
    return { ...transform3, y1: y12, y: Y3, x1: x12, x2: x22, x: mid(x12, x22) };
  }
  function stackX1(stackOptions = {}, options = {}) {
    if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);
    const { y1: y12, y: y3 = y12, x: x3 } = options;
    const [transform3, Y3, X3] = stack2(y3, x3, "y", "x", stackOptions, options);
    return { ...transform3, y1: y12, y: Y3, x: X3 };
  }
  function stackX2(stackOptions = {}, options = {}) {
    if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);
    const { y1: y12, y: y3 = y12, x: x3 } = options;
    const [transform3, Y3, , X3] = stack2(y3, x3, "y", "x", stackOptions, options);
    return { ...transform3, y1: y12, y: Y3, x: X3 };
  }
  function stackY(stackOptions = {}, options = {}) {
    if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);
    const { x1: x12, x: x3 = x12, y: y3, ...rest } = options;
    const [transform3, X3, y12, y22] = stack2(x3, y3, "x", "y", stackOptions, rest);
    return { ...transform3, x1: x12, x: X3, y1: y12, y2: y22, y: mid(y12, y22) };
  }
  function stackY1(stackOptions = {}, options = {}) {
    if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);
    const { x1: x12, x: x3 = x12, y: y3 } = options;
    const [transform3, X3, Y3] = stack2(x3, y3, "x", "y", stackOptions, options);
    return { ...transform3, x1: x12, x: X3, y: Y3 };
  }
  function stackY2(stackOptions = {}, options = {}) {
    if (arguments.length === 1) [stackOptions, options] = mergeOptions(stackOptions);
    const { x1: x12, x: x3 = x12, y: y3 } = options;
    const [transform3, X3, , Y3] = stack2(x3, y3, "x", "y", stackOptions, options);
    return { ...transform3, x1: x12, x: X3, y: Y3 };
  }
  function maybeStackX({ x: x3, x1: x12, x2: x22, ...options } = {}) {
    options = withTip(options, "y");
    if (x12 === void 0 && x22 === void 0) return stackX({ x: x3, ...options });
    [x12, x22] = maybeZero(x3, x12, x22);
    return { ...options, x1: x12, x2: x22 };
  }
  function maybeStackY({ y: y3, y1: y12, y2: y22, ...options } = {}) {
    options = withTip(options, "x");
    if (y12 === void 0 && y22 === void 0) return stackY({ y: y3, ...options });
    [y12, y22] = maybeZero(y3, y12, y22);
    return { ...options, y1: y12, y2: y22 };
  }
  function mergeOptions(options) {
    const { offset: offset2, order, reverse: reverse3, ...rest } = options;
    return [{ offset: offset2, order, reverse: reverse3 }, rest];
  }
  var lengthy = { length: true };
  function stack2(x3, y3 = one3, kx2, ky2, { offset: offset2, order, reverse: reverse3 }, options) {
    if (y3 === null) throw new Error(`stack requires ${ky2}`);
    const z2 = maybeZ(options);
    const [X3, setX] = maybeColumn(x3);
    const [Y13, setY1] = column(y3);
    const [Y23, setY2] = column(y3);
    Y13.hint = Y23.hint = lengthy;
    offset2 = maybeOffset(offset2);
    order = maybeOrder2(order, offset2, ky2);
    return [
      basic(options, (data, facets, plotOptions) => {
        ({ data, facets } = exclusiveFacets(data, facets));
        const X4 = x3 == null ? void 0 : setX(maybeApplyInterval(valueof(data, x3), plotOptions?.[kx2]));
        const Y3 = valueof(data, y3, Float64Array);
        const Z3 = valueof(data, z2);
        const compare = order && order(data, X4, Y3, Z3);
        const n9 = lengthof(data);
        const Y14 = setY1(new Float64Array(n9));
        const Y24 = setY2(new Float64Array(n9));
        const facetstacks = [];
        for (const facet of facets) {
          const stacks = X4 ? Array.from(group(facet, (i5) => X4[i5]).values()) : [facet];
          if (compare) for (const stack3 of stacks) stack3.sort(compare);
          for (const stack3 of stacks) {
            let yn2 = 0;
            let yp = 0;
            if (reverse3) stack3.reverse();
            for (const i5 of stack3) {
              const y4 = Y3[i5];
              if (y4 < 0) yn2 = Y24[i5] = (Y14[i5] = yn2) + y4;
              else if (y4 > 0) yp = Y24[i5] = (Y14[i5] = yp) + y4;
              else Y24[i5] = Y14[i5] = yp;
            }
          }
          facetstacks.push(stacks);
        }
        if (offset2) offset2(facetstacks, Y14, Y24, Z3);
        return { data, facets };
      }),
      X3,
      Y13,
      Y23
    ];
  }
  function maybeOffset(offset2) {
    if (offset2 == null) return;
    if (typeof offset2 === "function") return offset2;
    switch (`${offset2}`.toLowerCase()) {
      case "expand":
      case "normalize":
        return offsetExpand;
      case "center":
      case "silhouette":
        return offsetCenter;
      case "wiggle":
        return offsetWiggle;
    }
    throw new Error(`unknown offset: ${offset2}`);
  }
  function extent2(stack3, Y23) {
    let min4 = 0, max3 = 0;
    for (const i5 of stack3) {
      const y3 = Y23[i5];
      if (y3 < min4) min4 = y3;
      if (y3 > max3) max3 = y3;
    }
    return [min4, max3];
  }
  function offsetExpand(facetstacks, Y13, Y23) {
    for (const stacks of facetstacks) {
      for (const stack3 of stacks) {
        const [yn2, yp] = extent2(stack3, Y23);
        for (const i5 of stack3) {
          const m3 = 1 / (yp - yn2 || 1);
          Y13[i5] = m3 * (Y13[i5] - yn2);
          Y23[i5] = m3 * (Y23[i5] - yn2);
        }
      }
    }
  }
  function offsetCenter(facetstacks, Y13, Y23) {
    for (const stacks of facetstacks) {
      for (const stack3 of stacks) {
        const [yn2, yp] = extent2(stack3, Y23);
        for (const i5 of stack3) {
          const m3 = (yp + yn2) / 2;
          Y13[i5] -= m3;
          Y23[i5] -= m3;
        }
      }
      offsetZero(stacks, Y13, Y23);
    }
    offsetCenterFacets(facetstacks, Y13, Y23);
  }
  function offsetWiggle(facetstacks, Y13, Y23, Z3) {
    for (const stacks of facetstacks) {
      const prev = new InternMap();
      let y3 = 0;
      for (const stack3 of stacks) {
        let j2 = -1;
        const Fi = stack3.map((i5) => Math.abs(Y23[i5] - Y13[i5]));
        const Df = stack3.map((i5) => {
          j2 = Z3 ? Z3[i5] : ++j2;
          const value = Y23[i5] - Y13[i5];
          const diff = prev.has(j2) ? value - prev.get(j2) : 0;
          prev.set(j2, value);
          return diff;
        });
        const Cf1 = [0, ...cumsum(Df)];
        for (const i5 of stack3) {
          Y13[i5] += y3;
          Y23[i5] += y3;
        }
        const s1 = sum(Fi);
        if (s1) y3 -= sum(Fi, (d3, i5) => (Df[i5] / 2 + Cf1[i5]) * d3) / s1;
      }
      offsetZero(stacks, Y13, Y23);
    }
    offsetCenterFacets(facetstacks, Y13, Y23);
  }
  function offsetZero(stacks, Y13, Y23) {
    const m3 = min(stacks, (stack3) => min(stack3, (i5) => Y13[i5]));
    for (const stack3 of stacks) {
      for (const i5 of stack3) {
        Y13[i5] -= m3;
        Y23[i5] -= m3;
      }
    }
  }
  function offsetCenterFacets(facetstacks, Y13, Y23) {
    const n9 = facetstacks.length;
    if (n9 === 1) return;
    const facets = facetstacks.map((stacks) => stacks.flat());
    const m3 = facets.map((I2) => (min(I2, (i5) => Y13[i5]) + max(I2, (i5) => Y23[i5])) / 2);
    const m0 = min(m3);
    for (let j2 = 0; j2 < n9; j2++) {
      const p11 = m0 - m3[j2];
      for (const i5 of facets[j2]) {
        Y13[i5] += p11;
        Y23[i5] += p11;
      }
    }
  }
  function maybeOrder2(order, offset2, ky2) {
    if (order === void 0 && offset2 === offsetWiggle) return orderInsideOut(ascendingDefined2);
    if (order == null) return;
    if (typeof order === "string") {
      const negate3 = order.startsWith("-");
      const compare = negate3 ? descendingDefined : ascendingDefined2;
      switch ((negate3 ? order.slice(1) : order).toLowerCase()) {
        case "value":
        case ky2:
          return orderY(compare);
        case "z":
          return orderZ(compare);
        case "sum":
          return orderSum(compare);
        case "appearance":
          return orderAppearance(compare);
        case "inside-out":
          return orderInsideOut(compare);
      }
      return orderAccessor(field(order));
    }
    if (typeof order === "function") return (order.length === 1 ? orderAccessor : orderComparator)(order);
    if (isArray(order)) return orderGiven(order);
    throw new Error(`invalid order: ${order}`);
  }
  function orderY(compare) {
    return (data, X3, Y3) => (i5, j2) => compare(Y3[i5], Y3[j2]);
  }
  function orderZ(compare) {
    return (data, X3, Y3, Z3) => (i5, j2) => compare(Z3[i5], Z3[j2]);
  }
  function orderSum(compare) {
    return orderZDomain(
      compare,
      (data, X3, Y3, Z3) => groupSort(
        range2(data),
        (I2) => sum(I2, (i5) => Y3[i5]),
        (i5) => Z3[i5]
      )
    );
  }
  function orderAppearance(compare) {
    return orderZDomain(
      compare,
      (data, X3, Y3, Z3) => groupSort(
        range2(data),
        (I2) => X3[greatest(I2, (i5) => Y3[i5])],
        (i5) => Z3[i5]
      )
    );
  }
  function orderInsideOut(compare) {
    return orderZDomain(compare, (data, X3, Y3, Z3) => {
      const I2 = range2(data);
      const K2 = groupSort(
        I2,
        (I3) => X3[greatest(I3, (i5) => Y3[i5])],
        (i5) => Z3[i5]
      );
      const sums = rollup(
        I2,
        (I3) => sum(I3, (i5) => Y3[i5]),
        (i5) => Z3[i5]
      );
      const Kp = [], Kn = [];
      let s8 = 0;
      for (const k3 of K2) {
        if (s8 < 0) {
          s8 += sums.get(k3);
          Kp.push(k3);
        } else {
          s8 -= sums.get(k3);
          Kn.push(k3);
        }
      }
      return Kn.reverse().concat(Kp);
    });
  }
  function orderAccessor(f7) {
    return (data) => {
      const O = valueof(data, f7);
      return (i5, j2) => ascendingDefined2(O[i5], O[j2]);
    };
  }
  function orderComparator(f7) {
    return (data) => {
      return isArray(data) ? (i5, j2) => f7(data[i5], data[j2]) : (i5, j2) => f7(data.get(i5), data.get(j2));
    };
  }
  function orderGiven(domain) {
    return orderZDomain(ascendingDefined2, () => domain);
  }
  function orderZDomain(compare, domain) {
    return (data, X3, Y3, Z3) => {
      if (!Z3) throw new Error("missing channel: z");
      const map4 = new InternMap(domain(data, X3, Y3, Z3).map((d3, i5) => [d3, i5]));
      return (i5, j2) => compare(map4.get(Z3[i5]), map4.get(Z3[j2]));
    };
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/rect.js
  var defaults4 = {
    ariaLabel: "rect"
  };
  var Rect = class extends Mark {
    constructor(data, options = {}) {
      const { x1: x12, y1: y12, x2: x22, y2: y22 } = options;
      super(
        data,
        {
          x1: { value: x12, scale: "x", type: x12 != null && x22 == null ? "band" : void 0, optional: true },
          y1: { value: y12, scale: "y", type: y12 != null && y22 == null ? "band" : void 0, optional: true },
          x2: { value: x22, scale: "x", optional: true },
          y2: { value: y22, scale: "y", optional: true }
        },
        options,
        defaults4
      );
      rectInsets(this, options);
      rectRadii(this, options);
    }
    render(index2, scales, channels, dimensions, context) {
      const { x: x3, y: y3 } = scales;
      let { x1: X13, y1: Y13, x2: X23, y2: Y23 } = channels;
      const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;
      const { projection: projection3 } = context;
      const { insetTop, insetRight, insetBottom, insetLeft } = this;
      const { rx, ry, rx1y1, rx1y2, rx2y1, rx2y2 } = this;
      if ((X13 || X23) && !projection3 && isCollapsed(x3)) X13 = X23 = null;
      if ((Y13 || Y23) && !projection3 && isCollapsed(y3)) Y13 = Y23 = null;
      const bx = x3?.bandwidth ? x3.bandwidth() : 0;
      const by = y3?.bandwidth ? y3.bandwidth() : 0;
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}, 0, 0).call(
        (g2) => g2.selectAll().data(index2).enter().call(
          rx1y1 || rx1y2 || rx2y1 || rx2y2 ? (g3) => g3.append("path").call(applyDirectStyles, this).call(
            applyRoundedRect,
            X13 && X23 ? (i5) => X13[i5] + (X23[i5] < X13[i5] ? -insetRight : insetLeft) : X13 ? (i5) => X13[i5] + insetLeft : marginLeft + insetLeft,
            Y13 && Y23 ? (i5) => Y13[i5] + (Y23[i5] < Y13[i5] ? -insetBottom : insetTop) : Y13 ? (i5) => Y13[i5] + insetTop : marginTop + insetTop,
            X13 && X23 ? (i5) => X23[i5] - (X23[i5] < X13[i5] ? -insetLeft : insetRight) : X13 ? (i5) => X13[i5] + bx - insetRight : width - marginRight - insetRight,
            Y13 && Y23 ? (i5) => Y23[i5] - (Y23[i5] < Y13[i5] ? -insetTop : insetBottom) : Y13 ? (i5) => Y13[i5] + by - insetBottom : height - marginBottom - insetBottom,
            this
          ).call(applyChannelStyles, this, channels) : (g3) => g3.append("rect").call(applyDirectStyles, this).attr(
            "x",
            X13 ? X23 ? (i5) => Math.min(X13[i5], X23[i5]) + insetLeft : (i5) => X13[i5] + insetLeft : marginLeft + insetLeft
          ).attr(
            "y",
            Y13 ? Y23 ? (i5) => Math.min(Y13[i5], Y23[i5]) + insetTop : (i5) => Y13[i5] + insetTop : marginTop + insetTop
          ).attr(
            "width",
            X13 ? X23 ? (i5) => Math.max(0, Math.abs(X23[i5] - X13[i5]) + bx - insetLeft - insetRight) : bx - insetLeft - insetRight : width - marginRight - marginLeft - insetRight - insetLeft
          ).attr(
            "height",
            Y13 ? Y23 ? (i5) => Math.max(0, Math.abs(Y13[i5] - Y23[i5]) + by - insetTop - insetBottom) : by - insetTop - insetBottom : height - marginTop - marginBottom - insetTop - insetBottom
          ).call(applyAttr, "rx", rx).call(applyAttr, "ry", ry).call(applyChannelStyles, this, channels)
        )
      ).node();
    }
  };
  function rectInsets(mark, { inset = 0, insetTop = inset, insetRight = inset, insetBottom = inset, insetLeft = inset } = {}) {
    mark.insetTop = number5(insetTop);
    mark.insetRight = number5(insetRight);
    mark.insetBottom = number5(insetBottom);
    mark.insetLeft = number5(insetLeft);
  }
  function rectRadii(mark, {
    r: r6,
    rx,
    // for elliptic corners
    ry,
    // for elliptic corners
    rx1 = r6,
    ry1 = r6,
    rx2 = r6,
    ry2 = r6,
    rx1y1 = rx1 !== void 0 ? +rx1 : ry1 !== void 0 ? +ry1 : 0,
    rx1y2 = rx1 !== void 0 ? +rx1 : ry2 !== void 0 ? +ry2 : 0,
    rx2y1 = rx2 !== void 0 ? +rx2 : ry1 !== void 0 ? +ry1 : 0,
    rx2y2 = rx2 !== void 0 ? +rx2 : ry2 !== void 0 ? +ry2 : 0
  } = {}) {
    if (rx1y1 || rx1y2 || rx2y1 || rx2y2) {
      mark.rx1y1 = rx1y1;
      mark.rx1y2 = rx1y2;
      mark.rx2y1 = rx2y1;
      mark.rx2y2 = rx2y2;
    } else {
      mark.rx = impliedString(rx, "auto");
      mark.ry = impliedString(ry, "auto");
    }
  }
  function applyRoundedRect(selection2, X13, Y13, X23, Y23, mark) {
    const { rx1y1: r11, rx1y2: r12, rx2y1: r21, rx2y2: r22 } = mark;
    if (typeof X13 !== "function") X13 = constant(X13);
    if (typeof Y13 !== "function") Y13 = constant(Y13);
    if (typeof X23 !== "function") X23 = constant(X23);
    if (typeof Y23 !== "function") Y23 = constant(Y23);
    const rx = Math.max(Math.abs(r11 + r21), Math.abs(r12 + r22));
    const ry = Math.max(Math.abs(r11 + r12), Math.abs(r21 + r22));
    selection2.attr("d", (i5) => {
      const x12 = X13(i5);
      const y12 = Y13(i5);
      const x22 = X23(i5);
      const y22 = Y23(i5);
      const ix = x12 > x22;
      const iy = y12 > y22;
      const l8 = ix ? x22 : x12;
      const r6 = ix ? x12 : x22;
      const t5 = iy ? y22 : y12;
      const b2 = iy ? y12 : y22;
      const k3 = Math.min(1, (r6 - l8) / rx, (b2 - t5) / ry);
      const tl = k3 * (ix ? iy ? r22 : r21 : iy ? r12 : r11);
      const tr = k3 * (ix ? iy ? r12 : r11 : iy ? r22 : r21);
      const br = k3 * (ix ? iy ? r11 : r12 : iy ? r21 : r22);
      const bl = k3 * (ix ? iy ? r21 : r22 : iy ? r11 : r12);
      return `M${l8},${t5 + biasY(tl, bl)}A${tl},${tl} 0 0 ${tl < 0 ? 0 : 1} ${l8 + biasX(tl, bl)},${t5}H${r6 - biasX(tr, br)}A${tr},${tr} 0 0 ${tr < 0 ? 0 : 1} ${r6},${t5 + biasY(tr, br)}V${b2 - biasY(br, tr)}A${br},${br} 0 0 ${br < 0 ? 0 : 1} ${r6 - biasX(br, tr)},${b2}H${l8 + biasX(bl, tl)}A${bl},${bl} 0 0 ${bl < 0 ? 0 : 1} ${l8},${b2 - biasY(bl, tl)}Z`;
    });
  }
  function biasX(r1, r22) {
    return r22 < 0 ? r1 : Math.abs(r1);
  }
  function biasY(r1, r22) {
    return r22 < 0 ? Math.abs(r1) : r1;
  }
  function rect2(data, options) {
    return new Rect(data, maybeTrivialIntervalX(maybeTrivialIntervalY(options)));
  }
  function rectX(data, options = {}) {
    if (!hasXY(options)) options = { ...options, y: indexOf, x2: identity6, interval: 1 };
    return new Rect(data, maybeStackX(maybeTrivialIntervalY(maybeIdentityX(options))));
  }
  function rectY(data, options = {}) {
    if (!hasXY(options)) options = { ...options, x: indexOf, y2: identity6, interval: 1 };
    return new Rect(data, maybeStackY(maybeTrivialIntervalX(maybeIdentityY(options))));
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/frame.js
  var defaults5 = {
    ariaLabel: "frame",
    fill: "none",
    stroke: "currentColor",
    clip: false
  };
  var lineDefaults = {
    ariaLabel: "frame",
    fill: null,
    stroke: "currentColor",
    strokeLinecap: "square",
    clip: false
  };
  var Frame = class extends Mark {
    constructor(options = {}) {
      const { anchor = null } = options;
      super(singleton, void 0, options, anchor == null ? defaults5 : lineDefaults);
      this.anchor = maybeKeyword(anchor, "anchor", ["top", "right", "bottom", "left"]);
      rectInsets(this, options);
      if (!anchor) rectRadii(this, options);
    }
    render(index2, scales, channels, dimensions, context) {
      const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;
      const { anchor, insetTop, insetRight, insetBottom, insetLeft } = this;
      const { rx, ry, rx1y1, rx1y2, rx2y1, rx2y2 } = this;
      const x12 = marginLeft + insetLeft;
      const x22 = width - marginRight - insetRight;
      const y12 = marginTop + insetTop;
      const y22 = height - marginBottom - insetBottom;
      return create2(anchor ? "svg:line" : rx1y1 || rx1y2 || rx2y1 || rx2y2 ? "svg:path" : "svg:rect", context).datum(0).call(applyIndirectStyles, this, dimensions, context).call(applyDirectStyles, this).call(applyChannelStyles, this, channels).call(applyTransform, this, {}).call(
        anchor === "left" ? (line2) => line2.attr("x1", x12).attr("x2", x12).attr("y1", y12).attr("y2", y22) : anchor === "right" ? (line2) => line2.attr("x1", x22).attr("x2", x22).attr("y1", y12).attr("y2", y22) : anchor === "top" ? (line2) => line2.attr("x1", x12).attr("x2", x22).attr("y1", y12).attr("y2", y12) : anchor === "bottom" ? (line2) => line2.attr("x1", x12).attr("x2", x22).attr("y1", y22).attr("y2", y22) : rx1y1 || rx1y2 || rx2y1 || rx2y2 ? (path2) => path2.call(applyRoundedRect, x12, y12, x22, y22, this) : (rect3) => rect3.attr("x", x12).attr("y", y12).attr("width", x22 - x12).attr("height", y22 - y12).attr("rx", rx).attr("ry", ry)
      ).node();
    }
  };
  function frame3(options) {
    return new Frame(options);
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/tip.js
  var defaults6 = {
    ariaLabel: "tip",
    fill: "var(--plot-background)",
    stroke: "currentColor"
  };
  var ignoreChannels = /* @__PURE__ */ new Set(["geometry", "href", "src", "ariaLabel", "scales"]);
  var Tip = class extends Mark {
    constructor(data, options = {}) {
      if (options.tip) options = { ...options, tip: false };
      if (options.title === void 0 && isIterable(data) && isTextual(data)) options = { ...options, title: identity6 };
      const {
        x: x3,
        y: y3,
        x1: x12,
        x2: x22,
        y1: y12,
        y2: y22,
        anchor,
        preferredAnchor = "bottom",
        monospace,
        fontFamily = monospace ? "ui-monospace, monospace" : void 0,
        fontSize,
        fontStyle,
        fontVariant,
        fontWeight,
        lineHeight = 1,
        lineWidth = 20,
        frameAnchor,
        format: format3,
        textAnchor = "start",
        textOverflow,
        textPadding = 8,
        title,
        pointerSize = 12,
        pathFilter = "drop-shadow(0 3px 4px rgba(0,0,0,0.2))"
      } = options;
      super(
        data,
        {
          x: { value: x12 != null && x22 != null ? null : x3, scale: "x", optional: true },
          // ignore midpoint
          y: { value: y12 != null && y22 != null ? null : y3, scale: "y", optional: true },
          // ignore midpoint
          x1: { value: x12, scale: "x", optional: x22 == null },
          y1: { value: y12, scale: "y", optional: y22 == null },
          x2: { value: x22, scale: "x", optional: x12 == null },
          y2: { value: y22, scale: "y", optional: y12 == null },
          title: { value: title, optional: true }
          // filter: defined
        },
        options,
        defaults6
      );
      this.anchor = maybeAnchor(anchor, "anchor");
      this.preferredAnchor = maybeAnchor(preferredAnchor, "preferredAnchor");
      this.frameAnchor = maybeFrameAnchor(frameAnchor);
      this.textAnchor = impliedString(textAnchor, "middle");
      this.textPadding = +textPadding;
      this.pointerSize = +pointerSize;
      this.pathFilter = string(pathFilter);
      this.lineHeight = +lineHeight;
      this.lineWidth = +lineWidth;
      this.textOverflow = maybeTextOverflow(textOverflow);
      this.monospace = !!monospace;
      this.fontFamily = string(fontFamily);
      this.fontSize = number5(fontSize);
      this.fontStyle = string(fontStyle);
      this.fontVariant = string(fontVariant);
      this.fontWeight = string(fontWeight);
      for (const key in defaults6) if (key in this.channels) this[key] = defaults6[key];
      this.splitLines = splitter2(this);
      this.clipLine = clipper(this);
      this.format = typeof format3 === "string" || typeof format3 === "function" ? { title: format3 } : { ...format3 };
    }
    render(index2, scales, values2, dimensions, context) {
      const mark = this;
      const { x: x3, y: y3, fx, fy } = scales;
      const { ownerSVGElement: svg, document: document2 } = context;
      const { anchor, monospace, lineHeight, lineWidth } = this;
      const { textPadding: r6, pointerSize: m3, pathFilter } = this;
      const { marginTop, marginLeft } = dimensions;
      const { x1: X13, y1: Y13, x2: X23, y2: Y23, x: X3 = X13 ?? X23, y: Y3 = Y13 ?? Y23 } = values2;
      const ox2 = fx ? fx(index2.fx) - marginLeft : 0;
      const oy2 = fy ? fy(index2.fy) - marginTop : 0;
      const [cx, cy] = applyFrameAnchor(this, dimensions);
      const px = anchorX(values2, cx);
      const py = anchorY(values2, cy);
      const widthof = monospace ? monospaceWidth : defaultWidth;
      const ee = widthof(ellipsis);
      let sources, format3;
      if ("title" in values2) {
        sources = getSourceChannels.call(this, { title: values2.channels.title }, scales);
        format3 = formatTitle;
      } else {
        sources = getSourceChannels.call(this, values2.channels, scales);
        format3 = formatChannels;
      }
      const g2 = create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyIndirectTextStyles, this).call(applyTransform, this, { x: X3 && x3, y: Y3 && y3 }).call(
        (g3) => g3.selectAll().data(index2).enter().append("g").attr("transform", (i5) => `translate(${Math.round(px(i5))},${Math.round(py(i5))})`).call(applyDirectStyles, this).call((g4) => g4.append("path").attr("filter", pathFilter)).call(
          (g4) => g4.append("text").each(function(i5) {
            const that = select_default2(this);
            this.setAttribute("fill", "currentColor");
            this.setAttribute("fill-opacity", 1);
            this.setAttribute("stroke", "none");
            const lines = format3.call(mark, i5, index2, sources, scales, values2);
            if (typeof lines === "string") {
              for (const line2 of mark.splitLines(lines)) {
                renderLine(that, { value: mark.clipLine(line2) });
              }
            } else {
              const labels = /* @__PURE__ */ new Set();
              for (const line2 of lines) {
                const { label = "" } = line2;
                if (label && labels.has(label)) continue;
                else labels.add(label);
                renderLine(that, line2);
              }
            }
          })
        )
      );
      function renderLine(selection2, { label, value, color: color3, opacity: opacity2 }) {
        label ??= "", value ??= "";
        const swatch = color3 != null || opacity2 != null;
        let title;
        let w2 = lineWidth * 100;
        const [j2] = cut(label, w2, widthof, ee);
        if (j2 >= 0) {
          label = label.slice(0, j2).trimEnd() + ellipsis;
          title = value.trim();
          value = "";
        } else {
          if (label || !value && !swatch) value = " " + value;
          const [k3] = cut(value, w2 - widthof(label), widthof, ee);
          if (k3 >= 0) {
            title = value.trim();
            value = value.slice(0, k3).trimEnd() + ellipsis;
          }
        }
        const line2 = selection2.append("tspan").attr("x", 0).attr("dy", `${lineHeight}em`).text("\u200B");
        if (label) line2.append("tspan").attr("font-weight", "bold").text(label);
        if (value) line2.append(() => document2.createTextNode(value));
        if (swatch) line2.append("tspan").text(" \u25A0").attr("fill", color3).attr("fill-opacity", opacity2).style("user-select", "none");
        if (title) line2.append("title").text(title);
      }
      function postrender() {
        const { width, height } = dimensions.facet ?? dimensions;
        g2.selectChildren().each(function(i5) {
          let { x: tx, width: w2, height: h5 } = this.getBBox();
          w2 = Math.round(w2), h5 = Math.round(h5);
          let a5 = anchor;
          if (a5 === void 0) {
            const x4 = px(i5) + ox2;
            const y4 = py(i5) + oy2;
            const fitLeft = x4 + w2 + m3 + r6 * 2 < width;
            const fitRight = x4 - w2 - m3 - r6 * 2 > 0;
            const fitTop = y4 + h5 + m3 + r6 * 2 < height;
            const fitBottom = y4 - h5 - m3 - r6 * 2 > 0;
            a5 = fitLeft && fitRight ? fitTop && fitBottom ? mark.preferredAnchor : fitBottom ? "bottom" : "top" : fitTop && fitBottom ? fitLeft ? "left" : "right" : (fitLeft || fitRight) && (fitTop || fitBottom) ? `${fitBottom ? "bottom" : "top"}-${fitLeft ? "left" : "right"}` : mark.preferredAnchor;
          }
          const path2 = this.firstChild;
          const text2 = this.lastChild;
          path2.setAttribute("d", getPath(a5, m3, r6, w2, h5));
          if (tx) for (const t5 of text2.childNodes) t5.setAttribute("x", -tx);
          text2.setAttribute("y", `${+getLineOffset(a5, text2.childNodes.length, lineHeight).toFixed(6)}em`);
          text2.setAttribute("transform", `translate(${getTextTranslate(a5, m3, r6, w2, h5)})`);
        });
        g2.attr("visibility", null);
      }
      if (index2.length) {
        g2.attr("visibility", "hidden");
        if (svg.isConnected) Promise.resolve().then(postrender);
        else if (typeof requestAnimationFrame !== "undefined") requestAnimationFrame(postrender);
      }
      return g2.node();
    }
  };
  function tip(data, { x: x3, y: y3, ...options } = {}) {
    if (options.frameAnchor === void 0) [x3, y3] = maybeTuple(x3, y3);
    return new Tip(data, { ...options, x: x3, y: y3 });
  }
  function getLineOffset(anchor, length4, lineHeight) {
    return /^top(?:-|$)/.test(anchor) ? 0.94 - lineHeight : /^bottom(?:-|$)/ ? -0.29 - length4 * lineHeight : length4 / 2 * lineHeight;
  }
  function getTextTranslate(anchor, m3, r6, width, height) {
    switch (anchor) {
      case "middle":
        return [-width / 2, height / 2];
      case "top-left":
        return [r6, m3 + r6];
      case "top":
        return [-width / 2, m3 / 2 + r6];
      case "top-right":
        return [-width - r6, m3 + r6];
      case "right":
        return [-m3 / 2 - width - r6, height / 2];
      case "bottom-left":
        return [r6, -m3 - r6];
      case "bottom":
        return [-width / 2, -m3 / 2 - r6];
      case "bottom-right":
        return [-width - r6, -m3 - r6];
      case "left":
        return [r6 + m3 / 2, height / 2];
    }
  }
  function getPath(anchor, m3, r6, width, height) {
    const w2 = width + r6 * 2;
    const h5 = height + r6 * 2;
    switch (anchor) {
      case "middle":
        return `M${-w2 / 2},${-h5 / 2}h${w2}v${h5}h${-w2}z`;
      case "top-left":
        return `M0,0l${m3},${m3}h${w2 - m3}v${h5}h${-w2}z`;
      case "top":
        return `M0,0l${m3 / 2},${m3 / 2}h${(w2 - m3) / 2}v${h5}h${-w2}v${-h5}h${(w2 - m3) / 2}z`;
      case "top-right":
        return `M0,0l${-m3},${m3}h${m3 - w2}v${h5}h${w2}z`;
      case "right":
        return `M0,0l${-m3 / 2},${-m3 / 2}v${m3 / 2 - h5 / 2}h${-w2}v${h5}h${w2}v${m3 / 2 - h5 / 2}z`;
      case "bottom-left":
        return `M0,0l${m3},${-m3}h${w2 - m3}v${-h5}h${-w2}z`;
      case "bottom":
        return `M0,0l${m3 / 2},${-m3 / 2}h${(w2 - m3) / 2}v${-h5}h${-w2}v${h5}h${(w2 - m3) / 2}z`;
      case "bottom-right":
        return `M0,0l${-m3},${-m3}h${m3 - w2}v${-h5}h${w2}z`;
      case "left":
        return `M0,0l${m3 / 2},${-m3 / 2}v${m3 / 2 - h5 / 2}h${w2}v${h5}h${-w2}v${m3 / 2 - h5 / 2}z`;
    }
  }
  function getSourceChannels(channels, scales) {
    const sources = {};
    let format3 = this.format;
    format3 = maybeExpandPairedFormat(format3, channels, "x");
    format3 = maybeExpandPairedFormat(format3, channels, "y");
    this.format = format3;
    for (const key in format3) {
      const value = format3[key];
      if (value === null || value === false) {
        continue;
      } else if (key === "fx" || key === "fy") {
        sources[key] = true;
      } else {
        const source = getSource(channels, key);
        if (source) sources[key] = source;
      }
    }
    for (const key in channels) {
      if (key in sources || key in format3 || ignoreChannels.has(key)) continue;
      if ((key === "x" || key === "y") && channels.geometry) continue;
      const source = getSource(channels, key);
      if (source) {
        if (source.scale == null && source.defaultScale === "color") continue;
        sources[key] = source;
      }
    }
    if (this.facet) {
      if (scales.fx && !("fx" in format3)) sources.fx = true;
      if (scales.fy && !("fy" in format3)) sources.fy = true;
    }
    for (const key in sources) {
      const format4 = this.format[key];
      if (typeof format4 === "string") {
        const value = sources[key]?.value ?? scales[key]?.domain() ?? [];
        this.format[key] = (isTemporal(value) ? utcFormat : format)(format4);
      } else if (format4 === void 0 || format4 === true) {
        const scale3 = scales[key];
        this.format[key] = scale3?.bandwidth ? inferTickFormat(scale3, scale3.domain()) : formatDefault;
      }
    }
    return sources;
  }
  function maybeExpandPairedFormat(format3, channels, key) {
    if (!(key in format3)) return format3;
    const key1 = `${key}1`;
    const key2 = `${key}2`;
    if ((key1 in format3 || !(key1 in channels)) && (key2 in format3 || !(key2 in channels))) return format3;
    const entries = Object.entries(format3);
    const value = format3[key];
    entries.splice(entries.findIndex(([name]) => name === key) + 1, 0, [key1, value], [key2, value]);
    return Object.fromEntries(entries);
  }
  function formatTitle(i5, index2, { title }) {
    return this.format.title(title.value[i5], i5);
  }
  function* formatChannels(i5, index2, channels, scales, values2) {
    for (const key in channels) {
      if (key === "fx" || key === "fy") {
        yield {
          label: formatLabel(scales, channels, key),
          value: this.format[key](index2[key], i5)
        };
        continue;
      }
      if (key === "x1" && "x2" in channels) continue;
      if (key === "y1" && "y2" in channels) continue;
      const channel = channels[key];
      if (key === "x2" && "x1" in channels) {
        yield {
          label: formatPairLabel(scales, channels, "x"),
          value: formatPair(this.format.x2, channels.x1, channel, i5)
        };
      } else if (key === "y2" && "y1" in channels) {
        yield {
          label: formatPairLabel(scales, channels, "y"),
          value: formatPair(this.format.y2, channels.y1, channel, i5)
        };
      } else {
        const value = channel.value[i5];
        const scale3 = channel.scale;
        if (!defined(value) && scale3 == null) continue;
        yield {
          label: formatLabel(scales, channels, key),
          value: this.format[key](value, i5),
          color: scale3 === "color" ? values2[key][i5] : null,
          opacity: scale3 === "opacity" ? values2[key][i5] : null
        };
      }
    }
  }
  function formatPair(formatValue, c1, c22, i5) {
    return c22.hint?.length ? `${formatValue(c22.value[i5] - c1.value[i5], i5)}` : `${formatValue(c1.value[i5], i5)}\u2013${formatValue(c22.value[i5], i5)}`;
  }
  function formatPairLabel(scales, channels, key) {
    const l1 = formatLabel(scales, channels, `${key}1`, key);
    const l22 = formatLabel(scales, channels, `${key}2`, key);
    return l1 === l22 ? l1 : `${l1}\u2013${l22}`;
  }
  function formatLabel(scales, channels, key, defaultLabel = key) {
    const channel = channels[key];
    const scale3 = scales[channel?.scale ?? key];
    return String(scale3?.label ?? channel?.label ?? defaultLabel);
  }

  // ../../../../../node_modules/@observablehq/plot/src/plot.js
  function plot(options = {}) {
    const { facet, style, title, subtitle, caption, ariaLabel, ariaDescription } = options;
    const className = maybeClassName(options.className);
    const marks2 = options.marks === void 0 ? [] : flatMarks(options.marks);
    marks2.push(...inferTips(marks2));
    const topFacetState = maybeTopFacet(facet, options);
    const facetStateByMark = /* @__PURE__ */ new Map();
    for (const mark of marks2) {
      const facetState = maybeMarkFacet(mark, topFacetState, options);
      if (facetState) facetStateByMark.set(mark, facetState);
    }
    const channelsByScale = /* @__PURE__ */ new Map();
    if (topFacetState) addScaleChannels(channelsByScale, [topFacetState], options);
    addScaleChannels(channelsByScale, facetStateByMark, options);
    const axes = flatMarks(inferAxes(marks2, channelsByScale, options));
    for (const mark of axes) {
      const facetState = maybeMarkFacet(mark, topFacetState, options);
      if (facetState) facetStateByMark.set(mark, facetState);
    }
    marks2.unshift(...axes);
    let facets = createFacets(channelsByScale, options);
    if (facets !== void 0) {
      const topFacetsIndex = topFacetState ? facetFilter(facets, topFacetState) : void 0;
      for (const mark of marks2) {
        if (mark.facet === null || mark.facet === "super") continue;
        const facetState = facetStateByMark.get(mark);
        if (facetState === void 0) continue;
        facetState.facetsIndex = mark.fx != null || mark.fy != null ? facetFilter(facets, facetState) : topFacetsIndex;
      }
      const nonEmpty = /* @__PURE__ */ new Set();
      for (const { facetsIndex } of facetStateByMark.values()) {
        facetsIndex?.forEach((index2, i5) => {
          if (index2?.length > 0) {
            nonEmpty.add(i5);
          }
        });
      }
      facets.forEach(
        0 < nonEmpty.size && nonEmpty.size < facets.length ? (f7, i5) => f7.empty = !nonEmpty.has(i5) : (f7) => f7.empty = false
      );
      for (const mark of marks2) {
        if (mark.facet === "exclude") {
          const facetState = facetStateByMark.get(mark);
          if (facetState !== void 0) facetState.facetsIndex = facetExclude(facetState.facetsIndex);
        }
      }
    }
    for (const key of registry.keys()) {
      if (isScaleOptions(options[key]) && key !== "fx" && key !== "fy") {
        channelsByScale.set(key, []);
      }
    }
    const stateByMark = /* @__PURE__ */ new Map();
    for (const mark of marks2) {
      if (stateByMark.has(mark)) throw new Error("duplicate mark; each mark must be unique");
      const { facetsIndex, channels: facetChannels } = facetStateByMark.get(mark) ?? {};
      const { data, facets: facets2, channels } = mark.initialize(facetsIndex, facetChannels, options);
      applyScaleTransforms(channels, options);
      stateByMark.set(mark, { data, facets: facets2, channels });
    }
    const scaleDescriptors = createScales(addScaleChannels(channelsByScale, stateByMark, options), options);
    const dimensions = createDimensions(scaleDescriptors, marks2, options);
    autoScaleRange(scaleDescriptors, dimensions);
    const scales = createScaleFunctions(scaleDescriptors);
    const { fx, fy } = scales;
    const subdimensions = fx || fy ? innerDimensions(scaleDescriptors, dimensions) : dimensions;
    const superdimensions = fx || fy ? actualDimensions(scales, dimensions) : dimensions;
    const context = createContext(options);
    const document2 = context.document;
    const svg = creator_default("svg").call(document2.documentElement);
    let figure = svg;
    context.ownerSVGElement = svg;
    context.className = className;
    context.projection = createProjection(options, subdimensions);
    context.path = function() {
      return path_default(this.projection ?? xyProjection(scales));
    };
    context.filterFacets = (data, channels) => {
      return facetFilter(facets, { channels, groups: facetGroups(data, channels) });
    };
    context.getMarkState = (mark) => {
      const state = stateByMark.get(mark);
      const facetState = facetStateByMark.get(mark);
      return { ...state, channels: { ...state.channels, ...facetState?.channels } };
    };
    context.dispatchValue = (value) => {
      if (figure.value === value) return;
      figure.value = value;
      figure.dispatchEvent(new context.document.defaultView.Event("input", { bubbles: true }));
    };
    const newByScale = /* @__PURE__ */ new Set();
    for (const [mark, state] of stateByMark) {
      if (mark.initializer != null) {
        const dimensions2 = mark.facet === "super" ? superdimensions : subdimensions;
        const update = mark.initializer(state.data, state.facets, state.channels, scales, dimensions2, context);
        if (update.data !== void 0) {
          state.data = update.data;
        }
        if (update.facets !== void 0) {
          state.facets = update.facets;
        }
        if (update.channels !== void 0) {
          const { fx: fx2, fy: fy2, ...channels } = update.channels;
          inferChannelScales(channels);
          Object.assign(state.channels, channels);
          for (const channel of Object.values(channels)) {
            const { scale: scale3 } = channel;
            if (scale3 != null && !isPosition(registry.get(scale3))) {
              applyScaleTransform(channel, options);
              newByScale.add(scale3);
            }
          }
          if (fx2 != null || fy2 != null) facetStateByMark.set(mark, true);
        }
      }
    }
    if (newByScale.size) {
      const newChannelsByScale = /* @__PURE__ */ new Map();
      addScaleChannels(newChannelsByScale, stateByMark, options, (key) => newByScale.has(key));
      addScaleChannels(channelsByScale, stateByMark, options, (key) => newByScale.has(key));
      const newScaleDescriptors = inheritScaleLabels(createScales(newChannelsByScale, options), scaleDescriptors);
      const { scales: newExposedScales, ...newScales } = createScaleFunctions(newScaleDescriptors);
      Object.assign(scaleDescriptors, newScaleDescriptors);
      Object.assign(scales, newScales);
      Object.assign(scales.scales, newExposedScales);
    }
    let facetDomains, facetTranslate;
    if (facets !== void 0) {
      facetDomains = { x: fx?.domain(), y: fy?.domain() };
      facets = recreateFacets(facets, facetDomains);
      facetTranslate = facetTranslator(fx, fy, dimensions);
    }
    for (const [mark, state] of stateByMark) {
      state.values = mark.scale(state.channels, scales, context);
    }
    const { width, height } = dimensions;
    select_default2(svg).attr("class", className).attr("fill", "currentColor").attr("font-family", "system-ui, sans-serif").attr("font-size", 10).attr("text-anchor", "middle").attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).attr("aria-label", ariaLabel).attr("aria-description", ariaDescription).call(
      (svg2) => (
        // Warning: if you edit this, change defaultClassName.
        svg2.append("style").text(
          `:where(.${className}) {
  --plot-background: white;
  display: block;
  height: auto;
  height: intrinsic;
  max-width: 100%;
}
:where(.${className} text),
:where(.${className} tspan) {
  white-space: pre;
}`
        )
      )
    ).call(applyInlineStyles, style);
    for (const mark of marks2) {
      const { channels, values: values2, facets: indexes2 } = stateByMark.get(mark);
      if (facets === void 0 || mark.facet === "super") {
        let index2 = null;
        if (indexes2) {
          index2 = indexes2[0];
          index2 = mark.filter(index2, channels, values2);
          if (index2.length === 0) continue;
        }
        const node = mark.render(index2, scales, values2, superdimensions, context);
        if (node == null) continue;
        svg.appendChild(node);
      } else {
        let g2;
        for (const f7 of facets) {
          if (!(mark.facetAnchor?.(facets, facetDomains, f7) ?? !f7.empty)) continue;
          let index2 = null;
          if (indexes2) {
            const faceted = facetStateByMark.has(mark);
            index2 = indexes2[faceted ? f7.i : 0];
            index2 = mark.filter(index2, channels, values2);
            if (index2.length === 0) continue;
            if (!faceted && index2 === indexes2[0]) index2 = subarray(index2);
            index2.fx = f7.x, index2.fy = f7.y, index2.fi = f7.i;
          }
          const node = mark.render(index2, scales, values2, subdimensions, context);
          if (node == null) continue;
          (g2 ??= select_default2(svg).append("g")).append(() => node).datum(f7);
          for (const name of ["aria-label", "aria-description", "aria-hidden", "transform"]) {
            if (node.hasAttribute(name)) {
              g2.attr(name, node.getAttribute(name));
              node.removeAttribute(name);
            }
          }
        }
        g2?.selectChildren().each(facetTranslate);
      }
    }
    const legends = createLegends(scaleDescriptors, context, options);
    const { figure: figured = title != null || subtitle != null || caption != null || legends.length > 0 } = options;
    if (figured) {
      figure = document2.createElement("figure");
      figure.className = `${className}-figure`;
      figure.style.maxWidth = "initial";
      if (title != null) figure.append(createTitleElement(document2, title, "h2"));
      if (subtitle != null) figure.append(createTitleElement(document2, subtitle, "h3"));
      figure.append(...legends, svg);
      if (caption != null) figure.append(createFigcaption(document2, caption));
      if ("value" in svg) figure.value = svg.value, delete svg.value;
    }
    figure.scale = exposeScales(scales.scales);
    figure.legend = exposeLegends(scaleDescriptors, context, options);
    const w2 = consumeWarnings();
    if (w2 > 0) {
      select_default2(svg).append("text").attr("x", width).attr("y", 20).attr("dy", "-1em").attr("text-anchor", "end").attr("font-family", "initial").text("\u26A0\uFE0F").append("title").text(`${w2.toLocaleString("en-US")} warning${w2 === 1 ? "" : "s"}. Please check the console.`);
    }
    return figure;
  }
  function createTitleElement(document2, contents, tag) {
    if (contents.ownerDocument) return contents;
    const e11 = document2.createElement(tag);
    e11.append(contents);
    return e11;
  }
  function createFigcaption(document2, caption) {
    const e11 = document2.createElement("figcaption");
    e11.append(caption);
    return e11;
  }
  function flatMarks(marks2) {
    return marks2.flat(Infinity).filter((mark) => mark != null).map(markify);
  }
  function markify(mark) {
    return typeof mark.render === "function" ? mark : new Render(mark);
  }
  var Render = class extends Mark {
    constructor(render) {
      if (typeof render !== "function") throw new TypeError("invalid mark; missing render function");
      super();
      this.render = render;
    }
    render() {
    }
  };
  function applyScaleTransforms(channels, options) {
    for (const name in channels) applyScaleTransform(channels[name], options);
    return channels;
  }
  function applyScaleTransform(channel, options) {
    const { scale: scale3, transform: t5 = true } = channel;
    if (scale3 == null || !t5) return;
    const {
      type: type2,
      percent,
      interval: interval2,
      transform: transform3 = percent ? (x3) => x3 == null ? NaN : x3 * 100 : maybeIntervalTransform(interval2, type2)
    } = options[scale3] ?? {};
    if (transform3 == null) return;
    channel.value = map2(channel.value, transform3);
    channel.transform = false;
  }
  function inferChannelScales(channels) {
    for (const name in channels) {
      inferChannelScale(name, channels[name]);
    }
  }
  function addScaleChannels(channelsByScale, stateByMark, options, filter5 = yes) {
    for (const { channels } of stateByMark.values()) {
      for (const name in channels) {
        const channel = channels[name];
        const { scale: scale3 } = channel;
        if (scale3 != null && filter5(scale3)) {
          if (scale3 === "projection") {
            if (!hasProjection(options)) {
              const gx = options.x?.domain === void 0;
              const gy = options.y?.domain === void 0;
              if (gx || gy) {
                const [x3, y3] = getGeometryChannels(channel);
                if (gx) addScaleChannel(channelsByScale, "x", x3);
                if (gy) addScaleChannel(channelsByScale, "y", y3);
              }
            }
          } else {
            addScaleChannel(channelsByScale, scale3, channel);
          }
        }
      }
    }
    return channelsByScale;
  }
  function addScaleChannel(channelsByScale, scale3, channel) {
    const scaleChannels = channelsByScale.get(scale3);
    if (scaleChannels !== void 0) scaleChannels.push(channel);
    else channelsByScale.set(scale3, [channel]);
  }
  function maybeTopFacet(facet, options) {
    if (facet == null) return;
    const { x: x3, y: y3 } = facet;
    if (x3 == null && y3 == null) return;
    const data = dataify(facet.data);
    if (data == null) throw new Error("missing facet data");
    const channels = {};
    if (x3 != null) channels.fx = createChannel(data, { value: x3, scale: "fx" });
    if (y3 != null) channels.fy = createChannel(data, { value: y3, scale: "fy" });
    applyScaleTransforms(channels, options);
    const groups2 = facetGroups(data, channels);
    return { channels, groups: groups2, data: facet.data };
  }
  function maybeMarkFacet(mark, topFacetState, options) {
    if (mark.facet === null || mark.facet === "super") return;
    const { fx, fy } = mark;
    if (fx != null || fy != null) {
      const data2 = dataify(mark.data ?? fx ?? fy);
      if (data2 === void 0) throw new Error(`missing facet data in ${mark.ariaLabel}`);
      if (data2 === null) return;
      const channels2 = {};
      if (fx != null) channels2.fx = createChannel(data2, { value: fx, scale: "fx" });
      if (fy != null) channels2.fy = createChannel(data2, { value: fy, scale: "fy" });
      applyScaleTransforms(channels2, options);
      return { channels: channels2, groups: facetGroups(data2, channels2) };
    }
    if (topFacetState === void 0) return;
    const { channels, groups: groups2, data } = topFacetState;
    if (mark.facet !== "auto" || mark.data === data) return { channels, groups: groups2 };
    if (data.length > 0 && (groups2.size > 1 || groups2.size === 1 && channels.fx && channels.fy && [...groups2][0][1].size > 1) && lengthof(dataify(mark.data)) === lengthof(data)) {
      warn(
        `Warning: the ${mark.ariaLabel} mark appears to use faceted data, but isn\u2019t faceted. The mark data has the same length as the facet data and the mark facet option is "auto", but the mark data and facet data are distinct. If this mark should be faceted, set the mark facet option to true; otherwise, suppress this warning by setting the mark facet option to false.`
      );
    }
  }
  function derive(mark, options = {}) {
    return initializer({ ...options, x: null, y: null }, (data, facets, channels, scales, dimensions, context) => {
      return context.getMarkState(mark);
    });
  }
  function inferTips(marks2) {
    const tips = [];
    for (const mark of marks2) {
      let tipOptions = mark.tip;
      if (tipOptions) {
        if (tipOptions === true) tipOptions = {};
        else if (typeof tipOptions === "string") tipOptions = { pointer: tipOptions };
        let { pointer: p11, preferredAnchor: a5 } = tipOptions;
        p11 = /^x$/i.test(p11) ? pointerX : /^y$/i.test(p11) ? pointerY : pointer;
        tipOptions = p11(derive(mark, tipOptions));
        tipOptions.title = null;
        if (a5 === void 0) tipOptions.preferredAnchor = p11 === pointerY ? "left" : "bottom";
        const t5 = tip(mark.data, tipOptions);
        t5.facet = mark.facet;
        t5.facetAnchor = mark.facetAnchor;
        tips.push(t5);
      }
    }
    return tips;
  }
  function inferAxes(marks2, channelsByScale, options) {
    let {
      projection: projection3,
      x: x3 = {},
      y: y3 = {},
      fx = {},
      fy = {},
      axis: axis2,
      grid,
      facet = {},
      facet: { axis: facetAxis = axis2, grid: facetGrid } = facet,
      x: { axis: xAxis = axis2, grid: xGrid = xAxis === null ? null : grid } = x3,
      y: { axis: yAxis = axis2, grid: yGrid = yAxis === null ? null : grid } = y3,
      fx: { axis: fxAxis = facetAxis, grid: fxGrid = fxAxis === null ? null : facetGrid } = fx,
      fy: { axis: fyAxis = facetAxis, grid: fyGrid = fyAxis === null ? null : facetGrid } = fy
    } = options;
    if (projection3 || !isScaleOptions(x3) && !hasPositionChannel("x", marks2)) xAxis = xGrid = null;
    if (projection3 || !isScaleOptions(y3) && !hasPositionChannel("y", marks2)) yAxis = yGrid = null;
    if (!channelsByScale.has("fx")) fxAxis = fxGrid = null;
    if (!channelsByScale.has("fy")) fyAxis = fyGrid = null;
    if (xAxis === void 0) xAxis = !hasAxis(marks2, "x");
    if (yAxis === void 0) yAxis = !hasAxis(marks2, "y");
    if (fxAxis === void 0) fxAxis = !hasAxis(marks2, "fx");
    if (fyAxis === void 0) fyAxis = !hasAxis(marks2, "fy");
    if (xAxis === true) xAxis = "bottom";
    if (yAxis === true) yAxis = "left";
    if (fxAxis === true) fxAxis = xAxis === "top" || xAxis === null ? "bottom" : "top";
    if (fyAxis === true) fyAxis = yAxis === "right" || yAxis === null ? "left" : "right";
    const axes = [];
    maybeGrid(axes, fyGrid, gridFy, fy);
    maybeAxis(axes, fyAxis, axisFy, "right", "left", facet, fy);
    maybeGrid(axes, fxGrid, gridFx, fx);
    maybeAxis(axes, fxAxis, axisFx, "top", "bottom", facet, fx);
    maybeGrid(axes, yGrid, gridY, y3);
    maybeAxis(axes, yAxis, axisY, "left", "right", options, y3);
    maybeGrid(axes, xGrid, gridX, x3);
    maybeAxis(axes, xAxis, axisX, "bottom", "top", options, x3);
    return axes;
  }
  function maybeAxis(axes, axis2, axisType, primary, secondary, defaults22, options) {
    if (!axis2) return;
    const both = isBoth(axis2);
    options = axisOptions(both ? primary : axis2, defaults22, options);
    const { line: line2 } = options;
    if ((axisType === axisY || axisType === axisX) && line2 && !isNone(line2)) axes.push(frame3(lineOptions(options)));
    axes.push(axisType(options));
    if (both) axes.push(axisType({ ...options, anchor: secondary, label: null }));
  }
  function maybeGrid(axes, grid, gridType, options) {
    if (!grid || isNone(grid)) return;
    axes.push(gridType(gridOptions(grid, options)));
  }
  function isBoth(value) {
    return /^\s*both\s*$/i.test(value);
  }
  function axisOptions(anchor, defaults22, {
    line: line2 = defaults22.line,
    ticks: ticks2,
    tickSize,
    tickSpacing,
    tickPadding,
    tickFormat: tickFormat2,
    tickRotate,
    fontVariant,
    ariaLabel,
    ariaDescription,
    label = defaults22.label,
    labelAnchor,
    labelArrow = defaults22.labelArrow,
    labelOffset
  }) {
    return {
      anchor,
      line: line2,
      ticks: ticks2,
      tickSize,
      tickSpacing,
      tickPadding,
      tickFormat: tickFormat2,
      tickRotate,
      fontVariant,
      ariaLabel,
      ariaDescription,
      label,
      labelAnchor,
      labelArrow,
      labelOffset
    };
  }
  function lineOptions(options) {
    const { anchor, line: line2 } = options;
    return { anchor, facetAnchor: anchor + "-empty", stroke: line2 === true ? void 0 : line2 };
  }
  function gridOptions(grid, {
    stroke = isColor(grid) ? grid : void 0,
    ticks: ticks2 = isGridTicks(grid) ? grid : void 0,
    tickSpacing,
    ariaLabel,
    ariaDescription
  }) {
    return {
      stroke,
      ticks: ticks2,
      tickSpacing,
      ariaLabel,
      ariaDescription
    };
  }
  function isGridTicks(grid) {
    switch (typeof grid) {
      case "number":
        return true;
      case "string":
        return !isColor(grid);
    }
    return isIterable(grid) || typeof grid?.range === "function";
  }
  function hasAxis(marks2, k3) {
    const prefix = `${k3}-axis `;
    return marks2.some((m3) => m3.ariaLabel?.startsWith(prefix));
  }
  function hasPositionChannel(k3, marks2) {
    for (const mark of marks2) {
      for (const key in mark.channels) {
        const { scale: scale3 } = mark.channels[key];
        if (scale3 === k3 || scale3 === "projection") {
          return true;
        }
      }
    }
    return false;
  }
  function inheritScaleLabels(newScales, scales) {
    for (const key in newScales) {
      const newScale = newScales[key];
      const scale3 = scales[key];
      if (newScale.label === void 0 && scale3) {
        newScale.label = scale3.label;
      }
    }
    return newScales;
  }
  function actualDimensions({ fx, fy }, dimensions) {
    const { marginTop, marginRight, marginBottom, marginLeft, width, height } = outerDimensions(dimensions);
    const fxr = fx && outerRange(fx);
    const fyr = fy && outerRange(fy);
    return {
      marginTop: fy ? fyr[0] : marginTop,
      marginRight: fx ? width - fxr[1] : marginRight,
      marginBottom: fy ? height - fyr[1] : marginBottom,
      marginLeft: fx ? fxr[0] : marginLeft,
      // Some marks, namely the x- and y-axis labels, want to know what the
      // desired (rather than actual) margins are for positioning.
      inset: {
        marginTop: dimensions.marginTop,
        marginRight: dimensions.marginRight,
        marginBottom: dimensions.marginBottom,
        marginLeft: dimensions.marginLeft
      },
      width,
      height
    };
  }
  function outerRange(scale3) {
    const domain = scale3.domain();
    if (domain.length === 0) return [0, scale3.bandwidth()];
    let x12 = scale3(domain[0]);
    let x22 = scale3(domain[domain.length - 1]);
    if (x22 < x12) [x12, x22] = [x22, x12];
    return [x12, x22 + scale3.bandwidth()];
  }

  // ../../../../../node_modules/@observablehq/plot/src/curve.js
  var curves = /* @__PURE__ */ new Map([
    ["basis", basis_default2],
    ["basis-closed", basisClosed_default2],
    ["basis-open", basisOpen_default],
    ["bundle", bundle_default],
    ["bump-x", bumpX],
    ["bump-y", bumpY],
    ["cardinal", cardinal_default],
    ["cardinal-closed", cardinalClosed_default],
    ["cardinal-open", cardinalOpen_default],
    ["catmull-rom", catmullRom_default],
    ["catmull-rom-closed", catmullRomClosed_default],
    ["catmull-rom-open", catmullRomOpen_default],
    ["linear", linear_default],
    ["linear-closed", linearClosed_default],
    ["monotone-x", monotoneX],
    ["monotone-y", monotoneY],
    ["natural", natural_default],
    ["step", step_default],
    ["step-after", stepAfter],
    ["step-before", stepBefore]
  ]);
  function maybeCurve(curve = linear_default, tension) {
    if (typeof curve === "function") return curve;
    const c9 = curves.get(`${curve}`.toLowerCase());
    if (!c9) throw new Error(`unknown curve: ${curve}`);
    if (tension !== void 0) {
      if ("beta" in c9) {
        return c9.beta(tension);
      } else if ("tension" in c9) {
        return c9.tension(tension);
      } else if ("alpha" in c9) {
        return c9.alpha(tension);
      }
    }
    return c9;
  }
  function maybeCurveAuto(curve = curveAuto, tension) {
    return typeof curve !== "function" && `${curve}`.toLowerCase() === "auto" ? curveAuto : maybeCurve(curve, tension);
  }
  function curveAuto(context) {
    return linear_default(context);
  }

  // ../../../../../node_modules/@observablehq/plot/src/transforms/bin.js
  function binX(outputs = { y: "count" }, options = {}) {
    [outputs, options] = mergeOptions2(outputs, options);
    const { x: x3, y: y3 } = options;
    return binn(maybeBinValue(x3, options, identity6), null, null, y3, outputs, maybeInsetX(options));
  }
  function binY(outputs = { x: "count" }, options = {}) {
    [outputs, options] = mergeOptions2(outputs, options);
    const { x: x3, y: y3 } = options;
    return binn(null, maybeBinValue(y3, options, identity6), x3, null, outputs, maybeInsetY(options));
  }
  function bin(outputs = { fill: "count" }, options = {}) {
    [outputs, options] = mergeOptions2(outputs, options);
    const { x: x3, y: y3 } = maybeBinValueTuple(options);
    return binn(x3, y3, null, null, outputs, maybeInsetX(maybeInsetY(options)));
  }
  function maybeDenseInterval(bin2, k3, options = {}) {
    if (options?.interval == null) return options;
    const { reduce = reduceFirst } = options;
    const outputs = { filter: null };
    if (options[k3] != null) outputs[k3] = reduce;
    if (options[`${k3}1`] != null) outputs[`${k3}1`] = reduce;
    if (options[`${k3}2`] != null) outputs[`${k3}2`] = reduce;
    return bin2(outputs, options);
  }
  function maybeDenseIntervalX(options = {}) {
    return maybeDenseInterval(binX, "y", withTip(options, "x"));
  }
  function maybeDenseIntervalY(options = {}) {
    return maybeDenseInterval(binY, "x", withTip(options, "y"));
  }
  function binn(bx, by, gx, gy, {
    data: reduceData = reduceIdentity,
    // TODO avoid materializing when unused?
    filter: filter5 = reduceCount,
    // return only non-empty bins by default
    sort: sort3,
    reverse: reverse3,
    ...outputs
    // output channel definitions
  } = {}, inputs = {}) {
    bx = maybeBin(bx);
    by = maybeBin(by);
    outputs = maybeBinOutputs(outputs, inputs);
    reduceData = maybeBinReduce(reduceData, identity6);
    sort3 = sort3 == null ? void 0 : maybeBinOutput("sort", sort3, inputs);
    filter5 = filter5 == null ? void 0 : maybeBinEvaluator("filter", filter5, inputs);
    if (gx != null && hasOutput(outputs, "x", "x1", "x2")) gx = null;
    if (gy != null && hasOutput(outputs, "y", "y1", "y2")) gy = null;
    const [BX1, setBX1] = maybeColumn(bx);
    const [BX2, setBX2] = maybeColumn(bx);
    const [BY1, setBY1] = maybeColumn(by);
    const [BY2, setBY2] = maybeColumn(by);
    const [k3, gk] = gx != null ? [gx, "x"] : gy != null ? [gy, "y"] : [];
    const [GK, setGK] = maybeColumn(k3);
    const {
      x: x3,
      y: y3,
      z: z2,
      fill,
      stroke,
      x1: x12,
      x2: x22,
      // consumed if x is an output
      y1: y12,
      y2: y22,
      // consumed if y is an output
      domain,
      cumulative,
      thresholds,
      interval: interval2,
      ...options
    } = inputs;
    const [GZ, setGZ] = maybeColumn(z2);
    const [vfill] = maybeColorChannel(fill);
    const [vstroke] = maybeColorChannel(stroke);
    const [GF, setGF] = maybeColumn(vfill);
    const [GS, setGS] = maybeColumn(vstroke);
    return {
      ..."z" in inputs && { z: GZ || z2 },
      ..."fill" in inputs && { fill: GF || fill },
      ..."stroke" in inputs && { stroke: GS || stroke },
      ...basic(options, (data, facets, plotOptions) => {
        const K2 = maybeApplyInterval(valueof(data, k3), plotOptions?.[gk]);
        const Z3 = valueof(data, z2);
        const F = valueof(data, vfill);
        const S3 = valueof(data, vstroke);
        const G = maybeSubgroup(outputs, { z: Z3, fill: F, stroke: S3 });
        const groupFacets = [];
        const groupData = [];
        const GK2 = K2 && setGK([]);
        const GZ2 = Z3 && setGZ([]);
        const GF2 = F && setGF([]);
        const GS2 = S3 && setGS([]);
        const BX12 = bx && setBX1([]);
        const BX22 = bx && setBX2([]);
        const BY12 = by && setBY1([]);
        const BY22 = by && setBY2([]);
        const bin2 = bing(bx, by, data);
        let i5 = 0;
        for (const o12 of outputs) o12.initialize(data);
        if (sort3) sort3.initialize(data);
        if (filter5) filter5.initialize(data);
        for (const facet of facets) {
          const groupFacet = [];
          for (const o12 of outputs) o12.scope("facet", facet);
          if (sort3) sort3.scope("facet", facet);
          if (filter5) filter5.scope("facet", facet);
          for (const [f7, I2] of maybeGroup(facet, G)) {
            for (const [k4, g2] of maybeGroup(I2, K2)) {
              for (const [b2, extent3] of bin2(g2)) {
                if (G) extent3.z = f7;
                if (filter5 && !filter5.reduce(b2, extent3)) continue;
                groupFacet.push(i5++);
                groupData.push(reduceData.reduceIndex(b2, data, extent3));
                if (K2) GK2.push(k4);
                if (Z3) GZ2.push(G === Z3 ? f7 : Z3[(b2.length > 0 ? b2 : g2)[0]]);
                if (F) GF2.push(G === F ? f7 : F[(b2.length > 0 ? b2 : g2)[0]]);
                if (S3) GS2.push(G === S3 ? f7 : S3[(b2.length > 0 ? b2 : g2)[0]]);
                if (BX12) BX12.push(extent3.x1), BX22.push(extent3.x2);
                if (BY12) BY12.push(extent3.y1), BY22.push(extent3.y2);
                for (const o12 of outputs) o12.reduce(b2, extent3);
                if (sort3) sort3.reduce(b2, extent3);
              }
            }
          }
          groupFacets.push(groupFacet);
        }
        maybeSort(groupFacets, sort3, reverse3);
        return { data: groupData, facets: groupFacets };
      }),
      ...!hasOutput(outputs, "x") && (BX1 ? { x1: BX1, x2: BX2, x: mid(BX1, BX2) } : { x: x3, x1: x12, x2: x22 }),
      ...!hasOutput(outputs, "y") && (BY1 ? { y1: BY1, y2: BY2, y: mid(BY1, BY2) } : { y: y3, y1: y12, y2: y22 }),
      ...GK && { [gk]: GK },
      ...Object.fromEntries(outputs.map(({ name, output }) => [name, output]))
    };
  }
  function mergeOptions2({ cumulative, domain, thresholds, interval: interval2, ...outputs }, options) {
    return [outputs, { cumulative, domain, thresholds, interval: interval2, ...options }];
  }
  function maybeBinValue(value, { cumulative, domain, thresholds, interval: interval2 }, defaultValue) {
    value = { ...maybeValue(value) };
    if (value.domain === void 0) value.domain = domain;
    if (value.cumulative === void 0) value.cumulative = cumulative;
    if (value.thresholds === void 0) value.thresholds = thresholds;
    if (value.interval === void 0) value.interval = interval2;
    if (value.value === void 0) value.value = defaultValue;
    value.thresholds = maybeThresholds(value.thresholds, value.interval);
    return value;
  }
  function maybeBinValueTuple(options) {
    let { x: x3, y: y3 } = options;
    x3 = maybeBinValue(x3, options);
    y3 = maybeBinValue(y3, options);
    [x3.value, y3.value] = maybeTuple(x3.value, y3.value);
    return { x: x3, y: y3 };
  }
  function maybeBin(options) {
    if (options == null) return;
    const { value, cumulative, domain = extent, thresholds } = options;
    const bin2 = (data) => {
      let V2 = valueof(data, value);
      let T2;
      if (isTemporal(V2) || isTimeThresholds(thresholds)) {
        V2 = map2(V2, coerceDate, Float64Array);
        let [min4, max3] = typeof domain === "function" ? domain(V2) : domain;
        let t5 = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V2, min4, max3) : thresholds;
        if (typeof t5 === "number") t5 = utcTickInterval(min4, max3, t5);
        if (isInterval(t5)) {
          if (domain === extent) {
            min4 = t5.floor(min4);
            max3 = t5.offset(t5.floor(max3));
          }
          t5 = t5.range(min4, t5.offset(max3));
        }
        T2 = t5;
      } else {
        V2 = coerceNumbers(V2);
        let [min4, max3] = typeof domain === "function" ? domain(V2) : domain;
        let t5 = typeof thresholds === "function" && !isInterval(thresholds) ? thresholds(V2, min4, max3) : thresholds;
        if (typeof t5 === "number") {
          if (domain === extent) {
            let step3 = tickIncrement(min4, max3, t5);
            if (isFinite(step3)) {
              if (step3 > 0) {
                let r0 = Math.round(min4 / step3);
                let r1 = Math.round(max3 / step3);
                if (!(r0 * step3 <= min4)) --r0;
                if (!(r1 * step3 > max3)) ++r1;
                let n9 = r1 - r0 + 1;
                t5 = new Float64Array(n9);
                for (let i5 = 0; i5 < n9; ++i5) t5[i5] = (r0 + i5) * step3;
              } else if (step3 < 0) {
                step3 = -step3;
                let r0 = Math.round(min4 * step3);
                let r1 = Math.round(max3 * step3);
                if (!(r0 / step3 <= min4)) --r0;
                if (!(r1 / step3 > max3)) ++r1;
                let n9 = r1 - r0 + 1;
                t5 = new Float64Array(n9);
                for (let i5 = 0; i5 < n9; ++i5) t5[i5] = (r0 + i5) / step3;
              } else {
                t5 = [min4];
              }
            } else {
              t5 = [min4];
            }
          } else {
            t5 = ticks(min4, max3, t5);
          }
        } else if (isInterval(t5)) {
          if (domain === extent) {
            min4 = t5.floor(min4);
            max3 = t5.offset(t5.floor(max3));
          }
          t5 = t5.range(min4, t5.offset(max3));
        }
        T2 = t5;
      }
      const E4 = [];
      if (T2.length === 1) E4.push([T2[0], T2[0]]);
      else for (let i5 = 1; i5 < T2.length; ++i5) E4.push([T2[i5 - 1], T2[i5]]);
      E4.bin = (cumulative < 0 ? bin1cn : cumulative > 0 ? bin1cp : bin1)(E4, T2, V2);
      return E4;
    };
    bin2.label = labelof(value);
    return bin2;
  }
  function maybeThresholds(thresholds, interval2, defaultThresholds = thresholdAuto) {
    if (thresholds === void 0) {
      return interval2 === void 0 ? defaultThresholds : maybeRangeInterval(interval2);
    }
    if (typeof thresholds === "string") {
      switch (thresholds.toLowerCase()) {
        case "freedman-diaconis":
          return thresholdFreedmanDiaconis;
        case "scott":
          return thresholdScott;
        case "sturges":
          return thresholdSturges;
        case "auto":
          return thresholdAuto;
      }
      return utcInterval(thresholds);
    }
    return thresholds;
  }
  function maybeBinOutputs(outputs, inputs) {
    return maybeOutputs(outputs, inputs, maybeBinOutput);
  }
  function maybeBinOutput(name, reduce, inputs) {
    return maybeOutput(name, reduce, inputs, maybeBinEvaluator);
  }
  function maybeBinEvaluator(name, reduce, inputs) {
    return maybeEvaluator(name, reduce, inputs, maybeBinReduce);
  }
  function maybeBinReduce(reduce, value) {
    return maybeReduce(reduce, value, maybeBinReduceFallback);
  }
  function maybeBinReduceFallback(reduce) {
    switch (`${reduce}`.toLowerCase()) {
      case "x":
        return reduceX2;
      case "x1":
        return reduceX1;
      case "x2":
        return reduceX22;
      case "y":
        return reduceY2;
      case "y1":
        return reduceY1;
      case "y2":
        return reduceY22;
      case "z":
        return reduceZ;
    }
    throw new Error(`invalid bin reduce: ${reduce}`);
  }
  function thresholdAuto(values2, min4, max3) {
    return Math.min(200, thresholdScott(values2, min4, max3));
  }
  function isTimeThresholds(t5) {
    return isTimeInterval(t5) || isIterable(t5) && isTemporal(t5);
  }
  function bing(bx, by, data) {
    const EX = bx?.(data);
    const EY = by?.(data);
    return EX && EY ? function* (I2) {
      const X3 = EX.bin(I2);
      for (const [ix, [x12, x22]] of EX.entries()) {
        const Y3 = EY.bin(X3[ix]);
        for (const [iy, [y12, y22]] of EY.entries()) {
          yield [Y3[iy], { data, x1: x12, y1: y12, x2: x22, y2: y22 }];
        }
      }
    } : EX ? function* (I2) {
      const X3 = EX.bin(I2);
      for (const [i5, [x12, x22]] of EX.entries()) {
        yield [X3[i5], { data, x1: x12, x2: x22 }];
      }
    } : function* (I2) {
      const Y3 = EY.bin(I2);
      for (const [i5, [y12, y22]] of EY.entries()) {
        yield [Y3[i5], { data, y1: y12, y2: y22 }];
      }
    };
  }
  function bin1(E4, T2, V2) {
    T2 = coerceNumbers(T2);
    return (I2) => {
      const B4 = E4.map(() => []);
      for (const i5 of I2) B4[bisect_default(T2, V2[i5]) - 1]?.push(i5);
      return B4;
    };
  }
  function bin1cp(E4, T2, V2) {
    const bin2 = bin1(E4, T2, V2);
    return (I2) => {
      const B4 = bin2(I2);
      for (let i5 = 1, n9 = B4.length; i5 < n9; ++i5) {
        const C8 = B4[i5 - 1];
        const b2 = B4[i5];
        for (const j2 of C8) b2.push(j2);
      }
      return B4;
    };
  }
  function bin1cn(E4, T2, V2) {
    const bin2 = bin1(E4, T2, V2);
    return (I2) => {
      const B4 = bin2(I2);
      for (let i5 = B4.length - 2; i5 >= 0; --i5) {
        const C8 = B4[i5 + 1];
        const b2 = B4[i5];
        for (const j2 of C8) b2.push(j2);
      }
      return B4;
    };
  }
  function mid1(x12, x22) {
    const m3 = (+x12 + +x22) / 2;
    return x12 instanceof Date ? new Date(m3) : m3;
  }
  var reduceX2 = {
    reduceIndex(I2, X3, { x1: x12, x2: x22 }) {
      return mid1(x12, x22);
    }
  };
  var reduceY2 = {
    reduceIndex(I2, X3, { y1: y12, y2: y22 }) {
      return mid1(y12, y22);
    }
  };
  var reduceX1 = {
    reduceIndex(I2, X3, { x1: x12 }) {
      return x12;
    }
  };
  var reduceX22 = {
    reduceIndex(I2, X3, { x2: x22 }) {
      return x22;
    }
  };
  var reduceY1 = {
    reduceIndex(I2, X3, { y1: y12 }) {
      return y12;
    }
  };
  var reduceY22 = {
    reduceIndex(I2, X3, { y2: y22 }) {
      return y22;
    }
  };

  // ../../../../../node_modules/@observablehq/plot/src/marks/area.js
  var defaults7 = {
    ariaLabel: "area",
    strokeWidth: 1,
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeMiterlimit: 1
  };
  var Area = class extends Mark {
    constructor(data, options = {}) {
      const { x1: x12, y1: y12, x2: x22, y2: y22, z: z2, curve, tension } = options;
      super(
        data,
        {
          x1: { value: x12, scale: "x" },
          y1: { value: y12, scale: "y" },
          x2: { value: x22, scale: "x", optional: true },
          y2: { value: y22, scale: "y", optional: true },
          z: { value: maybeZ(options), optional: true }
        },
        options,
        defaults7
      );
      this.z = z2;
      this.curve = maybeCurve(curve, tension);
    }
    filter(index2) {
      return index2;
    }
    render(index2, scales, channels, dimensions, context) {
      const { x1: X13, y1: Y13, x2: X23 = X13, y2: Y23 = Y13 } = channels;
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales, 0, 0).call(
        (g2) => g2.selectAll().data(groupIndex(index2, [X13, Y13, X23, Y23], this, channels)).enter().append("path").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).attr(
          "d",
          area_default3().curve(this.curve).defined((i5) => i5 >= 0).x0((i5) => X13[i5]).y0((i5) => Y13[i5]).x1((i5) => X23[i5]).y1((i5) => Y23[i5])
        )
      ).node();
    }
  };
  function area(data, options) {
    if (options === void 0) return areaY(data, { x: first, y: second2 });
    return new Area(data, options);
  }
  function areaX(data, options) {
    const { y: y3 = indexOf, ...rest } = maybeDenseIntervalY(options);
    return new Area(data, maybeStackX(maybeIdentityX({ ...rest, y1: y3, y2: void 0 }, y3 === indexOf ? "x2" : "x")));
  }
  function areaY(data, options) {
    const { x: x3 = indexOf, ...rest } = maybeDenseIntervalX(options);
    return new Area(data, maybeStackY(maybeIdentityY({ ...rest, x1: x3, x2: void 0 }, x3 === indexOf ? "y2" : "y")));
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/link.js
  var defaults8 = {
    ariaLabel: "link",
    fill: "none",
    stroke: "currentColor",
    strokeMiterlimit: 1
  };
  var Link = class extends Mark {
    constructor(data, options = {}) {
      const { x1: x12, y1: y12, x2: x22, y2: y22, curve, tension } = options;
      super(
        data,
        {
          x1: { value: x12, scale: "x" },
          y1: { value: y12, scale: "y" },
          x2: { value: x22, scale: "x", optional: true },
          y2: { value: y22, scale: "y", optional: true }
        },
        options,
        defaults8
      );
      this.curve = maybeCurveAuto(curve, tension);
      markers(this, options);
    }
    project(channels, values2, context) {
      if (this.curve !== curveAuto) {
        super.project(channels, values2, context);
      }
    }
    render(index2, scales, channels, dimensions, context) {
      const { x1: X13, y1: Y13, x2: X23 = X13, y2: Y23 = Y13 } = channels;
      const { curve } = this;
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
        (g2) => g2.selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).attr(
          "d",
          curve === curveAuto && context.projection ? sphereLink(context.path(), X13, Y13, X23, Y23) : (i5) => {
            const p11 = pathRound();
            const c9 = curve(p11);
            c9.lineStart();
            c9.point(X13[i5], Y13[i5]);
            c9.point(X23[i5], Y23[i5]);
            c9.lineEnd();
            return p11;
          }
        ).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
      ).node();
    }
  };
  function sphereLink(path2, X13, Y13, X23, Y23) {
    X13 = coerceNumbers(X13);
    Y13 = coerceNumbers(Y13);
    X23 = coerceNumbers(X23);
    Y23 = coerceNumbers(Y23);
    return (i5) => path2({
      type: "LineString",
      coordinates: [
        [X13[i5], Y13[i5]],
        [X23[i5], Y23[i5]]
      ]
    });
  }
  function link2(data, { x: x3, x1: x12, x2: x22, y: y3, y1: y12, y2: y22, ...options } = {}) {
    [x12, x22] = maybeSameValue(x3, x12, x22);
    [y12, y22] = maybeSameValue(y3, y12, y22);
    return new Link(data, { ...options, x1: x12, x2: x22, y1: y12, y2: y22 });
  }
  function maybeSameValue(x3, x12, x22) {
    if (x3 === void 0) {
      if (x12 === void 0) {
        if (x22 !== void 0) return [x22];
      } else {
        if (x22 === void 0) return [x12];
      }
    } else if (x12 === void 0) {
      return x22 === void 0 ? [x3] : [x3, x22];
    } else if (x22 === void 0) {
      return [x3, x12];
    }
    return [x12, x22];
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/arrow.js
  var defaults9 = {
    ariaLabel: "arrow",
    fill: "none",
    stroke: "currentColor",
    strokeLinecap: "round",
    strokeMiterlimit: 1,
    strokeWidth: 1.5
  };
  var Arrow = class extends Mark {
    constructor(data, options = {}) {
      const {
        x1: x12,
        y1: y12,
        x2: x22,
        y2: y22,
        bend = 0,
        headAngle = 60,
        headLength = 8,
        // Disable the arrow with headLength = 0; or, use Plot.link.
        inset = 0,
        insetStart = inset,
        insetEnd = inset,
        sweep
      } = options;
      super(
        data,
        {
          x1: { value: x12, scale: "x" },
          y1: { value: y12, scale: "y" },
          x2: { value: x22, scale: "x", optional: true },
          y2: { value: y22, scale: "y", optional: true }
        },
        options,
        defaults9
      );
      this.bend = bend === true ? 22.5 : Math.max(-90, Math.min(90, bend));
      this.headAngle = +headAngle;
      this.headLength = +headLength;
      this.insetStart = +insetStart;
      this.insetEnd = +insetEnd;
      this.sweep = maybeSweep(sweep);
    }
    render(index2, scales, channels, dimensions, context) {
      const { x1: X13, y1: Y13, x2: X23 = X13, y2: Y23 = Y13, SW } = channels;
      const { strokeWidth, bend, headAngle, headLength, insetStart, insetEnd } = this;
      const sw = SW ? (i5) => SW[i5] : constant(strokeWidth === void 0 ? 1 : strokeWidth);
      const wingAngle = headAngle * radians3 / 2;
      const wingScale = headLength / 1.5;
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
        (g2) => g2.selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).attr("d", (i5) => {
          let x12 = X13[i5], y12 = Y13[i5], x22 = X23[i5], y22 = Y23[i5];
          const lineLength = Math.hypot(x22 - x12, y22 - y12);
          if (lineLength <= insetStart + insetEnd) return null;
          let lineAngle = Math.atan2(y22 - y12, x22 - x12);
          const headLength2 = Math.min(wingScale * sw(i5), lineLength / 3);
          const bendAngle = this.sweep(x12, y12, x22, y22) * bend * radians3;
          const r6 = Math.hypot(lineLength / Math.tan(bendAngle), lineLength) / 2;
          if (insetStart || insetEnd) {
            if (r6 < 1e5) {
              const sign4 = Math.sign(bendAngle);
              const [cx, cy] = pointPointCenter([x12, y12], [x22, y22], r6, sign4);
              if (insetStart) {
                [x12, y12] = circleCircleIntersect([cx, cy, r6], [x12, y12, insetStart], -sign4 * Math.sign(insetStart));
              }
              if (insetEnd) {
                const [x5, y5] = circleCircleIntersect([cx, cy, r6], [x22, y22, insetEnd], sign4 * Math.sign(insetEnd));
                lineAngle += Math.atan2(y5 - cy, x5 - cx) - Math.atan2(y22 - cy, x22 - cx);
                x22 = x5, y22 = y5;
              }
            } else {
              const dx = x22 - x12, dy = y22 - y12, d3 = Math.hypot(dx, dy);
              if (insetStart) x12 += dx / d3 * insetStart, y12 += dy / d3 * insetStart;
              if (insetEnd) x22 -= dx / d3 * insetEnd, y22 -= dy / d3 * insetEnd;
            }
          }
          const endAngle = lineAngle + bendAngle;
          const leftAngle = endAngle + wingAngle;
          const rightAngle = endAngle - wingAngle;
          const x3 = x22 - headLength2 * Math.cos(leftAngle);
          const y3 = y22 - headLength2 * Math.sin(leftAngle);
          const x4 = x22 - headLength2 * Math.cos(rightAngle);
          const y4 = y22 - headLength2 * Math.sin(rightAngle);
          const a5 = r6 < 1e5 ? `A${r6},${r6} 0,0,${bendAngle > 0 ? 1 : 0} ` : `L`;
          const h5 = headLength2 ? `M${x3},${y3}L${x22},${y22}L${x4},${y4}` : "";
          return `M${x12},${y12}${a5}${x22},${y22}${h5}`;
        }).call(applyChannelStyles, this, channels)
      ).node();
    }
  };
  function maybeSweep(sweep = 1) {
    if (typeof sweep === "number") return constant(Math.sign(sweep));
    if (typeof sweep === "function") return (x12, y12, x22, y22) => Math.sign(sweep(x12, y12, x22, y22));
    switch (keyword(sweep, "sweep", ["+x", "-x", "+y", "-y"])) {
      case "+x":
        return (x12, y12, x22) => ascending(x12, x22);
      case "-x":
        return (x12, y12, x22) => descending(x12, x22);
      case "+y":
        return (x12, y12, x22, y22) => ascending(y12, y22);
      case "-y":
        return (x12, y12, x22, y22) => descending(y12, y22);
    }
  }
  function pointPointCenter([ax, ay], [bx, by], r6, sign4) {
    const dx = bx - ax, dy = by - ay, d3 = Math.hypot(dx, dy);
    const k3 = sign4 * Math.sqrt(r6 * r6 - d3 * d3 / 4) / d3;
    return [(ax + bx) / 2 - dy * k3, (ay + by) / 2 + dx * k3];
  }
  function circleCircleIntersect([ax, ay, ar], [bx, by, br], sign4) {
    const dx = bx - ax, dy = by - ay, d3 = Math.hypot(dx, dy);
    const x3 = (dx * dx + dy * dy - br * br + ar * ar) / (2 * d3);
    const y3 = sign4 * Math.sqrt(ar * ar - x3 * x3);
    return [ax + (dx * x3 + dy * y3) / d3, ay + (dy * x3 - dx * y3) / d3];
  }
  function arrow(data, { x: x3, x1: x12, x2: x22, y: y3, y1: y12, y2: y22, ...options } = {}) {
    [x12, x22] = maybeSameValue(x3, x12, x22);
    [y12, y22] = maybeSameValue(y3, y12, y22);
    return new Arrow(data, { ...options, x1: x12, x2: x22, y1: y12, y2: y22 });
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/bar.js
  var barDefaults = {
    ariaLabel: "bar"
  };
  var AbstractBar = class extends Mark {
    constructor(data, channels, options = {}, defaults22 = barDefaults) {
      super(data, channels, options, defaults22);
      rectInsets(this, options);
      rectRadii(this, options);
    }
    render(index2, scales, channels, dimensions, context) {
      const { rx, ry, rx1y1, rx1y2, rx2y1, rx2y2 } = this;
      const x3 = this._x(scales, channels, dimensions);
      const y3 = this._y(scales, channels, dimensions);
      const w2 = this._width(scales, channels, dimensions);
      const h5 = this._height(scales, channels, dimensions);
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call(
        (g2) => g2.selectAll().data(index2).enter().call(
          rx1y1 || rx1y2 || rx2y1 || rx2y2 ? (g3) => g3.append("path").call(applyDirectStyles, this).call(applyRoundedRect, x3, y3, add2(x3, w2), add2(y3, h5), this).call(applyChannelStyles, this, channels) : (g3) => g3.append("rect").call(applyDirectStyles, this).attr("x", x3).attr("width", w2).attr("y", y3).attr("height", h5).call(applyAttr, "rx", rx).call(applyAttr, "ry", ry).call(applyChannelStyles, this, channels)
        )
      ).node();
    }
    _x(scales, { x: X3 }, { marginLeft }) {
      const { insetLeft } = this;
      return X3 ? (i5) => X3[i5] + insetLeft : marginLeft + insetLeft;
    }
    _y(scales, { y: Y3 }, { marginTop }) {
      const { insetTop } = this;
      return Y3 ? (i5) => Y3[i5] + insetTop : marginTop + insetTop;
    }
    _width({ x: x3 }, { x: X3 }, { marginRight, marginLeft, width }) {
      const { insetLeft, insetRight } = this;
      const bandwidth = X3 && x3 ? x3.bandwidth() : width - marginRight - marginLeft;
      return Math.max(0, bandwidth - insetLeft - insetRight);
    }
    _height({ y: y3 }, { y: Y3 }, { marginTop, marginBottom, height }) {
      const { insetTop, insetBottom } = this;
      const bandwidth = Y3 && y3 ? y3.bandwidth() : height - marginTop - marginBottom;
      return Math.max(0, bandwidth - insetTop - insetBottom);
    }
  };
  function add2(a5, b2) {
    return typeof a5 === "function" && typeof b2 === "function" ? (i5) => a5(i5) + b2(i5) : typeof a5 === "function" ? (i5) => a5(i5) + b2 : typeof b2 === "function" ? (i5) => a5 + b2(i5) : a5 + b2;
  }
  var BarX = class extends AbstractBar {
    constructor(data, options = {}, defaults22) {
      const { x1: x12, x2: x22, y: y3 } = options;
      super(
        data,
        {
          x1: { value: x12, scale: "x" },
          x2: { value: x22, scale: "x" },
          y: { value: y3, scale: "y", type: "band", optional: true }
        },
        options,
        defaults22
      );
    }
    _transform(selection2, mark, { x: x3 }) {
      selection2.call(applyTransform, mark, { x: x3 }, 0, 0);
    }
    _x({ x: x3 }, { x1: X13, x2: X23 }, { marginLeft }) {
      const { insetLeft } = this;
      return isCollapsed(x3) ? marginLeft + insetLeft : (i5) => Math.min(X13[i5], X23[i5]) + insetLeft;
    }
    _width({ x: x3 }, { x1: X13, x2: X23 }, { marginRight, marginLeft, width }) {
      const { insetLeft, insetRight } = this;
      return isCollapsed(x3) ? width - marginRight - marginLeft - insetLeft - insetRight : (i5) => Math.max(0, Math.abs(X23[i5] - X13[i5]) - insetLeft - insetRight);
    }
  };
  var BarY = class extends AbstractBar {
    constructor(data, options = {}, defaults22) {
      const { x: x3, y1: y12, y2: y22 } = options;
      super(
        data,
        {
          y1: { value: y12, scale: "y" },
          y2: { value: y22, scale: "y" },
          x: { value: x3, scale: "x", type: "band", optional: true }
        },
        options,
        defaults22
      );
    }
    _transform(selection2, mark, { y: y3 }) {
      selection2.call(applyTransform, mark, { y: y3 }, 0, 0);
    }
    _y({ y: y3 }, { y1: Y13, y2: Y23 }, { marginTop }) {
      const { insetTop } = this;
      return isCollapsed(y3) ? marginTop + insetTop : (i5) => Math.min(Y13[i5], Y23[i5]) + insetTop;
    }
    _height({ y: y3 }, { y1: Y13, y2: Y23 }, { marginTop, marginBottom, height }) {
      const { insetTop, insetBottom } = this;
      return isCollapsed(y3) ? height - marginTop - marginBottom - insetTop - insetBottom : (i5) => Math.max(0, Math.abs(Y23[i5] - Y13[i5]) - insetTop - insetBottom);
    }
  };
  function barX(data, options = {}) {
    if (!hasXY(options)) options = { ...options, y: indexOf, x2: identity6 };
    return new BarX(data, maybeStackX(maybeIntervalX(maybeIdentityX(options))));
  }
  function barY(data, options = {}) {
    if (!hasXY(options)) options = { ...options, x: indexOf, y2: identity6 };
    return new BarY(data, maybeStackY(maybeIntervalY(maybeIdentityY(options))));
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/cell.js
  var defaults10 = {
    ariaLabel: "cell"
  };
  var Cell = class extends AbstractBar {
    constructor(data, { x: x3, y: y3, ...options } = {}) {
      super(
        data,
        {
          x: { value: x3, scale: "x", type: "band", optional: true },
          y: { value: y3, scale: "y", type: "band", optional: true }
        },
        options,
        defaults10
      );
    }
    _transform(selection2, mark) {
      selection2.call(applyTransform, mark, {}, 0, 0);
    }
  };
  function cell(data, { x: x3, y: y3, ...options } = {}) {
    [x3, y3] = maybeTuple(x3, y3);
    return new Cell(data, { ...options, x: x3, y: y3 });
  }
  function cellX(data, { x: x3 = indexOf, fill, stroke, ...options } = {}) {
    if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0) fill = identity6;
    return new Cell(data, { ...options, x: x3, fill, stroke });
  }
  function cellY(data, { y: y3 = indexOf, fill, stroke, ...options } = {}) {
    if (fill === void 0 && maybeColorChannel(stroke)[0] === void 0) fill = identity6;
    return new Cell(data, { ...options, y: y3, fill, stroke });
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/dot.js
  var defaults11 = {
    ariaLabel: "dot",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 1.5
  };
  function withDefaultSort(options) {
    return options.sort === void 0 && options.reverse === void 0 ? sort2({ channel: "-r" }, options) : options;
  }
  var Dot = class extends Mark {
    constructor(data, options = {}) {
      const { x: x3, y: y3, r: r6, rotate, symbol: symbol3 = circle_default2, frameAnchor } = options;
      const [vrotate, crotate] = maybeNumberChannel(rotate, 0);
      const [vsymbol, csymbol] = maybeSymbolChannel(symbol3);
      const [vr, cr] = maybeNumberChannel(r6, vsymbol == null ? 3 : 4.5);
      super(
        data,
        {
          x: { value: x3, scale: "x", optional: true },
          y: { value: y3, scale: "y", optional: true },
          r: { value: vr, scale: "r", filter: positive, optional: true },
          rotate: { value: vrotate, optional: true },
          symbol: { value: vsymbol, scale: "auto", optional: true }
        },
        withDefaultSort(options),
        defaults11
      );
      this.r = cr;
      this.rotate = crotate;
      this.symbol = csymbol;
      this.frameAnchor = maybeFrameAnchor(frameAnchor);
      const { channels } = this;
      const { symbol: symbolChannel } = channels;
      if (symbolChannel) {
        const { fill: fillChannel, stroke: strokeChannel } = channels;
        symbolChannel.hint = {
          fill: fillChannel ? fillChannel.value === symbolChannel.value ? "color" : "currentColor" : this.fill ?? "currentColor",
          stroke: strokeChannel ? strokeChannel.value === symbolChannel.value ? "color" : "currentColor" : this.stroke ?? "none"
        };
      }
    }
    render(index2, scales, channels, dimensions, context) {
      const { x: x3, y: y3 } = scales;
      const { x: X3, y: Y3, r: R2, rotate: A5, symbol: S3 } = channels;
      const { r: r6, rotate, symbol: symbol3 } = this;
      const [cx, cy] = applyFrameAnchor(this, dimensions);
      const circle2 = symbol3 === circle_default2;
      const size = R2 ? void 0 : r6 * r6 * Math.PI;
      if (negative(r6)) index2 = [];
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x3, y: Y3 && y3 }).call(
        (g2) => g2.selectAll().data(index2).enter().append(circle2 ? "circle" : "path").call(applyDirectStyles, this).call(
          circle2 ? (selection2) => {
            selection2.attr("cx", X3 ? (i5) => X3[i5] : cx).attr("cy", Y3 ? (i5) => Y3[i5] : cy).attr("r", R2 ? (i5) => R2[i5] : r6);
          } : (selection2) => {
            selection2.attr(
              "transform",
              template`translate(${X3 ? (i5) => X3[i5] : cx},${Y3 ? (i5) => Y3[i5] : cy})${A5 ? (i5) => ` rotate(${A5[i5]})` : rotate ? ` rotate(${rotate})` : ``}`
            ).attr(
              "d",
              R2 && S3 ? (i5) => {
                const p11 = pathRound();
                S3[i5].draw(p11, R2[i5] * R2[i5] * Math.PI);
                return p11;
              } : R2 ? (i5) => {
                const p11 = pathRound();
                symbol3.draw(p11, R2[i5] * R2[i5] * Math.PI);
                return p11;
              } : S3 ? (i5) => {
                const p11 = pathRound();
                S3[i5].draw(p11, size);
                return p11;
              } : (() => {
                const p11 = pathRound();
                symbol3.draw(p11, size);
                return p11;
              })()
            );
          }
        ).call(applyChannelStyles, this, channels)
      ).node();
    }
  };
  function dot(data, { x: x3, y: y3, ...options } = {}) {
    if (options.frameAnchor === void 0) [x3, y3] = maybeTuple(x3, y3);
    return new Dot(data, { ...options, x: x3, y: y3 });
  }
  function dotX(data, { x: x3 = identity6, ...options } = {}) {
    return new Dot(data, maybeIntervalMidY({ ...options, x: x3 }));
  }
  function dotY(data, { y: y3 = identity6, ...options } = {}) {
    return new Dot(data, maybeIntervalMidX({ ...options, y: y3 }));
  }
  function circle(data, options) {
    return dot(data, { ...options, symbol: "circle" });
  }
  function hexagon(data, options) {
    return dot(data, { ...options, symbol: "hexagon" });
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/line.js
  var defaults12 = {
    ariaLabel: "line",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeMiterlimit: 1
  };
  var Line = class extends Mark {
    constructor(data, options = {}) {
      const { x: x3, y: y3, z: z2, curve, tension } = options;
      super(
        data,
        {
          x: { value: x3, scale: "x" },
          y: { value: y3, scale: "y" },
          z: { value: maybeZ(options), optional: true }
        },
        options,
        defaults12
      );
      this.z = z2;
      this.curve = maybeCurveAuto(curve, tension);
      markers(this, options);
    }
    filter(index2) {
      return index2;
    }
    project(channels, values2, context) {
      if (this.curve !== curveAuto) {
        super.project(channels, values2, context);
      }
    }
    render(index2, scales, channels, dimensions, context) {
      const { x: X3, y: Y3 } = channels;
      const { curve } = this;
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
        (g2) => g2.selectAll().data(groupIndex(index2, [X3, Y3], this, channels)).enter().append("path").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, channels).call(applyGroupedMarkers, this, channels, context).attr(
          "d",
          curve === curveAuto && context.projection ? sphereLine(context.path(), X3, Y3) : line_default2().curve(curve).defined((i5) => i5 >= 0).x((i5) => X3[i5]).y((i5) => Y3[i5])
        )
      ).node();
    }
  };
  function sphereLine(path2, X3, Y3) {
    X3 = coerceNumbers(X3);
    Y3 = coerceNumbers(Y3);
    return (I2) => {
      let line2 = [];
      const lines = [line2];
      for (const i5 of I2) {
        if (i5 === -1) {
          line2 = [];
          lines.push(line2);
        } else {
          line2.push([X3[i5], Y3[i5]]);
        }
      }
      return path2({ type: "MultiLineString", coordinates: lines });
    };
  }
  function line(data, { x: x3, y: y3, ...options } = {}) {
    [x3, y3] = maybeTuple(x3, y3);
    return new Line(data, { ...options, x: x3, y: y3 });
  }
  function lineX(data, { x: x3 = identity6, y: y3 = indexOf, ...options } = {}) {
    return new Line(data, maybeDenseIntervalY({ ...options, x: x3, y: y3 }));
  }
  function lineY(data, { x: x3 = indexOf, y: y3 = identity6, ...options } = {}) {
    return new Line(data, maybeDenseIntervalX({ ...options, x: x3, y: y3 }));
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/auto.js
  function autoSpec(data, options) {
    options = normalizeOptions(options);
    const { x: x3, y: y3, color: color3, size } = options;
    const X3 = materializeValue(data, x3);
    const Y3 = materializeValue(data, y3);
    const C8 = materializeValue(data, color3);
    const S3 = materializeValue(data, size);
    let {
      fx,
      fy,
      x: { value: xValue, reduce: xReduce, zero: xZero, ...xOptions },
      y: { value: yValue, reduce: yReduce, zero: yZero, ...yOptions },
      color: { value: colorValue, color: colorColor, reduce: colorReduce },
      size: { value: sizeValue, reduce: sizeReduce },
      // TODO constant radius?
      mark
    } = options;
    if (xReduce === void 0)
      xReduce = yReduce == null && xValue == null && sizeValue == null && yValue != null ? "count" : null;
    if (yReduce === void 0)
      yReduce = xReduce == null && yValue == null && sizeValue == null && xValue != null ? "count" : null;
    if (sizeReduce === void 0 && sizeValue == null && colorReduce == null && xReduce == null && yReduce == null && (xValue == null || isOrdinal(X3)) && (yValue == null || isOrdinal(Y3))) {
      sizeReduce = "count";
    }
    if (xZero === void 0) xZero = isZeroReducer(xReduce) ? true : void 0;
    if (yZero === void 0) yZero = isZeroReducer(yReduce) ? true : void 0;
    if (xValue == null && yValue == null) throw new Error("must specify x or y");
    if (xReduce != null && yValue == null) throw new Error("reducing x requires y");
    if (yReduce != null && xValue == null) throw new Error("reducing y requires x");
    if (mark === void 0) {
      mark = sizeValue != null || sizeReduce != null ? "dot" : isZeroReducer(xReduce) || isZeroReducer(yReduce) || colorReduce != null ? "bar" : xValue != null && yValue != null ? isOrdinal(X3) || isOrdinal(Y3) || xReduce == null && yReduce == null && !isMonotonic(X3) && !isMonotonic(Y3) ? "dot" : "line" : xValue != null || yValue != null ? "rule" : null;
    }
    let Z3;
    let colorMode;
    let markImpl;
    switch (mark) {
      case "dot":
        markImpl = dot;
        colorMode = "stroke";
        break;
      case "line":
        markImpl = X3 && Y3 || xReduce != null || yReduce != null ? yZero || yReduce != null || X3 && isMonotonic(X3) ? lineY : xZero || xReduce != null || Y3 && isMonotonic(Y3) ? lineX : line : X3 ? lineX : lineY;
        colorMode = "stroke";
        if (isHighCardinality(C8)) Z3 = null;
        break;
      case "area":
        markImpl = !(yZero || yReduce != null) && (xZero || xReduce != null || Y3 && isMonotonic(Y3)) ? areaX : areaY;
        colorMode = "fill";
        if (isHighCardinality(C8)) Z3 = null;
        break;
      case "rule":
        markImpl = X3 ? ruleX : ruleY;
        colorMode = "stroke";
        break;
      case "bar":
        markImpl = xReduce != null ? isOrdinal(Y3) ? isSelectReducer(xReduce) && X3 && isOrdinal(X3) ? cell : barX : rectX : yReduce != null ? isOrdinal(X3) ? isSelectReducer(yReduce) && Y3 && isOrdinal(Y3) ? cell : barY : rectY : colorReduce != null || sizeReduce != null ? X3 && isOrdinal(X3) && Y3 && isOrdinal(Y3) ? cell : X3 && isOrdinal(X3) ? barY : Y3 && isOrdinal(Y3) ? barX : rect2 : X3 && isNumeric(X3) && !(Y3 && isNumeric(Y3)) ? barX : Y3 && isNumeric(Y3) && !(X3 && isNumeric(X3)) ? barY : cell;
        colorMode = "fill";
        break;
      default:
        throw new Error(`invalid mark: ${mark}`);
    }
    let markOptions2 = {
      fx,
      fy,
      x: X3 ?? void 0,
      // treat null x as undefined for implicit stack
      y: Y3 ?? void 0,
      // treat null y as undefined for implicit stack
      [colorMode]: C8 ?? colorColor,
      z: Z3,
      r: S3 ?? void 0,
      // treat null size as undefined for default constant radius
      tip: true
    };
    let transformImpl;
    let transformOptions = { [colorMode]: colorReduce ?? void 0, r: sizeReduce ?? void 0 };
    if (xReduce != null && yReduce != null) {
      throw new Error(`cannot reduce both x and y`);
    } else if (yReduce != null) {
      transformOptions.y = yReduce;
      transformImpl = isOrdinal(X3) ? groupX : binX;
    } else if (xReduce != null) {
      transformOptions.x = xReduce;
      transformImpl = isOrdinal(Y3) ? groupY : binY;
    } else if (colorReduce != null || sizeReduce != null) {
      if (X3 && Y3) {
        transformImpl = isOrdinal(X3) && isOrdinal(Y3) ? group2 : isOrdinal(X3) ? binY : isOrdinal(Y3) ? binX : bin;
      } else if (X3) {
        transformImpl = isOrdinal(X3) ? groupX : binX;
      } else if (Y3) {
        transformImpl = isOrdinal(Y3) ? groupY : binY;
      }
    }
    if (transformImpl === bin || transformImpl === binX) markOptions2.x = { value: X3, ...xOptions };
    if (transformImpl === bin || transformImpl === binY) markOptions2.y = { value: Y3, ...yOptions };
    if (xZero === void 0)
      xZero = X3 && !(transformImpl === bin || transformImpl === binX) && (markImpl === barX || markImpl === areaX || markImpl === rectX || markImpl === ruleY);
    if (yZero === void 0)
      yZero = Y3 && !(transformImpl === bin || transformImpl === binY) && (markImpl === barY || markImpl === areaY || markImpl === rectY || markImpl === ruleX);
    return {
      fx: fx ?? null,
      fy: fy ?? null,
      x: {
        value: xValue ?? null,
        reduce: xReduce ?? null,
        zero: !!xZero,
        ...xOptions
      },
      y: {
        value: yValue ?? null,
        reduce: yReduce ?? null,
        zero: !!yZero,
        ...yOptions
      },
      color: {
        value: colorValue ?? null,
        reduce: colorReduce ?? null,
        ...colorColor !== void 0 && { color: colorColor }
      },
      size: {
        value: sizeValue ?? null,
        reduce: sizeReduce ?? null
      },
      mark,
      markImpl: implNames[markImpl],
      markOptions: markOptions2,
      transformImpl: implNames[transformImpl],
      transformOptions,
      colorMode
    };
  }
  function auto(data, options) {
    const spec = autoSpec(data, options);
    const {
      fx,
      fy,
      x: { zero: xZero },
      y: { zero: yZero },
      markOptions: markOptions2,
      transformOptions,
      colorMode
    } = spec;
    const markImpl = impls[spec.markImpl];
    const transformImpl = impls[spec.transformImpl];
    const frames = fx != null || fy != null ? frame3({ strokeOpacity: 0.1 }) : null;
    const rules = [xZero ? ruleX([0]) : null, yZero ? ruleY([0]) : null];
    const mark = markImpl(data, transformImpl ? transformImpl(transformOptions, markOptions2) : markOptions2);
    return colorMode === "stroke" ? marks(frames, rules, mark) : marks(frames, mark, rules);
  }
  function isMonotonic(values2) {
    let previous;
    let previousOrder;
    for (const value of values2) {
      if (value == null) continue;
      if (previous === void 0) {
        previous = value;
        continue;
      }
      const order = Math.sign(ascending(previous, value));
      if (!order) continue;
      if (previousOrder !== void 0 && order !== previousOrder) return false;
      previous = value;
      previousOrder = order;
    }
    return true;
  }
  function normalizeOptions({ x: x3, y: y3, color: color3, size, fx, fy, mark } = {}) {
    if (!isOptions(x3)) x3 = makeOptions(x3);
    if (!isOptions(y3)) y3 = makeOptions(y3);
    if (!isOptions(color3)) color3 = isColor(color3) ? { color: color3 } : makeOptions(color3);
    if (!isOptions(size)) size = makeOptions(size);
    if (isOptions(fx)) ({ value: fx } = makeOptions(fx));
    if (isOptions(fy)) ({ value: fy } = makeOptions(fy));
    if (mark != null) mark = `${mark}`.toLowerCase();
    return { x: x3, y: y3, color: color3, size, fx, fy, mark };
  }
  function materializeValue(data, options) {
    const V2 = valueof(data, options.value);
    if (V2) V2.label = labelof(options.value);
    return V2;
  }
  function makeOptions(value) {
    return isReducer(value) ? { reduce: value } : { value };
  }
  function isZeroReducer(reduce) {
    return /^(?:distinct|count|sum|proportion)$/i.test(reduce);
  }
  function isSelectReducer(reduce) {
    return /^(?:first|last|mode)$/i.test(reduce);
  }
  function isReducer(reduce) {
    if (reduce == null) return false;
    if (typeof reduce.reduceIndex === "function") return true;
    if (typeof reduce.reduce === "function" && isObject(reduce)) return true;
    if (/^p\d{2}$/i.test(reduce)) return true;
    switch (`${reduce}`.toLowerCase()) {
      case "first":
      case "last":
      case "count":
      case "distinct":
      case "sum":
      case "proportion":
      case "proportion-facet":
      // TODO remove me?
      case "deviation":
      case "min":
      case "min-index":
      // TODO remove me?
      case "max":
      case "max-index":
      // TODO remove me?
      case "mean":
      case "median":
      case "variance":
      case "mode":
        return true;
    }
    return false;
  }
  function isHighCardinality(value) {
    return value ? new InternSet(value).size > value.length >> 1 : false;
  }
  var impls = {
    dot,
    line,
    lineX,
    lineY,
    areaX,
    areaY,
    ruleX,
    ruleY,
    barX,
    barY,
    rect: rect2,
    rectX,
    rectY,
    cell,
    bin,
    binX,
    binY,
    group: group2,
    groupX,
    groupY
  };
  var implNames = Object.fromEntries(Object.entries(impls).map(([name, impl]) => [impl, name]));

  // ../../../../../node_modules/@observablehq/plot/src/transforms/map.js
  function mapX(mapper, options = {}) {
    let { x: x3, x1: x12, x2: x22 } = options;
    if (x3 === void 0 && x12 === void 0 && x22 === void 0) options = { ...options, x: x3 = identity6 };
    const outputs = {};
    if (x3 != null) outputs.x = mapper;
    if (x12 != null) outputs.x1 = mapper;
    if (x22 != null) outputs.x2 = mapper;
    return map3(outputs, options);
  }
  function mapY(mapper, options = {}) {
    let { y: y3, y1: y12, y2: y22 } = options;
    if (y3 === void 0 && y12 === void 0 && y22 === void 0) options = { ...options, y: y3 = identity6 };
    const outputs = {};
    if (y3 != null) outputs.y = mapper;
    if (y12 != null) outputs.y1 = mapper;
    if (y22 != null) outputs.y2 = mapper;
    return map3(outputs, options);
  }
  function map3(outputs = {}, options = {}) {
    const z2 = maybeZ(options);
    const channels = Object.entries(outputs).map(([key, map4]) => {
      const input = maybeInput(key, options);
      if (input == null) throw new Error(`missing channel: ${key}`);
      const [output, setOutput] = column(input);
      return { key, input, output, setOutput, map: maybeMap(map4) };
    });
    return {
      ...basic(options, (data, facets) => {
        const Z3 = valueof(data, z2);
        const X3 = channels.map(({ input }) => valueof(data, input));
        const MX = channels.map(({ setOutput }) => setOutput(new Array(data.length)));
        for (const facet of facets) {
          for (const I2 of Z3 ? group(facet, (i5) => Z3[i5]).values() : [facet]) {
            channels.forEach(({ map: map4 }, i5) => map4.mapIndex(I2, X3[i5], MX[i5]));
          }
        }
        return { data, facets };
      }),
      ...Object.fromEntries(channels.map(({ key, output }) => [key, output]))
    };
  }
  function maybeMap(map4) {
    if (map4 == null) throw new Error("missing map");
    if (typeof map4.mapIndex === "function") return map4;
    if (typeof map4.map === "function" && isObject(map4)) return mapMap(map4);
    if (typeof map4 === "function") return mapFunction(taker(map4));
    switch (`${map4}`.toLowerCase()) {
      case "cumsum":
        return mapCumsum;
      case "rank":
        return mapFunction((I2, V2) => rank(I2, (i5) => V2[i5]));
      case "quantile":
        return mapFunction((I2, V2) => rankQuantile(I2, (i5) => V2[i5]));
    }
    throw new Error(`invalid map: ${map4}`);
  }
  function mapMap(map4) {
    console.warn("deprecated map interface; implement mapIndex instead.");
    return { mapIndex: map4.map.bind(map4) };
  }
  function rankQuantile(I2, f7) {
    const n9 = count2(I2, f7) - 1;
    return rank(I2, f7).map((r6) => r6 / n9);
  }
  function mapFunction(f7) {
    return {
      mapIndex(I2, S3, T2) {
        const M4 = f7(I2, S3);
        if (M4.length !== I2.length) throw new Error("map function returned a mismatched length");
        for (let i5 = 0, n9 = I2.length; i5 < n9; ++i5) T2[I2[i5]] = M4[i5];
      }
    };
  }
  var mapCumsum = {
    mapIndex(I2, S3, T2) {
      let sum3 = 0;
      for (const i5 of I2) T2[i5] = sum3 += S3[i5];
    }
  };

  // ../../../../../node_modules/@observablehq/plot/src/transforms/window.js
  function windowX(windowOptions = {}, options) {
    if (arguments.length === 1) options = windowOptions;
    return mapX(window2(windowOptions), options);
  }
  function windowY(windowOptions = {}, options) {
    if (arguments.length === 1) options = windowOptions;
    return mapY(window2(windowOptions), options);
  }
  function window2(options = {}) {
    if (typeof options === "number") options = { k: options };
    let { k: k3, reduce, shift, anchor, strict } = options;
    if (anchor === void 0 && shift !== void 0) {
      anchor = maybeShift(shift);
      warn(`Warning: the shift option is deprecated; please use anchor "${anchor}" instead.`);
    }
    if (!((k3 = Math.floor(k3)) > 0)) throw new Error(`invalid k: ${k3}`);
    return maybeReduce2(reduce)(k3, maybeAnchor3(anchor, k3), strict);
  }
  function maybeAnchor3(anchor = "middle", k3) {
    switch (`${anchor}`.toLowerCase()) {
      case "middle":
        return k3 - 1 >> 1;
      case "start":
        return 0;
      case "end":
        return k3 - 1;
    }
    throw new Error(`invalid anchor: ${anchor}`);
  }
  function maybeShift(shift) {
    switch (`${shift}`.toLowerCase()) {
      case "centered":
        return "middle";
      case "leading":
        return "start";
      case "trailing":
        return "end";
    }
    throw new Error(`invalid shift: ${shift}`);
  }
  function maybeReduce2(reduce = "mean") {
    if (typeof reduce === "string") {
      if (/^p\d{2}$/i.test(reduce)) return reduceAccessor2(percentile(reduce));
      switch (reduce.toLowerCase()) {
        case "deviation":
          return reduceAccessor2(deviation);
        case "max":
          return reduceArray((I2, V2) => max(I2, (i5) => V2[i5]));
        case "mean":
          return reduceMean;
        case "median":
          return reduceAccessor2(median);
        case "min":
          return reduceArray((I2, V2) => min(I2, (i5) => V2[i5]));
        case "mode":
          return reduceArray((I2, V2) => mode(I2, (i5) => V2[i5]));
        case "sum":
          return reduceSum2;
        case "variance":
          return reduceAccessor2(variance);
        case "difference":
          return reduceDifference;
        case "ratio":
          return reduceRatio;
        case "first":
          return reduceFirst2;
        case "last":
          return reduceLast2;
      }
    }
    if (typeof reduce !== "function") throw new Error(`invalid reduce: ${reduce}`);
    return reduceArray(taker(reduce));
  }
  function reduceAccessor2(f7) {
    return (k3, s8, strict) => strict ? {
      mapIndex(I2, S3, T2) {
        const v3 = (i5) => S3[i5] == null ? NaN : +S3[i5];
        let nans = 0;
        for (let i5 = 0; i5 < k3 - 1; ++i5) if (isNaN(v3(i5))) ++nans;
        for (let i5 = 0, n9 = I2.length - k3 + 1; i5 < n9; ++i5) {
          if (isNaN(v3(i5 + k3 - 1))) ++nans;
          T2[I2[i5 + s8]] = nans === 0 ? f7(subarray(I2, i5, i5 + k3), v3) : NaN;
          if (isNaN(v3(i5))) --nans;
        }
      }
    } : {
      mapIndex(I2, S3, T2) {
        const v3 = (i5) => S3[i5] == null ? NaN : +S3[i5];
        for (let i5 = -s8; i5 < 0; ++i5) {
          T2[I2[i5 + s8]] = f7(subarray(I2, 0, i5 + k3), v3);
        }
        for (let i5 = 0, n9 = I2.length - s8; i5 < n9; ++i5) {
          T2[I2[i5 + s8]] = f7(subarray(I2, i5, i5 + k3), v3);
        }
      }
    };
  }
  function reduceArray(f7) {
    return (k3, s8, strict) => strict ? {
      mapIndex(I2, S3, T2) {
        let count4 = 0;
        for (let i5 = 0; i5 < k3 - 1; ++i5) count4 += defined(S3[I2[i5]]);
        for (let i5 = 0, n9 = I2.length - k3 + 1; i5 < n9; ++i5) {
          count4 += defined(S3[I2[i5 + k3 - 1]]);
          if (count4 === k3) T2[I2[i5 + s8]] = f7(subarray(I2, i5, i5 + k3), S3);
          count4 -= defined(S3[I2[i5]]);
        }
      }
    } : {
      mapIndex(I2, S3, T2) {
        for (let i5 = -s8; i5 < 0; ++i5) {
          T2[I2[i5 + s8]] = f7(subarray(I2, 0, i5 + k3), S3);
        }
        for (let i5 = 0, n9 = I2.length - s8; i5 < n9; ++i5) {
          T2[I2[i5 + s8]] = f7(subarray(I2, i5, i5 + k3), S3);
        }
      }
    };
  }
  function reduceSum2(k3, s8, strict) {
    return strict ? {
      mapIndex(I2, S3, T2) {
        let nans = 0;
        let sum3 = 0;
        for (let i5 = 0; i5 < k3 - 1; ++i5) {
          const v3 = S3[I2[i5]];
          if (v3 === null || isNaN(v3)) ++nans;
          else sum3 += +v3;
        }
        for (let i5 = 0, n9 = I2.length - k3 + 1; i5 < n9; ++i5) {
          const a5 = S3[I2[i5]];
          const b2 = S3[I2[i5 + k3 - 1]];
          if (b2 === null || isNaN(b2)) ++nans;
          else sum3 += +b2;
          T2[I2[i5 + s8]] = nans === 0 ? sum3 : NaN;
          if (a5 === null || isNaN(a5)) --nans;
          else sum3 -= +a5;
        }
      }
    } : {
      mapIndex(I2, S3, T2) {
        let sum3 = 0;
        const n9 = I2.length;
        for (let i5 = 0, j2 = Math.min(n9, k3 - s8 - 1); i5 < j2; ++i5) {
          sum3 += +S3[I2[i5]] || 0;
        }
        for (let i5 = -s8, j2 = n9 - s8; i5 < j2; ++i5) {
          sum3 += +S3[I2[i5 + k3 - 1]] || 0;
          T2[I2[i5 + s8]] = sum3;
          sum3 -= +S3[I2[i5]] || 0;
        }
      }
    };
  }
  function reduceMean(k3, s8, strict) {
    if (strict) {
      const sum3 = reduceSum2(k3, s8, strict);
      return {
        mapIndex(I2, S3, T2) {
          sum3.mapIndex(I2, S3, T2);
          for (let i5 = 0, n9 = I2.length - k3 + 1; i5 < n9; ++i5) {
            T2[I2[i5 + s8]] /= k3;
          }
        }
      };
    } else {
      return {
        mapIndex(I2, S3, T2) {
          let sum3 = 0;
          let count4 = 0;
          const n9 = I2.length;
          for (let i5 = 0, j2 = Math.min(n9, k3 - s8 - 1); i5 < j2; ++i5) {
            let v3 = S3[I2[i5]];
            if (v3 !== null && !isNaN(v3 = +v3)) sum3 += v3, ++count4;
          }
          for (let i5 = -s8, j2 = n9 - s8; i5 < j2; ++i5) {
            let a5 = S3[I2[i5 + k3 - 1]];
            let b2 = S3[I2[i5]];
            if (a5 !== null && !isNaN(a5 = +a5)) sum3 += a5, ++count4;
            T2[I2[i5 + s8]] = sum3 / count4;
            if (b2 !== null && !isNaN(b2 = +b2)) sum3 -= b2, --count4;
          }
        }
      };
    }
  }
  function firstDefined(S3, I2, i5, k3) {
    for (let j2 = i5 + k3; i5 < j2; ++i5) {
      const v3 = S3[I2[i5]];
      if (defined(v3)) return v3;
    }
  }
  function lastDefined(S3, I2, i5, k3) {
    for (let j2 = i5 + k3 - 1; j2 >= i5; --j2) {
      const v3 = S3[I2[j2]];
      if (defined(v3)) return v3;
    }
  }
  function firstNumber(S3, I2, i5, k3) {
    for (let j2 = i5 + k3; i5 < j2; ++i5) {
      let v3 = S3[I2[i5]];
      if (v3 !== null && !isNaN(v3 = +v3)) return v3;
    }
  }
  function lastNumber(S3, I2, i5, k3) {
    for (let j2 = i5 + k3 - 1; j2 >= i5; --j2) {
      let v3 = S3[I2[j2]];
      if (v3 !== null && !isNaN(v3 = +v3)) return v3;
    }
  }
  function reduceDifference(k3, s8, strict) {
    return strict ? {
      mapIndex(I2, S3, T2) {
        for (let i5 = 0, n9 = I2.length - k3; i5 < n9; ++i5) {
          const a5 = S3[I2[i5]];
          const b2 = S3[I2[i5 + k3 - 1]];
          T2[I2[i5 + s8]] = a5 === null || b2 === null ? NaN : b2 - a5;
        }
      }
    } : {
      mapIndex(I2, S3, T2) {
        for (let i5 = -s8, n9 = I2.length - k3 + s8 + 1; i5 < n9; ++i5) {
          T2[I2[i5 + s8]] = lastNumber(S3, I2, i5, k3) - firstNumber(S3, I2, i5, k3);
        }
      }
    };
  }
  function reduceRatio(k3, s8, strict) {
    return strict ? {
      mapIndex(I2, S3, T2) {
        for (let i5 = 0, n9 = I2.length - k3; i5 < n9; ++i5) {
          const a5 = S3[I2[i5]];
          const b2 = S3[I2[i5 + k3 - 1]];
          T2[I2[i5 + s8]] = a5 === null || b2 === null ? NaN : b2 / a5;
        }
      }
    } : {
      mapIndex(I2, S3, T2) {
        for (let i5 = -s8, n9 = I2.length - k3 + s8 + 1; i5 < n9; ++i5) {
          T2[I2[i5 + s8]] = lastNumber(S3, I2, i5, k3) / firstNumber(S3, I2, i5, k3);
        }
      }
    };
  }
  function reduceFirst2(k3, s8, strict) {
    return strict ? {
      mapIndex(I2, S3, T2) {
        for (let i5 = 0, n9 = I2.length - k3; i5 < n9; ++i5) {
          T2[I2[i5 + s8]] = S3[I2[i5]];
        }
      }
    } : {
      mapIndex(I2, S3, T2) {
        for (let i5 = -s8, n9 = I2.length - k3 + s8 + 1; i5 < n9; ++i5) {
          T2[I2[i5 + s8]] = firstDefined(S3, I2, i5, k3);
        }
      }
    };
  }
  function reduceLast2(k3, s8, strict) {
    return strict ? {
      mapIndex(I2, S3, T2) {
        for (let i5 = 0, n9 = I2.length - k3; i5 < n9; ++i5) {
          T2[I2[i5 + s8]] = S3[I2[i5 + k3 - 1]];
        }
      }
    } : {
      mapIndex(I2, S3, T2) {
        for (let i5 = -s8, n9 = I2.length - k3 + s8 + 1; i5 < n9; ++i5) {
          T2[I2[i5 + s8]] = lastDefined(S3, I2, i5, k3);
        }
      }
    };
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/bollinger.js
  var defaults13 = {
    n: 20,
    k: 2,
    color: "currentColor",
    opacity: 0.2,
    strict: true,
    anchor: "end"
  };
  function bollingerX(data, {
    x: x3 = identity6,
    y: y3,
    k: k3 = defaults13.k,
    color: color3 = defaults13.color,
    opacity: opacity2 = defaults13.opacity,
    fill = color3,
    fillOpacity = opacity2,
    stroke = color3,
    strokeOpacity,
    strokeWidth,
    ...options
  } = {}) {
    return marks(
      isNoneish(fill) ? null : areaX(
        data,
        map3(
          { x1: bollinger({ k: -k3, ...options }), x2: bollinger({ k: k3, ...options }) },
          { x1: x3, x2: x3, y: y3, fill, fillOpacity, ...options }
        )
      ),
      isNoneish(stroke) ? null : lineX(data, map3({ x: bollinger(options) }, { x: x3, y: y3, stroke, strokeOpacity, strokeWidth, ...options }))
    );
  }
  function bollingerY(data, {
    x: x3,
    y: y3 = identity6,
    k: k3 = defaults13.k,
    color: color3 = defaults13.color,
    opacity: opacity2 = defaults13.opacity,
    fill = color3,
    fillOpacity = opacity2,
    stroke = color3,
    strokeOpacity,
    strokeWidth,
    ...options
  } = {}) {
    return marks(
      isNoneish(fill) ? null : areaY(
        data,
        map3(
          { y1: bollinger({ k: -k3, ...options }), y2: bollinger({ k: k3, ...options }) },
          { x: x3, y1: y3, y2: y3, fill, fillOpacity, ...options }
        )
      ),
      isNoneish(stroke) ? null : lineY(data, map3({ y: bollinger(options) }, { x: x3, y: y3, stroke, strokeOpacity, strokeWidth, ...options }))
    );
  }
  function bollinger({ n: n9 = defaults13.n, k: k3 = 0, strict = defaults13.strict, anchor = defaults13.anchor } = {}) {
    return window2({ k: n9, reduce: (Y3) => mean(Y3) + k3 * (deviation(Y3) || 0), strict, anchor });
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/tick.js
  var defaults14 = {
    ariaLabel: "tick",
    fill: null,
    stroke: "currentColor"
  };
  var AbstractTick = class extends Mark {
    constructor(data, channels, options) {
      super(data, channels, options, defaults14);
      markers(this, options);
    }
    render(index2, scales, channels, dimensions, context) {
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call(
        (g2) => g2.selectAll().data(index2).enter().append("line").call(applyDirectStyles, this).attr("x1", this._x1(scales, channels, dimensions)).attr("x2", this._x2(scales, channels, dimensions)).attr("y1", this._y1(scales, channels, dimensions)).attr("y2", this._y2(scales, channels, dimensions)).call(applyChannelStyles, this, channels).call(applyMarkers, this, channels, context)
      ).node();
    }
  };
  var TickX = class extends AbstractTick {
    constructor(data, options = {}) {
      const { x: x3, y: y3, inset = 0, insetTop = inset, insetBottom = inset } = options;
      super(
        data,
        {
          x: { value: x3, scale: "x" },
          y: { value: y3, scale: "y", type: "band", optional: true }
        },
        options
      );
      this.insetTop = number5(insetTop);
      this.insetBottom = number5(insetBottom);
    }
    _transform(selection2, mark, { x: x3 }) {
      selection2.call(applyTransform, mark, { x: x3 }, offset, 0);
    }
    _x1(scales, { x: X3 }) {
      return (i5) => X3[i5];
    }
    _x2(scales, { x: X3 }) {
      return (i5) => X3[i5];
    }
    _y1({ y: y3 }, { y: Y3 }, { marginTop }) {
      const { insetTop } = this;
      return Y3 && y3 ? (i5) => Y3[i5] + insetTop : marginTop + insetTop;
    }
    _y2({ y: y3 }, { y: Y3 }, { height, marginBottom }) {
      const { insetBottom } = this;
      return Y3 && y3 ? (i5) => Y3[i5] + y3.bandwidth() - insetBottom : height - marginBottom - insetBottom;
    }
  };
  var TickY = class extends AbstractTick {
    constructor(data, options = {}) {
      const { x: x3, y: y3, inset = 0, insetRight = inset, insetLeft = inset } = options;
      super(
        data,
        {
          y: { value: y3, scale: "y" },
          x: { value: x3, scale: "x", type: "band", optional: true }
        },
        options
      );
      this.insetRight = number5(insetRight);
      this.insetLeft = number5(insetLeft);
    }
    _transform(selection2, mark, { y: y3 }) {
      selection2.call(applyTransform, mark, { y: y3 }, 0, offset);
    }
    _x1({ x: x3 }, { x: X3 }, { marginLeft }) {
      const { insetLeft } = this;
      return X3 && x3 ? (i5) => X3[i5] + insetLeft : marginLeft + insetLeft;
    }
    _x2({ x: x3 }, { x: X3 }, { width, marginRight }) {
      const { insetRight } = this;
      return X3 && x3 ? (i5) => X3[i5] + x3.bandwidth() - insetRight : width - marginRight - insetRight;
    }
    _y1(scales, { y: Y3 }) {
      return (i5) => Y3[i5];
    }
    _y2(scales, { y: Y3 }) {
      return (i5) => Y3[i5];
    }
  };
  function tickX(data, { x: x3 = identity6, ...options } = {}) {
    return new TickX(data, { ...options, x: x3 });
  }
  function tickY(data, { y: y3 = identity6, ...options } = {}) {
    return new TickY(data, { ...options, y: y3 });
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/box.js
  function boxX(data, {
    x: x3 = identity6,
    y: y3 = null,
    r: r6,
    fill = "#ccc",
    fillOpacity,
    stroke = "currentColor",
    strokeOpacity,
    strokeWidth = 2,
    sort: sort3,
    ...options
  } = {}) {
    const group3 = y3 != null ? groupY : groupZ;
    return marks(
      ruleY(data, group3({ x1: loqr1, x2: hiqr2 }, { x: x3, y: y3, stroke, strokeOpacity, ...options })),
      barX(data, group3({ x1: "p25", x2: "p75" }, { x: x3, y: y3, fill, fillOpacity, ...options })),
      tickX(data, group3({ x: "p50" }, { x: x3, y: y3, stroke, strokeOpacity, strokeWidth, sort: sort3, ...options })),
      dot(data, map3({ x: oqr }, { x: x3, y: y3, z: y3, r: r6, stroke, strokeOpacity, ...options }))
    );
  }
  function boxY(data, {
    y: y3 = identity6,
    x: x3 = null,
    r: r6,
    fill = "#ccc",
    fillOpacity,
    stroke = "currentColor",
    strokeOpacity,
    strokeWidth = 2,
    sort: sort3,
    ...options
  } = {}) {
    const group3 = x3 != null ? groupX : groupZ;
    return marks(
      ruleX(data, group3({ y1: loqr1, y2: hiqr2 }, { x: x3, y: y3, stroke, strokeOpacity, ...options })),
      barY(data, group3({ y1: "p25", y2: "p75" }, { x: x3, y: y3, fill, fillOpacity, ...options })),
      tickY(data, group3({ y: "p50" }, { x: x3, y: y3, stroke, strokeOpacity, strokeWidth, sort: sort3, ...options })),
      dot(data, map3({ y: oqr }, { x: x3, y: y3, z: x3, r: r6, stroke, strokeOpacity, ...options }))
    );
  }
  function oqr(values2) {
    const r1 = loqr1(values2);
    const r22 = hiqr2(values2);
    return values2.map((v3) => v3 < r1 || v3 > r22 ? v3 : NaN);
  }
  function loqr1(values2) {
    const lo = quartile1(values2) * 2.5 - quartile3(values2) * 1.5;
    return min(values2, (d3) => d3 >= lo ? d3 : NaN);
  }
  function hiqr2(values2) {
    const hi = quartile3(values2) * 2.5 - quartile1(values2) * 1.5;
    return max(values2, (d3) => d3 <= hi ? d3 : NaN);
  }
  function quartile1(values2) {
    return quantile(values2, 0.25);
  }
  function quartile3(values2) {
    return quantile(values2, 0.75);
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/raster.js
  var defaults15 = {
    ariaLabel: "raster",
    stroke: null,
    pixelSize: 1
  };
  function number6(input, name) {
    const x3 = +input;
    if (isNaN(x3)) throw new Error(`invalid ${name}: ${input}`);
    return x3;
  }
  function integer(input, name) {
    const x3 = Math.floor(input);
    if (isNaN(x3)) throw new Error(`invalid ${name}: ${input}`);
    return x3;
  }
  var AbstractRaster = class extends Mark {
    constructor(data, channels, options = {}, defaults22) {
      let {
        width,
        height,
        x: x3,
        y: y3,
        x1: x12 = x3 == null ? 0 : void 0,
        y1: y12 = y3 == null ? 0 : void 0,
        x2: x22 = x3 == null ? width : void 0,
        y2: y22 = y3 == null ? height : void 0,
        pixelSize = defaults22.pixelSize,
        blur: blur3 = 0,
        interpolate
      } = options;
      if (width != null) width = integer(width, "width");
      if (height != null) height = integer(height, "height");
      if (x12 != null) x12 = number6(x12, "x1");
      if (y12 != null) y12 = number6(y12, "y1");
      if (x22 != null) x22 = number6(x22, "x2");
      if (y22 != null) y22 = number6(y22, "y2");
      if (x3 == null && (x12 == null || x22 == null)) throw new Error("missing x");
      if (y3 == null && (y12 == null || y22 == null)) throw new Error("missing y");
      if (data != null && width != null && height != null) {
        if (x3 === void 0 && x12 != null && x22 != null) x3 = denseX(x12, x22, width, height);
        if (y3 === void 0 && y12 != null && y22 != null) y3 = denseY(y12, y22, width, height);
      }
      super(
        data,
        {
          x: { value: x3, scale: "x", optional: true },
          y: { value: y3, scale: "y", optional: true },
          x1: { value: x12 == null ? null : [x12], scale: "x", optional: true, filter: null },
          y1: { value: y12 == null ? null : [y12], scale: "y", optional: true, filter: null },
          x2: { value: x22 == null ? null : [x22], scale: "x", optional: true, filter: null },
          y2: { value: y22 == null ? null : [y22], scale: "y", optional: true, filter: null },
          ...channels
        },
        options,
        defaults22
      );
      this.width = width;
      this.height = height;
      this.pixelSize = number6(pixelSize, "pixelSize");
      this.blur = number6(blur3, "blur");
      this.interpolate = x3 == null || y3 == null ? null : maybeInterpolate(interpolate);
    }
  };
  var Raster = class extends AbstractRaster {
    constructor(data, options = {}) {
      const { imageRendering } = options;
      if (data == null) {
        const { fill, fillOpacity } = options;
        if (maybeNumberChannel(fillOpacity)[0] !== void 0) options = sampler("fillOpacity", options);
        if (maybeColorChannel(fill)[0] !== void 0) options = sampler("fill", options);
      }
      super(data, void 0, options, defaults15);
      this.imageRendering = impliedString(imageRendering, "auto");
    }
    // Ignore the color scale, so the fill channel is returned unscaled.
    scale(channels, { color: color3, ...scales }, context) {
      return super.scale(channels, scales, context);
    }
    render(index2, scales, values2, dimensions, context) {
      const color3 = scales[values2.channels.fill?.scale] ?? ((x3) => x3);
      const { x: X3, y: Y3 } = values2;
      const { document: document2 } = context;
      const [x12, y12, x22, y22] = renderBounds(values2, dimensions, context);
      const dx = x22 - x12;
      const dy = y22 - y12;
      const { pixelSize: k3, width: w2 = Math.round(Math.abs(dx) / k3), height: h5 = Math.round(Math.abs(dy) / k3) } = this;
      const n9 = w2 * h5;
      let { fill: F, fillOpacity: FO } = values2;
      let offset2 = 0;
      if (this.interpolate) {
        const kx2 = w2 / dx;
        const ky2 = h5 / dy;
        const IX = map2(X3, (x3) => (x3 - x12) * kx2, Float64Array);
        const IY = map2(Y3, (y3) => (y3 - y12) * ky2, Float64Array);
        if (F) F = this.interpolate(index2, w2, h5, IX, IY, F);
        if (FO) FO = this.interpolate(index2, w2, h5, IX, IY, FO);
      } else if (this.data == null && index2) offset2 = index2.fi * n9;
      const canvas = document2.createElement("canvas");
      canvas.width = w2;
      canvas.height = h5;
      const context2d = canvas.getContext("2d");
      const image2 = context2d.createImageData(w2, h5);
      const imageData = image2.data;
      let { r: r6, g: g2, b: b2 } = rgb(this.fill) ?? { r: 0, g: 0, b: 0 };
      let a5 = (this.fillOpacity ?? 1) * 255;
      for (let i5 = 0; i5 < n9; ++i5) {
        const j2 = i5 << 2;
        if (F) {
          const fi = color3(F[i5 + offset2]);
          if (fi == null) {
            imageData[j2 + 3] = 0;
            continue;
          }
          ({ r: r6, g: g2, b: b2 } = rgb(fi));
        }
        if (FO) a5 = FO[i5 + offset2] * 255;
        imageData[j2 + 0] = r6;
        imageData[j2 + 1] = g2;
        imageData[j2 + 2] = b2;
        imageData[j2 + 3] = a5;
      }
      if (this.blur > 0) blurImage(image2, this.blur);
      context2d.putImageData(image2, 0, 0);
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
        (g3) => g3.append("image").attr("transform", `translate(${x12},${y12}) scale(${Math.sign(x22 - x12)},${Math.sign(y22 - y12)})`).attr("width", Math.abs(dx)).attr("height", Math.abs(dy)).attr("preserveAspectRatio", "none").call(applyAttr, "image-rendering", this.imageRendering).call(applyDirectStyles, this).attr("xlink:href", canvas.toDataURL())
      ).node();
    }
  };
  function maybeTuples(k3, data, options) {
    if (arguments.length < 3) options = data, data = null;
    let { x: x3, y: y3, [k3]: z2, ...rest } = options;
    if (x3 === void 0 && y3 === void 0 && isTuples(data)) {
      x3 = first, y3 = second2;
      if (z2 === void 0) z2 = third;
    }
    return [data, { ...rest, x: x3, y: y3, [k3]: z2 }];
  }
  function raster() {
    const [data, options] = maybeTuples("fill", ...arguments);
    return new Raster(
      data,
      data == null || options.fill !== void 0 || options.fillOpacity !== void 0 ? options : { ...options, fill: identity6 }
    );
  }
  function renderBounds({ x1: x12, y1: y12, x2: x22, y2: y22 }, dimensions, { projection: projection3 }) {
    const { width, height, marginTop, marginRight, marginBottom, marginLeft } = dimensions;
    return [
      x12 && projection3 == null ? x12[0] : marginLeft,
      y12 && projection3 == null ? y12[0] : marginTop,
      x22 && projection3 == null ? x22[0] : width - marginRight,
      y22 && projection3 == null ? y22[0] : height - marginBottom
    ];
  }
  function rasterBounds({ x1: x12, y1: y12, x2: x22, y2: y22 }, scales, dimensions, context) {
    const channels = {};
    if (x12) channels.x1 = x12;
    if (y12) channels.y1 = y12;
    if (x22) channels.x2 = x22;
    if (y22) channels.y2 = y22;
    return renderBounds(valueObject(channels, scales), dimensions, context);
  }
  function sampler(name, options = {}) {
    const { [name]: value } = options;
    if (typeof value !== "function") throw new Error(`invalid ${name}: not a function`);
    return initializer({ ...options, [name]: void 0 }, function(data, facets, channels, scales, dimensions, context) {
      const { x: x3, y: y3 } = scales;
      if (!x3) throw new Error("missing scale: x");
      if (!y3) throw new Error("missing scale: y");
      const [x12, y12, x22, y22] = rasterBounds(channels, scales, dimensions, context);
      const dx = x22 - x12;
      const dy = y22 - y12;
      const { pixelSize: k3 } = this;
      const { width: w2 = Math.round(Math.abs(dx) / k3), height: h5 = Math.round(Math.abs(dy) / k3) } = options;
      const V2 = new Array(w2 * h5 * (facets ? facets.length : 1));
      const kx2 = dx / w2;
      const ky2 = dy / h5;
      let i5 = 0;
      for (const facet of facets ?? [void 0]) {
        for (let yi = 0.5; yi < h5; ++yi) {
          for (let xi = 0.5; xi < w2; ++xi, ++i5) {
            V2[i5] = value(x3.invert(x12 + xi * kx2), y3.invert(y12 + yi * ky2), facet);
          }
        }
      }
      return { data: V2, facets, channels: { [name]: { value: V2, scale: "auto" } } };
    });
  }
  function maybeInterpolate(interpolate) {
    if (typeof interpolate === "function") return interpolate;
    if (interpolate == null) return interpolateNone;
    switch (`${interpolate}`.toLowerCase()) {
      case "none":
        return interpolateNone;
      case "nearest":
        return interpolateNearest;
      case "barycentric":
        return interpolatorBarycentric();
      case "random-walk":
        return interpolatorRandomWalk();
    }
    throw new Error(`invalid interpolate: ${interpolate}`);
  }
  function interpolateNone(index2, width, height, X3, Y3, V2) {
    const W = new Array(width * height);
    for (const i5 of index2) {
      if (X3[i5] < 0 || X3[i5] >= width || Y3[i5] < 0 || Y3[i5] >= height) continue;
      W[Math.floor(Y3[i5]) * width + Math.floor(X3[i5])] = V2[i5];
    }
    return W;
  }
  function interpolatorBarycentric({ random = lcg(42) } = {}) {
    return (index2, width, height, X3, Y3, V2) => {
      const { points, triangles, hull: hull2 } = Delaunay.from(
        index2,
        (i5) => X3[i5],
        (i5) => Y3[i5]
      );
      const W = new V2.constructor(width * height).fill(NaN);
      const S3 = new Uint8Array(width * height);
      const mix = mixer(V2, random);
      for (let i5 = 0; i5 < triangles.length; i5 += 3) {
        const ta = triangles[i5];
        const tb = triangles[i5 + 1];
        const tc = triangles[i5 + 2];
        const Ax = points[2 * ta];
        const Bx = points[2 * tb];
        const Cx = points[2 * tc];
        const Ay = points[2 * ta + 1];
        const By = points[2 * tb + 1];
        const Cy = points[2 * tc + 1];
        const x12 = Math.min(Ax, Bx, Cx);
        const x22 = Math.max(Ax, Bx, Cx);
        const y12 = Math.min(Ay, By, Cy);
        const y22 = Math.max(Ay, By, Cy);
        const z2 = (By - Cy) * (Ax - Cx) + (Ay - Cy) * (Cx - Bx);
        if (!z2) continue;
        const va = V2[index2[ta]];
        const vb = V2[index2[tb]];
        const vc = V2[index2[tc]];
        for (let x3 = Math.floor(x12); x3 < x22; ++x3) {
          for (let y3 = Math.floor(y12); y3 < y22; ++y3) {
            if (x3 < 0 || x3 >= width || y3 < 0 || y3 >= height) continue;
            const xp = x3 + 0.5;
            const yp = y3 + 0.5;
            const s8 = Math.sign(z2);
            const ga = (By - Cy) * (xp - Cx) + (yp - Cy) * (Cx - Bx);
            if (ga * s8 < 0) continue;
            const gb = (Cy - Ay) * (xp - Cx) + (yp - Cy) * (Ax - Cx);
            if (gb * s8 < 0) continue;
            const gc = z2 - (ga + gb);
            if (gc * s8 < 0) continue;
            const i6 = x3 + width * y3;
            W[i6] = mix(va, ga / z2, vb, gb / z2, vc, gc / z2, x3, y3);
            S3[i6] = 1;
          }
        }
      }
      extrapolateBarycentric(W, S3, X3, Y3, V2, width, height, hull2, index2, mix);
      return W;
    };
  }
  function extrapolateBarycentric(W, S3, X3, Y3, V2, width, height, hull2, index2, mix) {
    X3 = Float64Array.from(hull2, (i5) => X3[index2[i5]]);
    Y3 = Float64Array.from(hull2, (i5) => Y3[index2[i5]]);
    V2 = Array.from(hull2, (i5) => V2[index2[i5]]);
    const n9 = X3.length;
    const rays = Array.from({ length: n9 }, (_2, j2) => ray(j2, X3, Y3));
    let k3 = 0;
    for (let y3 = 0; y3 < height; ++y3) {
      const yp = y3 + 0.5;
      for (let x3 = 0; x3 < width; ++x3) {
        const i5 = x3 + width * y3;
        if (!S3[i5]) {
          const xp = x3 + 0.5;
          for (let l8 = 0; l8 < n9; ++l8) {
            const j2 = (n9 + k3 + (l8 % 2 ? (l8 + 1) / 2 : -l8 / 2)) % n9;
            if (rays[j2](xp, yp)) {
              const t5 = segmentProject(X3.at(j2 - 1), Y3.at(j2 - 1), X3[j2], Y3[j2], xp, yp);
              W[i5] = mix(V2.at(j2 - 1), t5, V2[j2], 1 - t5, V2[j2], 0, x3, y3);
              k3 = j2;
              break;
            }
          }
        }
      }
    }
  }
  function segmentProject(x12, y12, x22, y22, x3, y3) {
    const dx = x22 - x12;
    const dy = y22 - y12;
    const a5 = dx * (x22 - x3) + dy * (y22 - y3);
    const b2 = dx * (x3 - x12) + dy * (y3 - y12);
    return a5 > 0 && b2 > 0 ? a5 / (a5 + b2) : +(a5 > b2);
  }
  function cross2(xa, ya, xb, yb) {
    return xa * yb - xb * ya;
  }
  function ray(j2, X3, Y3) {
    const n9 = X3.length;
    const xc = X3.at(j2 - 2);
    const yc = Y3.at(j2 - 2);
    const xa = X3.at(j2 - 1);
    const ya = Y3.at(j2 - 1);
    const xb = X3[j2];
    const yb = Y3[j2];
    const xd = X3.at(j2 + 1 - n9);
    const yd = Y3.at(j2 + 1 - n9);
    const dxab = xa - xb;
    const dyab = ya - yb;
    const dxca = xc - xa;
    const dyca = yc - ya;
    const dxbd = xb - xd;
    const dybd = yb - yd;
    const hab = Math.hypot(dxab, dyab);
    const hca = Math.hypot(dxca, dyca);
    const hbd = Math.hypot(dxbd, dybd);
    return (x3, y3) => {
      const dxa = x3 - xa;
      const dya = y3 - ya;
      const dxb = x3 - xb;
      const dyb = y3 - yb;
      return cross2(dxa, dya, dxb, dyb) > -1e-6 && cross2(dxa, dya, dxab, dyab) * hca - cross2(dxa, dya, dxca, dyca) * hab > -1e-6 && cross2(dxb, dyb, dxbd, dybd) * hab - cross2(dxb, dyb, dxab, dyab) * hbd <= 0;
    };
  }
  function interpolateNearest(index2, width, height, X3, Y3, V2) {
    const W = new V2.constructor(width * height);
    const delaunay = Delaunay.from(
      index2,
      (i5) => X3[i5],
      (i5) => Y3[i5]
    );
    let iy, ix;
    for (let y3 = 0.5, k3 = 0; y3 < height; ++y3) {
      ix = iy;
      for (let x3 = 0.5; x3 < width; ++x3, ++k3) {
        ix = delaunay.find(x3, y3, ix);
        if (x3 === 0.5) iy = ix;
        W[k3] = V2[index2[ix]];
      }
    }
    return W;
  }
  function interpolatorRandomWalk({ random = lcg(42), minDistance = 0.5, maxSteps = 2 } = {}) {
    return (index2, width, height, X3, Y3, V2) => {
      const W = new V2.constructor(width * height);
      const delaunay = Delaunay.from(
        index2,
        (i5) => X3[i5],
        (i5) => Y3[i5]
      );
      let iy, ix, iw;
      for (let y3 = 0.5, k3 = 0; y3 < height; ++y3) {
        ix = iy;
        for (let x3 = 0.5; x3 < width; ++x3, ++k3) {
          let cx = x3;
          let cy = y3;
          iw = ix = delaunay.find(cx, cy, ix);
          if (x3 === 0.5) iy = ix;
          let distance;
          let step3 = 0;
          while ((distance = Math.hypot(X3[index2[iw]] - cx, Y3[index2[iw]] - cy)) > minDistance && step3 < maxSteps) {
            const angle = random(x3, y3, step3) * 2 * Math.PI;
            cx += Math.cos(angle) * distance;
            cy += Math.sin(angle) * distance;
            iw = delaunay.find(cx, cy, iw);
            ++step3;
          }
          W[k3] = V2[index2[iw]];
        }
      }
      return W;
    };
  }
  function blend(a5, ca3, b2, cb, c9, cc2) {
    return ca3 * a5 + cb * b2 + cc2 * c9;
  }
  function pick(random) {
    return (a5, ca3, b2, cb, c9, cc2, x3, y3) => {
      const u7 = random(x3, y3);
      return u7 < ca3 ? a5 : u7 < ca3 + cb ? b2 : c9;
    };
  }
  function mixer(F, random) {
    return isNumeric(F) || isTemporal(F) ? blend : pick(random);
  }
  function denseX(x12, x22, width) {
    return {
      transform(data) {
        const n9 = data.length;
        const X3 = new Float64Array(n9);
        const kx2 = (x22 - x12) / width;
        const x06 = x12 + kx2 / 2;
        for (let i5 = 0; i5 < n9; ++i5) X3[i5] = i5 % width * kx2 + x06;
        return X3;
      }
    };
  }
  function denseY(y12, y22, width, height) {
    return {
      transform(data) {
        const n9 = data.length;
        const Y3 = new Float64Array(n9);
        const ky2 = (y22 - y12) / height;
        const y06 = y12 + ky2 / 2;
        for (let i5 = 0; i5 < n9; ++i5) Y3[i5] = Math.floor(i5 / width) % height * ky2 + y06;
        return Y3;
      }
    };
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/contour.js
  var defaults16 = {
    ariaLabel: "contour",
    fill: "none",
    stroke: "currentColor",
    strokeMiterlimit: 1,
    pixelSize: 2
  };
  var Contour = class extends AbstractRaster {
    constructor(data, { smooth = true, value, ...options } = {}) {
      const channels = styles2({}, options, defaults16);
      if (value === void 0) {
        for (const key in channels) {
          if (channels[key].value != null) {
            if (value !== void 0) throw new Error("ambiguous contour value");
            value = options[key];
            options[key] = "value";
          }
        }
      }
      if (value != null) {
        const v3 = { transform: (D4) => D4.map((d3) => d3.value), label: labelof(value) };
        for (const key in channels) {
          if (options[key] === "value") {
            options[key] = v3;
          }
        }
      }
      if (data == null) {
        if (value == null) throw new Error("missing contour value");
        options = sampler("value", { value, ...options });
        value = null;
      } else {
        let { interpolate } = options;
        if (value === void 0) value = identity6;
        if (interpolate === void 0) options.interpolate = "nearest";
      }
      super(data, { value: { value, optional: true } }, contourGeometry(options), defaults16);
      const contourChannels = { geometry: { value: identity6 } };
      for (const key in this.channels) {
        const channel = this.channels[key];
        const { scale: scale3 } = channel;
        if (scale3 === "x" || scale3 === "y" || key === "value") continue;
        contourChannels[key] = channel;
        delete this.channels[key];
      }
      this.contourChannels = contourChannels;
      this.smooth = !!smooth;
    }
    filter(index2, { x: x3, y: y3, value, ...channels }, values2) {
      return super.filter(index2, channels, values2);
    }
    render(index2, scales, channels, dimensions, context) {
      const { geometry: G } = channels;
      const path2 = path_default();
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g2) => {
        g2.selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).attr("d", (i5) => path2(G[i5])).call(applyChannelStyles, this, channels);
      }).node();
    }
  };
  function contourGeometry({ thresholds, interval: interval2, ...options }) {
    thresholds = maybeThresholds(thresholds, interval2, thresholdSturges);
    return initializer(options, function(data, facets, channels, scales, dimensions, context) {
      const [x12, y12, x22, y22] = rasterBounds(channels, scales, dimensions, context);
      const dx = x22 - x12;
      const dy = y22 - y12;
      const { pixelSize: k3, width: w2 = Math.round(Math.abs(dx) / k3), height: h5 = Math.round(Math.abs(dy) / k3) } = this;
      const kx2 = w2 / dx;
      const ky2 = h5 / dy;
      const V2 = channels.value.value;
      const VV = [];
      if (this.interpolate) {
        const { x: X3, y: Y3 } = applyPosition(channels, scales, context);
        const IX = map2(X3, (x3) => (x3 - x12) * kx2, Float64Array);
        const IY = map2(Y3, (y3) => (y3 - y12) * ky2, Float64Array);
        const ichannels = [channels.x, channels.y, channels.value];
        const ivalues = [IX, IY, V2];
        for (const facet of facets) {
          const index2 = this.filter(facet, ichannels, ivalues);
          VV.push(this.interpolate(index2, w2, h5, IX, IY, V2));
        }
      } else if (facets) {
        const n9 = w2 * h5;
        const m3 = facets.length;
        for (let i5 = 0; i5 < m3; ++i5) VV.push(V2.slice(i5 * n9, i5 * n9 + n9));
      } else {
        VV.push(V2);
      }
      if (this.blur > 0) for (const V3 of VV) blur2({ data: V3, width: w2, height: h5 }, this.blur);
      const T2 = maybeTicks(thresholds, V2, ...finiteExtent(VV));
      if (T2 === null) throw new Error(`unsupported thresholds: ${thresholds}`);
      const { contour: contour2 } = contours_default().size([w2, h5]).smooth(this.smooth);
      const contourData = [];
      const contourFacets = [];
      for (const V3 of VV) {
        contourFacets.push(range(contourData.length, contourData.push(...map2(T2, (t5) => contour2(V3, t5)))));
      }
      for (const { coordinates } of contourData) {
        for (const rings of coordinates) {
          for (const ring of rings) {
            for (const point6 of ring) {
              point6[0] = point6[0] / kx2 + x12;
              point6[1] = point6[1] / ky2 + y12;
            }
          }
        }
      }
      return {
        data: contourData,
        facets: contourFacets,
        channels: createChannels(this.contourChannels, contourData)
      };
    });
  }
  function maybeTicks(thresholds, V2, min4, max3) {
    if (typeof thresholds?.range === "function") return thresholds.range(thresholds.floor(min4), max3);
    if (typeof thresholds === "function") thresholds = thresholds(V2, min4, max3);
    if (typeof thresholds !== "number") return arrayify2(thresholds);
    const tz = ticks(...nice(min4, max3, thresholds), thresholds);
    while (tz[tz.length - 1] >= max3) tz.pop();
    while (tz[1] < min4) tz.shift();
    return tz;
  }
  function contour() {
    return new Contour(...maybeTuples("value", ...arguments));
  }
  function finiteExtent(VV) {
    return [min(VV, (V2) => min(V2, finite3)), max(VV, (V2) => max(V2, finite3))];
  }
  function finite3(x3) {
    return isFinite(x3) ? x3 : NaN;
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/crosshair.js
  function crosshair(data, options) {
    return crosshairK(pointer, data, options);
  }
  function crosshairX(data, options = {}) {
    return crosshairK(pointerX, data, options);
  }
  function crosshairY(data, options = {}) {
    return crosshairK(pointerY, data, options);
  }
  function crosshairK(pointer2, data, options = {}) {
    const { x: x3, y: y3, maxRadius } = options;
    const p11 = pointer2({ px: x3, py: y3, maxRadius });
    const M4 = [];
    if (x3 != null) M4.push(ruleX(data, ruleOptions("x", { ...p11, inset: -6 }, options)));
    if (y3 != null) M4.push(ruleY(data, ruleOptions("y", { ...p11, inset: -6 }, options)));
    if (x3 != null) M4.push(text(data, textOptions("x", { ...p11, dy: 9, frameAnchor: "bottom", lineAnchor: "top" }, options)));
    if (y3 != null) M4.push(text(data, textOptions("y", { ...p11, dx: -9, frameAnchor: "left", textAnchor: "end" }, options)));
    for (const m3 of M4) m3.ariaLabel = `crosshair ${m3.ariaLabel}`;
    return marks(...M4);
  }
  function markOptions(k3, { channels: pointerChannels, ...pointerOptions }, { facet, facetAnchor, fx, fy, [k3]: p11, channels, transform: transform3, initializer: initializer2 }) {
    return {
      ...pointerOptions,
      facet,
      facetAnchor,
      fx,
      fy,
      [k3]: p11,
      channels: { ...pointerChannels, ...channels },
      transform: transform3,
      initializer: pxpy(k3, initializer2)
    };
  }
  function pxpy(k3, i5) {
    if (i5 == null) return i5;
    return function(data, facets, { x: x12, y: y12, px, py, ...c1 }, ...args2) {
      const { channels: { x: x3, y: y3, ...c9 } = {}, ...rest } = i5.call(this, data, facets, { ...c1, x: px, y: py }, ...args2);
      return {
        channels: {
          ...c9,
          ...x3 && { px: x3, ...k3 === "x" && { x: x3 } },
          ...y3 && { py: y3, ...k3 === "y" && { y: y3 } }
        },
        ...rest
      };
    };
  }
  function ruleOptions(k3, pointerOptions, options) {
    const {
      color: color3 = "currentColor",
      opacity: opacity2 = 0.2,
      ruleStroke: stroke = color3,
      ruleStrokeOpacity: strokeOpacity = opacity2,
      ruleStrokeWidth: strokeWidth
    } = options;
    return {
      ...markOptions(k3, pointerOptions, options),
      stroke,
      strokeOpacity,
      strokeWidth
    };
  }
  function textOptions(k3, pointerOptions, options) {
    const {
      color: color3 = "currentColor",
      textFill: fill = color3,
      textFillOpacity: fillOpacity,
      textStroke: stroke = "var(--plot-background)",
      textStrokeOpacity: strokeOpacity,
      textStrokeWidth: strokeWidth = 5
    } = options;
    return {
      ...markOptions(k3, pointerOptions, textChannel(k3, options)),
      fill,
      fillOpacity,
      stroke,
      strokeOpacity,
      strokeWidth
    };
  }
  function textChannel(source, options) {
    return initializer(options, (data, facets, channels) => {
      return { channels: { text: { value: getSource(channels, source)?.value } } };
    });
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/delaunay.js
  var delaunayLinkDefaults = {
    ariaLabel: "delaunay link",
    fill: "none",
    stroke: "currentColor",
    strokeMiterlimit: 1
  };
  var delaunayMeshDefaults = {
    ariaLabel: "delaunay mesh",
    fill: null,
    stroke: "currentColor",
    strokeOpacity: 0.2
  };
  var hullDefaults = {
    ariaLabel: "hull",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 1.5,
    strokeMiterlimit: 1
  };
  var voronoiDefaults = {
    ariaLabel: "voronoi",
    fill: "none",
    stroke: "currentColor",
    strokeMiterlimit: 1
  };
  var voronoiMeshDefaults = {
    ariaLabel: "voronoi mesh",
    fill: null,
    stroke: "currentColor",
    strokeOpacity: 0.2
  };
  var DelaunayLink = class extends Mark {
    constructor(data, options = {}) {
      const { x: x3, y: y3, z: z2, curve, tension } = options;
      super(
        data,
        {
          x: { value: x3, scale: "x", optional: true },
          y: { value: y3, scale: "y", optional: true },
          z: { value: z2, optional: true }
        },
        options,
        delaunayLinkDefaults
      );
      this.curve = maybeCurve(curve, tension);
      markers(this, options);
    }
    render(index2, scales, channels, dimensions, context) {
      const { x: x3, y: y3 } = scales;
      const { x: X3, y: Y3, z: Z3 } = channels;
      const { curve } = this;
      const [cx, cy] = applyFrameAnchor(this, dimensions);
      const xi = X3 ? (i5) => X3[i5] : constant(cx);
      const yi = Y3 ? (i5) => Y3[i5] : constant(cy);
      const mark = this;
      function links(index3) {
        let i5 = -1;
        const newIndex = [];
        const newChannels = {};
        for (const k3 in channels) newChannels[k3] = [];
        const X13 = [];
        const X23 = [];
        const Y13 = [];
        const Y23 = [];
        function link3(ti, tj) {
          ti = index3[ti];
          tj = index3[tj];
          newIndex.push(++i5);
          X13[i5] = xi(ti);
          Y13[i5] = yi(ti);
          X23[i5] = xi(tj);
          Y23[i5] = yi(tj);
          for (const k3 in channels) newChannels[k3].push(channels[k3][tj]);
        }
        const { halfedges, hull: hull2, triangles } = Delaunay.from(index3, xi, yi);
        for (let i6 = 0; i6 < halfedges.length; ++i6) {
          const j2 = halfedges[i6];
          if (j2 > i6) link3(triangles[i6], triangles[j2]);
        }
        for (let i6 = 0; i6 < hull2.length; ++i6) {
          link3(hull2[i6], hull2[(i6 + 1) % hull2.length]);
        }
        select_default2(this).selectAll().data(newIndex).enter().append("path").call(applyDirectStyles, mark).attr("d", (i6) => {
          const p11 = pathRound();
          const c9 = curve(p11);
          c9.lineStart();
          c9.point(X13[i6], Y13[i6]);
          c9.point(X23[i6], Y23[i6]);
          c9.lineEnd();
          return p11;
        }).call(applyChannelStyles, mark, newChannels).call(applyMarkers, mark, newChannels, context);
      }
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x3, y: Y3 && y3 }).call(
        Z3 ? (g2) => g2.selectAll().data(group(index2, (i5) => Z3[i5]).values()).enter().append("g").each(links) : (g2) => g2.datum(index2).each(links)
      ).node();
    }
  };
  var AbstractDelaunayMark = class extends Mark {
    constructor(data, options = {}, defaults22, zof = ({ z: z2 }) => z2) {
      const { x: x3, y: y3 } = options;
      super(
        data,
        {
          x: { value: x3, scale: "x", optional: true },
          y: { value: y3, scale: "y", optional: true },
          z: { value: zof(options), optional: true }
        },
        options,
        defaults22
      );
    }
    render(index2, scales, channels, dimensions, context) {
      const { x: x3, y: y3 } = scales;
      const { x: X3, y: Y3, z: Z3 } = channels;
      const [cx, cy] = applyFrameAnchor(this, dimensions);
      const xi = X3 ? (i5) => X3[i5] : constant(cx);
      const yi = Y3 ? (i5) => Y3[i5] : constant(cy);
      const mark = this;
      function mesh(index3) {
        const delaunay = Delaunay.from(index3, xi, yi);
        select_default2(this).append("path").datum(index3[0]).call(applyDirectStyles, mark).attr("d", mark._render(delaunay, dimensions)).call(applyChannelStyles, mark, channels);
      }
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x3, y: Y3 && y3 }).call(
        Z3 ? (g2) => g2.selectAll().data(group(index2, (i5) => Z3[i5]).values()).enter().append("g").each(mesh) : (g2) => g2.datum(index2).each(mesh)
      ).node();
    }
  };
  var DelaunayMesh = class extends AbstractDelaunayMark {
    constructor(data, options = {}) {
      super(data, options, delaunayMeshDefaults);
      this.fill = "none";
    }
    _render(delaunay) {
      return delaunay.render();
    }
  };
  var Hull = class extends AbstractDelaunayMark {
    constructor(data, options = {}) {
      super(data, options, hullDefaults, maybeZ);
    }
    _render(delaunay) {
      return delaunay.renderHull();
    }
  };
  var Voronoi2 = class extends Mark {
    constructor(data, options = {}) {
      const { x: x3, y: y3, z: z2 } = options;
      super(
        data,
        {
          x: { value: x3, scale: "x", optional: true },
          y: { value: y3, scale: "y", optional: true },
          z: { value: z2, optional: true }
        },
        initializer(options, function(data2, facets, channels, scales, dimensions, context) {
          let { x: X3, y: Y3, z: Z3 } = channels;
          ({ x: X3, y: Y3 } = applyPosition(channels, scales, context));
          Z3 = Z3?.value;
          const C8 = new Array((X3 ?? Y3).length).fill(null);
          const [cx, cy] = applyFrameAnchor(this, dimensions);
          const xi = X3 ? (i5) => X3[i5] : constant(cx);
          const yi = Y3 ? (i5) => Y3[i5] : constant(cy);
          for (let I2 of facets) {
            if (X3) I2 = I2.filter((i5) => defined(xi(i5)));
            if (Y3) I2 = I2.filter((i5) => defined(yi(i5)));
            for (const [, J] of maybeGroup(I2, Z3)) {
              const delaunay = Delaunay.from(J, xi, yi);
              const voronoi2 = voronoiof(delaunay, dimensions);
              for (let i5 = 0, n9 = J.length; i5 < n9; ++i5) {
                C8[J[i5]] = voronoi2.renderCell(i5);
              }
            }
          }
          return { data: data2, facets, channels: { cells: { value: C8 } } };
        }),
        voronoiDefaults
      );
    }
    render(index2, scales, channels, dimensions, context) {
      const { x: x3, y: y3 } = scales;
      const { x: X3, y: Y3, cells: C8 } = channels;
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x3, y: Y3 && y3 }).call((g2) => {
        g2.selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).attr("d", (i5) => C8[i5]).call(applyChannelStyles, this, channels);
      }).node();
    }
  };
  var VoronoiMesh = class extends AbstractDelaunayMark {
    constructor(data, options) {
      super(data, options, voronoiMeshDefaults);
      this.fill = "none";
    }
    _render(delaunay, dimensions) {
      return voronoiof(delaunay, dimensions).render();
    }
  };
  function voronoiof(delaunay, dimensions) {
    const { width, height, marginTop, marginRight, marginBottom, marginLeft } = dimensions;
    return delaunay.voronoi([marginLeft, marginTop, width - marginRight, height - marginBottom]);
  }
  function delaunayMark(DelaunayMark, data, { x: x3, y: y3, ...options } = {}) {
    [x3, y3] = maybeTuple(x3, y3);
    return new DelaunayMark(data, { ...options, x: x3, y: y3 });
  }
  function delaunayLink(data, options) {
    return delaunayMark(DelaunayLink, data, options);
  }
  function delaunayMesh(data, options) {
    return delaunayMark(DelaunayMesh, data, options);
  }
  function hull(data, options) {
    return delaunayMark(Hull, data, options);
  }
  function voronoi(data, { x: x3, y: y3, initializer: initializer2, ...options } = {}) {
    return delaunayMark(Voronoi2, data, { ...basic({ ...options, x: x3, y: y3 }, exclusiveFacets), initializer: initializer2 });
  }
  function voronoiMesh(data, options) {
    return delaunayMark(VoronoiMesh, data, options);
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/density.js
  var defaults17 = {
    ariaLabel: "density",
    fill: "none",
    stroke: "currentColor",
    strokeMiterlimit: 1
  };
  var Density = class extends Mark {
    constructor(data, { x: x3, y: y3, z: z2, weight, fill, stroke, ...options } = {}) {
      const fillDensity = isDensity(fill) && (fill = "currentColor", true);
      const strokeDensity = isDensity(stroke) && (stroke = "currentColor", true);
      super(
        data,
        {
          x: { value: x3, scale: "x", optional: true },
          y: { value: y3, scale: "y", optional: true },
          z: { value: maybeZ({ z: z2, fill, stroke }), optional: true },
          weight: { value: weight, optional: true }
        },
        densityInitializer({ ...options, fill, stroke }, fillDensity, strokeDensity),
        defaults17
      );
      if (fillDensity) this.fill = void 0;
      if (strokeDensity) this.stroke = void 0;
      this.z = z2;
    }
    filter(index2) {
      return index2;
    }
    render(index2, scales, channels, dimensions, context) {
      const { contours } = channels;
      const path2 = path_default();
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}).call(
        (g2) => g2.selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).call(applyChannelStyles, this, channels).attr("d", (i5) => path2(contours[i5]))
      ).node();
    }
  };
  function density(data, { x: x3, y: y3, ...options } = {}) {
    [x3, y3] = maybeTuple(x3, y3);
    return new Density(data, { ...options, x: x3, y: y3 });
  }
  var dropChannels = /* @__PURE__ */ new Set(["x", "y", "z", "weight"]);
  function densityInitializer(options, fillDensity, strokeDensity) {
    const k3 = 100;
    let { bandwidth, thresholds } = options;
    bandwidth = bandwidth === void 0 ? 20 : +bandwidth;
    thresholds = thresholds === void 0 ? 20 : typeof thresholds?.[Symbol.iterator] === "function" ? coerceNumbers(thresholds) : +thresholds;
    return initializer(options, function(data, facets, channels, scales, dimensions, context) {
      const W = channels.weight ? coerceNumbers(channels.weight.value) : null;
      const Z3 = channels.z?.value;
      const { z: z2 } = this;
      const [cx, cy] = applyFrameAnchor(this, dimensions);
      const { width, height } = dimensions;
      const { x: X3, y: Y3 } = applyPosition(channels, scales, context);
      const newChannels = Object.fromEntries(
        Object.entries(channels).filter(([key]) => !dropChannels.has(key)).map(([key, channel]) => [key, { ...channel, value: [] }])
      );
      const FD = fillDensity && [];
      const SD = strokeDensity && [];
      const density2 = density_default().x(X3 ? (i5) => X3[i5] : cx).y(Y3 ? (i5) => Y3[i5] : cy).weight(W ? (i5) => W[i5] : 1).size([width, height]).bandwidth(bandwidth);
      const facetsContours = [];
      for (const facet of facets) {
        const facetContours = [];
        facetsContours.push(facetContours);
        for (const index2 of Z3 ? groupZ2(facet, Z3, z2) : [facet]) {
          const contour2 = density2.contours(index2);
          facetContours.push([index2, contour2]);
        }
      }
      let T2 = thresholds;
      if (!(T2 instanceof TypedArray)) {
        let maxValue = 0;
        for (const facetContours of facetsContours) {
          for (const [, contour2] of facetContours) {
            const max3 = contour2.max;
            if (max3 > maxValue) maxValue = max3;
          }
        }
        T2 = Float64Array.from({ length: thresholds - 1 }, (_2, i5) => maxValue * k3 * (i5 + 1) / thresholds);
      }
      const newFacets = [];
      const contours = [];
      for (const facetContours of facetsContours) {
        const newFacet = [];
        newFacets.push(newFacet);
        for (const [index2, contour2] of facetContours) {
          for (const t5 of T2) {
            newFacet.push(contours.length);
            contours.push(contour2(t5 / k3));
            if (FD) FD.push(t5);
            if (SD) SD.push(t5);
            for (const key in newChannels) {
              newChannels[key].value.push(channels[key].value[index2[0]]);
            }
          }
        }
      }
      if (FD) FD.push(0);
      if (SD) SD.push(0);
      return {
        data,
        facets: newFacets,
        channels: {
          ...newChannels,
          ...FD && { fill: { value: FD, scale: "color" } },
          ...SD && { stroke: { value: SD, scale: "color" } },
          contours: { value: contours }
        }
      };
    });
  }
  function isDensity(value) {
    return /^density$/i.test(value);
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/difference.js
  function differenceX(data, options) {
    return differenceK("x", data, options);
  }
  function differenceY(data, options) {
    return differenceK("y", data, options);
  }
  function differenceK(k3, data, {
    x1: x12,
    x2: x22,
    y1: y12,
    y2: y22,
    x: x3 = x12 === void 0 && x22 === void 0 ? k3 === "y" ? indexOf : identity6 : void 0,
    y: y3 = y12 === void 0 && y22 === void 0 ? k3 === "x" ? indexOf : identity6 : void 0,
    fill,
    // ignored
    positiveFill = "#3ca951",
    negativeFill = "#4269d0",
    fillOpacity = 1,
    positiveFillOpacity = fillOpacity,
    negativeFillOpacity = fillOpacity,
    stroke,
    strokeOpacity,
    z: z2 = maybeColorChannel(stroke)[0],
    clip,
    // optional additional clip for area
    tip: tip2,
    render,
    ...options
  } = {}) {
    [x12, x22] = memoTuple(x3, x12, x22);
    [y12, y22] = memoTuple(y3, y12, y22);
    if (x12 === x22 && y12 === y22) {
      if (k3 === "y") y12 = memo(0);
      else x12 = memo(0);
    }
    ({ tip: tip2 } = withTip({ tip: tip2 }, k3 === "y" ? "x" : "y"));
    return marks(
      !isNoneish(positiveFill) ? Object.assign(
        area(data, {
          x1: x12,
          x2: x22,
          y1: y12,
          y2: y22,
          z: z2,
          fill: positiveFill,
          fillOpacity: positiveFillOpacity,
          render: composeRender(render, clipDifference(k3, true)),
          clip,
          ...options
        }),
        { ariaLabel: "positive difference" }
      ) : null,
      !isNoneish(negativeFill) ? Object.assign(
        area(data, {
          x1: x12,
          x2: x22,
          y1: y12,
          y2: y22,
          z: z2,
          fill: negativeFill,
          fillOpacity: negativeFillOpacity,
          render: composeRender(render, clipDifference(k3, false)),
          clip,
          ...options
        }),
        { ariaLabel: "negative difference" }
      ) : null,
      line(data, {
        x: x22,
        y: y22,
        z: z2,
        stroke,
        strokeOpacity,
        tip: tip2,
        clip: true,
        ...options
      })
    );
  }
  function memoTuple(x3, x12, x22) {
    if (x12 === void 0 && x22 === void 0) {
      x12 = x22 = memo(x3);
    } else if (x12 === void 0) {
      x22 = memo(x22);
      x12 = x3 === void 0 ? x22 : memo(x3);
    } else if (x22 === void 0) {
      x12 = memo(x12);
      x22 = x3 === void 0 ? x12 : memo(x3);
    } else {
      x12 = memo(x12);
      x22 = memo(x22);
    }
    return [x12, x22];
  }
  function memo(v3) {
    let V2;
    const { value, label = labelof(value) } = maybeValue(v3);
    return { transform: (data) => V2 || (V2 = valueof(data, value)), label };
  }
  function clipDifference(k3, positive2) {
    const f7 = k3 === "x" ? "y" : "x";
    const f12 = `${f7}1`;
    const f22 = `${f7}2`;
    const k1 = `${k3}1`;
    const k22 = `${k3}2`;
    return (index2, scales, channels, dimensions, context, next) => {
      const { [f12]: F1, [f22]: F2 } = channels;
      const K1 = new Float32Array(F1.length);
      const K2 = new Float32Array(F2.length);
      const m3 = dimensions[k3 === "y" ? "height" : "width"];
      (positive2 === inferScaleOrder(scales[k3]) < 0 ? K1 : K2).fill(m3);
      const oc = next(index2, scales, { ...channels, [f22]: F1, [k22]: K2 }, dimensions, context);
      const og = next(index2, scales, { ...channels, [f12]: F2, [k1]: K1 }, dimensions, context);
      const c9 = oc.querySelector("g") ?? oc;
      const g2 = og.querySelector("g") ?? og;
      for (let i5 = 0; c9.firstChild; i5 += 2) {
        const id2 = getClipId();
        const clipPath = create2("svg:clipPath", context).attr("id", id2).node();
        clipPath.appendChild(c9.firstChild);
        g2.childNodes[i5].setAttribute("clip-path", `url(#${id2})`);
        g2.insertBefore(clipPath, g2.childNodes[i5]);
      }
      return og;
    };
  }

  // ../../../../../node_modules/@observablehq/plot/src/transforms/centroid.js
  function centroid({ geometry = identity6, ...options } = {}) {
    const getG = memoize1((data) => valueof(data, geometry));
    return initializer(
      // Suppress defaults for x and y since they will be computed by the initializer.
      // Propagate the (memoized) geometry channel in case its still needed.
      { ...options, x: null, y: null, geometry: { transform: getG } },
      (data, facets, channels, scales, dimensions, context) => {
        const G = getG(data);
        const n9 = G.length;
        const X3 = new Float64Array(n9);
        const Y3 = new Float64Array(n9);
        const { centroid: centroid2 } = context.path();
        for (let i5 = 0; i5 < n9; ++i5) [X3[i5], Y3[i5]] = centroid2(G[i5]);
        return {
          data,
          facets,
          channels: { x: { value: X3, scale: null, source: null }, y: { value: Y3, scale: null, source: null } }
        };
      }
    );
  }
  function geoCentroid({ geometry = identity6, ...options } = {}) {
    const getG = memoize1((data) => valueof(data, geometry));
    const getC = memoize1((data) => valueof(getG(data), centroid_default));
    return {
      ...options,
      x: { transform: (data) => Float64Array.from(getC(data), ([x3]) => x3) },
      y: { transform: (data) => Float64Array.from(getC(data), ([, y3]) => y3) },
      geometry: { transform: getG }
    };
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/geo.js
  var defaults18 = {
    ariaLabel: "geo",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 1,
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeMiterlimit: 1
  };
  var Geo = class extends Mark {
    constructor(data, options = {}) {
      const [vr, cr] = maybeNumberChannel(options.r, 3);
      super(
        data,
        {
          x: { value: options.tip ? options.x : null, scale: "x", optional: true },
          y: { value: options.tip ? options.y : null, scale: "y", optional: true },
          r: { value: vr, scale: "r", filter: positive, optional: true },
          geometry: { value: options.geometry, scale: "projection" }
        },
        withDefaultSort(options),
        defaults18
      );
      this.r = cr;
    }
    render(index2, scales, channels, dimensions, context) {
      const { geometry: G, r: R2 } = channels;
      const path2 = context.path();
      const { r: r6 } = this;
      if (negative(r6)) index2 = [];
      else if (r6 !== void 0) path2.pointRadius(r6);
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call((g2) => {
        g2.selectAll().data(index2).enter().append("path").call(applyDirectStyles, this).attr("d", R2 ? (i5) => path2.pointRadius(R2[i5])(G[i5]) : (i5) => path2(G[i5])).call(applyChannelStyles, this, channels);
      }).node();
    }
  };
  function geo(data, options = {}) {
    if (options.tip && options.x === void 0 && options.y === void 0) options = centroid(options);
    else if (options.geometry === void 0) options = { ...options, geometry: identity6 };
    return new Geo(data, options);
  }
  function sphere2({ strokeWidth = 1.5, ...options } = {}) {
    return geo({ type: "Sphere" }, { strokeWidth, ...options });
  }
  function graticule2({ strokeOpacity = 0.1, ...options } = {}) {
    return geo(graticule10(), { strokeOpacity, ...options });
  }

  // ../../../../../node_modules/@observablehq/plot/src/transforms/hexbin.js
  var ox = 0.5;
  var oy = 0;
  function hexbin(outputs = { fill: "count" }, { binWidth, ...options } = {}) {
    const { z: z2 } = options;
    binWidth = binWidth === void 0 ? 20 : number5(binWidth);
    outputs = maybeGroupOutputs(outputs, options);
    if (hasOutput(outputs, "fill")) options.channels = { ...options.channels, fill: { value: [] } };
    if (options.symbol === void 0) options.symbol = "hexagon";
    if (options.r === void 0 && !hasOutput(outputs, "r")) options.r = binWidth / 2;
    return initializer(options, (data, facets, channels, scales, _2, context) => {
      let { x: X3, y: Y3, z: Z3, fill: F, stroke: S3, symbol: Q } = channels;
      if (X3 === void 0) throw new Error("missing channel: x");
      if (Y3 === void 0) throw new Error("missing channel: y");
      ({ x: X3, y: Y3 } = applyPosition(channels, scales, context));
      Z3 = Z3 ? Z3.value : valueof(data, z2);
      F = F?.value;
      S3 = S3?.value;
      Q = Q?.value;
      const G = maybeSubgroup(outputs, { z: Z3, fill: F, stroke: S3, symbol: Q });
      const GZ = Z3 && [];
      const GF = F && [];
      const GS = S3 && [];
      const GQ = Q && [];
      const binFacets = [];
      const BX = [];
      const BY = [];
      let i5 = -1;
      for (const o12 of outputs) o12.initialize(data);
      for (const facet of facets) {
        const binFacet = [];
        for (const o12 of outputs) o12.scope("facet", facet);
        for (const [f7, I2] of maybeGroup(facet, G)) {
          for (const { index: b2, extent: extent3 } of hbin(data, I2, X3, Y3, binWidth)) {
            binFacet.push(++i5);
            BX.push(extent3.x);
            BY.push(extent3.y);
            if (Z3) GZ.push(G === Z3 ? f7 : Z3[b2[0]]);
            if (F) GF.push(G === F ? f7 : F[b2[0]]);
            if (S3) GS.push(G === S3 ? f7 : S3[b2[0]]);
            if (Q) GQ.push(G === Q ? f7 : Q[b2[0]]);
            for (const o12 of outputs) o12.reduce(b2, extent3);
          }
        }
        binFacets.push(binFacet);
      }
      const sx = channels.x.scale;
      const sy = channels.y.scale;
      const binChannels = {
        x: { value: BX, source: scales[sx] ? { value: map2(BX, scales[sx].invert), scale: sx } : null },
        y: { value: BY, source: scales[sy] ? { value: map2(BY, scales[sy].invert), scale: sy } : null },
        ...Z3 && { z: { value: GZ } },
        ...F && { fill: { value: GF, scale: "auto" } },
        ...S3 && { stroke: { value: GS, scale: "auto" } },
        ...Q && { symbol: { value: GQ, scale: "auto" } },
        ...Object.fromEntries(
          outputs.map(({ name, output }) => [
            name,
            {
              scale: "auto",
              label: output.label,
              radius: name === "r" ? binWidth / 2 : void 0,
              value: output.transform()
            }
          ])
        )
      };
      return { data, facets: binFacets, channels: binChannels };
    });
  }
  function hbin(data, I2, X3, Y3, dx) {
    const dy = dx * (1.5 / sqrt35);
    const bins = /* @__PURE__ */ new Map();
    for (const i5 of I2) {
      let px = X3[i5], py = Y3[i5];
      if (isNaN(px) || isNaN(py)) continue;
      let pj = Math.round(py = (py - oy) / dy), pi5 = Math.round(px = (px - ox) / dx - (pj & 1) / 2), py1 = py - pj;
      if (Math.abs(py1) * 3 > 1) {
        let px1 = px - pi5, pi22 = pi5 + (px < pi5 ? -1 : 1) / 2, pj2 = pj + (py < pj ? -1 : 1), px2 = px - pi22, py2 = py - pj2;
        if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) pi5 = pi22 + (pj & 1 ? 1 : -1) / 2, pj = pj2;
      }
      const key = `${pi5},${pj}`;
      let bin2 = bins.get(key);
      if (bin2 === void 0) {
        bin2 = { index: [], extent: { data, x: (pi5 + (pj & 1) / 2) * dx + ox, y: pj * dy + oy } };
        bins.set(key, bin2);
      }
      bin2.index.push(i5);
    }
    return bins.values();
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/hexgrid.js
  var defaults19 = {
    ariaLabel: "hexgrid",
    fill: "none",
    stroke: "currentColor",
    strokeOpacity: 0.1
  };
  function hexgrid(options) {
    return new Hexgrid(options);
  }
  var Hexgrid = class extends Mark {
    constructor({ binWidth = 20, clip = true, ...options } = {}) {
      super(singleton, void 0, { clip, ...options }, defaults19);
      this.binWidth = number5(binWidth);
    }
    render(index2, scales, channels, dimensions, context) {
      const { binWidth } = this;
      const { marginTop, marginRight, marginBottom, marginLeft, width, height } = dimensions;
      const x06 = marginLeft - ox, x12 = width - marginRight - ox, y06 = marginTop - oy, y12 = height - marginBottom - oy, rx = binWidth / 2, ry = rx * sqrt4_3, hy = ry / 2, wx = rx * 2, wy = ry * 1.5, i0 = Math.floor(x06 / wx), i12 = Math.ceil(x12 / wx), j0 = Math.floor((y06 + hy) / wy), j12 = Math.ceil((y12 - hy) / wy) + 1, path2 = `m0,${round(-ry)}l${round(rx)},${round(hy)}v${round(ry)}l${round(-rx)},${round(hy)}`;
      let d3 = path2;
      for (let j2 = j0; j2 < j12; ++j2) {
        for (let i5 = i0; i5 < i12; ++i5) {
          d3 += `M${round(i5 * wx + (j2 & 1) * rx)},${round(j2 * wy)}${path2}`;
        }
      }
      return create2("svg:g", context).datum(0).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, {}, offset + ox, offset + oy).call((g2) => g2.append("path").call(applyDirectStyles, this).call(applyChannelStyles, this, channels).attr("d", d3)).node();
    }
  };
  function round(x3) {
    return Math.round(x3 * 1e3) / 1e3;
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/image.js
  var defaults20 = {
    ariaLabel: "image",
    fill: null,
    stroke: null
  };
  function isPath(string2) {
    return /^\.*\//.test(string2);
  }
  function isUrl(string2) {
    return /^(blob|data|file|http|https):/i.test(string2);
  }
  function maybePathChannel(value) {
    return typeof value === "string" && (isPath(value) || isUrl(value)) ? [void 0, value] : [value, void 0];
  }
  var Image = class extends Mark {
    constructor(data, options = {}) {
      let { x: x3, y: y3, r: r6, width, height, rotate, src, preserveAspectRatio, crossOrigin, frameAnchor, imageRendering } = options;
      if (r6 == null) r6 = void 0;
      if (r6 === void 0 && width === void 0 && height === void 0) width = height = 16;
      else if (width === void 0 && height !== void 0) width = height;
      else if (height === void 0 && width !== void 0) height = width;
      const [vs, cs] = maybePathChannel(src);
      const [vr, cr] = maybeNumberChannel(r6);
      const [vw, cw] = maybeNumberChannel(width, cr !== void 0 ? cr * 2 : void 0);
      const [vh, ch] = maybeNumberChannel(height, cr !== void 0 ? cr * 2 : void 0);
      const [va, ca3] = maybeNumberChannel(rotate, 0);
      super(
        data,
        {
          x: { value: x3, scale: "x", optional: true },
          y: { value: y3, scale: "y", optional: true },
          r: { value: vr, scale: "r", filter: positive, optional: true },
          width: { value: vw, filter: positive, optional: true },
          height: { value: vh, filter: positive, optional: true },
          rotate: { value: va, optional: true },
          src: { value: vs, optional: true }
        },
        withDefaultSort(options),
        defaults20
      );
      this.src = cs;
      this.width = cw;
      this.rotate = ca3;
      this.height = ch;
      this.r = cr;
      this.preserveAspectRatio = impliedString(preserveAspectRatio, "xMidYMid");
      this.crossOrigin = string(crossOrigin);
      this.frameAnchor = maybeFrameAnchor(frameAnchor);
      this.imageRendering = impliedString(imageRendering, "auto");
    }
    render(index2, scales, channels, dimensions, context) {
      const { x: x3, y: y3 } = scales;
      const { x: X3, y: Y3, width: W, height: H2, r: R2, rotate: A5, src: S3 } = channels;
      const { r: r6, width, height, rotate } = this;
      const [cx, cy] = applyFrameAnchor(this, dimensions);
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, { x: X3 && x3, y: Y3 && y3 }).call(
        (g2) => g2.selectAll().data(index2).enter().append("image").call(applyDirectStyles, this).attr("x", position2(X3, W, R2, cx, width, r6)).attr("y", position2(Y3, H2, R2, cy, height, r6)).attr("width", W ? (i5) => W[i5] : width !== void 0 ? width : R2 ? (i5) => R2[i5] * 2 : r6 * 2).attr("height", H2 ? (i5) => H2[i5] : height !== void 0 ? height : R2 ? (i5) => R2[i5] * 2 : r6 * 2).attr("transform", A5 ? (i5) => `rotate(${A5[i5]})` : rotate ? `rotate(${rotate})` : null).attr("transform-origin", A5 || rotate ? template`${X3 ? (i5) => X3[i5] : cx}px ${Y3 ? (i5) => Y3[i5] : cy}px` : null).call(applyAttr, "href", S3 ? (i5) => S3[i5] : this.src).call(applyAttr, "preserveAspectRatio", this.preserveAspectRatio).call(applyAttr, "crossorigin", this.crossOrigin).call(applyAttr, "image-rendering", this.imageRendering).call(applyAttr, "clip-path", R2 ? (i5) => `circle(${R2[i5]}px)` : r6 !== void 0 ? `circle(${r6}px)` : null).call(applyChannelStyles, this, channels)
      ).node();
    }
  };
  function position2(X3, W, R2, x3, w2, r6) {
    return W && X3 ? (i5) => X3[i5] - W[i5] / 2 : W ? (i5) => x3 - W[i5] / 2 : X3 && w2 !== void 0 ? (i5) => X3[i5] - w2 / 2 : w2 !== void 0 ? x3 - w2 / 2 : R2 && X3 ? (i5) => X3[i5] - R2[i5] : R2 ? (i5) => x3 - R2[i5] : X3 ? (i5) => X3[i5] - r6 : x3 - r6;
  }
  function image(data, { x: x3, y: y3, ...options } = {}) {
    if (options.frameAnchor === void 0) [x3, y3] = maybeTuple(x3, y3);
    return new Image(data, { ...options, x: x3, y: y3 });
  }

  // ../../../../../node_modules/@observablehq/plot/src/stats.js
  function ibetainv(p11, a5, b2) {
    var EPS = 1e-8;
    var a1 = a5 - 1;
    var b1 = b2 - 1;
    var j2 = 0;
    var lna, lnb, pp, t5, u7, err, x3, al, h5, w2, afac;
    if (p11 <= 0) return 0;
    if (p11 >= 1) return 1;
    if (a5 >= 1 && b2 >= 1) {
      pp = p11 < 0.5 ? p11 : 1 - p11;
      t5 = Math.sqrt(-2 * Math.log(pp));
      x3 = (2.30753 + t5 * 0.27061) / (1 + t5 * (0.99229 + t5 * 0.04481)) - t5;
      if (p11 < 0.5) x3 = -x3;
      al = (x3 * x3 - 3) / 6;
      h5 = 2 / (1 / (2 * a5 - 1) + 1 / (2 * b2 - 1));
      w2 = x3 * Math.sqrt(al + h5) / h5 - (1 / (2 * b2 - 1) - 1 / (2 * a5 - 1)) * (al + 5 / 6 - 2 / (3 * h5));
      x3 = a5 / (a5 + b2 * Math.exp(2 * w2));
    } else {
      lna = Math.log(a5 / (a5 + b2));
      lnb = Math.log(b2 / (a5 + b2));
      t5 = Math.exp(a5 * lna) / a5;
      u7 = Math.exp(b2 * lnb) / b2;
      w2 = t5 + u7;
      if (p11 < t5 / w2) x3 = Math.pow(a5 * w2 * p11, 1 / a5);
      else x3 = 1 - Math.pow(b2 * w2 * (1 - p11), 1 / b2);
    }
    afac = -gammaln(a5) - gammaln(b2) + gammaln(a5 + b2);
    for (; j2 < 10; j2++) {
      if (x3 === 0 || x3 === 1) return x3;
      err = ibeta(x3, a5, b2) - p11;
      t5 = Math.exp(a1 * Math.log(x3) + b1 * Math.log(1 - x3) + afac);
      u7 = err / t5;
      x3 -= t5 = u7 / (1 - 0.5 * Math.min(1, u7 * (a1 / x3 - b1 / (1 - x3))));
      if (x3 <= 0) x3 = 0.5 * (x3 + t5);
      if (x3 >= 1) x3 = 0.5 * (x3 + t5 + 1);
      if (Math.abs(t5) < EPS * x3 && j2 > 0) break;
    }
    return x3;
  }
  function ibeta(x3, a5, b2) {
    var bt = x3 === 0 || x3 === 1 ? 0 : Math.exp(gammaln(a5 + b2) - gammaln(a5) - gammaln(b2) + a5 * Math.log(x3) + b2 * Math.log(1 - x3));
    if (x3 < 0 || x3 > 1) return false;
    if (x3 < (a5 + 1) / (a5 + b2 + 2))
      return bt * betacf(x3, a5, b2) / a5;
    return 1 - bt * betacf(1 - x3, b2, a5) / b2;
  }
  function betacf(x3, a5, b2) {
    var fpmin = 1e-30;
    var m3 = 1;
    var qab = a5 + b2;
    var qap = a5 + 1;
    var qam = a5 - 1;
    var c9 = 1;
    var d3 = 1 - qab * x3 / qap;
    var m22, aa2, del, h5;
    if (Math.abs(d3) < fpmin) d3 = fpmin;
    d3 = 1 / d3;
    h5 = d3;
    for (; m3 <= 100; m3++) {
      m22 = 2 * m3;
      aa2 = m3 * (b2 - m3) * x3 / ((qam + m22) * (a5 + m22));
      d3 = 1 + aa2 * d3;
      if (Math.abs(d3) < fpmin) d3 = fpmin;
      c9 = 1 + aa2 / c9;
      if (Math.abs(c9) < fpmin) c9 = fpmin;
      d3 = 1 / d3;
      h5 *= d3 * c9;
      aa2 = -(a5 + m3) * (qab + m3) * x3 / ((a5 + m22) * (qap + m22));
      d3 = 1 + aa2 * d3;
      if (Math.abs(d3) < fpmin) d3 = fpmin;
      c9 = 1 + aa2 / c9;
      if (Math.abs(c9) < fpmin) c9 = fpmin;
      d3 = 1 / d3;
      del = d3 * c9;
      h5 *= del;
      if (Math.abs(del - 1) < 3e-7) break;
    }
    return h5;
  }
  function gammaln(x3) {
    var j2 = 0;
    var cof = [
      76.18009172947146,
      -86.5053203294167,
      24.01409824083091,
      -1.231739572450155,
      0.001208650973866179,
      -5395239384953e-18
    ];
    var ser = 1.000000000190015;
    var xx, y3, tmp;
    tmp = (y3 = xx = x3) + 5.5;
    tmp -= (xx + 0.5) * Math.log(tmp);
    for (; j2 < 6; j2++) ser += cof[j2] / ++y3;
    return Math.log(2.506628274631 * ser / xx) - tmp;
  }
  function qt(p11, dof) {
    var x3 = ibetainv(2 * Math.min(p11, 1 - p11), 0.5 * dof, 0.5);
    x3 = Math.sqrt(dof * (1 - x3) / x3);
    return p11 > 0.5 ? x3 : -x3;
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/linearRegression.js
  var defaults21 = {
    ariaLabel: "linear-regression",
    fill: "currentColor",
    fillOpacity: 0.1,
    stroke: "currentColor",
    strokeWidth: 1.5,
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeMiterlimit: 1
  };
  var LinearRegression = class extends Mark {
    constructor(data, options = {}) {
      const { x: x3, y: y3, z: z2, ci = 0.95, precision = 4 } = options;
      super(
        data,
        {
          x: { value: x3, scale: "x" },
          y: { value: y3, scale: "y" },
          z: { value: maybeZ(options), optional: true }
        },
        options,
        defaults21
      );
      this.z = z2;
      this.ci = +ci;
      this.precision = +precision;
      if (!(0 <= this.ci && this.ci < 1)) throw new Error(`invalid ci; not in [0, 1): ${ci}`);
      if (!(this.precision > 0)) throw new Error(`invalid precision: ${precision}`);
    }
    render(index2, scales, channels, dimensions, context) {
      const { x: X3, y: Y3, z: Z3 } = channels;
      const { ci } = this;
      return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(applyTransform, this, scales).call(
        (g2) => g2.selectAll().data(Z3 ? groupZ2(index2, Z3, this.z) : [index2]).enter().call(
          (enter) => enter.append("path").attr("fill", "none").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, { ...channels, fill: null, fillOpacity: null }).attr("d", (I2) => this._renderLine(I2, X3, Y3)).call(
            ci && !isNone(this.fill) ? (path2) => path2.select(pathBefore).attr("stroke", "none").call(applyDirectStyles, this).call(applyGroupedChannelStyles, this, {
              ...channels,
              stroke: null,
              strokeOpacity: null,
              strokeWidth: null
            }).attr("d", (I2) => this._renderBand(I2, X3, Y3)) : () => {
            }
          )
        )
      ).node();
    }
  };
  function pathBefore() {
    return this.parentNode.insertBefore(this.ownerDocument.createElementNS(namespaces_default.svg, "path"), this);
  }
  var LinearRegressionX = class extends LinearRegression {
    constructor(data, options) {
      super(data, options);
    }
    _renderBand(I2, X3, Y3) {
      const { ci, precision } = this;
      const [y12, y22] = extent(I2, (i5) => Y3[i5]);
      const f7 = linearRegressionF(I2, Y3, X3);
      const g2 = confidenceIntervalF(I2, Y3, X3, (1 - ci) / 2, f7);
      return area_default3().y((y3) => y3).x0((y3) => g2(y3, -1)).x1((y3) => g2(y3, 1))(range(y12, y22 - precision / 2, precision).concat(y22));
    }
    _renderLine(I2, X3, Y3) {
      const [y12, y22] = extent(I2, (i5) => Y3[i5]);
      const f7 = linearRegressionF(I2, Y3, X3);
      return `M${f7(y12)},${y12}L${f7(y22)},${y22}`;
    }
  };
  var LinearRegressionY = class extends LinearRegression {
    constructor(data, options) {
      super(data, options);
    }
    _renderBand(I2, X3, Y3) {
      const { ci, precision } = this;
      const [x12, x22] = extent(I2, (i5) => X3[i5]);
      const f7 = linearRegressionF(I2, X3, Y3);
      const g2 = confidenceIntervalF(I2, X3, Y3, (1 - ci) / 2, f7);
      return area_default3().x((x3) => x3).y0((x3) => g2(x3, -1)).y1((x3) => g2(x3, 1))(range(x12, x22 - precision / 2, precision).concat(x22));
    }
    _renderLine(I2, X3, Y3) {
      const [x12, x22] = extent(I2, (i5) => X3[i5]);
      const f7 = linearRegressionF(I2, X3, Y3);
      return `M${x12},${f7(x12)}L${x22},${f7(x22)}`;
    }
  };
  function linearRegressionX(data, { y: y3 = indexOf, x: x3 = identity6, stroke, fill = isNoneish(stroke) ? "currentColor" : stroke, ...options } = {}) {
    return new LinearRegressionX(data, maybeDenseIntervalY({ ...options, x: x3, y: y3, fill, stroke }));
  }
  function linearRegressionY(data, { x: x3 = indexOf, y: y3 = identity6, stroke, fill = isNoneish(stroke) ? "currentColor" : stroke, ...options } = {}) {
    return new LinearRegressionY(data, maybeDenseIntervalX({ ...options, x: x3, y: y3, fill, stroke }));
  }
  function linearRegressionF(I2, X3, Y3) {
    let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
    for (const i5 of I2) {
      const xi = X3[i5];
      const yi = Y3[i5];
      sumX += xi;
      sumY += yi;
      sumXY += xi * yi;
      sumX2 += xi * xi;
    }
    const n9 = I2.length;
    const slope = (n9 * sumXY - sumX * sumY) / (n9 * sumX2 - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n9;
    return (x3) => slope * x3 + intercept;
  }
  function confidenceIntervalF(I2, X3, Y3, p11, f7) {
    const mean2 = sum(I2, (i5) => X3[i5]) / I2.length;
    let a5 = 0, b2 = 0;
    for (const i5 of I2) {
      a5 += (X3[i5] - mean2) ** 2;
      b2 += (Y3[i5] - f7(X3[i5])) ** 2;
    }
    const sy = Math.sqrt(b2 / (I2.length - 2));
    const t5 = qt(p11, I2.length - 2);
    return (x3, k3) => {
      const Y4 = f7(x3);
      const se = sy * Math.sqrt(1 / I2.length + (x3 - mean2) ** 2 / a5);
      return Y4 + k3 * t5 * se;
    };
  }

  // ../../../../../node_modules/@observablehq/plot/src/transforms/tree.js
  function treeNode({
    path: path2 = identity6,
    // the delimited path
    delimiter,
    // how the path is separated
    frameAnchor,
    treeLayout = tree_default,
    treeSort,
    treeSeparation,
    treeAnchor,
    treeFilter,
    ...options
  } = {}) {
    treeAnchor = maybeTreeAnchor(treeAnchor);
    treeSort = maybeTreeSort(treeSort);
    if (treeFilter != null) treeFilter = maybeNodeValue(treeFilter);
    if (frameAnchor === void 0) frameAnchor = treeAnchor.frameAnchor;
    const normalize4 = normalizer(delimiter);
    const outputs = treeOutputs(options, maybeNodeValue);
    const [X3, setX] = column();
    const [Y3, setY] = column();
    return {
      x: X3,
      y: Y3,
      frameAnchor,
      ...basic(options, (data, facets) => {
        const P2 = normalize4(valueof(data, path2));
        const X4 = setX([]);
        const Y4 = setY([]);
        let treeIndex = -1;
        const treeData = [];
        const treeFacets = [];
        const rootof = stratify_default().path((i5) => P2[i5]);
        const setData = isArray(data) ? (node) => node.data = data[node.data] : (node) => node.data = data.get(node.data);
        const layout = treeLayout();
        if (layout.nodeSize) layout.nodeSize([1, 1]);
        if (layout.separation && treeSeparation !== void 0) layout.separation(treeSeparation ?? one3);
        for (const o12 of outputs) o12[output_values] = o12[output_setValues]([]);
        for (const facet of facets) {
          const treeFacet = [];
          const root2 = rootof(facet.filter((i5) => P2[i5] != null)).each(setData);
          if (treeSort != null) root2.sort(treeSort);
          layout(root2);
          for (const node of root2.descendants()) {
            if (treeFilter != null && !treeFilter(node)) continue;
            treeFacet.push(++treeIndex);
            treeData[treeIndex] = node.data;
            treeAnchor.position(node, treeIndex, X4, Y4);
            for (const o12 of outputs) o12[output_values][treeIndex] = o12[output_evaluate](node);
          }
          treeFacets.push(treeFacet);
        }
        return { data: treeData, facets: treeFacets };
      }),
      ...Object.fromEntries(outputs)
    };
  }
  function treeLink({
    path: path2 = identity6,
    // the delimited path
    delimiter,
    // how the path is separated
    curve = "bump-x",
    stroke = "#555",
    strokeWidth = 1.5,
    strokeOpacity = 0.5,
    treeLayout = tree_default,
    treeSort,
    treeSeparation,
    treeAnchor,
    treeFilter,
    ...options
  } = {}) {
    treeAnchor = maybeTreeAnchor(treeAnchor);
    treeSort = maybeTreeSort(treeSort);
    if (treeFilter != null) treeFilter = maybeLinkValue(treeFilter);
    options = { curve, stroke, strokeWidth, strokeOpacity, ...options };
    const normalize4 = normalizer(delimiter);
    const outputs = treeOutputs(options, maybeLinkValue);
    const [X13, setX1] = column();
    const [X23, setX2] = column();
    const [Y13, setY1] = column();
    const [Y23, setY2] = column();
    return {
      x1: X13,
      x2: X23,
      y1: Y13,
      y2: Y23,
      ...basic(options, (data, facets) => {
        const P2 = normalize4(valueof(data, path2));
        const X14 = setX1([]);
        const X24 = setX2([]);
        const Y14 = setY1([]);
        const Y24 = setY2([]);
        let treeIndex = -1;
        const treeData = [];
        const treeFacets = [];
        const rootof = stratify_default().path((i5) => P2[i5]);
        const layout = treeLayout();
        if (layout.nodeSize) layout.nodeSize([1, 1]);
        if (layout.separation && treeSeparation !== void 0) layout.separation(treeSeparation ?? one3);
        for (const o12 of outputs) o12[output_values] = o12[output_setValues]([]);
        for (const facet of facets) {
          const treeFacet = [];
          const root2 = rootof(facet.filter((i5) => P2[i5] != null)).each((node) => node.data = data[node.data]);
          if (treeSort != null) root2.sort(treeSort);
          layout(root2);
          for (const { source, target } of root2.links()) {
            if (treeFilter != null && !treeFilter(target, source)) continue;
            treeFacet.push(++treeIndex);
            treeData[treeIndex] = target.data;
            treeAnchor.position(source, treeIndex, X14, Y14);
            treeAnchor.position(target, treeIndex, X24, Y24);
            for (const o12 of outputs) o12[output_values][treeIndex] = o12[output_evaluate](target, source);
          }
          treeFacets.push(treeFacet);
        }
        return { data: treeData, facets: treeFacets };
      }),
      ...Object.fromEntries(outputs)
    };
  }
  function maybeTreeAnchor(anchor = "left") {
    switch (`${anchor}`.trim().toLowerCase()) {
      case "left":
        return treeAnchorLeft;
      case "right":
        return treeAnchorRight;
    }
    throw new Error(`invalid tree anchor: ${anchor}`);
  }
  var treeAnchorLeft = {
    frameAnchor: "left",
    dx: 6,
    position({ x: x3, y: y3 }, i5, X3, Y3) {
      X3[i5] = y3;
      Y3[i5] = -x3;
    }
  };
  var treeAnchorRight = {
    frameAnchor: "right",
    dx: -6,
    position({ x: x3, y: y3 }, i5, X3, Y3) {
      X3[i5] = -y3;
      Y3[i5] = -x3;
    }
  };
  function maybeTreeSort(sort3) {
    return sort3 == null || typeof sort3 === "function" ? sort3 : `${sort3}`.trim().toLowerCase().startsWith("node:") ? nodeSort(maybeNodeValue(sort3)) : nodeSort(nodeData(sort3));
  }
  function nodeSort(value) {
    return (a5, b2) => ascendingDefined2(value(a5), value(b2));
  }
  function nodeData(field2) {
    return (node) => node.data?.[field2];
  }
  function normalizer(delimiter = "/") {
    delimiter = `${delimiter}`;
    if (delimiter === "/") return (P2) => P2;
    if (delimiter.length !== 1) throw new Error("delimiter must be exactly one character");
    const delimiterCode = delimiter.charCodeAt(0);
    return (P2) => P2.map((p11) => slashDelimiter(p11, delimiterCode));
  }
  var CODE_BACKSLASH = 92;
  var CODE_SLASH = 47;
  function slashDelimiter(input, delimiterCode) {
    if (delimiterCode === CODE_BACKSLASH) throw new Error("delimiter cannot be backslash");
    let afterBackslash = false;
    for (let i5 = 0, n9 = input.length; i5 < n9; ++i5) {
      switch (input.charCodeAt(i5)) {
        case CODE_BACKSLASH:
          if (!afterBackslash) {
            afterBackslash = true;
            continue;
          }
          break;
        case delimiterCode:
          if (afterBackslash) {
            input = input.slice(0, i5 - 1) + input.slice(i5), --i5, --n9;
          } else {
            input = input.slice(0, i5) + "/" + input.slice(i5 + 1);
          }
          break;
        case CODE_SLASH:
          if (afterBackslash) {
            input = input.slice(0, i5) + "\\\\" + input.slice(i5), i5 += 2, n9 += 2;
          } else {
            input = input.slice(0, i5) + "\\" + input.slice(i5), ++i5, ++n9;
          }
          break;
      }
      afterBackslash = false;
    }
    return input;
  }
  function slashUnescape(input) {
    let afterBackslash = false;
    for (let i5 = 0, n9 = input.length; i5 < n9; ++i5) {
      switch (input.charCodeAt(i5)) {
        case CODE_BACKSLASH:
          if (!afterBackslash) {
            afterBackslash = true;
            continue;
          }
        // eslint-disable-next-line no-fallthrough
        case CODE_SLASH:
          if (afterBackslash) {
            input = input.slice(0, i5 - 1) + input.slice(i5), --i5, --n9;
          }
          break;
      }
      afterBackslash = false;
    }
    return input;
  }
  function isNodeValue(option) {
    return isObject(option) && typeof option.node === "function";
  }
  function isLinkValue(option) {
    return isObject(option) && typeof option.link === "function";
  }
  function maybeNodeValue(value) {
    if (isNodeValue(value)) return value.node;
    value = `${value}`.trim().toLowerCase();
    if (!value.startsWith("node:")) return;
    switch (value) {
      case "node:name":
        return nodeName;
      case "node:path":
        return nodePath;
      case "node:internal":
        return nodeInternal;
      case "node:external":
        return nodeExternal;
      case "node:depth":
        return nodeDepth;
      case "node:height":
        return nodeHeight;
    }
    throw new Error(`invalid node value: ${value}`);
  }
  function maybeLinkValue(value) {
    if (isNodeValue(value)) return value.node;
    if (isLinkValue(value)) return value.link;
    value = `${value}`.trim().toLowerCase();
    if (!value.startsWith("node:") && !value.startsWith("parent:")) return;
    switch (value) {
      case "parent:name":
        return parentValue(nodeName);
      case "parent:path":
        return parentValue(nodePath);
      case "parent:depth":
        return parentValue(nodeDepth);
      case "parent:height":
        return parentValue(nodeHeight);
      case "node:name":
        return nodeName;
      case "node:path":
        return nodePath;
      case "node:internal":
        return nodeInternal;
      case "node:external":
        return nodeExternal;
      case "node:depth":
        return nodeDepth;
      case "node:height":
        return nodeHeight;
    }
    throw new Error(`invalid link value: ${value}`);
  }
  function nodePath(node) {
    return node.id;
  }
  function nodeName(node) {
    return nameof(node.id);
  }
  function nodeDepth(node) {
    return node.depth;
  }
  function nodeHeight(node) {
    return node.height;
  }
  function nodeInternal(node) {
    return !!node.children;
  }
  function nodeExternal(node) {
    return !node.children;
  }
  function parentValue(evaluate) {
    return (child, parent) => parent == null ? void 0 : evaluate(parent);
  }
  function nameof(path2) {
    let i5 = path2.length;
    while (--i5 > 0) if (slash2(path2, i5)) break;
    return slashUnescape(path2.slice(i5 + 1));
  }
  function slash2(path2, i5) {
    if (path2[i5] === "/") {
      let k3 = 0;
      while (i5 > 0 && path2[--i5] === "\\") ++k3;
      if ((k3 & 1) === 0) return true;
    }
    return false;
  }
  var output_setValues = 2;
  var output_evaluate = 3;
  var output_values = 4;
  function treeOutputs(options, maybeTreeValue) {
    const outputs = [];
    for (const name in options) {
      const value = options[name];
      const treeValue = maybeTreeValue(value);
      if (treeValue !== void 0) {
        outputs.push([name, ...column(value), treeValue]);
      }
    }
    return outputs;
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/tree.js
  function tree(data, {
    fill,
    stroke,
    strokeWidth,
    strokeOpacity,
    strokeLinejoin,
    strokeLinecap,
    strokeMiterlimit,
    strokeDasharray,
    strokeDashoffset,
    marker,
    markerStart = marker,
    markerEnd = marker,
    dot: dotDot = isNoneish(markerStart) && isNoneish(markerEnd),
    text: textText = "node:name",
    textStroke = "var(--plot-background)",
    title = "node:path",
    dx,
    dy,
    textAnchor,
    treeLayout = tree_default,
    textLayout = treeLayout === tree_default || treeLayout === cluster_default ? "mirrored" : "normal",
    tip: tip2,
    ...options
  } = {}) {
    if (dx === void 0) dx = maybeTreeAnchor(options.treeAnchor).dx;
    if (textAnchor !== void 0) throw new Error("textAnchor is not a configurable tree option");
    textLayout = keyword(textLayout, "textLayout", ["mirrored", "normal"]);
    function treeText(textOptions2) {
      return text(
        data,
        treeNode({
          treeLayout,
          text: textText,
          fill: fill === void 0 ? "currentColor" : fill,
          stroke: textStroke,
          dx,
          dy,
          title,
          ...textOptions2,
          ...options
        })
      );
    }
    return marks(
      link2(
        data,
        treeLink({
          treeLayout,
          markerStart,
          markerEnd,
          stroke: stroke !== void 0 ? stroke : fill === void 0 ? "node:internal" : fill,
          strokeWidth,
          strokeOpacity,
          strokeLinejoin,
          strokeLinecap,
          strokeMiterlimit,
          strokeDasharray,
          strokeDashoffset,
          ...options
        })
      ),
      dotDot ? dot(data, treeNode({ treeLayout, fill: fill === void 0 ? "node:internal" : fill, title, tip: tip2, ...options })) : null,
      textText != null ? textLayout === "mirrored" ? [
        treeText({ textAnchor: "start", treeFilter: "node:external" }),
        treeText({ textAnchor: "end", treeFilter: "node:internal", dx: -dx })
      ] : treeText() : null
    );
  }
  function cluster(data, options) {
    return tree(data, { ...options, treeLayout: cluster_default });
  }

  // ../../../../../node_modules/@observablehq/plot/src/marks/waffle.js
  var waffleDefaults = {
    ariaLabel: "waffle"
  };
  var WaffleX = class extends BarX {
    constructor(data, { unit: unit3 = 1, gap = 1, round: round2, multiple, ...options } = {}) {
      super(data, wafflePolygon("x", options), waffleDefaults);
      this.unit = Math.max(0, unit3);
      this.gap = +gap;
      this.round = maybeRound2(round2);
      this.multiple = maybeMultiple(multiple);
    }
  };
  var WaffleY = class extends BarY {
    constructor(data, { unit: unit3 = 1, gap = 1, round: round2, multiple, ...options } = {}) {
      super(data, wafflePolygon("y", options), waffleDefaults);
      this.unit = Math.max(0, unit3);
      this.gap = +gap;
      this.round = maybeRound2(round2);
      this.multiple = maybeMultiple(multiple);
    }
  };
  function wafflePolygon(y3, options) {
    const x3 = y3 === "y" ? "x" : "y";
    const y12 = `${y3}1`;
    const y22 = `${y3}2`;
    return initializer(waffleRender(options), function(data, facets, channels, scales, dimensions) {
      const { round: round2, unit: unit3 } = this;
      const Y13 = channels[y12].value;
      const Y23 = channels[y22].value;
      const xy = valueObject({ ...x3 in channels && { [x3]: channels[x3] }, [y12]: channels[y12], [y22]: channels[y22] }, scales);
      const barwidth = this[y3 === "y" ? "_width" : "_height"](scales, xy, dimensions);
      const barx = this[y3 === "y" ? "_x" : "_y"](scales, xy, dimensions);
      const scale3 = unit3 * scaleof(scales.scales[y3]);
      const { multiple = Math.max(1, Math.floor(Math.sqrt(barwidth / scale3))) } = this;
      const cx = Math.min(barwidth / multiple, scale3 * multiple);
      const cy = scale3 * multiple;
      const tx = (barwidth - multiple * cx) / 2;
      const x06 = typeof barx === "function" ? (i5) => barx(i5) + tx : barx + tx;
      const y06 = scales[y3](0);
      const transform3 = y3 === "y" ? ([x4, y4]) => [x4 * cx, -y4 * cy] : ([x4, y4]) => [y4 * cy, x4 * cx];
      const mx = typeof x06 === "function" ? (i5) => x06(i5) - barwidth / 2 : () => x06;
      const [ix, iy] = y3 === "y" ? [0, 1] : [1, 0];
      const n9 = Y23.length;
      const P2 = new Array(n9);
      const X3 = new Float64Array(n9);
      const Y3 = new Float64Array(n9);
      for (let i5 = 0; i5 < n9; ++i5) {
        P2[i5] = wafflePoints(round2(Y13[i5] / unit3), round2(Y23[i5] / unit3), multiple).map(transform3);
        const c9 = P2[i5].pop();
        X3[i5] = c9[ix] + mx(i5);
        Y3[i5] = c9[iy] + y06;
      }
      return {
        channels: {
          polygon: { value: P2, source: null, filter: null },
          [`c${x3}`]: { value: [cx, x06], source: null, filter: null },
          [`c${y3}`]: { value: [cy, y06], source: null, filter: null },
          [x3]: { value: X3, scale: null, source: null },
          [y12]: { value: Y3, scale: null, source: channels[y12] },
          [y22]: { value: Y3, scale: null, source: channels[y22] }
        }
      };
    });
  }
  function waffleRender({ render, ...options }) {
    return {
      ...options,
      render: composeRender(render, function(index2, scales, values2, dimensions, context) {
        const { gap, rx, ry } = this;
        const { channels, ariaLabel, href, title, ...visualValues } = values2;
        const { document: document2 } = context;
        const polygon = channels.polygon.value;
        const [cx, x06] = channels.cx.value;
        const [cy, y06] = channels.cy.value;
        const patternId = getPatternId();
        const basePattern = document2.createElementNS(namespaces_default.svg, "pattern");
        basePattern.setAttribute("width", cx);
        basePattern.setAttribute("height", cy);
        basePattern.setAttribute("patternUnits", "userSpaceOnUse");
        const basePatternRect = basePattern.appendChild(document2.createElementNS(namespaces_default.svg, "rect"));
        basePatternRect.setAttribute("x", gap / 2);
        basePatternRect.setAttribute("y", gap / 2);
        basePatternRect.setAttribute("width", cx - gap);
        basePatternRect.setAttribute("height", cy - gap);
        if (rx != null) basePatternRect.setAttribute("rx", rx);
        if (ry != null) basePatternRect.setAttribute("ry", ry);
        return create2("svg:g", context).call(applyIndirectStyles, this, dimensions, context).call(this._transform, this, scales).call(
          (g2) => g2.selectAll().data(index2).enter().append(() => basePattern.cloneNode(true)).attr("id", (i5) => `${patternId}-${i5}`).select("rect").call(applyDirectStyles, this).call(applyChannelStyles, this, visualValues)
        ).call(
          (g2) => g2.selectAll().data(index2).enter().append("path").attr("transform", template`translate(${x06},${y06})`).attr("d", (i5) => `M${polygon[i5].join("L")}Z`).attr("fill", (i5) => `url(#${patternId}-${i5})`).attr("stroke", this.stroke == null ? null : "none").call(applyChannelStyles, this, { ariaLabel, href, title })
        ).node();
      })
    };
  }
  function wafflePoints(i12, i22, columns) {
    if (i22 < i12) return wafflePoints(i22, i12, columns);
    if (i12 < 0) return wafflePointsOffset(i12, i22, columns, Math.ceil(-Math.min(i12, i22) / columns));
    const x1f = Math.floor(i12 % columns);
    const x1c = Math.ceil(i12 % columns);
    const x2f = Math.floor(i22 % columns);
    const x2c = Math.ceil(i22 % columns);
    const y1f = Math.floor(i12 / columns);
    const y1c = Math.ceil(i12 / columns);
    const y2f = Math.floor(i22 / columns);
    const y2c = Math.ceil(i22 / columns);
    const points = [];
    if (y2c > y1c) points.push([0, y1c]);
    points.push([x1f, y1c], [x1f, y1f + i12 % 1], [x1c, y1f + i12 % 1]);
    if (!(i12 % columns > columns - 1)) {
      points.push([x1c, y1f]);
      if (y2f > y1f) points.push([columns, y1f]);
    }
    if (y2f > y1f) points.push([columns, y2f]);
    points.push([x2c, y2f], [x2c, y2f + i22 % 1], [x2f, y2f + i22 % 1]);
    if (!(i22 % columns < 1)) {
      points.push([x2f, y2c]);
      if (y2c > y1c) points.push([0, y2c]);
    }
    points.push(waffleCentroid(i12, i22, columns));
    return points;
  }
  function wafflePointsOffset(i12, i22, columns, k3) {
    return wafflePoints(i12 + k3 * columns, i22 + k3 * columns, columns).map(([x3, y3]) => [x3, y3 - k3]);
  }
  function waffleCentroid(i12, i22, columns) {
    const r6 = Math.floor(i22 / columns) - Math.floor(i12 / columns);
    return r6 === 0 ? (
      // Single row
      waffleRowCentroid(i12, i22, columns)
    ) : r6 === 1 ? (
      // Two incomplete rows; use the midpoint of their overlap if any, otherwise the larger row
      Math.floor(i22 % columns) > Math.ceil(i12 % columns) ? [(Math.floor(i22 % columns) + Math.ceil(i12 % columns)) / 2, Math.floor(i22 / columns)] : i22 % columns > columns - i12 % columns ? waffleRowCentroid(i22 - i22 % columns, i22, columns) : waffleRowCentroid(i12, columns * Math.ceil(i12 / columns), columns)
    ) : (
      // At least one full row; take the midpoint of all the rows that include the middle
      [columns / 2, (Math.round(i12 / columns) + Math.round(i22 / columns)) / 2]
    );
  }
  function waffleRowCentroid(i12, i22, columns) {
    const c9 = Math.floor(i22) - Math.floor(i12);
    return c9 === 0 ? (
      // Single cell
      [Math.floor(i12 % columns) + 0.5, Math.floor(i12 / columns) + (i12 + i22) / 2 % 1]
    ) : c9 === 1 ? (
      // Two incomplete cells; use the overlap if large enough, otherwise use the largest
      i22 % 1 - i12 % 1 > 0.5 ? [Math.ceil(i12 % columns), Math.floor(i22 / columns) + (i12 % 1 + i22 % 1) / 2] : i22 % 1 > 1 - i12 % 1 ? [Math.floor(i22 % columns) + 0.5, Math.floor(i22 / columns) + i22 % 1 / 2] : [Math.floor(i12 % columns) + 0.5, Math.floor(i12 / columns) + (1 + i12 % 1) / 2]
    ) : (
      // At least one full cell; take the midpoint
      [
        Math.ceil(i12 % columns) + Math.ceil(Math.floor(i22) - Math.ceil(i12)) / 2,
        Math.floor(i12 / columns) + (i22 >= 1 + i12 ? 0.5 : (i12 + i22) / 2 % 1)
      ]
    );
  }
  function maybeRound2(round2) {
    if (round2 === void 0 || round2 === false) return Number;
    if (round2 === true) return Math.round;
    if (typeof round2 !== "function") throw new Error(`invalid round: ${round2}`);
    return round2;
  }
  function maybeMultiple(multiple) {
    return multiple === void 0 ? void 0 : Math.max(1, Math.floor(multiple));
  }
  function scaleof({ domain, range: range3 }) {
    return spread(range3) / spread(domain);
  }
  function spread(domain) {
    const [min4, max3] = extent(domain);
    return max3 - min4;
  }
  function waffleX(data, { tip: tip2, ...options } = {}) {
    if (!hasXY(options)) options = { ...options, y: indexOf, x2: identity6 };
    return new WaffleX(data, { tip: waffleTip(tip2), ...maybeStackX(maybeIntervalX(maybeIdentityX(options))) });
  }
  function waffleY(data, { tip: tip2, ...options } = {}) {
    if (!hasXY(options)) options = { ...options, x: indexOf, y2: identity6 };
    return new WaffleY(data, { tip: waffleTip(tip2), ...maybeStackY(maybeIntervalY(maybeIdentityY(options))) });
  }
  function waffleTip(tip2) {
    return tip2 === true ? { maxRadius: Infinity } : isObject(tip2) && tip2.maxRadius === void 0 ? { ...tip2, maxRadius: Infinity } : void 0;
  }

  // ../../../../../node_modules/@observablehq/plot/src/transforms/dodge.js
  var import_interval_tree_1d = __toESM(require_interval_tree(), 1);
  var anchorXLeft = ({ marginLeft }) => [1, marginLeft];
  var anchorXRight = ({ width, marginRight }) => [-1, width - marginRight];
  var anchorXMiddle = ({ width, marginLeft, marginRight }) => [0, (marginLeft + width - marginRight) / 2];
  var anchorYTop = ({ marginTop }) => [1, marginTop];
  var anchorYBottom = ({ height, marginBottom }) => [-1, height - marginBottom];
  var anchorYMiddle = ({ height, marginTop, marginBottom }) => [0, (marginTop + height - marginBottom) / 2];
  function maybeAnchor4(anchor) {
    return typeof anchor === "string" ? { anchor } : anchor;
  }
  function dodgeX(dodgeOptions = {}, options = {}) {
    if (arguments.length === 1) [dodgeOptions, options] = mergeOptions3(dodgeOptions);
    let { anchor = "left", padding = 1, r: r6 = options.r } = maybeAnchor4(dodgeOptions);
    switch (`${anchor}`.toLowerCase()) {
      case "left":
        anchor = anchorXLeft;
        break;
      case "right":
        anchor = anchorXRight;
        break;
      case "middle":
        anchor = anchorXMiddle;
        break;
      default:
        throw new Error(`unknown dodge anchor: ${anchor}`);
    }
    return dodge("x", "y", anchor, number5(padding), r6, options);
  }
  function dodgeY(dodgeOptions = {}, options = {}) {
    if (arguments.length === 1) [dodgeOptions, options] = mergeOptions3(dodgeOptions);
    let { anchor = "bottom", padding = 1, r: r6 = options.r } = maybeAnchor4(dodgeOptions);
    switch (`${anchor}`.toLowerCase()) {
      case "top":
        anchor = anchorYTop;
        break;
      case "bottom":
        anchor = anchorYBottom;
        break;
      case "middle":
        anchor = anchorYMiddle;
        break;
      default:
        throw new Error(`unknown dodge anchor: ${anchor}`);
    }
    return dodge("y", "x", anchor, number5(padding), r6, options);
  }
  function mergeOptions3(options) {
    const { anchor, padding, ...rest } = options;
    const { r: r6 } = rest;
    return [{ anchor, padding, r: r6 }, rest];
  }
  function dodge(y3, x3, anchor, padding, r6, options) {
    if (r6 != null && typeof r6 !== "number") {
      let { channels, sort: sort3, reverse: reverse3 } = options;
      channels = maybeNamed(channels);
      if (channels?.r === void 0) options = { ...options, channels: { ...channels, r: { value: r6, scale: "r" } } };
      if (sort3 === void 0 && reverse3 === void 0) options.sort = { channel: "-r" };
    }
    return initializer(options, function(data, facets, channels, scales, dimensions, context) {
      let { [x3]: X3, r: R2 } = channels;
      if (!channels[x3]) throw new Error(`missing channel: ${x3}`);
      ({ [x3]: X3 } = applyPosition(channels, scales, context));
      const cr = R2 ? void 0 : r6 !== void 0 ? number5(r6) : this.r !== void 0 ? this.r : 3;
      if (R2) R2 = valueof(R2.value, scales[R2.scale] || identity6, Float64Array);
      let [ky2, ty] = anchor(dimensions);
      const compare = ky2 ? compareAscending : compareSymmetric;
      const Y3 = new Float64Array(X3.length);
      const radius2 = R2 ? (i5) => R2[i5] : () => cr;
      for (let I2 of facets) {
        const tree2 = (0, import_interval_tree_1d.default)();
        I2 = I2.filter(R2 ? (i5) => finite2(X3[i5]) && positive(R2[i5]) : (i5) => finite2(X3[i5]));
        const intervals = new Float64Array(2 * I2.length + 2);
        for (const i5 of I2) {
          const ri = radius2(i5);
          const y06 = ky2 ? ri + padding : 0;
          const l8 = X3[i5] - ri;
          const h5 = X3[i5] + ri;
          let k3 = 2;
          tree2.queryInterval(l8 - padding, h5 + padding, ([, , j2]) => {
            const yj = Y3[j2] - y06;
            const dx = X3[i5] - X3[j2];
            const dr = padding + (R2 ? R2[i5] + R2[j2] : 2 * cr);
            const dy = Math.sqrt(dr * dr - dx * dx);
            intervals[k3++] = yj - dy;
            intervals[k3++] = yj + dy;
          });
          let candidates = intervals.slice(0, k3);
          if (ky2) candidates = candidates.filter((y4) => y4 >= 0);
          out: for (const y4 of candidates.sort(compare)) {
            for (let j2 = 0; j2 < k3; j2 += 2) {
              if (intervals[j2] + 1e-6 < y4 && y4 < intervals[j2 + 1] - 1e-6) {
                continue out;
              }
            }
            Y3[i5] = y4 + y06;
            break;
          }
          tree2.insert([l8, h5, i5]);
        }
      }
      if (!ky2) ky2 = 1;
      for (const I2 of facets) {
        for (const i5 of I2) {
          Y3[i5] = Y3[i5] * ky2 + ty;
        }
      }
      return {
        data,
        facets,
        channels: {
          [y3]: { value: Y3, source: null },
          // dont show in tooltip
          [x3]: { value: X3, source: channels[x3] },
          ...R2 && { r: { value: R2, source: channels.r } }
        }
      };
    });
  }
  function compareSymmetric(a5, b2) {
    return Math.abs(a5) - Math.abs(b2);
  }
  function compareAscending(a5, b2) {
    return a5 - b2;
  }

  // ../../../../../node_modules/@observablehq/plot/src/transforms/normalize.js
  function normalizeX(basis2, options) {
    if (arguments.length === 1) ({ basis: basis2, ...options } = basis2);
    return mapX(normalize3(basis2), options);
  }
  function normalizeY(basis2, options) {
    if (arguments.length === 1) ({ basis: basis2, ...options } = basis2);
    return mapY(normalize3(basis2), options);
  }
  function normalize3(basis2) {
    if (basis2 === void 0) return normalizeFirst;
    if (typeof basis2 === "function") return normalizeBasis(taker(basis2));
    if (/^p\d{2}$/i.test(basis2)) return normalizeAccessor(percentile(basis2));
    switch (`${basis2}`.toLowerCase()) {
      case "deviation":
        return normalizeDeviation;
      case "first":
        return normalizeFirst;
      case "last":
        return normalizeLast;
      case "max":
        return normalizeMax;
      case "mean":
        return normalizeMean;
      case "median":
        return normalizeMedian;
      case "min":
        return normalizeMin;
      case "sum":
        return normalizeSum;
      case "extent":
        return normalizeExtent;
    }
    throw new Error(`invalid basis: ${basis2}`);
  }
  function normalizeBasis(basis2) {
    return {
      mapIndex(I2, S3, T2) {
        const b2 = +basis2(I2, S3);
        for (const i5 of I2) {
          T2[i5] = S3[i5] === null ? NaN : S3[i5] / b2;
        }
      }
    };
  }
  function normalizeAccessor(f7) {
    return normalizeBasis((I2, S3) => f7(I2, (i5) => S3[i5]));
  }
  var normalizeExtent = {
    mapIndex(I2, S3, T2) {
      const [s1, s22] = extent(I2, (i5) => S3[i5]);
      const d3 = s22 - s1;
      for (const i5 of I2) {
        T2[i5] = S3[i5] === null ? NaN : (S3[i5] - s1) / d3;
      }
    }
  };
  var normalizeFirst = normalizeBasis((I2, S3) => {
    for (let i5 = 0; i5 < I2.length; ++i5) {
      const s8 = S3[I2[i5]];
      if (defined(s8)) return s8;
    }
  });
  var normalizeLast = normalizeBasis((I2, S3) => {
    for (let i5 = I2.length - 1; i5 >= 0; --i5) {
      const s8 = S3[I2[i5]];
      if (defined(s8)) return s8;
    }
  });
  var normalizeDeviation = {
    mapIndex(I2, S3, T2) {
      const m3 = mean(I2, (i5) => S3[i5]);
      const d3 = deviation(I2, (i5) => S3[i5]);
      for (const i5 of I2) {
        T2[i5] = S3[i5] === null ? NaN : d3 ? (S3[i5] - m3) / d3 : 0;
      }
    }
  };
  var normalizeMax = normalizeAccessor(max);
  var normalizeMean = normalizeAccessor(mean);
  var normalizeMedian = normalizeAccessor(median);
  var normalizeMin = normalizeAccessor(min);
  var normalizeSum = normalizeAccessor(sum);

  // ../../../../../node_modules/@observablehq/plot/src/transforms/shift.js
  function shiftX(interval2, options) {
    return shiftK("x", interval2, options);
  }
  function shiftY(interval2, options) {
    return shiftK("y", interval2, options);
  }
  function shiftK(x3, interval2, options = {}) {
    let offset2;
    let k3 = 1;
    if (typeof interval2 === "number") {
      k3 = interval2;
      offset2 = (x4, k4) => +x4 + k4;
    } else {
      if (typeof interval2 === "string") {
        const sign4 = interval2.startsWith("-") ? -1 : 1;
        [interval2, k3] = parseTimeInterval(interval2.replace(/^[+-]/, ""));
        k3 *= sign4;
      }
      interval2 = maybeInterval(interval2);
      offset2 = (x4, k4) => interval2.offset(x4, k4);
    }
    const x12 = `${x3}1`;
    const x22 = `${x3}2`;
    const mapped = map3(
      {
        [x12]: (D4) => D4.map((d3) => offset2(d3, k3)),
        [x22]: (D4) => D4
      },
      options
    );
    const t5 = mapped[x22].transform;
    mapped[x22].transform = () => {
      const V2 = t5();
      const [x06, x13] = extent(V2);
      V2.domain = k3 < 0 ? [x06, offset2(x13, k3)] : [offset2(x06, k3), x13];
      return V2;
    };
    return mapped;
  }

  // ../../../../../node_modules/@observablehq/plot/src/transforms/select.js
  function select(selector, options = {}) {
    if (typeof selector === "string") {
      switch (selector.toLowerCase()) {
        case "first":
          return selectFirst(options);
        case "last":
          return selectLast(options);
      }
    }
    if (typeof selector === "function") {
      return selectChannel(null, selector, options);
    }
    let key, value;
    for (key in selector) {
      if (value !== void 0) throw new Error("ambiguous selector; multiple inputs");
      value = maybeSelector(selector[key]);
    }
    if (value === void 0) throw new Error(`invalid selector: ${selector}`);
    return selectChannel(key, value, options);
  }
  function maybeSelector(selector) {
    if (typeof selector === "function") return selector;
    switch (`${selector}`.toLowerCase()) {
      case "min":
        return selectorMin;
      case "max":
        return selectorMax;
    }
    throw new Error(`unknown selector: ${selector}`);
  }
  function selectFirst(options) {
    return selectChannel(null, selectorFirst, options);
  }
  function selectLast(options) {
    return selectChannel(null, selectorLast, options);
  }
  function selectMinX(options) {
    return selectChannel("x", selectorMin, options);
  }
  function selectMinY(options) {
    return selectChannel("y", selectorMin, options);
  }
  function selectMaxX(options) {
    return selectChannel("x", selectorMax, options);
  }
  function selectMaxY(options) {
    return selectChannel("y", selectorMax, options);
  }
  function* selectorFirst(I2) {
    yield I2[0];
  }
  function* selectorLast(I2) {
    yield I2[I2.length - 1];
  }
  function* selectorMin(I2, X3) {
    yield least(I2, (i5) => X3[i5]);
  }
  function* selectorMax(I2, X3) {
    yield greatest(I2, (i5) => X3[i5]);
  }
  function selectChannel(v3, selector, options) {
    if (v3 != null) {
      if (options[v3] == null) throw new Error(`missing channel: ${v3}`);
      v3 = options[v3];
    }
    const z2 = maybeZ(options);
    return basic(options, (data, facets) => {
      const Z3 = valueof(data, z2);
      const V2 = valueof(data, v3);
      const selectFacets = [];
      for (const facet of facets) {
        const selectFacet = [];
        for (const I2 of Z3 ? group(facet, (i5) => Z3[i5]).values() : [facet]) {
          for (const i5 of selector(I2, V2)) {
            selectFacet.push(i5);
          }
        }
        selectFacets.push(selectFacet);
      }
      return { data, facets: selectFacets };
    });
  }

  // ../../../../../node_modules/@observablehq/plot/src/index.js
  Mark.prototype.plot = function({ marks: marks2 = [], ...options } = {}) {
    return plot({ ...options, marks: [...marks2, this] });
  };

  // prebundle.js
  window.Algebrite = import_algebrite.default;
  window.Plot = src_exports;
  hotkeys_esm_default.filter = (event) => {
    const target = event.target || event.srcElement;
    const { tagName, id: id2 } = target;
    if (id2 == "clipboard-shim") {
      return true;
    }
    let flag2 = true;
    const isInput = tagName === "INPUT" && ![
      "checkbox",
      "radio",
      "range",
      "button",
      "file",
      "reset",
      "submit",
      "color"
    ].includes(target.type);
    if (target.isContentEditable || (isInput || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
      flag2 = false;
    }
    return flag2;
  };
})();
/*! Bundled license information:

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive-helpers.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/repeat.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/live.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/async-directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/ref.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

hotkeys-js/dist/hotkeys.esm.js:
  (*!
   * hotkeys-js v3.8.7
   * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.
   * 
   * Copyright (c) 2021 kenny wong <wowohoo@qq.com>
   * http://jaywcjlove.github.io/hotkeys
   * 
   * Licensed under the MIT license.
   *)

lit-html/directives/unsafe-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/join.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@material/mwc-icon/mwc-icon-host.css.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-LIcense-Identifier: Apache-2.0
   *)

@material/mwc-icon/mwc-icon.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/
